<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NodeJS]]></title>
    <url>%2Fmyhexo%2F2019%2F03%2F20%2FNodeJS%2F</url>
    <content type="text"><![CDATA[NodeJS入门 NodeJS模块 http模块 server.js 123456789101112131415161718const http=require('http');let server=http.createServer((req, res)=&gt;&#123; switch(req.url)&#123; case '/aaa': res.write('abc'); break; case '/bbb': res.write('dddd'); break; case '/1.html': res.write('&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;sdfasfasf&lt;/body&gt;&lt;/html&gt;'); break; &#125; res.end();&#125;);server.listen(8080); server2.js 1234567891011121314const http=require('http');const fs=require('fs');let server=http.createServer((req, res)=&gt;&#123; fs.readFile(`www$&#123;req.url&#125;`, (err, data)=&gt;&#123; if(err)&#123; res.write('404'); //? &#125;else&#123; res.write(data); &#125; res.end(); &#125;);&#125;);server.listen(8080); 断言——assert 1234567891011const assert=require('assert');function sum(a, b)&#123; assert(arguments.length==2, '必须传2个参数'); assert(typeof a=='number', '第一个参数必须是数字'); assert(typeof b=='number', '第二个参数必须是数字'); return a+b;&#125;console.log(sum(12, 5)); File System 读写文件 fs.js 123456789101112131415161718const fs=require('fs');fs.readFile('1.txt', (err, data)=&gt;&#123; if(err)&#123; console.log('有错'); &#125;else&#123; //'ads'.charCodeAt(0) console.log(data.toString()); &#125;&#125;);/*fs.writeFile('3.txt', 'erqwreqwere', err=&gt;&#123; if(err)&#123; console.log(err); &#125;else&#123; console.log('成功'); &#125;&#125;);*/ fs2.js 1234567891011const fs=require('fs');fs.readFile('ofo.png', (err, data)=&gt;&#123; fs.writeFile('ofo2.png', data, (err)=&gt;&#123; if(err)&#123; console.log(err); &#125;else&#123; console.log('成功'); &#125; &#125;);&#125;); 多进程 进程和线程的区别： 进程拥有独立的执行空间、存储同一个进程内的所有线程共享一套空间、代码 多进程(PHP、Node) 成本高(慢)；安全(进程间隔离)；进程间通信麻烦；写代码简单多线程(Java、C) 成本低(快)；不安全(线程要死一块死)；线程间通信容易；写代码复杂 进程间通信的几种方式管道共享内存socket Crypto——签名 MD5是单向散列生成hash值，不可逆破解 md5.js 1234567891011const crypto=require('crypto');let obj=crypto.createHash('md5');obj.update('123456');// obj.update('123');// obj.update('4');// obj.update('56');console.log(obj.digest('hex')); 双重加密 md5_2.js 12345678910const crypto=require('crypto');function md5(str)&#123; let obj=crypto.createHash('md5'); obj.update(str); return obj.digest('hex');&#125;console.log(md5(md5('123456')+'se32ssdfsd43')); OS 获取系统信息 123const os=require('os');console.log(os.cpus()); Path 123456789const path=require('path');let str='/var/local/www/aaa/1.png';//dirname//basename//extnameconsole.log(path.extname(str)); Events事件队列 和普通js函数的定义调用区别：解耦 12345678910111213141516171819const Event=require('events').EventEmitter;let ev=new Event();//1.监听(接收)ev.on('msg', function (a, b, c)&#123; console.log('收到了msg事件：', a, b, c);&#125;);//2.派发(发送)ev.emit('msg', 12, 5, 88);/*function msg(a, b, c)&#123; console.log('收到了msg事件：', a, b, c);&#125;msg(12, 5, 88);*/ Query Strings、URL 地址解析 querystring.js 12345const querystring=require('querystring');let obj=querystring.parse('ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=aa&amp;rsv_pq=f80d982000063ffb&amp;rsv_t=6498LAZdRZjq9v4v0hs88kZItnCjDpT6UNBKr%2FF83%2F%2Bg4eiPURW2eQl9Iwc&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug2=0&amp;inputT=10&amp;rsv_sug4=10');console.log(obj); url.js 12345const url=require('url');let obj=url.parse('https://www.baidu.com:8080/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=aa&amp;rsv_pq=f80d982000063ffb&amp;rsv_t=6498LAZdRZjq9v4v0hs88kZItnCjDpT6UNBKr%2FF83%2F%2Bg4eiPURW2eQl9Iwc&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug2=0&amp;inputT=10&amp;rsv_sug4=10',true);console.log(obj); 域名解析 DNS、Domain 123456789const dns=require('dns');dns.resolve('www.goole.com', (err, res)=&gt;&#123; if(err)&#123; console.log('解析失败'); &#125;else&#123; console.log(res); &#125;&#125;); 流操作——Stream 连续数据都是流——视频流、网络流、文件流、语音流 TLS/SSL 加密、安全 ZLIB——gz 压缩 NodeJS数据交互 设置响应头 get请求 数据放在url地址上，存放的数量小(32k) post请求 在body里面,存放的数据量大(1G),一个大数据包切成一堆小包传输,容错性强 安全性 一切来自前台的数据都不可信前后台都得进行数据校验 前台校验：提高用户体验 后台校验：提高安全性 数据库 关系型数据库——MySQL、Oracle 最常见、最常用,数据之间是有关系的MySQL使用占比80%，免费，绝大多数普通应用，性能很高、安全性很高，容灾略差Oracle收费，应用在金融、医疗，容灾特别强 文件型数据库——sqlite 使用简单、存储数据量小 文档型数据库——MongoDB 直接存储异构数据，使用方便 NoSQL 没有复杂的关系、对性能有极高的要求常见的有redis、memcached、hypertable、bigtable NodeJS进阶上 文件数据解析 表单的三种POST text/plain,用的很少，纯文字application/x-www-form-urlencoded,默认,以url编码方式,xxx=xxx&amp;xxx=xx...multipart/form-data上传文件内容 file上传，是post请求方式 普通纯文本表单文件上传 普通纯文本文件上传可以用字符串拼接接收，有弊端，如果是图片文件上传，用字符串接收会出现数据错乱 描述：可以看到纯文本文件上传请求了2个资源 浏览器 后台结果输出 包含了前台表单用户名、密码和纯文本文件的描述和内容 1234567891011121314151617/upload------WebKitFormBoundaryNIoabcKEXajTUMAIContent-Disposition: form-data; name=&quot;user&quot;shenlibing------WebKitFormBoundaryNIoabcKEXajTUMAIContent-Disposition: form-data; name=&quot;pass&quot;000000------WebKitFormBoundaryNIoabcKEXajTUMAIContent-Disposition: form-data; name=&quot;f1&quot;; filename=&quot;1.txt&quot;Content-Type: text/plainabc------WebKitFormBoundaryNIoabcKEXajTUMAI--/favicon.ico Buffer接收文件上传的原始二进制数据 1234/upload&lt;Buffer 2d 2d 2d 2d 2d 2d 57 65 62 4b 69 74 46 6f 72 6d 42 6f 75 6e 64 61 72 79 75 42 6d 6b 78 4a 65 51 6d 35 6b 4a 4f 68 59 65 0d 0a 43 6f 6e 74 65 6e 74 2d ... &gt;/favicon.ico&lt;Buffer &gt; Buffer数据进行查找、截取、切分 如果是非纯文本文件上传，用字符串接收会破坏数据的完整性，需要用Buffer接收二进制数据 Buffer数据查找 123let b=new Buffer('abccc-=-dddder-=-qwerqwer');console.log(b.indexOf('-=-')); Buffer数据截取 123let b=new Buffer('abccc-=-dddder-=-qwerqwer');console.log(b.slice(17).toString()); Buffer数据切分 Buffer本身不具有split方法 123456789101112131415161718192021let b=new Buffer('abccc-=-dddder-=-qwerqwer');Buffer.prototype.split=Buffer.prototype.split||function (b)&#123; let arr=[]; let cur=0; let n=0; while((n=this.indexOf(b, cur))!=-1)&#123; arr.push(this.slice(cur, n)); cur=n+b.length; &#125; arr.push(this.slice(cur)); return arr;&#125;;let arr=b.split('-=-');console.log(arr);console.log(arr.map(buffer=&gt;buffer.toString())); 解析数据 数据化简 先对纯文本文件上传用字符串拼接的结果进行分析化简版本一 1234567891011121314分隔符Content-Disposition: form-data; name=&quot;user&quot;shenlibing分隔符Content-Disposition: form-data; name=&quot;pass&quot;000000分隔符Content-Disposition: form-data; name=&quot;f1&quot;; filename=&quot;1.txt&quot;Content-Type: text/plainabc分隔符-- 化简版本二：每一行末尾会自动加上\r\n 1234567891011121314分隔符\r\nContent-Disposition: form-data; name=&quot;user&quot;\r\n\r\nshenlibing\r\n分隔符\r\nContent-Disposition: form-data; name=&quot;pass&quot;\r\n\r\n000000\r\n分隔符\r\nContent-Disposition: form-data; name=&quot;f1&quot;; filename=&quot;1.txt&quot;\r\nContent-Type: text/plain\r\n\r\nabc\r\n分隔符--\r\n 化简版本三 1234分隔符\r\n数据描述\r\n\r\n数据值\r\n分隔符\r\n数据描述\r\n\r\n数据值\r\n分隔符\r\n数据描述1\r\n数据描述2\r\n\r\n文件内容\r\n分隔符--\r\n 化简到版本三的时候，就可以开始解析数据了 用分隔符切开数据 1234567[ 空, \r\n数据描述\r\n\r\n数据值\r\n, \r\n数据描述\r\n\r\n数据值\r\n, \r\n数据描述1\r\n数据描述2\r\n\r\n&lt;文件内容&gt;\r\n, --\r\n] 丢弃头尾元素 12345[ \r\n数据描述\r\n\r\n数据值\r\n, \r\n数据描述\r\n\r\n数据值\r\n, \r\n数据描述1\r\n数据描述2\r\n\r\n&lt;文件内容&gt;\r\n,] 丢弃每一项的头尾\r\n 12345[ 数据描述\r\n\r\n数据值, 数据描述\r\n\r\n数据值, 数据描述1\r\n数据描述2\r\n\r\n&lt;文件内容&gt;,] 用第一次出现的\r\n\r\n切分 普通数据：[数据描述, 数据值] 文件数据：[数据描述1\r\n数据描述2, &lt;文件内容&gt;] 判断描述的里面有没有\r\n 有的话就是文件数据：[数据描述1\r\n数据描述2, &lt;文件内容&gt;]没有的话就是普通数据：[数据描述, 数据值] 分析数据描述 文件上传代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687const http=require('http');const common=require('./libs/common');const fs=require('fs');const uuid=require('uuid/v4');let server=http.createServer((req, res)=&gt;&#123; let arr=[]; req.on('data', data=&gt;&#123; arr.push(data); &#125;); req.on('end', ()=&gt;&#123; let data=Buffer.concat(arr); //data //解析二进制文件上传数据 let post=&#123;&#125;; let files=&#123;&#125;; if(req.headers['content-type'])&#123; let str=req.headers['content-type'].split('; ')[1]; if(str)&#123; let boundary='--'+str.split('=')[1]; //1.用"分隔符切分整个数据" let arr=data.split(boundary); //2.丢弃头尾两个数据 arr.shift(); arr.pop(); //3.丢弃掉每个数据头尾的"\r\n" arr=arr.map(buffer=&gt;buffer.slice(2,buffer.length-2)); //4.每个数据在第一个"\r\n\r\n"处切成两半 arr.forEach(buffer=&gt;&#123; let n=buffer.indexOf('\r\n\r\n'); let disposition=buffer.slice(0, n); let content=buffer.slice(n+4); disposition=disposition.toString(); if(disposition.indexOf('\r\n')==-1)&#123; //普通数据 //Content-Disposition: form-data; name="user" content=content.toString(); let name=disposition.split('; ')[1].split('=')[1]; name=name.substring(1, name.length-1); post[name]=content; &#125;else&#123; //文件数据 /*Content-Disposition: form-data; name="f1"; filename="a.txt"\r\n Content-Type: text/plain*/ let [line1, line2]=disposition.split('\r\n'); let [,name,filename]=line1.split('; '); let type=line2.split(': ')[1]; name=name.split('=')[1]; name=name.substring(1,name.length-1); filename=filename.split('=')[1]; filename=filename.substring(1,filename.length-1); let path=`upload/$&#123;uuid().replace(/\-/g, '')&#125;`; fs.writeFile(path, content, err=&gt;&#123; if(err)&#123; console.log('文件写入失败', err); &#125;else&#123; files[name]=&#123;filename, path, type&#125;; console.log(files); &#125; &#125;); &#125; &#125;); //5.完成 console.log(post); &#125; &#125; res.end(); &#125;);&#125;);server.listen(8080); 流操作 fs.readFile和fs.writeFile的弊端 描述：以上文件上传的一个瑕疵就是会等到所有数据都到达了才开始处理，然后通过fs.writeFile上传文件 12345http.createServer((req, res)=&gt;&#123; fs.readFile(`www$&#123;req.url&#125;`, (err, data)=&gt;&#123; res.write(data); &#125;);&#125;); fs.readFile先把所有数据全读到内存中，然后回调,这种方式极其占用内存且资源利用极其不充分，读取文件的过程中网络传输一直空闲，等到文件IO读取完毕，IO一直空闲，网络传输变得繁忙 解决：收到一部分就解析一部分，极大节约内存,使用流读取文件，读一点、发一点 分类 读取流fs.createReadStream写入流fs.createWriteStream 12345678910111213141516const http=require('http');const fs=require('fs');let server=http.createServer((req, res)=&gt;&#123; let rs=fs.createReadStream(`www$&#123;req.url&#125;`); rs.pipe(res); rs.on('error', err=&gt;&#123; res.writeHeader(404); res.write('Not Found'); res.end(); &#125;);&#125;);server.listen(8080); gz压缩 无gz压缩传输 没有通过gz压缩传输,请求资源1.html文件大小321B，jquery.js文件大小262KB 12345678910111213141516171819202122const http=require('http');const fs=require('fs');const zlib=require('zlib');let server=http.createServer((req, res)=&gt;&#123; let rs=fs.createReadStream(`www$&#123;req.url&#125;`); rs.pipe(res); /*res.setHeader('content-encoding', 'gzip'); let gz=zlib.createGzip(); rs.pipe(gz).pipe(res);*/ rs.on('error', err=&gt;&#123; res.writeHeader(404); res.write('Not Found'); res.end(); &#125;);&#125;);server.listen(8080); gz压缩传输 读写流,通过gz压缩传输,请求资源1.html文件大小292B，jquery.js文件大小77.8KB 创建读取流读取www${req.url}文件，通过gz压缩、加密该文件然后返回给浏览器，需要设置响应头res.setHeader(&#39;content-encoding&#39;, &#39;gzip&#39;),让浏览器识别该资源是通过gz压缩的文件 12345678910111213141516171819202122const http=require('http');const fs=require('fs');const zlib=require('zlib');let server=http.createServer((req, res)=&gt;&#123; let rs=fs.createReadStream(`www$&#123;req.url&#125;`); //rs.pipe(res); res.setHeader('content-encoding', 'gzip'); let gz=zlib.createGzip(); rs.pipe(gz).pipe(res); rs.on('error', err=&gt;&#123; res.writeHeader(404); res.write('Not Found'); res.end(); &#125;);&#125;);server.listen(8080); NodeJS进阶下 缓存 标记文件修改时间实现缓存 获得文件修改时间 123456789const fs=require('fs');fs.stat('./www/1.html', (err, stat)=&gt;&#123; if(err)&#123; console.log('获取文件信息失败'); &#125;else&#123; console.log(stat.mtime.toGMTString()); &#125;&#125;); 服务器设置响应头Last-Modified 标记文件最后一次修改时间 缓存实现过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const http=require('http');const fs=require('fs');const url=require('url');http.createServer((req, res)=&gt;&#123; let &#123;pathname&#125;=url.parse(req.url); //获取文件日期 fs.stat(`www$&#123;pathname&#125;`, (err, stat)=&gt;&#123; if(err)&#123; res.writeHeader(404); res.write('Not Found'); res.end(); &#125;else&#123; // console.log(req) if(req.headers['if-modified-since'])&#123; let oDate=new Date(req.headers['if-modified-since']); let time_client=Math.floor(oDate.getTime()/1000); let time_server=Math.floor(stat.mtime.getTime()/1000); if(time_server&gt;time_client)&#123; //服务器的文件时间&gt;客户端手里的版本 sendFileToClient(); &#125;else&#123; res.writeHeader(304); res.write('Not Modified'); res.end(); &#125; &#125;else&#123; sendFileToClient(); &#125; function sendFileToClient()&#123; //发送 let rs=fs.createReadStream(`www$&#123;pathname&#125;`); res.setHeader('Last-Modified', stat.mtime.toGMTString()); //输出 rs.pipe(res); rs.on('error', err=&gt;&#123; res.writeHeader(404); res.write('Not Found'); res.end(); &#125;); &#125; &#125; &#125;);&#125;).listen(8080); 第一次请求,响应状态码200,浏览器没有缓存 服务器响应头带了Last-Modified标记该资源文件最后一次修改时间 第二次请求,响应状态码304，浏览器有缓存 请求头带了if-modified-since标记该资源文件的最后一次修改时间,通过该标记去告诉服务器我本地有这个文件及这个文件最后一次修改时间，服务器收到请求通过if-modified-since标记的时间和服务器上该文件的时间进行比较，如果服务器的文件等于if-modified-since的时间，说明该资源文件没有被修改过，浏览器决定从不从缓存中取出 缓存策略 服务器设置响应头cache-control和expires 多进程 主进程负责派生子进程，子进程负责干活 特点 普通程序不能“创建”进程，只有系统进程才能创建进程；只有主进程能分裂进程是分裂出来分裂出来的两个进程执行的是同一套代码父子进程之间可以共享”句柄”(如：8080端口) 进程分裂实现 通过cluster.isMaster判断是否是主进程，如果是主进程则cluster.fork()分裂子进程 12345678910111213141516171819202122232425const http=require('http');const cluster=require('cluster');const os=require('os');const process=require('process');if(cluster.isMaster)&#123; for(let i=0;i&lt;os.cpus().length;i++)&#123; cluster.fork(); &#125; console.log('主进程');&#125;else&#123; console.log('子进程'); let server=http.createServer((req, res)=&gt;&#123; //进程id console.log('子进程id',process.pid); res.write('aaaa'); res.end(); &#125;); server.listen(8080); console.log('服务器开好了，在8080上');&#125; 123456789101112131415161718主进程子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程 26956 进程调度 主进程通过系统的CPU核数分裂了8个子进程，浏览器发起请求的时候只有一个子进程 26956干活 多个进程同时存在时，进程的调度原则是第一个进程满了才开启第二个进程，前面两个进程满了才开启第三个进程，这样做的原因是因为进程调度即进程切换是需要花费开销的 坑 主进程能否分裂100个进程，有必要么 可以分裂100个进程，但是没有必要，进程调度需要花费开销，况且进程的实际工作计算能力需要根据计算机本身硬件的限制 NodeJS使用MySQL]]></content>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0开始独立完成企业级Java电商网站开发（服务端）]]></title>
    <url>%2Fmyhexo%2F2019%2F03%2F13%2F%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%8B%AC%E7%AB%8B%E5%AE%8C%E6%88%90%E4%BC%81%E4%B8%9A%E7%BA%A7Java%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据表结构设计 唯一索引unique，保证数据唯一性 1234567891011121314CREATE TABLE `mmall_user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户表id', `username` varchar(50) NOT NULL COMMENT '用户名', `password` varchar(50) NOT NULL COMMENT '用户密码，MD5加密', `email` varchar(50) DEFAULT NULL, `phone` varchar(20) DEFAULT NULL, `question` varchar(100) DEFAULT NULL COMMENT '找回密码问题', `answer` varchar(100) DEFAULT NULL COMMENT '找回密码答案', `role` int(4) NOT NULL COMMENT '角色0-管理员,1-普通用户', `create_time` datetime NOT NULL COMMENT '创建时间', `update_time` datetime NOT NULL COMMENT '最后一次更新时间', PRIMARY KEY (`id`), UNIQUE KEY `user_name_unique` (`username`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8; 单索引及组合索引 12345678910111213141516CREATE TABLE `mmall_order_item` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '订单子表id', `user_id` int(11) DEFAULT NULL, `order_no` bigint(20) DEFAULT NULL, `product_id` int(11) DEFAULT NULL COMMENT '商品id', `product_name` varchar(100) DEFAULT NULL COMMENT '商品名称', `product_image` varchar(500) DEFAULT NULL COMMENT '商品图片地址', `current_unit_price` decimal(20,2) DEFAULT NULL COMMENT '生成订单时的商品单价，单位是元,保留两位小数', `quantity` int(10) DEFAULT NULL COMMENT '商品数量', `total_price` decimal(20,2) DEFAULT NULL COMMENT '商品总价,单位是元,保留两位小数', `create_time` datetime DEFAULT NULL, `update_time` datetime DEFAULT NULL, PRIMARY KEY (`id`), KEY `order_no_index` (`order_no`) USING BTREE, KEY `order_no_user_id_index` (`user_id`,`order_no`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=135 DEFAULT CHARSET=utf8; 查业务问题的后悔药 create_time 数据创建时间update_time 数据更新时间 mybatis三剑客 mybatis-generator自动化生成数据库交互代码 配置pom.xml 12345678910111213&lt;build&gt; &lt;finalName&gt;mmall&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/build&gt; datasource.properties 12345678910111213141516db.driverLocation=/Users/imooc/mysql-connector-java-5.1.6-bin.jardb.driverClassName=com.mysql.jdbc.Driver#db.url=jdbc:mysql://192.1.1.1:3306/mmall?characterEncoding=utf-8db.url=jdbc:mysql://你的数据库IP:你的数据库Port/你的database?characterEncoding=utf-8db.username=mmalldb.password=dbpassworddb.initialSize = 20db.maxActive = 50db.maxIdle = 20db.minIdle = 10db.maxWait = 10db.defaultAutoCommit = truedb.minEvictableIdleTimeMillis = 3600000 generatorConfig.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!--导入属性配置--&gt; &lt;properties resource="datasource.properties"&gt;&lt;/properties&gt; &lt;!--指定特定数据库的jdbc驱动jar包的位置--&gt; &lt;classPathEntry location="$&#123;db.driverLocation&#125;"/&gt; &lt;context id="default" targetRuntime="MyBatis3"&gt; &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--jdbc的数据库连接 --&gt; &lt;jdbcConnection driverClass="$&#123;db.driverClassName&#125;" connectionURL="$&#123;db.url&#125;" userId="$&#123;db.username&#125;" password="$&#123;db.password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类 targetPackage 指定生成的model生成所在的包名 targetProject 指定在该项目下所在的路径 --&gt; &lt;!--&lt;javaModelGenerator targetPackage="com.mmall.pojo" targetProject=".\src\main\java"&gt;--&gt; &lt;javaModelGenerator targetPackage="com.mmall.pojo" targetProject="./src/main/java"&gt; &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;!-- 是否对model添加 构造函数 --&gt; &lt;property name="constructorBased" value="true"/&gt; &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;!-- 建立的Model对象是否 不可改变 即生成的Model对象不会有 setter方法，只有构造方法 --&gt; &lt;property name="immutable" value="false"/&gt; &lt;/javaModelGenerator&gt; &lt;!--mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt; &lt;!--&lt;sqlMapGenerator targetPackage="mappers" targetProject=".\src\main\resources"&gt;--&gt; &lt;sqlMapGenerator targetPackage="mappers" targetProject="./src/main/resources"&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码 type="ANNOTATEDMAPPER",生成Java Model 和基于注解的Mapper对象 type="MIXEDMAPPER",生成基于注解的Java Model 和相应的Mapper对象 type="XMLMAPPER",生成SQLMap XML文件和独立的Mapper接口 --&gt; &lt;!-- targetPackage：mapper接口dao生成的位置 --&gt; &lt;!--&lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.mmall.dao" targetProject=".\src\main\java"&gt;--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.mmall.dao" targetProject="./src/main/java"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/javaClientGenerator&gt; &lt;table tableName="mmall_shipping" domainObjectName="Shipping" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_cart" domainObjectName="Cart" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_cart_item" domainObjectName="CartItem" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_category" domainObjectName="Category" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_order" domainObjectName="Order" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_order_item" domainObjectName="OrderItem" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_pay_info" domainObjectName="PayInfo" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_product" domainObjectName="Product" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt; &lt;columnOverride column="detail" jdbcType="VARCHAR" /&gt; &lt;columnOverride column="sub_images" jdbcType="VARCHAR" /&gt; &lt;/table&gt; &lt;table tableName="mmall_user" domainObjectName="User" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;!-- geelynote mybatis插件的搭建 --&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 运行 mybatis-plugin idea插件，实现mybatis的接口文件和xml自动跳转 下载 mybatis-pagehelper mybatis分页组件 配置pom.xml 12345678910111213141516171819&lt;!-- mybatis pager --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.miemiedev&lt;/groupId&gt; &lt;artifactId&gt;mybatis-paginator&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.4&lt;/version&gt; &lt;/dependency&gt; Tomcat加载spring、springmvc 方式一：配置web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 启动我们自己的listener --&gt; &lt;listener&gt; &lt;listener-class&gt;com.atguigu.scw.manager.listener.MyAppListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 启动spring容器 --&gt; &lt;!-- needed for ContextLoaderListener --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Bootstraps the root web application context before servlet initialization --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- The front controller of this Spring Web application, responsible for handling all application requests --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- Map all requests to the DispatcherServlet for handling --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 加上字符编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 只是指定了编码格式 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 进行请求乱码解决 --&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 方式二：配置web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 测试插件 FeHelper Restlet Client 用户模块 横向越权 入参需要指定当前用户id 纵向越权 MD5明文加密 盐值加密 MD5Util.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.mmall.util;import org.springframework.util.StringUtils;import java.security.MessageDigest;/** * Created by geely */public class MD5Util &#123; private static String byteArrayToHexString(byte b[]) &#123; StringBuffer resultSb = new StringBuffer(); for (int i = 0; i &lt; b.length; i++) resultSb.append(byteToHexString(b[i])); return resultSb.toString(); &#125; private static String byteToHexString(byte b) &#123; int n = b; if (n &lt; 0) n += 256; int d1 = n / 16; int d2 = n % 16; return hexDigits[d1] + hexDigits[d2]; &#125; /** * 返回大写MD5 * * @param origin * @param charsetname * @return */ private static String MD5Encode(String origin, String charsetname) &#123; String resultString = null; try &#123; resultString = new String(origin); MessageDigest md = MessageDigest.getInstance("MD5"); if (charsetname == null || "".equals(charsetname)) resultString = byteArrayToHexString(md.digest(resultString.getBytes())); else resultString = byteArrayToHexString(md.digest(resultString.getBytes(charsetname))); &#125; catch (Exception exception) &#123; &#125; return resultString.toUpperCase(); &#125; public static String MD5EncodeUtf8(String origin) &#123; origin = origin + PropertiesUtil.getProperty("password.salt", ""); return MD5Encode(origin, "utf-8"); &#125; private static final String hexDigits[] = &#123;"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"&#125;;&#125; PropertiesUtil.java 读取src/main/resources目录下的配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.mmall.util;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.io.InputStreamReader;import java.util.Properties;/** * Created by geely */public class PropertiesUtil &#123; private static Logger logger = LoggerFactory.getLogger(PropertiesUtil.class); private static Properties props; static &#123; String fileName = "mmall.properties"; props = new Properties(); try &#123; props.load(new InputStreamReader(PropertiesUtil.class.getClassLoader().getResourceAsStream(fileName),"UTF-8")); &#125; catch (IOException e) &#123; logger.error("配置文件读取异常",e); &#125; &#125; public static String getProperty(String key)&#123; String value = props.getProperty(key.trim()); if(StringUtils.isBlank(value))&#123; return null; &#125; return value.trim(); &#125; public static String getProperty(String key,String defaultValue)&#123; String value = props.getProperty(key.trim()); if(StringUtils.isBlank(value))&#123; value = defaultValue; &#125; return value.trim(); &#125;&#125; mmall.properties 123456789ftp.server.ip=你的FTP服务器ip地址ftp.user=mmallftpftp.pass=ftppasswordftp.server.http.prefix=http://img.happymmall.com/alipay.callback.url=http://www.happymmall.com/order/alipay_callback.dopassword.salt = geelysdafaqj23ou89ZXcj@#$@#$#@KJdjklj;D../dSF., 应用：明文加密 guava缓存 设置token并传给前台用户 验证token TokenCache.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.mmall.common;import com.google.common.cache.CacheBuilder;import com.google.common.cache.CacheLoader;import com.google.common.cache.LoadingCache;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.concurrent.TimeUnit;/** * Created by geely */public class TokenCache &#123; private static Logger logger = LoggerFactory.getLogger(TokenCache.class); public static final String TOKEN_PREFIX = "token_"; //LRU算法 private static LoadingCache&lt;String,String&gt; localCache = CacheBuilder.newBuilder().initialCapacity(1000).maximumSize(10000).expireAfterAccess(12, TimeUnit.HOURS) .build(new CacheLoader&lt;String, String&gt;() &#123; //默认的数据加载实现,当调用get取值的时候,如果key没有对应的值,就调用这个方法进行加载. @Override public String load(String s) throws Exception &#123; return "null"; &#125; &#125;); public static void setKey(String key,String value)&#123; localCache.put(key,value); &#125; public static String getKey(String key)&#123; String value = null; try &#123; value = localCache.get(key); if("null".equals(value))&#123; return null; &#125; return value; &#125;catch (Exception e)&#123; logger.error("localCache get error",e); &#125; return null; &#125;&#125; UserServiceImpl.java 12345678910111213141516171819202122232425262728293031323334353637383940public ServerResponse&lt;String&gt; checkAnswer(String username,String question,String answer)&#123; int resultCount = userMapper.checkAnswer(username,question,answer); if(resultCount&gt;0)&#123; //说明问题及问题答案是这个用户的,并且是正确的 String forgetToken = UUID.randomUUID().toString(); TokenCache.setKey(TokenCache.TOKEN_PREFIX+username,forgetToken); return ServerResponse.createBySuccess(forgetToken); &#125; return ServerResponse.createByErrorMessage("问题的答案错误"); &#125; public ServerResponse&lt;String&gt; forgetResetPassword(String username,String passwordNew,String forgetToken)&#123; if(org.apache.commons.lang3.StringUtils.isBlank(forgetToken))&#123; return ServerResponse.createByErrorMessage("参数错误,token需要传递"); &#125; ServerResponse validResponse = this.checkValid(username,Const.USERNAME); if(validResponse.isSuccess())&#123; //用户不存在 return ServerResponse.createByErrorMessage("用户不存在"); &#125; String token = TokenCache.getKey(TokenCache.TOKEN_PREFIX+username); if(org.apache.commons.lang3.StringUtils.isBlank(token))&#123; return ServerResponse.createByErrorMessage("token无效或者过期"); &#125; if(org.apache.commons.lang3.StringUtils.equals(forgetToken,token))&#123; String md5Password = MD5Util.MD5EncodeUtf8(passwordNew); int rowCount = userMapper.updatePasswordByUsername(username,md5Password); if(rowCount &gt; 0)&#123; return ServerResponse.createBySuccessMessage("修改密码成功"); &#125; &#125;else&#123; return ServerResponse.createByErrorMessage("token错误,请重新获取重置密码的token"); &#125; return ServerResponse.createByErrorMessage("修改密码失败"); &#125; 高复用服务响应对象的设计思想和封装 ServerResponse.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.mmall.common;import org.codehaus.jackson.annotate.JsonIgnore;import org.codehaus.jackson.map.annotate.JsonSerialize;import java.io.Serializable;/** * Created by geely */@JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL)//保证序列化json的时候,如果是null的对象,key也会消失public class ServerResponse&lt;T&gt; implements Serializable &#123; private int status; private String msg; private T data; private ServerResponse(int status)&#123; this.status = status; &#125; private ServerResponse(int status,T data)&#123; this.status = status; this.data = data; &#125; private ServerResponse(int status,String msg,T data)&#123; this.status = status; this.msg = msg; this.data = data; &#125; private ServerResponse(int status,String msg)&#123; this.status = status; this.msg = msg; &#125; @JsonIgnore //使之不在json序列化结果当中 public boolean isSuccess()&#123; return this.status == ResponseCode.SUCCESS.getCode(); &#125; public int getStatus()&#123; return status; &#125; public T getData()&#123; return data; &#125; public String getMsg()&#123; return msg; &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess()&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode()); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccessMessage(String msg)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),msg); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess(T data)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),data); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess(String msg,T data)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),msg,data); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByError()&#123; return new ServerResponse&lt;T&gt;(ResponseCode.ERROR.getCode(),ResponseCode.ERROR.getDesc()); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByErrorMessage(String errorMessage)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.ERROR.getCode(),errorMessage); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByErrorCodeMessage(int errorCode,String errorMessage)&#123; return new ServerResponse&lt;T&gt;(errorCode,errorMessage); &#125;&#125; ResponseCode.java 1234567891011121314151617181920212223242526272829package com.mmall.common;/** * Created by geely */public enum ResponseCode &#123; SUCCESS(0,"SUCCESS"), ERROR(1,"ERROR"), NEED_LOGIN(10,"NEED_LOGIN"), ILLEGAL_ARGUMENT(2,"ILLEGAL_ARGUMENT"); private final int code; private final String desc; ResponseCode(int code,String desc)&#123; this.code = code; this.desc = desc; &#125; public int getCode()&#123; return code; &#125; public String getDesc()&#123; return desc; &#125;&#125; 分类模块 递归算法 12345678910111213141516171819202122232425262728293031323334/** * 递归查询本节点的id及孩子节点的id * @param categoryId * @return */public ServerResponse&lt;List&lt;Integer&gt;&gt; selectCategoryAndChildrenById(Integer categoryId)&#123; Set&lt;Category&gt; categorySet = Sets.newHashSet(); findChildCategory(categorySet,categoryId); List&lt;Integer&gt; categoryIdList = Lists.newArrayList(); if(categoryId != null)&#123; for(Category categoryItem : categorySet)&#123; categoryIdList.add(categoryItem.getId()); &#125; &#125; return ServerResponse.createBySuccess(categoryIdList);&#125;//递归算法,算出子节点private Set&lt;Category&gt; findChildCategory(Set&lt;Category&gt; categorySet ,Integer categoryId)&#123; Category category = categoryMapper.selectByPrimaryKey(categoryId); if(category != null)&#123; categorySet.add(category); &#125; //查找子节点,递归算法一定要有一个退出的条件 List&lt;Category&gt; categoryList = categoryMapper.selectCategoryChildrenByParentId(categoryId); for(Category categoryItem : categoryList)&#123; findChildCategory(categorySet,categoryItem.getId()); &#125; return categorySet;&#125; 复杂对象排重 Set集合 重写自定义对象Category的equals和hashCode方法 无限层级树结构设计 商品模块 POJO、BO、VO抽象模型 Product.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package com.mmall.pojo;import java.math.BigDecimal;import java.util.Date;public class Product &#123; private Integer id; private Integer categoryId; private String name; private String subtitle; private String mainImage; private String subImages; private String detail; private BigDecimal price; private Integer stock; private Integer status; private Date createTime; private Date updateTime; public Product(Integer id, Integer categoryId, String name, String subtitle, String mainImage, String subImages, String detail, BigDecimal price, Integer stock, Integer status, Date createTime, Date updateTime) &#123; this.id = id; this.categoryId = categoryId; this.name = name; this.subtitle = subtitle; this.mainImage = mainImage; this.subImages = subImages; this.detail = detail; this.price = price; this.stock = stock; this.status = status; this.createTime = createTime; this.updateTime = updateTime; &#125; public Product() &#123; super(); &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getCategoryId() &#123; return categoryId; &#125; public void setCategoryId(Integer categoryId) &#123; this.categoryId = categoryId; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name == null ? null : name.trim(); &#125; public String getSubtitle() &#123; return subtitle; &#125; public void setSubtitle(String subtitle) &#123; this.subtitle = subtitle == null ? null : subtitle.trim(); &#125; public String getMainImage() &#123; return mainImage; &#125; public void setMainImage(String mainImage) &#123; this.mainImage = mainImage == null ? null : mainImage.trim(); &#125; public String getSubImages() &#123; return subImages; &#125; public void setSubImages(String subImages) &#123; this.subImages = subImages == null ? null : subImages.trim(); &#125; public String getDetail() &#123; return detail; &#125; public void setDetail(String detail) &#123; this.detail = detail == null ? null : detail.trim(); &#125; public BigDecimal getPrice() &#123; return price; &#125; public void setPrice(BigDecimal price) &#123; this.price = price; &#125; public Integer getStock() &#123; return stock; &#125; public void setStock(Integer stock) &#123; this.stock = stock; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; public Date getCreateTime() &#123; return createTime; &#125; public void setCreateTime(Date createTime) &#123; this.createTime = createTime; &#125; public Date getUpdateTime() &#123; return updateTime; &#125; public void setUpdateTime(Date updateTime) &#123; this.updateTime = updateTime; &#125;&#125; ProductDetailVo.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package com.mmall.vo;import java.math.BigDecimal;/** * Created by geely */public class ProductDetailVo &#123; private Integer id; private Integer categoryId; private String name; private String subtitle; private String mainImage; private String subImages; private String detail; private BigDecimal price; private Integer stock; private Integer status; private String createTime; private String updateTime; private String imageHost; private Integer parentCategoryId; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getCategoryId() &#123; return categoryId; &#125; public void setCategoryId(Integer categoryId) &#123; this.categoryId = categoryId; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSubtitle() &#123; return subtitle; &#125; public void setSubtitle(String subtitle) &#123; this.subtitle = subtitle; &#125; public String getMainImage() &#123; return mainImage; &#125; public void setMainImage(String mainImage) &#123; this.mainImage = mainImage; &#125; public String getSubImages() &#123; return subImages; &#125; public void setSubImages(String subImages) &#123; this.subImages = subImages; &#125; public String getDetail() &#123; return detail; &#125; public void setDetail(String detail) &#123; this.detail = detail; &#125; public BigDecimal getPrice() &#123; return price; &#125; public void setPrice(BigDecimal price) &#123; this.price = price; &#125; public Integer getStock() &#123; return stock; &#125; public void setStock(Integer stock) &#123; this.stock = stock; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; public String getCreateTime() &#123; return createTime; &#125; public void setCreateTime(String createTime) &#123; this.createTime = createTime; &#125; public String getUpdateTime() &#123; return updateTime; &#125; public void setUpdateTime(String updateTime) &#123; this.updateTime = updateTime; &#125; public String getImageHost() &#123; return imageHost; &#125; public void setImageHost(String imageHost) &#123; this.imageHost = imageHost; &#125; public Integer getParentCategoryId() &#123; return parentCategoryId; &#125; public void setParentCategoryId(Integer parentCategoryId) &#123; this.parentCategoryId = parentCategoryId; &#125;&#125; 静态代码块&gt;普通代码块&gt;构造代码块 Tomcat启动加载静态代码块 时间转换工具类DateTimeUtil.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.mmall.util;import org.apache.commons.lang3.StringUtils;import org.joda.time.DateTime;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;import java.util.Date;/** * Created by geely */public class DateTimeUtil &#123; //joda-time //str-&gt;Date //Date-&gt;str public static final String STANDARD_FORMAT = "yyyy-MM-dd HH:mm:ss"; public static Date strToDate(String dateTimeStr,String formatStr)&#123; DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(formatStr); DateTime dateTime = dateTimeFormatter.parseDateTime(dateTimeStr); return dateTime.toDate(); &#125; public static String dateToStr(Date date,String formatStr)&#123; if(date == null)&#123; return StringUtils.EMPTY; &#125; DateTime dateTime = new DateTime(date); return dateTime.toString(formatStr); &#125; public static Date strToDate(String dateTimeStr)&#123; DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(STANDARD_FORMAT); DateTime dateTime = dateTimeFormatter.parseDateTime(dateTimeStr); return dateTime.toDate(); &#125; public static String dateToStr(Date date)&#123; if(date == null)&#123; return StringUtils.EMPTY; &#125; DateTime dateTime = new DateTime(date); return dateTime.toString(STANDARD_FORMAT); &#125; public static void main(String[] args) &#123; System.out.println(DateTimeUtil.dateToStr(new Date(),"yyyy-MM-dd HH:mm:ss")); System.out.println(DateTimeUtil.strToDate("2010-01-01 11:11:11","yyyy-MM-dd HH:mm:ss")); &#125;&#125; mybatis-pagehelper高效分页 配置pom.xml 实现 mybatis-pagehelper动态排序 mybatis对List遍历的实现方法 mybatis对where语句动态拼装 FTP服务对接 先将文件上传到本地======&gt;上传到远程ftp====&gt;删除本地文件 配置pom.xml 12345678910111213&lt;!-- file upload --&gt; &lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; 配置dispatcher-servlet.xml 123456&lt;!-- 文件上传 --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="10485760"/&gt; &lt;!-- 10m --&gt; &lt;property name="maxInMemorySize" value="4096" /&gt; &lt;property name="defaultEncoding" value="UTF-8"&gt;&lt;/property&gt;&lt;/bean&gt; FileServiceImpl.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.mmall.service.impl;import com.google.common.collect.Lists;import com.mmall.service.IFileService;import com.mmall.util.FTPUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Service;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;import java.util.UUID;/** * Created by geely */@Service("iFileService")public class FileServiceImpl implements IFileService &#123; private Logger logger = LoggerFactory.getLogger(FileServiceImpl.class); public String upload(MultipartFile file,String path)&#123; String fileName = file.getOriginalFilename(); //扩展名 //abc.jpg String fileExtensionName = fileName.substring(fileName.lastIndexOf(".")+1); String uploadFileName = UUID.randomUUID().toString()+"."+fileExtensionName; logger.info("开始上传文件,上传文件的文件名:&#123;&#125;,上传的路径:&#123;&#125;,新文件名:&#123;&#125;",fileName,path,uploadFileName); File fileDir = new File(path); if(!fileDir.exists())&#123; fileDir.setWritable(true); fileDir.mkdirs(); &#125; File targetFile = new File(path,uploadFileName); try &#123; file.transferTo(targetFile); //文件已经上传成功了 FTPUtil.uploadFile(Lists.newArrayList(targetFile)); //已经上传到ftp服务器上 targetFile.delete(); &#125; catch (IOException e) &#123; logger.error("上传文件异常",e); return null; &#125; //A:abc.jpg //B:abc.jpg return targetFile.getName(); &#125;&#125; 连接远程ftp，上传文件 FTPUtil.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.mmall.util;import org.apache.commons.net.ftp.FTPClient;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.util.List;/** * Created by geely */public class FTPUtil &#123; private static final Logger logger = LoggerFactory.getLogger(FTPUtil.class); private static String ftpIp = PropertiesUtil.getProperty("ftp.server.ip"); private static String ftpUser = PropertiesUtil.getProperty("ftp.user"); private static String ftpPass = PropertiesUtil.getProperty("ftp.pass"); public FTPUtil(String ip,int port,String user,String pwd)&#123; this.ip = ip; this.port = port; this.user = user; this.pwd = pwd; &#125; public static boolean uploadFile(List&lt;File&gt; fileList) throws IOException &#123; FTPUtil ftpUtil = new FTPUtil(ftpIp,21,ftpUser,ftpPass); logger.info("开始连接ftp服务器"); boolean result = ftpUtil.uploadFile("img",fileList); logger.info("开始连接ftp服务器,结束上传,上传结果:&#123;&#125;"); return result; &#125; private boolean uploadFile(String remotePath,List&lt;File&gt; fileList) throws IOException &#123; boolean uploaded = true; FileInputStream fis = null; //连接FTP服务器 if(connectServer(this.ip,this.port,this.user,this.pwd))&#123; try &#123; ftpClient.changeWorkingDirectory(remotePath); ftpClient.setBufferSize(1024); ftpClient.setControlEncoding("UTF-8"); ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); ftpClient.enterLocalPassiveMode(); for(File fileItem : fileList)&#123; fis = new FileInputStream(fileItem); ftpClient.storeFile(fileItem.getName(),fis); &#125; &#125; catch (IOException e) &#123; logger.error("上传文件异常",e); uploaded = false; e.printStackTrace(); &#125; finally &#123; fis.close(); ftpClient.disconnect(); &#125; &#125; return uploaded; &#125; private boolean connectServer(String ip,int port,String user,String pwd)&#123; boolean isSuccess = false; ftpClient = new FTPClient(); try &#123; ftpClient.connect(ip); isSuccess = ftpClient.login(user,pwd); &#125; catch (IOException e) &#123; logger.error("连接FTP服务器异常",e); &#125; return isSuccess; &#125; private String ip; private int port; private String user; private String pwd; private FTPClient ftpClient; public String getIp() &#123; return ip; &#125; public void setIp(String ip) &#123; this.ip = ip; &#125; public int getPort() &#123; return port; &#125; public void setPort(int port) &#123; this.port = port; &#125; public String getUser() &#123; return user; &#125; public void setUser(String user) &#123; this.user = user; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; public FTPClient getFtpClient() &#123; return ftpClient; &#125; public void setFtpClient(FTPClient ftpClient) &#123; this.ftpClient = ftpClient; &#125;&#125; 富文本上传 和ftp文件上传类似，只是对返回值有特殊要求 购物车模块 商品总价计算复用封装 123456789101112131415161718192021222324252627282930313233343536373839404142package com.mmall.util;import java.math.BigDecimal;/** * Created by geely */public class BigDecimalUtil &#123; private BigDecimalUtil()&#123; &#125; public static BigDecimal add(double v1,double v2)&#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.add(b2); &#125; public static BigDecimal sub(double v1,double v2)&#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.subtract(b2); &#125; public static BigDecimal mul(double v1,double v2)&#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.multiply(b2); &#125; public static BigDecimal div(double v1,double v2)&#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.divide(b2,2,BigDecimal.ROUND_HALF_UP);//四舍五入,保留2位小数 //除不尽的情况 &#125;&#125; 高复用的逻辑方法封装思想 解决商业运算丢失精度的坑 一定要用BigDecimal的String构造函数 123456789101112131415161718192021222324252627public class BigDecimalTest &#123; @Test public void test1()&#123; System.out.println(0.05+0.01); System.out.println(1.0-0.42); System.out.println(4.015*100); System.out.println(123.3/100); &#125; @Test public void test2()&#123; BigDecimal b1 = new BigDecimal(0.05); BigDecimal b2 = new BigDecimal(0.01); System.out.println(b1.add(b2)); &#125; @Test public void test3()&#123; BigDecimal b1 = new BigDecimal("0.05"); BigDecimal b2 = new BigDecimal("0.01"); System.out.println(b1.add(b2)); &#125;&#125; 订单模块 安全漏洞解决方案 订单号生成规则 强大的常量、枚举设计 Const.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package com.mmall.common;import com.google.common.collect.Sets;import java.util.Set;/** * Created by geely */public class Const &#123; public static final String CURRENT_USER = "currentUser"; public static final String EMAIL = "email"; public static final String USERNAME = "username"; public interface ProductListOrderBy&#123; Set&lt;String&gt; PRICE_ASC_DESC = Sets.newHashSet("price_desc","price_asc"); &#125; public interface Cart&#123; int CHECKED = 1;//即购物车选中状态 int UN_CHECKED = 0;//购物车中未选中状态 String LIMIT_NUM_FAIL = "LIMIT_NUM_FAIL"; String LIMIT_NUM_SUCCESS = "LIMIT_NUM_SUCCESS"; &#125; public interface Role&#123; int ROLE_CUSTOMER = 0; //普通用户 int ROLE_ADMIN = 1;//管理员 &#125; public enum ProductStatusEnum&#123; ON_SALE(1,"在线"); private String value; private int code; ProductStatusEnum(int code,String value)&#123; this.code = code; this.value = value; &#125; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; &#125; public enum OrderStatusEnum&#123; CANCELED(0,"已取消"), NO_PAY(10,"未支付"), PAID(20,"已付款"), SHIPPED(40,"已发货"), ORDER_SUCCESS(50,"订单完成"), ORDER_CLOSE(60,"订单关闭"); OrderStatusEnum(int code,String value)&#123; this.code = code; this.value = value; &#125; private String value; private int code; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; public static OrderStatusEnum codeOf(int code)&#123; for(OrderStatusEnum orderStatusEnum : values())&#123; if(orderStatusEnum.getCode() == code)&#123; return orderStatusEnum; &#125; &#125; throw new RuntimeException("么有找到对应的枚举"); &#125; &#125; public interface AlipayCallback&#123; String TRADE_STATUS_WAIT_BUYER_PAY = "WAIT_BUYER_PAY"; String TRADE_STATUS_TRADE_SUCCESS = "TRADE_SUCCESS"; String RESPONSE_SUCCESS = "success"; String RESPONSE_FAILED = "failed"; &#125; public enum PayPlatformEnum&#123; ALIPAY(1,"支付宝"); PayPlatformEnum(int code,String value)&#123; this.code = code; this.value = value; &#125; private String value; private int code; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; &#125; public enum PaymentTypeEnum&#123; ONLINE_PAY(1,"在线支付"); PaymentTypeEnum(int code,String value)&#123; this.code = code; this.value = value; &#125; private String value; private int code; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; public static PaymentTypeEnum codeOf(int code)&#123; for(PaymentTypeEnum paymentTypeEnum : values())&#123; if(paymentTypeEnum.getCode() == code)&#123; return paymentTypeEnum; &#125; &#125; throw new RuntimeException("么有找到对应的枚举"); &#125; &#125;&#125; 使用 mybatis批量插入 收货地址 同步获取自增主键 数据绑定的对象绑定 收货地址对象必须要有get和set方法 越权问题升级巩固 支付模块 支付宝SDK源码解析 当面付 当面付Demo 服务端SDK下载和使用教程 沙箱环境使用 生成RSA密钥 支付宝支付流程与集成 导入依赖 配置maven插件,除了pom.xml配置的依赖，lib包中的依赖也会一起打包部署 配置沙箱环境zfbinfo.properties 1234567891011121314151617181920212223242526272829303132333435# 支付宝网关名、partnerId和appIdopen_api_domain = https://openapi.alipaydev.com/gateway.domcloud_api_domain = http://mcloudmonitor.com/gateway.dopid = 2088102180444972appid = 2016102100728313# RSA私钥、公钥和支付宝公钥private_key = MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCKQ2pEIzXM4IoN1cMzOFXdlk8yVX2cKXWITZ92EGAQQcRytaV07yQOaz3UE9KTeT9Nu628G+HZMsJUxQjEUETagmY5nLtbeL35M2UcibYpM3e2gVTtUW86CA65GCdLzUhdIug8yf2F9zWayzG4sHZ9DcTezG6ZjFu+EtDpFgg+CtqY7n/ihjTIqeE1lX0C2ZIKpIYs7QjR8AztB/qRcpOJKRfMKGDgmT9GALN8LeFEYCbQ+W/GJHN8bQ0Bk1Ll6EKQ4cHXZ1Yko+aXaRfbXfUZYgD9hwAVlxtwZndgeFX8KapOCw0J25pzV4WkutIjMlt7I2Q1jaWNoKLuxtz4M2mzAgMBAAECggEAAhnsL4TpeGehMXyiLtEYXPm/0mACPLFUm/GyDrVJAHY/ag7gqNpJjf6LPgHfHWamU6Qai9VQpWBkG62y6Gjf4wJAU3fSUR2QpYzmaHyfTBkAJMHqbIDkU9lzf9SiJEDGbMPvC512QOb05ZlY9Bmac2QWLdylgafkbQsUKbawAWFa/BAOMIp0tgYLW8/yY2aG6jeLqhOgTo8MWIW5d1qHtX5m/x7g97dYYMdX3kTo2i1dFLUVfEOvZe4US6VBvLg71dMxwadVF5YMaY9jq/ShPD0Gkf29wdThwsjcH6u9Tq/KArQTK+z02DAGkdWOcue3pHql+gvoIA8U5uFDdIeYwQKBgQDri3jPkDKi48efdKQk38rn+CJYeNFNRAhlly3h2AHaFEY92XRlBsho/vGFg43BvHu+cMz0Run4SS8Vo09vcTIY6p2xNMffjR0w2gQqx6PUdGHBFtw7FavxN4uVtVhL6uTAqfBv97mqQO0bq+DhOGwSRNIWqvnzfXywqwmXhKYECwKBgQCWRTl6tNv8scxPq4fpRL/uw71TU6XqSS/nME7KT4uyQPAXPk0mXVVwdmyST9Crlr6O6WJopPe9nMIFUYdjdkLfGKLCR96AH3U7frr4jf60eDYEhfHGIzln/ptrTJLvvbXTaPctAaZd6TIv63QVz3yim4MMl3VSdRlrE+O9R5ZR+QKBgQDjEP8TyUSnNsJX+4/JZFwsp04kz8OlorIdjVHT5/JREz5rnVfRlGpanXqjZSCg5Vy9R+ysiDhA+/wB9f87xXmv/2ypSeJspZLAZ0uhGffbdZ5PEASaiNfKn+tWFQ3bkcOX37tDlSJM+G4bQOR2+XdlXSbSZ1yx2AT+IsQKZvvL5QKBgQCPZEUiEz0sV1kX2R2a+XCQ3RVnUxWqh+X/HPjCUr+B/DdeZqPl7QAfjdGymBkN842o/4lZQ7nnpJL70j14KpxLGM4Ox9fIuLv8ZsTxc0XOXjtle48nO+uGkc0qyWoY/RVpQ+tBdiaTzHeIhIxEV7adz/lwZYKdiYIUzGjv8ES/uQKBgCgeWysXjahCQItxx5fTrS8SQFP7Dx5vDW+UkqQ2pbL0AlHyUS7pWJj3AAe3pn4AJZZp4SZPoQP+Z8JPqDA6MrQWHYMi0XkMuMYwLWbGCkmf1MnjUxgOaLXoItjxS/y3jQfeOmHhmOAVkjnEvAh+BWlZxFMv2kiuHRU72bNa0rDIpublic_key = MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAikNqRCM1zOCKDdXDMzhV3ZZPMlV9nCl1iE2fdhBgEEHEcrWldO8kDms91BPSk3k/TbutvBvh2TLCVMUIxFBE2oJmOZy7W3i9+TNlHIm2KTN3toFU7VFvOggOuRgnS81IXSLoPMn9hfc1mssxuLB2fQ3E3sxumYxbvhLQ6RYIPgramO5/4oY0yKnhNZV9AtmSCqSGLO0I0fAM7Qf6kXKTiSkXzChg4Jk/RgCzfC3hRGAm0PlvxiRzfG0NAZNS5ehCkOHB12dWJKPml2kX2131GWIA/YcAFZcbcGZ3YHhV/CmqTgsNCduac1eFpLrSIzJbeyNkNY2ljaCi7sbc+DNpswIDAQAB#SHA1withRsa对应支付宝公钥#alipay_public_key = MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDI6d306Q8fIfCOaTXyiUeJHkrIvYISRcc73s3vF1ZT7XN8RNPwJxo8pWaJMmvyTn9N4HQ632qJBVHf8sxHi/fEsraprwCtzvzQETrNRwVxLO5jVmRGi60j8Ue1efIlzPXV9je9mkjzOmdssymZkh2QhUrCmZYI/FCEa3/cNMW0QIDAQAB#SHA256withRsa对应支付宝公钥alipay_public_key = MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqzWgVL/NWrJAeyEImwtaK3IDwj0dKkqUDIfqqWn5SiLaWMYi9RmKhn+jY9VM7JXEIkYYeVlqIL6Xn7OvYFRTi4buTCXGKvFLn95aDcaur77/S/0ibcdN1K2wIoHzaqQhXAb1ezKxTnFP7OLJsAL22b0NzrQDj2OH9SA06gJb8nHBfR+7Sx7DfwcqE0OtTcDHjbbcB24Qgg/dfItxoEnKuSyRVrf6BtpUnJxSzG/Ge7FfF+VBq8re1t4ZTSxaDEjto071I5VFBxr7I4SyqZsc7WpAmZL8AqUgEbQ1XYBWx2LnpJXM5GQW/thUvcDDqzea7LJNWJOQPM5DaZQgu7QuuwIDAQAB# 签名类型: RSA-&gt;SHA1withRsa,RSA2-&gt;SHA256withRsasign_type = RSA2# 当面付最大查询次数和查询间隔（毫秒）max_query_retry = 5query_duration = 5000# 当面付最大撤销次数和撤销间隔（毫秒）max_cancel_retry = 3cancel_duration = 2000# 交易保障线程第一次调度延迟和调度间隔（秒）heartbeat_delay = 5heartbeat_duration = 900 二维码生成，扫码支付 配置回调url 两次回调，扫码进行一次回调，扫码付款成功进行一次回调 生成二维码，上传到ftp服务器 OrderServiceImpl.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216package com.mmall.service.impl;/** * Created by geely */@Service("iOrderService")public class OrderServiceImpl implements IOrderService &#123; private static AlipayTradeService tradeService; static &#123; /** 一定要在创建AlipayTradeService之前调用Configs.init()设置默认参数 * Configs会读取classpath下的zfbinfo.properties文件配置信息，如果找不到该文件则确认该文件是否在classpath目录 */ Configs.init("zfbinfo.properties"); /** 使用Configs提供的默认参数 * AlipayTradeService可以使用单例或者为静态成员对象，不需要反复new */ tradeService = new AlipayTradeServiceImpl.ClientBuilder().build(); &#125; private static final Logger logger = LoggerFactory.getLogger(OrderServiceImpl.class); @Autowired private OrderMapper orderMapper; @Autowired private OrderItemMapper orderItemMapper; @Autowired private PayInfoMapper payInfoMapper; @Autowired private CartMapper cartMapper; @Autowired private ProductMapper productMapper; @Autowired private ShippingMapper shippingMapper; public ServerResponse pay(Long orderNo,Integer userId,String path)&#123; Map&lt;String ,String&gt; resultMap = Maps.newHashMap(); Order order = orderMapper.selectByUserIdAndOrderNo(userId,orderNo); if(order == null)&#123; return ServerResponse.createByErrorMessage("用户没有该订单"); &#125; resultMap.put("orderNo",String.valueOf(order.getOrderNo())); // (必填) 商户网站订单系统中唯一订单号，64个字符以内，只能包含字母、数字、下划线， // 需保证商户系统端不能重复，建议通过数据库sequence生成， String outTradeNo = order.getOrderNo().toString(); // (必填) 订单标题，粗略描述用户的支付目的。如“xxx品牌xxx门店当面付扫码消费” String subject = new StringBuilder().append("happymmall扫码支付,订单号:").append(outTradeNo).toString(); // (必填) 订单总金额，单位为元，不能超过1亿元 // 如果同时传入了【打折金额】,【不可打折金额】,【订单总金额】三者,则必须满足如下条件:【订单总金额】=【打折金额】+【不可打折金额】 String totalAmount = order.getPayment().toString(); // (可选) 订单不可打折金额，可以配合商家平台配置折扣活动，如果酒水不参与打折，则将对应金额填写至此字段 // 如果该值未传入,但传入了【订单总金额】,【打折金额】,则该值默认为【订单总金额】-【打折金额】 String undiscountableAmount = "0"; // 卖家支付宝账号ID，用于支持一个签约账号下支持打款到不同的收款账号，(打款到sellerId对应的支付宝账号) // 如果该字段为空，则默认为与支付宝签约的商户的PID，也就是appid对应的PID String sellerId = ""; // 订单描述，可以对交易或商品进行一个详细地描述，比如填写"购买商品2件共15.00元" String body = new StringBuilder().append("订单").append(outTradeNo).append("购买商品共").append(totalAmount).append("元").toString(); // 商户操作员编号，添加此参数可以为商户操作员做销售统计 String operatorId = "test_operator_id"; // (必填) 商户门店编号，通过门店号和商家后台可以配置精准到门店的折扣信息，详询支付宝技术支持 String storeId = "test_store_id"; // 业务扩展参数，目前可添加由支付宝分配的系统商编号(通过setSysServiceProviderId方法)，详情请咨询支付宝技术支持 ExtendParams extendParams = new ExtendParams(); extendParams.setSysServiceProviderId("2088100200300400500"); // 支付超时，定义为120分钟 String timeoutExpress = "120m"; // 商品明细列表，需填写购买商品详细信息， List&lt;GoodsDetail&gt; goodsDetailList = new ArrayList&lt;GoodsDetail&gt;(); List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNoUserId(orderNo,userId); for(OrderItem orderItem : orderItemList)&#123; GoodsDetail goods = GoodsDetail.newInstance(orderItem.getProductId().toString(), orderItem.getProductName(), BigDecimalUtil.mul(orderItem.getCurrentUnitPrice().doubleValue(),new Double(100).doubleValue()).longValue(), orderItem.getQuantity()); goodsDetailList.add(goods); &#125; // 创建扫码支付请求builder，设置请求参数 AlipayTradePrecreateRequestBuilder builder = new AlipayTradePrecreateRequestBuilder() .setSubject(subject).setTotalAmount(totalAmount).setOutTradeNo(outTradeNo) .setUndiscountableAmount(undiscountableAmount).setSellerId(sellerId).setBody(body) .setOperatorId(operatorId).setStoreId(storeId).setExtendParams(extendParams) .setTimeoutExpress(timeoutExpress) .setNotifyUrl(PropertiesUtil.getProperty("alipay.callback.url"))//支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置 .setGoodsDetailList(goodsDetailList); AlipayF2FPrecreateResult result = tradeService.tradePrecreate(builder); switch (result.getTradeStatus()) &#123; case SUCCESS: logger.info("支付宝预下单成功: )"); AlipayTradePrecreateResponse response = result.getResponse(); dumpResponse(response); File folder = new File(path); if(!folder.exists())&#123; folder.setWritable(true); folder.mkdirs(); &#125; // 需要修改为运行机器上的路径 //细节细节细节 String qrPath = String.format(path+"/qr-%s.png",response.getOutTradeNo()); String qrFileName = String.format("qr-%s.png",response.getOutTradeNo()); ZxingUtils.getQRCodeImge(response.getQrCode(), 256, qrPath); File targetFile = new File(path,qrFileName); try &#123; FTPUtil.uploadFile(Lists.newArrayList(targetFile)); &#125; catch (IOException e) &#123; logger.error("上传二维码异常",e); &#125; logger.info("qrPath:" + qrPath); String qrUrl = PropertiesUtil.getProperty("ftp.server.http.prefix")+targetFile.getName(); resultMap.put("qrUrl",qrUrl); return ServerResponse.createBySuccess(resultMap); case FAILED: logger.error("支付宝预下单失败!!!"); return ServerResponse.createByErrorMessage("支付宝预下单失败!!!"); case UNKNOWN: logger.error("系统异常，预下单状态未知!!!"); return ServerResponse.createByErrorMessage("系统异常，预下单状态未知!!!"); default: logger.error("不支持的交易状态，交易返回异常!!!"); return ServerResponse.createByErrorMessage("不支持的交易状态，交易返回异常!!!"); &#125; &#125; // 简单打印应答 private void dumpResponse(AlipayResponse response) &#123; if (response != null) &#123; logger.info(String.format("code:%s, msg:%s", response.getCode(), response.getMsg())); if (StringUtils.isNotEmpty(response.getSubCode())) &#123; logger.info(String.format("subCode:%s, subMsg:%s", response.getSubCode(), response.getSubMsg())); &#125; logger.info("body:" + response.getBody()); &#125; &#125; public ServerResponse aliCallback(Map&lt;String,String&gt; params)&#123; Long orderNo = Long.parseLong(params.get("out_trade_no")); String tradeNo = params.get("trade_no"); String tradeStatus = params.get("trade_status"); Order order = orderMapper.selectByOrderNo(orderNo); if(order == null)&#123; return ServerResponse.createByErrorMessage("非快乐慕商城的订单,回调忽略"); &#125; if(order.getStatus() &gt;= Const.OrderStatusEnum.PAID.getCode())&#123; return ServerResponse.createBySuccess("支付宝重复调用"); &#125; if(Const.AlipayCallback.TRADE_STATUS_TRADE_SUCCESS.equals(tradeStatus))&#123; order.setPaymentTime(DateTimeUtil.strToDate(params.get("gmt_payment"))); order.setStatus(Const.OrderStatusEnum.PAID.getCode()); orderMapper.updateByPrimaryKeySelective(order); &#125; PayInfo payInfo = new PayInfo(); payInfo.setUserId(order.getUserId()); payInfo.setOrderNo(order.getOrderNo()); payInfo.setPayPlatform(Const.PayPlatformEnum.ALIPAY.getCode()); payInfo.setPlatformNumber(tradeNo); payInfo.setPlatformStatus(tradeStatus); payInfoMapper.insert(payInfo); return ServerResponse.createBySuccess(); &#125; public ServerResponse queryOrderPayStatus(Integer userId,Long orderNo)&#123; Order order = orderMapper.selectByUserIdAndOrderNo(userId,orderNo); if(order == null)&#123; return ServerResponse.createByErrorMessage("用户没有该订单"); &#125; if(order.getStatus() &gt;= Const.OrderStatusEnum.PAID.getCode())&#123; return ServerResponse.createBySuccess(); &#125; return ServerResponse.createByError(); &#125;&#125; 内网穿透 NATAPP1分钟快速新手图文教程 线上部署 云服务器vsftpd、nginx等配置 云服务器的配置与域名解析 发布上线注意事项]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Mysql</tag>
        <tag>Git</tag>
        <tag>Maven</tag>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux系统下开发环境安装与配置]]></title>
    <url>%2Fmyhexo%2F2019%2F03%2F07%2Flinux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装系统环境 CentOS 6.8 64位 jdk版本 7u80 64位 Tomcat版本 Tomcat7 maven版本 Apache Maven 3.6.0 vsftpd版本 vsftpd-2.2.2-24.el6.x86_64 Nginx版本 nginx-1.14.2 mysql版本 mysql-server-5.1.73-8.el6_8.x86_64 git版本 git version 2.18.0 阿里源配置 123456#备份[root@192 yum.repos.d]# mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup#下载新的CentOS-Base.repo 到/etc/yum.repos.d/[root@192 yum.repos.d]# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo#生成缓存[root@192 yum.repos.d]# yum makecache 设置开机时关闭防火墙 1[root@192 vsftpd]# chkconfig iptables off jdk安装 下载 清理系统默认自带jdk 12345[root@192 yum.repos.d]# rpm -qa | grep jdkjava-1.6.0-openjdk-1.6.0.38-1.13.10.4.el6.x86_64java-1.7.0-openjdk-1.7.0.99-2.6.5.1.el6.x86_64[root@192 yum.repos.d]# yum remove java-1.6.0-openjdk-1.6.0.38-1.13.10.4.el6.x86_64[root@192 yum.repos.d]# yum remove java-1.7.0-openjdk-1.7.0.99-2.6.5.1.el6.x86_64 授权 1[root@192 soft]# chmod 777 jdk-7u80-linux-x64.rpm 安装 1[root@192 soft]# rpm -ivh jdk-7u80-linux-x64.rpm 默认安装路径/user/java jdk配置环境变量,编辑/etc/profile文件，末尾追加 1234#jdkexport JAVA_HOME=/usr/java/jdk1.7.0_80export PATH=$PATH:$JAVA_HOME/binexport CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 使得/etc/profile文件立即生效 1[root@192 apache-maven-3.6.0]# source /etc/profile Tomcat安装 下载 解压 12[root@192 soft]# tar -zxvf apache-tomcat-7.0.93.tar.gz -C /opt/module/ Tomcat配置环境变量,编辑/etc/profile文件，末尾追加 123#tomcatexport CATALINA_HOME=/opt/module/apache-tomcat-7.0.93export PATH=$PATH:$CATALINA_HOME/bin 使得/etc/profile文件立即生效 1[root@192 apache-maven-3.6.0]# source /etc/profile 配置UTF-8字符集，进入Tomcat安装的conf文件夹，编辑server.xml文件，找到配置8080默认端口的位置，在xml节点末尾增加URIEncoding=&quot;UTF-8&quot; 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; /&gt; 启动Tomcat，进入/opt/module/apache-tomcat-7.0.93/bin目录，执行./startup.sh 访问http://192.168.1.104:8080/ Maven安装 下载 解压 1[root@192 soft]# tar -zxvf apache-maven-3.6.0-bin.tar.gz -C /opt/module/ Maven配置环境变量,编辑/etc/profile文件，末尾追加 123#mavenexport MAVEN_HOME=/opt/module/apache-maven-3.6.0export PATH=$PATH:$MAVEN_HOME/bin 使得/etc/profile文件立即生效 1[root@192 apache-maven-3.6.0]# source /etc/profile 验证 1[root@192 apache-maven-3.6.0]# mvn -version vsftpd安装 安装 1[root@192 apache-maven-3.6.0]# yum -y install vsftpd 查看是否已安装 12[root@192 apache-maven-3.6.0]# rpm -qa | grep vsftpdvsftpd-2.2.2-24.el6.x86_64 默认配置文件/etc/vsftpd/vsftpd.conf 创建虚拟用户 根目录下创建ftp文件夹 12[root@192 vsftpd]# cd /[root@192 /]# mkdir ftpfile 添加匿名用户 1[root@192 /]# useradd ftpuser -d /ftpfile/ -s /sbin/nologin 修改ftpfile权限 1[root@192 /]# chown -R ftpuser.ftpuser /ftpfile/ 重设ftpuser密码 1[root@192 /]# passwd ftpuser 将刚刚新增的虚拟用户添加到此配置文件中 1234[root@192 ~]# cd /etc/vsftpd/[root@192 vsftpd]# vim chroo_list [root@192 bin]# cat /etc/vsftpd/chroo_list ftpuser 编辑配置文件/etc/vsftpd/vsftpd.conf，末尾追加 1234local_root=/ftpfileanon_root=/ftpfileuse_localtime=YESanonymous_enable=no 登录验证的时候出现500提示,编辑/etc/selinux/config文件，设置SELINUX=disabled 1[root@192 vsftpd]# vim /etc/selinux/config 如果还报500，执行 1[root@192 vsftpd]# setsebool -P ftp_home_dir 1 设置开启启动vsftpd服务 1[root@192 vsftpd]# chkconfig vsftpd on 访问ftp://192.168.1.104/ 安装Nginx 下载 安装依赖gcc、pcre、zlib、openssl 1[root@192 vsftpd]# yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 解压 1[root@192 soft]# tar -zxvf nginx-1.14.2.tar.gz -C /opt/module/ 编译安装 12345[root@192 nginx-1.14.2]# pwd/opt/module/nginx-1.14.2[root@192 nginx-1.14.2]# ./configure[root@192 nginx-1.14.2]# make[root@192 nginx-1.14.2]# make install 查看Nginx安装目录、版本 1234[root@192 nginx-1.14.2]# whereis nginxnginx: /usr/local/nginx[root@192 nginx-1.14.2]# /usr/local/nginx/sbin/nginx -vnginx version: nginx/1.14.2 测试配置文件nginx.conf的正确性 1[root@192 nginx-1.14.2]# /usr/local/nginx/sbin/nginx -t 启动Nginx 12345[root@192 nginx-1.14.2]# /usr/local/nginx/sbin/nginx[root@192 nginx-1.14.2]# ps -ef | grep nginxroot 5606 1 0 01:02 ? 00:00:00 nginx: master process /usr/local/nginx/sbin/nginxnobody 5607 5606 0 01:02 ? 00:00:00 nginx: worker process root 5626 2868 0 01:09 pts/0 00:00:00 grep nginx 停止Nginx 1[root@192 nginx-1.14.2]# /usr/local/nginx/sbin/nginx -s stop 访问http://192.168.1.104/ Nginx配置虚拟域名 编辑/usr/local/nginx/conf/nginx.conf文件，追加 12###########################vhost############################################## include vhost/*.conf; 在/usr/local/nginx/conf目录下，新建vhost文件夹 在/usr/local/nginx/conf/vhost目录下，新建域名转发www.test.com.conf配置文件 123456789101112131415161718[root@192 vhost]# cat /usr/local/nginx/conf/vhost/www.test.com.conf #Start www.test.comserver &#123; listen 80; server_name www.test.com; access_log /usr/local/nginx/logs/access.log combined; index index.html index.htm index.php; if ( $query_string ~* &quot;.*[\;&apos;\&lt;\&gt;].*&quot; )&#123; return 404; &#125; # send request back to apach location / &#123; proxy_pass http://127.0.0.1:8080/; &#125;&#125; 访问www.test.com mysql安装 安装 1[root@192 ~]# yum -y install mysql-server 配置字符集,编辑/etc/my.cnf文件，追加 12#utf8default-character-set=utf8 设置mysql服务随系统自动启动 123[root@192 ~]# chkconfig mysqld on[root@192 ~]# chkconfig --list mysqldmysqld 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭 启动mysql服务 12[root@192 ~]# service mysqld start正在启动 mysqld： [确定] 登录，使用非密码登录 1234567891011121314[root@192 mysql]# mysql -uroot Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 5Server version: 5.1.73 Source distributionCopyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; 查看mysql的用户 1234567891011mysql&gt; select user,host,password from mysql.user;+------+---------------+----------+| user | host | password |+------+---------------+----------+| root | localhost | || root | 192.168.1.104 | || root | 127.0.0.1 | || | localhost | || | 192.168.1.104 | |+------+---------------+----------+5 rows in set (0.00 sec) 删除匿名用户 12mysql&gt; delete from mysql.user where user=&apos;&apos;;Query OK, 2 rows affected (0.00 sec) 刷新，立即生效 12mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec) 修改root密码 12mysql&gt; set password for root@localhost=password(&quot;000000&quot;);Query OK, 0 rows affected (0.00 sec) 插入mysql新用户 12mysql&gt; insert into mysql.user(Host,User,Password) values(&quot;localhost&quot;,&quot;admin&quot;,password(&quot;000000&quot;));Query OK, 1 row affected, 3 warnings (0.01 sec) 查看用户权限 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162mysql&gt; select * from mysql.user \G*************************** 1. row *************************** Host: localhost User: root Password: *032197AE5731D4664921A6CCAC7CFCE6A0698693 Select_priv: Y Insert_priv: Y Update_priv: Y Delete_priv: Y Create_priv: Y Drop_priv: Y Reload_priv: Y Shutdown_priv: Y Process_priv: Y File_priv: Y Grant_priv: Y References_priv: Y Index_priv: Y Alter_priv: Y Show_db_priv: Y Super_priv: YCreate_tmp_table_priv: Y Lock_tables_priv: Y Execute_priv: Y Repl_slave_priv: Y Repl_client_priv: Y Create_view_priv: Y Show_view_priv: Y Create_routine_priv: Y Alter_routine_priv: Y Create_user_priv: Y Event_priv: Y Trigger_priv: Y ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0*************************** 2. row *************************** Host: 192.168.1.104 User: root Password: Select_priv: Y Insert_priv: Y Update_priv: Y Delete_priv: Y Create_priv: Y Drop_priv: Y Reload_priv: Y Shutdown_priv: Y Process_priv: Y File_priv: Y Grant_priv: Y References_priv: Y Index_priv: Y Alter_priv: Y Show_db_priv: Y Super_priv: YCreate_tmp_table_priv: Y Lock_tables_priv: Y Execute_priv: Y Repl_slave_priv: Y Repl_client_priv: Y Create_view_priv: Y Show_view_priv: Y Create_routine_priv: Y Alter_routine_priv: Y Create_user_priv: Y Event_priv: Y Trigger_priv: Y ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0*************************** 3. row *************************** Host: 127.0.0.1 User: root Password: Select_priv: Y Insert_priv: Y Update_priv: Y Delete_priv: Y Create_priv: Y Drop_priv: Y Reload_priv: Y Shutdown_priv: Y Process_priv: Y File_priv: Y Grant_priv: Y References_priv: Y Index_priv: Y Alter_priv: Y Show_db_priv: Y Super_priv: YCreate_tmp_table_priv: Y Lock_tables_priv: Y Execute_priv: Y Repl_slave_priv: Y Repl_client_priv: Y Create_view_priv: Y Show_view_priv: Y Create_routine_priv: Y Alter_routine_priv: Y Create_user_priv: Y Event_priv: Y Trigger_priv: Y ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0*************************** 4. row *************************** Host: localhost User: admin Password: *032197AE5731D4664921A6CCAC7CFCE6A0698693 Select_priv: N Insert_priv: N Update_priv: N Delete_priv: N Create_priv: N Drop_priv: N Reload_priv: N Shutdown_priv: N Process_priv: N File_priv: N Grant_priv: N References_priv: N Index_priv: N Alter_priv: N Show_db_priv: N Super_priv: NCreate_tmp_table_priv: N Lock_tables_priv: N Execute_priv: N Repl_slave_priv: N Repl_client_priv: N Create_view_priv: N Show_view_priv: N Create_routine_priv: N Alter_routine_priv: N Create_user_priv: N Event_priv: N Trigger_priv: N ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 04 rows in set (0.00 sec) 查库，新建database数据库 123456789101112131415161718192021mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || test |+--------------------+3 rows in set (0.01 sec)mysql&gt; create database mytest default character set utf8 collate utf8_general_ci;Query OK, 1 row affected (0.00 sec)mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || mytest || test |+--------------------+4 rows in set (0.00 sec) 本地用户赋予所有权限、给账号开通外网所有权限 1234mysql&gt; grant all privileges on mytest.* to admin@&apos;%&apos; identified by &apos;000000&apos; with grant option;Query OK, 0 rows affected (0.00 sec)mysql&gt; grant select,delete,create on mytest.* to admin@&apos;192.168.1.104&apos; identified by &apos;000000&apos; with grant option;Query OK, 0 rows affected (0.00 sec) 导入sql文件 1mysql&gt; source /opt/module/mmall.sql git安装 下载 解压 1[root@192 ~]# tar -zxvf git-2.18.0.tar.gz -C /opt/module/ 安装依赖 1[root@192 ~]# yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker cpio 编译安装 1[root@192 git-2.18.0]# make prefix=/usr/local/ install 验证 12[root@192 ~]# git --versiongit version 2.18.0 生成公私密钥对 123456789101112131415161718192021[root@192 ~]# ssh-keygen -t rsa -C &quot;782125244@qq.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:85:1e:ef:5a:33:ab:e7:79:a4:46:f6:8e:8f:7f:af:cd 782125244@qq.comThe key&apos;s randomart image is:+--[ RSA 2048]----+| || . || o . || . + || S . || .o . || o=+ || o+Bo .o || o=*=+..oE|+-----------------+ 复制公钥粘贴到码云或者GitHub上SSH公钥上 12[root@192 .ssh]# cat id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA1sZvTnjQyVn7r2C7G9Q/WyVTTmJYqWhQdVfh3tBCUX8kJHaAcThwR4sl8ROz6xXl/22wbzlsKtfsiyr5zrV0Ifnq7KuCeNVNUYjOQCTn+ODaRzdj7DYC4Mz9BvxZAr0MDfSbgpLp6ZLAvZlkP3DioOPda7VnfJSAHGEYztOVPITj31pVnP1nXkPZRQlsTwImXEGJpuU+zOaurMShpaukrY/ONxWHR6xlG5M1FgOLdBvEnlbhOFoME1HHziI4/08Xw/NrHIUhvjZZgkAzWUo5NvYZLEwrUjOPtlVxHbYwBEtgBWRgWLFMfTlxQnEJVKzbwUDPLvZWac9WSpGLx5xiww== 782125244@qq.com 配置用户名、邮箱，提交时会引用 12345[root@192 mytest]# git config --global user.name &quot;shenlibng&quot;[root@192 mytest]# git config --global user.email &quot;782125244@qq.com&quot;[root@192 mytest]# git config --global core.autocrlf false[root@192 mytest]# git config --global core.quotepath off[root@192 mytest]# git config --global gui.encoding utf-8 开启防火墙配置 查看防火墙初始化配置 1234567891011121314[root@192 ~]# cat /etc/sysconfig/iptables# Firewall configuration written by system-config-firewall# Manual customization of this file is not recommended.*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibitedCOMMIT 开放Tomcat端口 重启生效防火墙 12345[root@192 ~]# service iptables restartiptables：将链设置为政策 ACCEPT：filter [确定]iptables：清除防火墙规则： [确定]iptables：正在卸载模块： [确定]iptables：应用防火墙规则： [确定] 查看防火墙状态 1234567891011121314151617[root@192 ~]# service iptables status表格：filterChain INPUT (policy ACCEPT)num target prot opt source destination 1 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 2 ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 3 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 4 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22 5 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8080 6 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain FORWARD (policy ACCEPT)num target prot opt source destination 1 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain OUTPUT (policy ACCEPT)num target prot opt source destination]]></content>
      <tags>
        <tag>maven</tag>
        <tag>mysql</tag>
        <tag>linux</tag>
        <tag>jdk</tag>
        <tag>tomcat</tag>
        <tag>vsftpd</tag>
        <tag>nginx</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh无密登录_集群分发脚本xsync]]></title>
    <url>%2Fmyhexo%2F2019%2F02%2F18%2Fssh%E6%97%A0%E5%AF%86%E7%99%BB%E5%BD%95-%E9%9B%86%E7%BE%A4%E5%88%86%E5%8F%91%E8%84%9A%E6%9C%ACxsync%2F</url>
    <content type="text"><![CDATA[1、ssh免密登录 ssh ip地址 123[root@192 ~]# ssh 192.168.1.102root@192.168.1.102&apos;s password: Last login: Mon Feb 18 20:40:28 2019 from 192.168.1.101 免密登录配置 生成公钥和私钥 1234567891011121314151617181920212223[root@192 ~]# ssh-keygen -t rsa Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:d4:95:6c:a8:21:9b:27:62:79:43:76:e8:4b:32:6c:fe root@192.168.1.101The key&apos;s randomart image is:+--[ RSA 2048]----+| . o.. || = o...+ || . = =.o.. || O O.o || + * =S || . . || . || E || |+-----------------+[root@192 ~]# ls /root/.ssh/id_rsa id_rsa.pub 将公钥拷贝到要免密登录的目标机器上 .ssh文件夹下（~/.ssh）的文件功能解释（1）known_hosts ：记录ssh访问过计算机的公钥(public key)（2）id_rsa ：生成的私钥（3）id_rsa.pub ：生成的公钥（4）authorized_keys ：存放授权过得无密登录服务器公钥 123456789101112131415161718192021[root@192 ~]# hostname 192.168.1.101[root@192 ~]# ssh-copy-id 192.168.1.102The authenticity of host &apos;192.168.1.102 (192.168.1.102)&apos; can&apos;t be established.RSA key fingerprint is 56:57:4c:81:94:e0:47:fe:1e:aa:8c:9c:2a:87:a6:dc.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;192.168.1.102&apos; (RSA) to the list of known hosts.root@192.168.1.102&apos;s password: Now try logging into the machine, with &quot;ssh &apos;192.168.1.102&apos;&quot;, and check in: .ssh/authorized_keysto make sure we haven&apos;t added extra keys that you weren&apos;t expecting.[root@192 ~]# ls /root/.ssh/id_rsa id_rsa.pub known_hosts[root@192 ~]# ssh 192.168.1.102Last login: Mon Feb 18 22:50:53 2019 from 192.168.1.101[root@192 ~]# ls /root/.ssh/authorized_keys 2、集群分发脚本xsync 服务器与服务器数据拷贝 rsync和scp区别：用rsync做文件的复制要比scp的速度快，rsync只对差异文件做更新。scp是把所有文件都复制过去。 scp 12[root@192 ~]# scp -r /tmp/1.txt root@192.168.1.102:/tmp/1.txt rsync 选项 功能-r 递归-v 显示复制过程-l 拷贝符号连接 123456[root@192 ~]# rsync -rvl /tmp/2.txt root@192.168.1.102:/tmp/sending incremental file list2.txtsent 84 bytes received 31 bytes 76.67 bytes/sectotal size is 13 speedup is 0.11 集群分发脚本xsync 12345[root@192 ~]# mkdir bin[root@192 ~]# cd bin/[root@192 bin]# touch xsync[root@192 bin]# vim xsync[root@192 bin]# chmod 777 xsync 12345678910111213141516171819202122232425262728#!/bin/bash#1 获取输入参数个数，如果没有参数，直接退出pcount=$#if((pcount==0)); thenecho no args;exit;fi#2 获取文件名称p1=$1fname=`basename $p1`echo fname=$fname#3 获取上级目录到绝对路径pdir=`cd -P $(dirname $p1); pwd`echo pdir=$pdir#4 获取当前用户名称user=`whoami`#5 循环for((host=102; host&lt;104; host++)); do echo --------------------- 192.168.1.$host ---------------- rsync -rvl $pdir/$fname $user@192.168.1.$host:$pdir #echo ------"rsync -rvl $pdir/$fname $user@192.168.1.$host:$pdir complete"------------done xsync调用 1234567891011121314151617181920[root@192 bin]# xsync /tmp/1.txt /tmp/fname=1.txtpdir=/tmp--------------------- 192.168.1.102 ----------------sending incremental file list1.txtsent 516 bytes received 31 bytes 364.67 bytes/sectotal size is 445 speedup is 0.81--------------------- 192.168.1.103 ----------------The authenticity of host &apos;192.168.1.103 (192.168.1.103)&apos; can&apos;t be established.RSA key fingerprint is 56:57:4c:81:94:e0:47:fe:1e:aa:8c:9c:2a:87:a6:dc.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;192.168.1.103&apos; (RSA) to the list of known hosts.root@192.168.1.103&apos;s password: sending incremental file list1.txtsent 71 bytes received 37 bytes 5.84 bytes/sectotal size is 445 speedup is 4.12]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ssh</tag>
        <tag>scp</tag>
        <tag>rsync</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机配置静态ip]]></title>
    <url>%2Fmyhexo%2F2019%2F02%2F15%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81ip%2F</url>
    <content type="text"><![CDATA[镜像下载链接 https://wiki.centos.org/Download 环境：CentOS-6.8-x86_64-bin-DVD1.iso 1、克隆虚拟机 修改主机名 [root@192 桌面]# vim /etc/sysconfig/network 12NETWORKING=yesHOSTNAME=192.168.1.104 修改网卡信息 [root@192 桌面]# vim /etc/udev/rules.d/70-persistent-net.rules 删除或者注释eth0该行；将eth1修改为eth0，同时复制物理ip地址00:0c:29:ac:81:e4 123456789101112# This file was automatically generated by the /lib/udev/write_net_rules# program, run by the persistent-net-generator.rules rules file.## You can modify it, as long as you keep each rule on a single# line, and change only the value of the NAME= key.# PCI device 0x8086:0x100f (e1000)#SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;00:0c:29:00:88:b3&quot;, ATTR&#123;type&#125;==&quot;1&quot;, KERNEL==&quot;eth*&quot;, NAME=&quot;eth0&quot;# PCI device 0x8086:0x100f (e1000)SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;00:0c:29:ac:81:e4&quot;, ATTR&#123;type&#125;==&quot;1&quot;, KERNEL==&quot;eth*&quot;, NAME=&quot;eth0&quot;[root@192 桌面]# 更新物理ip地址HWADDR=00:0c:29:ac:81:e4 [root@192 桌面]# vim /etc/sysconfig/network-scripts/ifcfg-eth0 1234567DEVICE=eth0HWADDR=00:0c:29:ac:81:e4TYPE=EthernetUUID=55735d7f-16c6-46fe-9db8-f7d484b3e7c0ONBOOT=noneNM_CONTROLLED=yesBOOTPROTO=dhcp 2、NAT模式配置 编辑–虚拟网络编辑器 配置静态ip网段和子网掩码 NAT设置 网关ip不能和vmnet8的ip地址冲突 宿主机上的vmnet8网卡会自动分配ip 3、配置静态ip ONBOOT=yes系统启动时激活网卡BOOTPROTO=static通过指定方式的办法来获得地址，设置为静态手动配置IPADDR=192.168.1.104主机ip地址GATEWAY=192.168.1.2网关NETMASK=255.255.255.0子网掩码DNS1=8.8.8.8配置DNS域名解析访问互联网DNS2=8.8.4.4 123456789101112DEVICE=eth0HWADDR=00:0c:29:ac:81:e4TYPE=EthernetUUID=55735d7f-16c6-46fe-9db8-f7d484b3e7c0ONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.1.104GATEWAY=192.168.1.2NETMASK=255.255.255.0DNS1=8.8.8.8DNS2=8.8.4.4]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring定时任务_文件上传进度条]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F30%2Fspring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[spring定时任务 导依赖 123456&lt;!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz --&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt;&lt;/dependency&gt; 配置定时任务类 123456789101112package com.atguigu.scw.portal.service;import org.springframework.stereotype.Service;@Servicepublic class ExampleJob &#123; public void hello() &#123; System.out.println("定时任务触发===========&gt;"); &#125;&#125; 配置定时任务 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd"&gt; &lt;!-- &lt;bean id="exampleJob" class="com.atguigu.scw.portal.service.ExampleJob"&gt;&lt;/bean&gt; --&gt; &lt;!--配置定时任务触发类和方法 --&gt; &lt;bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;property name="targetObject" ref="exampleJob" /&gt; &lt;property name="targetMethod" value="hello" /&gt; &lt;/bean&gt; &lt;!--配置触发器，指定何时触发 --&gt; &lt;bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="jobDetail" /&gt; &lt;!-- run every morning at 6 AM --&gt; &lt;property name="cronExpression" value="*/5 * * * * ?" /&gt; &lt;/bean&gt; &lt;!--配置定时任务调用哪一个触发器 --&gt; &lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt; &lt;property name="triggers"&gt; &lt;list&gt; &lt;ref bean="cronTrigger" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; cron表达式使用 123456789每隔5秒执行一次：*/5 * * * * ?每隔1分钟执行一次：0 */1 * * * ?每天23点执行一次：0 0 23 * * ?每天凌晨1点执行一次：0 0 1 * * ?每月1号凌晨1点执行一次：0 0 1 1 * ?每月最后一天23点执行一次：0 0 23 L * ?每周星期天凌晨1点实行一次：0 0 1 ? * L在26分、29分、33分执行一次：0 26,29,33 * * * ?每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ? 参考 https://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#scheduling-quartz 文件上传进度条 ajax异步提交表单$(&quot;#subBtn&quot;).on(&#39;click&#39;, function() { return false}是js对象的机制 &lt;button type=&quot;submit&quot; id=&#39;subBtn&#39; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;点击按钮直接提交是浏览器的机制 文件上传 表单直接提交action=&#39;${ctp}/member/upload&#39; method=&#39;post&#39; enctype=&quot;multipart/form-data&quot; 1234567891011&lt;form action='$&#123;ctp&#125;/member/upload' method='post' enctype="multipart/form-data"&gt; &lt;div class="form-group"&gt; &lt;input type="file" class="form-control" id="file" name='file'&gt; &lt;/div&gt; &lt;div class="progress"&gt; &lt;div class="progress-bar" role="progressbar" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100" style="width: 60%;"&gt; 60%&lt;/div&gt; &lt;/div&gt; &lt;button type="submit" id='subBtn' class="btn btn-default"&gt;Submit&lt;/button&gt;&lt;/form&gt; ajax提交type : &quot;post&quot;,contentType : false,processData : false 进度条:获取myXhr = $.ajaxSettings.xhr()对象并返回 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;form id='submitForm'&gt; &lt;div class="form-group"&gt; &lt;input type="file" class="form-control" id="file" name='file'&gt; &lt;/div&gt; &lt;div class="progress" style='display: none;'&gt; &lt;div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%;"&gt;0%&lt;/div&gt; &lt;/div&gt; &lt;button type="submit" id='subBtn' class="btn btn-default"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script type="text/javascript"&gt; $("#subBtn").on('click', function() &#123; var fd = new FormData($("#submitForm")[0]); $.ajax(&#123; url : "$&#123;ctp&#125;/member/upload", data : fd, type : "post", contentType : false, processData : false, //获取ajaxSettings中的xhr对象，为它的upload属性绑定progress事件的处理函数 xhr : function() &#123; myXhr = $.ajaxSettings.xhr() //检查upload属性是否存在 if (myXhr.upload) &#123; //绑定progress事件的回调函数 myXhr.upload.addEventListener('progress', progressHandlingFunction, false) &#125; //xhr对象返回给jQuery使用 return myXhr; &#125;, success : function(result) &#123; console.log("result==========&gt;", result) &#125;, error : function(e) &#123; console.log('e=========&gt;', e) &#125; &#125;) return false &#125;) var progressHandlingFunction = function(e) &#123; var curr = e.loaded var total = e.total process = curr / total * 100 console.log('上传进度============&gt;', process) $('.progress').attr('style', 'display:show;') $('.progress-bar').html(process + '%') $('.progress-bar').attr('style', 'width:' + process + '%;') &#125;&lt;/script&gt; 图片预览 123456789101112131415161718$("#ad_file_input").on('change', function(event) &#123; $(this).empty() $(this).parent('.form-group').next('.form-group').find('.imgdiv').empty() fileList = event.currentTarget.files log('fileList==============&gt;', fileList) var URL = window.URL || window.webkitURL var imgURL //遍历上传的文件进行显示 $.each(fileList, function (index, item) &#123; //创建一个临时的url地址 imgURL = URL.createObjectURL(item) log('this=========&gt;',this) log('item==========&gt;',item) $('#ad_file_input').parent(".form-group").next(".form-group").find(".imgdiv").append("&lt;img src='"+imgURL+"' style='width:200px;height:220px;'/&gt;").append('&lt;p&gt;'+item.name+'&lt;p&gt;') &#125;)&#125;)]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多表连接查询]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F29%2F%E5%A4%9A%E8%A1%A8%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[1、查询用户拥有的权限 尚筹网第16天_讨论权限与安全 子查询和连接查询2种，比较推荐连接查询，子查询比较影响性能，子查询看起来比较容易理解，而连接查询需要比较熟悉各个表之间的关系 123456789101112131415161718SELECT DISTINCT p.* FROM t_permission p LEFT JOIN t_role_permission trp ON trp.`permissionid`=p.`id` LEFT JOIN t_role tr ON tr.`id`=trp.`roleid` WHERE tr.id IN( SELECT t_r.id FROM t_role t_r LEFT JOIN t_user_role t_u_r ON t_u_r.`roleid`=t_r.`id` WHERE t_u_r.`userid`=31 );子查询不太推荐，比较影响性能推荐连接查询SELECT DISTINCT p.* FROM t_permission p LEFT JOIN t_role_permission trp ON trp.`permissionid`=p.`id` LEFT JOIN t_role tr ON tr.`id`=trp.`roleid` LEFT JOIN t_user_role tur ON tur.`roleid`=tr.`id` LEFT JOIN t_user tu ON tu.`id`=tur.`userid` WHERE tu.`id`=31;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HttpClient远程接口调用_实名认证]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F28%2FHttpClient%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8-%E5%AE%9E%E5%90%8D%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[1、HttpClient远程接口调用 1)用户注册 注册按钮button提交表单时，要return false form表单 12345&lt;!-- action="http://localhost:8082/scw-restapi/member/regist" --&gt;&lt;form class="form-signin" role="form" action="$&#123;ctp&#125;/member/regist" method="post" id="regForm"&gt;...&lt;/form&gt; js提交表单 1234567891011121314$("#submitBtn").click(function() &#123; var loginType = $("select.form-control").val(); log("注册类型==============&gt;", loginType) /* if (loginType == "管理") &#123; $("#regForm").submit(); &#125; else &#123; alert("此功能尚未开通"); &#125; */ $("#regForm").submit(); return false&#125;) 2)加载外部资源文件 app.properties 123restapi.server.ip=127.0.0.1restapi.server.port=8082restapi.server.apppath=scw-restapi 编辑springmvc.xml 123&lt;!-- 引入外部配置文件 --&gt;&lt;context:property-placeholder location="classpath:other/app.properties" /&gt; RestApiServerInfo.java 123456789101112131415161718@Controllerpublic class RestApiServerInfo &#123; // MemberService memberService; @Value("$&#123;restapi.server.ip&#125;") private String restapiserver; @Value("$&#123;restapi.server.port&#125;") private String restapiport; @Value("$&#123;restapi.server.apppath&#125;") private String appPath; public String getRestApiURL() &#123; System.out.println("http://" + restapiserver + ":" + restapiport); return "http://" + restapiserver + ":" + restapiport + "/" + appPath; &#125;&#125; 3)HTTPClient工具远程调用接口 导入依赖 123456&lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.3&lt;/version&gt;&lt;/dependency&gt; 发送post请求 1public static String httpPostRequest(String url, Map&lt;String, Object&gt; params) 工具类HttpClientUtil.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152package com.atguigu.project;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.URISyntaxException;import java.util.ArrayList;import java.util.Map;import org.apache.http.HttpEntity;import org.apache.http.NameValuePair;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.client.methods.HttpRequestBase;import org.apache.http.client.utils.URIBuilder;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;/** * @author Nan 2015-11 */public class HttpClientUtil &#123; private static PoolingHttpClientConnectionManager cm; private static String EMPTY_STR = ""; private static String UTF_8 = "UTF-8"; private static void init() &#123; if (cm == null) &#123; cm = new PoolingHttpClientConnectionManager(); cm.setMaxTotal(50);// 整个连接池最大连接数 cm.setDefaultMaxPerRoute(5);// 每路由最大连接数，默认值是2 &#125; &#125; /** * 通过连接池获取HttpClient * * @return */ private static CloseableHttpClient getHttpClient() &#123; init(); return HttpClients.custom().setConnectionManager(cm).build(); &#125; /** * @param url * @return */ public static String httpGetRequest(String url) &#123; HttpGet httpGet = new HttpGet(url); return getResult(httpGet); &#125; public static String httpGetRequest(String url, Map&lt;String, Object&gt; params) throws URISyntaxException &#123; URIBuilder ub = new URIBuilder(); ub.setPath(url); ArrayList&lt;NameValuePair&gt; pairs = covertParams2NVPS(params); ub.setParameters(pairs); HttpGet httpGet = new HttpGet(ub.build()); return getResult(httpGet); &#125; public static String httpGetRequest(String url, Map&lt;String, Object&gt; headers, Map&lt;String, Object&gt; params) throws URISyntaxException &#123; URIBuilder ub = new URIBuilder(); ub.setPath(url); ArrayList&lt;NameValuePair&gt; pairs = covertParams2NVPS(params); ub.setParameters(pairs); HttpGet httpGet = new HttpGet(ub.build()); for (Map.Entry&lt;String, Object&gt; param : headers.entrySet()) &#123; httpGet.addHeader(param.getKey(), String.valueOf(param.getValue())); &#125; return getResult(httpGet); &#125; public static String httpPostRequest(String url) &#123; HttpPost httpPost = new HttpPost(url); return getResult(httpPost); &#125; public static String httpPostRequest(String url, Map&lt;String, Object&gt; params) throws UnsupportedEncodingException &#123; HttpPost httpPost = new HttpPost(url); ArrayList&lt;NameValuePair&gt; pairs = covertParams2NVPS(params); httpPost.setEntity(new UrlEncodedFormEntity(pairs, UTF_8)); return getResult(httpPost); &#125; public static String httpPostRequest(String url, Map&lt;String, Object&gt; headers, Map&lt;String, Object&gt; params) throws UnsupportedEncodingException &#123; HttpPost httpPost = new HttpPost(url); for (Map.Entry&lt;String, Object&gt; param : headers.entrySet()) &#123; httpPost.addHeader(param.getKey(), String.valueOf(param.getValue())); &#125; ArrayList&lt;NameValuePair&gt; pairs = covertParams2NVPS(params); httpPost.setEntity(new UrlEncodedFormEntity(pairs, UTF_8)); return getResult(httpPost); &#125; private static ArrayList&lt;NameValuePair&gt; covertParams2NVPS(Map&lt;String, Object&gt; params) &#123; ArrayList&lt;NameValuePair&gt; pairs = new ArrayList&lt;NameValuePair&gt;(); for (Map.Entry&lt;String, Object&gt; param : params.entrySet()) &#123; pairs.add(new BasicNameValuePair(param.getKey(), String.valueOf(param.getValue()))); &#125; return pairs; &#125; /** * 处理Http请求 * * @param request * @return */ private static String getResult(HttpRequestBase request) &#123; // CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpClient httpClient = getHttpClient(); try &#123; CloseableHttpResponse response = httpClient.execute(request); // response.getStatusLine().getStatusCode(); HttpEntity entity = response.getEntity(); if (entity != null) &#123; // long len = entity.getContentLength();// -1 表示长度未知 String result = EntityUtils.toString(entity); response.close(); // httpClient.close(); return result; &#125; &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; &#125; return EMPTY_STR; &#125;&#125; 远程接口返回ScwReturn&lt;T&gt;封装对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.atguigu.scw.restapi.bean;import java.util.Map;public class ScwReturn&lt;T&gt; &#123; private int code;// 状态码 1：表示成功 0:表示失败 private String msg;// 要给的提示信息 private T content;// 响应的内容； private Map&lt;String, Object&gt; ext;// 额外的数据 public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public T getContent() &#123; return content; &#125; public void setContent(T content) &#123; this.content = content; &#125; public Map&lt;String, Object&gt; getExt() &#123; return ext; &#125; public void setExt(Map&lt;String, Object&gt; ext) &#123; this.ext = ext; &#125; // 两个快速的成功失败方法 public static &lt;T&gt; ScwReturn&lt;T&gt; success(String msg, T content, Map&lt;String, Object&gt; ext) &#123; ScwReturn&lt;T&gt; t = new ScwReturn&lt;T&gt;(); t.setCode(1); t.setMsg(msg); t.setContent(content); t.setExt(ext); return t; &#125; public static &lt;T&gt; ScwReturn&lt;T&gt; fail(String msg, T content, Map&lt;String, Object&gt; ext) &#123; ScwReturn&lt;T&gt; t = new ScwReturn&lt;T&gt;(); t.setCode(0); t.setMsg(msg); t.setContent(content); t.setExt(ext); return t; &#125;&#125; 注册调用远程接口 发送请求 1String response = HttpClientUtil.httpPostRequest(url, params); 远程接口返回的响应字符串转java对象 12readValue = new ObjectMapper().readValue(response.getBytes(), new TypeReference&lt;ScwReturn&lt;TMemeber&gt;&gt;() &#123; &#125;); 1234567891011121314151617181920212223242526272829303132333435363738394041@RequestMapping("/regist")public String regist(TMemeber memeber, Model model) throws Exception &#123; // 需要利用http工具去模拟发调用接口的请求 // http://localhost:8082/scw-restapi/member/regist // &lt;httpclient.version&gt;4.5.3&lt;/httpclient.version&gt; // httpclient使用java代码来模拟发送请求 // 能收到api调用后产生的json数据； // 1、可以将产生的json逆向成对象ScwReturn&lt;TMemeber&gt; // 2、可以直接将json写给页面 System.out.println("memeber===========&gt;" + memeber); // 注册成功以后可以来到一个页面； // 1、应该去发送请求来进行注册；java代码发请求 String url = serverInfo.getRestApiURL() + "/member/regist"; System.out.println("url===========&gt;" + url); // 2、构建请求参数 Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;(); params.put("loginacct", memeber.getLoginacct()); // 密码是业务逻辑加密的，我们不用管 params.put("userpswd", memeber.getUserpswd()); params.put("email", memeber.getEmail()); // 响应内容； String response = HttpClientUtil.httpPostRequest(url, params); // 封装响应为对象 ScwReturn&lt;TMemeber&gt; readValue = null; readValue = new ObjectMapper().readValue(response.getBytes(), new TypeReference&lt;ScwReturn&lt;TMemeber&gt;&gt;() &#123; &#125;); // 判断，注册成功！来到登陆页面 if (readValue.getCode() == 1) &#123; return "redirect:/login.jsp"; &#125; else &#123; // 注册失败！来到注册页面进行回显 model.addAttribute("msg", "用户名和邮箱已经被注册了！"); return "forward:/reg.jsp"; &#125;&#125; 远程接口注册方法 控制层 123456789101112131415161718192021222324252627/** * ScwReturn&lt;List&lt;TMemeber&gt;&gt;:泛型是content内容的对象的类型 * * @Description (TODO这里用一句话描述这个方法的作用) * @param memeber * @return */ @RequestMapping("/regist") public ScwReturn&lt;TMemeber&gt; regist(TMemeber memeber) &#123; // 创建一个空的对象 TMemeber regist = new TMemeber(); Map&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;(); try &#123; regist = memberService.regist(memeber); &#125; catch (Exception e) &#123; // 判断异常类型来放错误 // e.printStackTrace(); hashMap.put("error", "触犯唯一约束，请保证用户名和邮箱唯一"); &#125; regist.setUserpswd(""); if (regist.getId() != null) &#123; return ScwReturn.success("用户注册成功！", regist, null); &#125; else &#123; return ScwReturn.fail("用户注册失败!", null, hashMap); &#125; &#125; 业务层 带条件插入 1int i = memeberMapper.insertSelective(tMemeber); 12345678910111213141516171819202122@Override public TMemeber regist(TMemeber tMemeber) &#123; // TODO Auto-generated method stub String digest = MD5Util.digest(tMemeber.getUserpswd()); // 加密密码保存 tMemeber.setUserpswd(digest); // 初始化用户名和账号 tMemeber.setUsername(tMemeber.getLoginacct()); // 实名认证状态 0:未实名认证 1::实名认证 tMemeber.setAuthstatus("0"); // 真实姓名；实名认证是保存的 tMemeber.setRealname("未实名"); // 0：普通会员 1：月费会员 2：年费会员 3： tMemeber.setUsertype("0"); // 身份证号，账户类型；（实名认证是做的） // 账户类型：直接保存账户的全名 int i = memeberMapper.insertSelective(tMemeber); // 刚才就是按照这个对象给数据库插入值，希望获取到数据库分配的自增主键 return tMemeber; &#125; 2、实名认证文件上传 1)上传用户资质证件 导入依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt; 编辑springmvc.xml文件 1234&lt;!-- 1、文件上传需要一个文件上传解析器 --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="defaultEncoding" value="utf-8"&gt;&lt;/property&gt;&lt;/bean&gt; 前台ajax提交 带有文件表单，一次提交所有项1var fd = new FormData($(&quot;#certForm&quot;)[0]) 带有文件表单,提交部分内容 123456//使用formData（js对象来包装form表单）var fd = new FormData();log($(&quot;#ad_name_input&quot;).val())log($(&quot;#ad_file_input&quot;)[0].files[0])fd.append(&quot;name&quot;, $(&quot;#ad_name_input&quot;).val());fd.append(&quot;ad&quot;, $(&quot;#ad_file_input&quot;)[0].files[0]) processData(默认: true) 默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 “application/x-www-form-urlencoded”。 contentType 不使用默认的内容类型；(默认: “application/x-www-form-urlencoded”) 发送信息至服务器时内容编码类型。 123456789101112131415161718//这是一个资质文件上传的页面//发送文件上传资质文件请求；var fd = new FormData($("#certForm")[0]);$.ajax(&#123; url:"http://localhost:8082/scw-restapi/auth/upload", data:fd, type:"post", contentType:false, dataType:"json", processData:false, success:function(result)&#123; //来到邮箱填写页面 location.href="$&#123;ctp&#125;/auth/apply-2.html" &#125;, error:function(e)&#123; layer.msg("上传失败:"+e); &#125;&#125;); 控制层 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//文件上传 private String uploadfile(String webPath,MultipartFile file,HttpSession session)&#123; ServletContext context = session.getServletContext(); String realPath = context.getRealPath(webPath); String name = UUID.randomUUID().toString().replace("-", "").substring(0, 10) +"_file_"+ file.getOriginalFilename(); try &#123; //webPath不存在的情况下必须创建 File file2 = new File(realPath); if(!file2.exists())&#123; //创建目录 file2.mkdirs(); &#125; file.transferTo(new File(realPath+"/"+name)); //返回这个图片在服务器下的路径 return webPath+"/"+name; &#125;catch (Exception e) &#123; return null; &#125; &#125; @RequestMapping("/upload") public ScwReturn&lt;Object&gt; upload(HttpSession session, @RequestParam("file")MultipartFile[] file, @RequestParam("certid")Integer[] certid,@RequestParam("memberid")Integer memberid)&#123; try &#123; System.out.println("资质的id"+certid); List&lt;TMemberCert&gt; certsList= new ArrayList&lt;TMemberCert&gt;(); for (int i=0;i&lt;certid.length;i++) &#123; TMemberCert cert = new TMemberCert(); MultipartFile multipartFile = file[i]; String uploadfile = uploadfile("/certsimg", multipartFile, session); cert.setCertid(certid[i]); cert.setMemberid(memberid); cert.setIconpath(uploadfile); certsList.add(cert); &#125; //调用业务逻辑进行保存;/删除原有资质，保存新的资质 certService.insertCerts(certsList); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block System.out.println(e); return ScwReturn.fail("资质保存失败！", null, null); &#125; return ScwReturn.success("保存成功！", null, null); &#125; 2)批量插入用户资质证件描述信息 业务层 CertService.java 1public void insertCerts(List&lt;TMemberCert&gt; certsList); CertServiceImpl.java 1234567891011@Override public void insertCerts(List&lt;TMemberCert&gt; certsList) &#123; // TODO Auto-generated method stub TMemberCertExample example = new TMemberCertExample(); Criteria criteria = example.createCriteria(); criteria.andMemberidEqualTo(certsList.get(0).getMemberid()); //先删除 memberCertMapper.deleteByExample(example); //后保存 certMapper.insertBatch(certsList); &#125; dao层 TCertMapper.java 1void insertBatch(@Param("certs")List&lt;TMemberCert&gt; certsList); TCertMapper.xml 12345678&lt;!-- void insertBatch(@Param("certs")List&lt;TMemberCert&gt; certsList); --&gt;&lt;insert id="insertBatch"&gt; INSERT INTO t_member_cert(memberid,certid,iconpath) VALUES&lt;foreach collection="certs" item="c" separator=","&gt; (#&#123;c.memberid&#125;,#&#123;c.certid&#125;,#&#123;c.iconpath&#125;)&lt;/foreach&gt;&lt;/insert&gt;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>HTTPClient</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术分享]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F26%2F%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[1、快速深入地学习一个新技术、知识点步骤 1）我们有一个需求 项目开发时，我们需要解决某个问题—页面局部刷新问题 跳槽，学习新技术 2）先看看使用现有的技术能否解决这个问题 可以解决，使用传统的方法iframe 发现使用传统的方法可以解决，但是不够好，使用新技术ajax 3）学习新技术或者知识点 原理 基本语法 4）快速入门案例 特点是简单 了解新技术或者知识点的基本使用，这里不需要涉及技术细节 5）讨论这个新技术或者知识点的细节 怎么使用更规范 使用该技术有没有什么陷阱 需要使用时，注意些什么 2、学习方法的介绍 1）高效而愉快地学习 2）先建立一个整体框架，然后细节 3）在实际工作中，要培养用到什么，能够快速学习什么的能力 4）先know how，再know why 5）软件编程是一门’做中学‘的学科，不是会了再做，而是做了才会 6）适当的囫囵吞枣 7）学习软件编程是在在琢磨别人怎么做，而不是我认为应该怎么做的过程 123for i:=0;i&lt;10;i++ &#123; fmt.Println(&quot;hello,world&quot;)&#125;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[es6异步]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F25%2Fes6%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[1、promise-解决异步操作 同步——串行 简单、方便 异步——并发 性能高、体验好 jQuery异步问题：回到地狱 123456789101112131415161718192021222324252627282930313233$.ajax(&#123; url: '/banner_data', success(banners)&#123; $.ajax(&#123; url: '/user_data', success(user)&#123; $.ajax(&#123; url: '/item_data', success(items)&#123; $.ajax(&#123; url: '/news_data', success(news)&#123; &#125;, error()&#123; alert('数据获取失败'); &#125; &#125;) &#125;, error()&#123; alert('数据获取失败'); &#125; &#125;) &#125;, error()&#123; alert('数据获取失败'); &#125; &#125;) &#125;, error()&#123; alert('数据获取失败'); &#125;&#125;) 使用Promise Promise.all() 与：所有的都成功 Promise.race() 或：只要有一个完成 123456789//PromisePromise.all([ $.ajax('/banner_data'), $.ajax('/item_data'), $.ajax('/user_data'), $.ajax('/news_data'),]).then(arr=&gt;&#123; let [banners, items, user, news]=arr;&#125;, ()=&gt;&#123;&#125;) 1.txt 1&#123;&quot;a&quot;: 3, &quot;b&quot;: 5&#125; 2.txt 1[12,5,8,3] 3.txt 1&#123;&quot;name&quot;: &quot;blue&quot;, &quot;age&quot;: 18&#125; promise怎么用.html 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; let p = new Promise((resolve, reject) =&gt; &#123; //resolve 解决-&gt;成功 //reject 拒绝-&gt;失败 $.ajax(&#123; url: '1.txt', dataType: 'json', success(json) &#123; resolve(json) &#125;, error(err) &#123; reject(err) &#125; &#125;) &#125;) debugger p.then(json =&gt; &#123; alert('成功') console.log(json) &#125;, err =&gt; &#123; alert('失败') &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; promise怎么用2.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; let p = new Promise((resolve, reject) =&gt; &#123; //resolve 解决-&gt;成功 //reject 拒绝-&gt;失败 $.ajax(&#123; url: '1.txt', dataType: 'json', success(json) &#123; resolve(json) &#125;, error(err) &#123; reject(err) &#125; &#125;) &#125;) let p2 = new Promise((resolve, reject) =&gt; &#123; //resolve 解决-&gt;成功 //reject 拒绝-&gt;失败 $.ajax(&#123; url: '2.txt', dataType: 'json', success(json) &#123; resolve(json) &#125;, error(err) &#123; reject(err) &#125; &#125;); &#125;); let p3 = new Promise((resolve, reject) =&gt; &#123; //resolve 解决-&gt;成功 //reject 拒绝-&gt;失败 $.ajax(&#123; url: '3.txt', dataType: 'json', success(json) &#123; resolve(json) &#125;, error(err) &#123; reject(err) &#125; &#125;) &#125;) Promise.all([p, p2, p3]).then(arr =&gt; &#123; let [j1, a, j2] = arr; alert('成功') console.log(j1, a, j2) &#125;, err =&gt; &#123; alert('失败') &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; promise怎么用3.html 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; $.ajax(&#123; url: '1.txt', dataType: 'json' &#125;).then(json=&gt;&#123; alert('成了'); &#125;, err=&gt;&#123; alert('错了'); &#125;); debugger /* Promise.all([p, p2, p3]).then(arr=&gt;&#123; let [j1, a, j2]=arr; alert('成功'); console.log(j1, a, j2); &#125;, err=&gt;&#123; alert('失败'); &#125;); */ &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; promise怎么用4.html 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; Promise.all([ $.ajax(&#123;url: '1.txt', dataType: 'json'&#125;), $.ajax(&#123;url: '2.txt', dataType: 'json'&#125;), $.ajax(&#123;url: '3.txt', dataType: 'json'&#125;), ]).then(arr=&gt;&#123; let [j1, a, j2]=arr; console.log(j1, a, j2); &#125;, err=&gt;&#123; alert('失败'); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 结论 Proimse有用——解除异步操作 Promise有局限——带逻辑的异步操作麻烦 2、generator-生成器（过渡） 可以暂停 generator函数.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function* show() &#123; alert('aaa') yield alert('bbb') &#125; let gen = show() gen.next() //aaa setTimeout(function() &#123; gen.next() //bbb &#125;, 5000) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; generator函数3.html 传参 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function *show()&#123; alert('aaa'); let a=yield; alert('bbb'+a); &#125; let gen=show(); gen.next(); gen.next(12); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; generator函数4.html 返回值 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function* show() &#123; alert('aaa') yield 55 alert('bbb') return 89 &#125; let gen = show() let res1 = gen.next() // debugger console.log(res1) //&#123;value: 55, done: false&#125; let res2 = gen.next() console.log(res2) //&#123;value: 89, done: true&#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 3、async/await（推荐，es7） 可以暂停且可以处理带业务逻辑、异常 async和await.html 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function sleep(sec) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; resolve() &#125;, sec * 1000) &#125;) &#125; async function show() &#123; alert('a') await sleep(1) alert('b') await sleep(2) alert('c') &#125; show() &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 处理带业务逻辑 async和await2.html 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; (async () =&gt; &#123; let data1 = await $.ajax(&#123; url: '1.txt', dataType: 'json' &#125;) console.log('data1=========&gt;', data1) if (data1.a + data1.b &lt; 10) &#123; let data2 = await $.ajax(&#123; url: '2.txt', dataType: 'json' &#125;) alert(data2[0]) &#125; else &#123; let data3 = await $.ajax(&#123; url: '3.txt', dataType: 'json' &#125;) alert(data3.name) &#125; &#125;)() &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 处理异常 async和await3.html 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; async function show() &#123; try &#123; let data1 = await $.ajax(&#123; url: '1.txt', dataType: 'json' &#125;) let data2 = await $.ajax(&#123; url: '33.txt', dataType: 'json' &#125;) let data3 = await $.ajax(&#123; url: '3.txt', dataType: 'json' &#125;) console.log(data1, data2, data3) &#125; catch (e) &#123; alert('有问题') throw new Error('我错了....') &#125; &#125; show() &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F23%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[1、安装Node.js https://nodejs.org/en/ 2、安装Git https://git-scm.com/ 3、安装Hexo 12//全局安装$ npm install -g hexo-cli 存放位置 1C:\Users\libingshen\AppData\Roaming\npm\node_modules 验证安装是否成功 1234567891011121314151617181920212223242526C:\Users\libingshen&gt;node --versionv10.15.0C:\Users\libingshen&gt;npm --version6.4.1C:\Users\libingshen&gt;git --versiongit version 2.16.2.windows.1C:\Users\libingshen&gt;hexo --versionhexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64http_parser: 2.8.0node: 10.15.0v8: 6.8.275.32-node.45uv: 1.23.2zlib: 1.2.11ares: 1.15.0modules: 64nghttp2: 1.34.0napi: 3openssl: 1.1.0jicu: 62.1unicode: 11.0cldr: 33.1tz: 2018e 4、Hexo博客初始化 1234567891011$ cd D:\mytest\myhexo$ hexo init//安装依赖$ npm install//或者hexo generate生成静态页$ hexo g //或者hexo server，启动服务器，可以在http://localhost:4000/ 查看$ hexo s 5、Hexo博客部署到GitHub 1）本地客户端与GitHub建立授权连接生成公私钥 1ssh-keygen -t rsa -C &quot;782125244@qq.com&quot; 公私钥存放位置 1C:\Users\libingshen\.ssh 将公钥内容上传到GitHub 2)GitHub创建仓库作为hexo博客的站点 3）hexo配置GitHub连接 安装 hexo-deployer-git 1$ npm install hexo-deployer-git --save 修改配置D:\mytest\myhexo_config.yml 12345678910111213141516#配置GitHub博客站址访问路径# URL这里要是没有配置，GitHub样式显示不出来## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://shenlibing.github.io/myhexo/root: /myhexopermalink: :year/:month/:day/:title/permalink_defaults:#博客推送到GitHub地址配置# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/shenlibing/myhexo.git branch: [master] 4)配置GitHub Pages 6、备份博客源文件 hexo部署到GitHub只上传.deploy_git文件夹的内容，并不会上传_posts文件夹下的博客源文件 123D:\mytest\myhexo\.deploy_gitD:\mytest\myhexo\source\_posts 解决： 将_posts文件夹作为git仓库，上传到GitHub，使得其作为另一个分支 创建并切换到新分支 123libingshen@DESKTOP-7V287SK MINGW64 /d/mytest/myhexo/source/_posts (master)$ git checkout -b srcSwitched to a new branch &apos;src&apos; 将新分支推送到GitHub 123git add .git commit -m &apos;add_v1:-新增hello-world笔记初始化&apos;git push origin src 将博客源文件分支设为推送的默认分支，git push推送直接推送到src分支 补充： 删除本地分支 1$ git branch -d src 删除远程分支 1$ git push origin -d src 切换分支 1$ git checkout master 查看提交日志 1$ git log --oneline 7、拓展 1)更换hexo主题 下载 https://github.com/theme-next/hexo-theme-next 解压放到D:\mytest\myhexo\themes 修改D:\mytest\myhexo\_config.yml配置文件 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-next-master 2）修改站点语言 编辑D:\mytest\myhexo\_config.yml文件 12345678# Sitetitle: 小兵兵subtitle:description:keywords:author: shenlibinglanguage: zh-CNtimezone: 3）开启搜索、字数统计和阅读时长统计 安装依赖hexo-symbols-count-time、hexo-generator-searchdb，安装依赖不成功时先删除D:\mytest\myhexo\node_modules文件夹，重新安装依赖 1234npm install hexo-symbols-count-time --savenpm install hexo-generator-searchdb --save 配置主题样式文件 进入D:\mytest\myhexo\themes\hexo-theme-next-master\文件夹，编辑_config.yml文件 123456789101112# Local search# Dependencies: https://github.com/theme-next/hexo-generator-searchdblocal_search: enable: true# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 4 wpm: 275 配置站点文件 编辑D:\mytest\myhexo\_config.yml文件 12345678910111213#阅读时长和本文字数symbols_count_time: symbols: true time: true total_symbols: true total_time: true#搜索功能search: path: search.xml field: post format: html limit: 10000 4）添加分类和标签 123$ hexo new page categories$ hexo new page tags 编辑D:\mytest\myhexo\source\categories\index.md 123456---title: categoriesdate: 2019-01-22 16:37:58type: &quot;categories&quot; #这部分是新添加的--- 编辑D:\mytest\myhexo\source\tags\index.md 123456---title: tagsdate: 2019-01-22 16:38:40type: &quot;tags&quot; #新添加的内容--- 修改菜单，添加categories和tags到menu中 123456789menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 新增文章，添加categories、tags 123456789101112---title: hexo博客搭建date: 2019-01-23 09:07:30categories: 日常记录tags: - hexo - git - github - node - markdown--- 5）更换页面菜单布局位置 12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 6）配置文章浏览量 注册 https://leancloud.cn/ 创建应用 创建Class 配置web安全域名 获取app_id、app_key 编辑D:\mytest\myhexo\themes\hexo-theme-next-master\_config.yml配置文件，填app_id、 app_key;security设置为false 123456789101112# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: BedsOkBLOBR4nM4W52xTcBhb-gzGzoHsz #&lt;app_id&gt; app_key: EEaRfb6dCMaS38laDCkSYhM9 #&lt;app_key&gt; # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don&apos;t care about security in leancloud counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set `security` to `false`. security: false betterPerformance: false 7）插入本地图片 安装依赖 1npm install hexo-asset-image --save 编辑D:\mytest\myhexo\_config.yml配置文件 1post_asset_folder: true 命令hexo new post test来生成博文时，/source/_post文件夹中除了test.md外，还有一个同名test文件夹 8)设置动态背景 进入D:\mytest\myhexo\themes\hexo-theme-next-master\layout\文件夹，编辑_layout.swig文件，在&lt;/body&gt;之前添加 1&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt; 9)添加Fork me on GitHub 进入D:\mytest\myhexo\themes\hexo-theme-next-master\layout\文件夹，编辑_layout.swig文件，在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面添加选择的图标样式代码 1&lt;a href=&quot;https://github.com/shenlibing/&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 10）添加友情链接 方式一进入D:\mytest\myhexo\themes\hexo-theme-next-master\layout\_partials文件夹，在footer.swig文件末尾追加 123456&lt;div&gt;友情链接： &lt;a class=&quot;theme-link&quot; href=&quot;http://collect.w3ctrain.com/&quot;&gt; 前端收藏夹 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;a class=&quot;theme-link&quot; href=&quot;http://www.alloyteam.com/nav/&quot;&gt; Web前端导航 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;a class=&quot;theme-link&quot; href=&quot;http://www.runoob.com/&quot;&gt; 菜鸟教程 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;a class=&quot;theme-link&quot; href=&quot;https://mccxj.github.io/&quot;&gt; 小毛的胡思乱想 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/div&gt; 方式二进入D:\mytest\myhexo\themes\hexo-theme-next-master文件夹，编辑_config.yml文件 1234567891011# Blog rollslinks_icon: linklinks_title: Linkslinks_layout: block#links_layout: inline#links: #Title: http://example.comlinks: 美团技术团队: https://tech.meituan.com/ 百度FEX: http://fex.baidu.com/ 淘宝FED: http://taobaofed.org/ 11）设置阅读全文 进入D:\mytest\myhexo\themes\hexo-theme-next-master文件夹，编辑_config.yml文件 12345# Automatically Excerpt. Not recommend.# Use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150 参考： 【持续更新】Github Pages + Hexo 博客搭建，Next主题个性化修改 Hexo+NexT 打造一个炫酷博客 hexo史上最全搭建教程]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化点击事件绑定]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F15%2F%E4%BC%98%E5%8C%96%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[1、优化点击事件绑定 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button data-action="id1"&gt;新增按钮1&lt;/button&gt;&lt;button data-action="id2"&gt;删除按钮2&lt;/button&gt;&lt;button data-action="id3"&gt;按钮3&lt;/button&gt;&lt;button data-action="id4"&gt;按钮4&lt;/button&gt;&lt;script&gt; var log = function () &#123; console.log.apply(console, arguments) &#125; var actionList = &#123; 'id1': function () &#123; alert('id1=============&gt;') &#125;, 'id2': function () &#123; alert('id2===============&gt;') &#125;, 'id3': function () &#123; alert('id3===============&gt;') &#125;, 'id4': function () &#123; alert('id4===============&gt;') &#125; &#125; let $body = $('body') $body.on('click', '[data-action]', function () &#123; //jQuery获取html标签自定义属性值或data值 let action_name = $(this).data('action') let action = actionList[action_name] // log(action) // log($.isFunction(action)) if ($.isFunction(action)) &#123; action() &#125; &#125;) //页面需要新增一个按钮，做扩展 $body.append('&lt;button data-action="id5"&gt;按钮5&lt;/button&gt;') $.extend(actionList, &#123; 'id5': function () &#123; alert('id5============&gt;') &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考 https://github.com/cssmagic/blog/issues/48]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户分配角色_角色维护权限树]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F14%2F%E7%94%A8%E6%88%B7%E5%88%86%E9%85%8D%E8%A7%92%E8%89%B2_%E8%A7%92%E8%89%B2%E7%BB%B4%E6%8A%A4%E6%9D%83%E9%99%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1、用户分配角色 效果图： 实现思路： 1）先静态实现页面 2）从数据库查询用户未分配角色和已分配角色，前端初始化该列表 3）添加、移除用户拥有的角色 前端： 1)左移、右移：append和appendTo的使用 12$(&quot;.unroles :selected&quot;).appendTo(&quot;.roles_select&quot;) 2）遍历选中的角色 123456//遍历选中的元素,拼接用户角色id$(&apos;.unroles :selected&apos;).each(function() &#123; log(this) rids += $(this).val() + &apos;,&apos;&#125;) 3)ajax发送异步请求（参数拼接：用户id,角色rids） 1234567uid = &apos;$&#123;param.uid&#125;&apos;url = &apos;$&#123;ctp&#125;/permission/user/assignrole?opt=remove&amp;uid=&apos; + uid + &apos;&amp;rids=&apos; + rids + &apos;&apos;//发送请求移除$.get(url, fnf) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;div class="panel panel-default"&gt; &lt;div class="panel-body"&gt; &lt;form role="form" class="form-inline"&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputPassword1"&gt;未分配角色列表&lt;/label&gt;&lt;br&gt; &lt;select class="form-control unroles" multiple size="10" style="width: 100px; overflow-y: auto;"&gt; &lt;c:forEach items="$&#123;list_user_unrole&#125;" var="user_unrole"&gt; &lt;option value="$&#123;user_unrole.id&#125;"&gt;$&#123;user_unrole.name&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;ul&gt; &lt;li class="btn btn-default glyphicon glyphicon-chevron-right"&gt;&lt;/li&gt; &lt;br&gt; &lt;li class="btn btn-default glyphicon glyphicon-chevron-left" style="margin-top: 20px;"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="form-group" style="margin-left: 40px;"&gt; &lt;label for="exampleInputPassword1"&gt;已分配角色列表&lt;/label&gt;&lt;br&gt; &lt;select class="form-control roles_select" multiple size="10" style="width: 100px; overflow-y: auto;"&gt; &lt;c:forEach items="$&#123;list_user_role&#125;" var="user_role"&gt; &lt;option value="$&#123;user_role.id&#125;"&gt;$&#123;user_role.name&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;script type="text/javascript"&gt; $(function() &#123; $(".list-group-item").click(function() &#123; if ($(this).find("ul")) &#123; $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) &#123; $("ul", this).hide("fast"); &#125; else &#123; $("ul", this).show("fast"); &#125; &#125; &#125;); &#125;); //页面加载完成执行 $(function() &#123; addUserRoleEvent() removeUserRoleEvent() &#125;) //用户添加角色事件 var addUserRoleEvent = function() &#123; $('.glyphicon-chevron-right').click( function() &#123; log('向右移动=============&gt;') var uid = '' var rids = '' //遍历选中的元素,拼接用户角色id $('.unroles :selected').each(function() &#123; log(this) rids += $(this).val() + ',' &#125;) rids = rids.substring(0, rids.length - 1) log('用户角色ids==========&gt;', rids) uid = '$&#123;param.uid&#125;' url = '$&#123;ctp&#125;/permission/user/assignrole?opt=add&amp;uid=' + uid + '&amp;rids=' + rids + '' //选中的得进行处理添加到用户角色表中 //发送请求给当前用户添加这几个角色，必须带上权限id的拼串和userid $.get(url, fns) &#125;) &#125; //用户删除角色事件 var removeUserRoleEvent = function() &#123; $('.glyphicon-chevron-left') .click( function() &#123; log('向左移动=============&gt;') var rids = '' $('.roles_select :selected').each(function() &#123; rids += $(this).val() + ',' &#125;) rids = rids.substring(0, rids.length - 1) log('用户角色ids==========&gt;', rids) uid = '$&#123;param.uid&#125;' url = '$&#123;ctp&#125;/permission/user/assignrole?opt=remove&amp;uid=' + uid + '&amp;rids=' + rids + '' //发送请求移除 $.get(url, fnf) &#125;) &#125; //异步请求成功的回调函数 var fns = function(data) &#123; log('异步请求成功的回调函数===============&gt;') log('data===========&gt;', data) //$('.roles_select').append($('.unroles :selected')) $(".unroles :selected").appendTo(".roles_select") &#125; //异步请求失败的回调函数 var fnf = function(data) &#123; log('异步请求失败的回调函数===============&gt;') log('data===========&gt;', data) $('.roles_select :selected').appendTo('.unroles') &#125;&lt;/script&gt; 控制层: 1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 添加移除用户角色 @RequestMapping("/assignrole") @ResponseBody public String userRole(@RequestParam("uid") Integer uid, @RequestParam("rids") String rids, @RequestParam("opt") String opt) &#123; System.out.println("添加移除用户角色==================&gt;"); System.out.println("用户id-----角色ids------类型：添加、移除"); System.out.println(uid); System.out.println(rids); System.out.println(opt); if ("add".equals(opt)) &#123; // 为某个用户添加角色 int i = userRoleService.add(uid, rids); &#125; else if ("remove".equals(opt)) &#123; // 为某个用户删除角色 int i = userRoleService.remove(uid, rids); &#125; return "success"; &#125; @RequestMapping("/toAssignRolePage") public String toAssignRolePage(@RequestParam(value = "uid") Integer uid, Model model) &#123; System.out.println("UserController.toAssignRolePage去分配角色页面=============&gt;"); // 1、查出所有角色 List&lt;TRole&gt; list_role = roleService.getAllRole(); System.out.println("所有角色===========&gt;"); System.out.println(list_role); // 2、查出当前用户拥有的角色 List&lt;TRole&gt; list_user_role = roleService.getUserRole(uid); System.out.println("当前用户的角色==========&gt;"); System.out.println(list_user_role); HashMap&lt;Integer, TRole&gt; map_user_role = new HashMap&lt;&gt;(); for (TRole tRole : list_user_role) &#123; map_user_role.put(tRole.getId(), tRole); &#125; // 3、用户未分配的角色 ArrayList&lt;TRole&gt; list_user_unrole = new ArrayList&lt;&gt;(); for (TRole tRole : list_role) &#123; if (!map_user_role.containsKey(tRole.getId())) &#123; list_user_unrole.add(tRole); &#125; &#125; System.out.println("用户未分配的角色=============&gt;"); System.out.println(list_user_unrole); model.addAttribute("list_user_role", list_user_role); model.addAttribute("list_user_unrole", list_user_unrole); // model.addAttribute("uid", uid); return "manager/permission/assignRole"; &#125; sql: 1)用户表、用户_角色表、角色表3个表多表查询 12345678910111213141516171819&lt;resultMap id="BaseResultMap" type="com.atguigu.scw.manager.bean.TRole"&gt; &lt;id column="id" jdbcType="INTEGER" property="id" /&gt; &lt;result column="name" jdbcType="VARCHAR" property="name" /&gt;&lt;/resultMap&gt;&lt;!-- List&lt;TRole&gt; getUserRole(Integer uid); --&gt;&lt;select id="getUserRole" resultMap="BaseResultMap"&gt; SELECT a.* FROM t_role a LEFT JOIN t_user_role b ON a.`id` = b.`roleid` LEFT JOIN t_user c ON b.`userid` = c.`id` WHERE c.`id` = #&#123;uid&#125;&lt;/select&gt; 2、角色维护权限树 效果图： 实现思路： 1）zTree展示权限树，初始化含有复选框的权限树，异步请求控制层（参数：角色rid）查询出角色拥有的权限 2）点击分配权限携带角色rid和权限permission_ids到控制层，先删除角色所拥有的权限，再更加permission_ids更新角色拥有的权限，同步到前端 3）bootstrap模态框–分配权限按钮绑定参数 前端： 1）zTree权限树复选框初始化的时候刚开始使用2次异步请求（一次请求所有权限，一次请求角色拥有的权限），展示数据有点混乱，后来改为一次异步请求同时查询出（所有权限、角色拥有的权限）。 2）bootstrap自定义图标显示不出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201&lt;!-- Modal模态框 --&gt;&lt;div class="modal fade" id="permissModel" tabindex="-1" role="dialog" aria-labelledby="myModalLabel"&gt; &lt;div class="modal-dialog" role="document"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"&gt; &lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;h4 class="modal-title" id="myModalLabel"&gt;Modal title&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;!--展示权限树 --&gt; &lt;ul id="permissionTree" class="ztree"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;关闭&lt;/button&gt; &lt;button type="button" class="btn btn-primary" id='addPermissionBtn'&gt;分配权限&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; $(function() &#123; $(".list-group-item").click(function() &#123; if ($(this).find("ul")) &#123; $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) &#123; $("ul", this).hide("fast"); &#125; else &#123; $("ul", this).show("fast"); &#125; &#125; &#125;); &#125;); /* $("tbody .btn-success").click(function() &#123; window.location.href = "assignPermission.html"; &#125;); */ var zTree //设置ajax同步 //$.ajaxSettings.async = false var assignPermissionEvent = function() &#123; $(".assignPermissionModelBtn").click(function() &#123; log('assignPermissionEvent==============&gt;') //获取当前角色id log('当前角色id==========&gt;', $(this).attr('rid')) var rid = $(this).attr('rid') loadModalAndTree(rid) &#125;) &#125; var loadModalAndTree = function(rid) &#123; //模态框设置 var options = &#123; backdrop : 'static', show : true &#125; //手动打开模态框 $('#permissModel').modal(options) //从数据库查出的所有权限节点数据 //发送ajax请求获取到所有权限的json数据 var url = '$&#123;ctp&#125;/permission/role/json/' + rid $.getJSON(url, fns) //将角色id保存到模态框的哪个属性中； //打开模态框将角色id传递给model里面的权限分配按钮 log('角色id===========&gt;', rid) $('#addPermissionBtn').attr("rid", rid) &#125; //成功回调函数，刷新权限树 var fns = function(data) &#123; log('成功返回数据', data) log('event==========&gt;', event) var ids = [] $.each(data.listCurrentPermission, function() &#123; ids.push(this.id) &#125;) log('ids===========&gt;', ids) //遍历每一条权限 $.each(data.listPermission, function() &#123; //给每一个节点修改或者添加一些属性 if (this.pid == 0) &#123; this.open = true &#125; if (ids.includes(this.id)) &#123; this.checked = true &#125; &#125;) var setting = &#123; data : &#123; simpleData : &#123; enable : true, idKey : "id", pIdKey : "pid", &#125;, key : &#123; url : "haha" &#125; &#125;, /* view : &#123; addDiyDom : showIcon &#125;, */ check : &#123; enable : true &#125; &#125; zTree = $.fn.zTree.init($("#permissionTree"), setting, data.listPermission) log('zTree赋值完成==========&gt;', zTree) &#125; //用于在节点上固定显示用户自定义控件 //?图标无法正常显示可能是字体样式没有引入进来 var showIcon = function(treeId, treeNode) &#123; log('自定义显示图标==============&gt;') log('treeId===============&gt;', treeId) log('treeNode===============&gt;', treeNode) //#permissionTree_10_ico $("#" + treeNode.tId + "_ico").removeClass() .addClass(treeNode.icon) &#125; //默认勾选当前角色的权限 var checkcurPermisson = function(rid) &#123; var url = '$&#123;ctp&#125;/permission/role/curPermission/' + rid $.getJSON(url, fns2) &#125; //获取当前角色权限成功回调函数 var fns2 = function(data) &#123; log('fns2===============&gt;') log('fns2_data================', data) //遍历当前角色拥有的权限 $.each(data, function() &#123; //$(this).attr('id') var node = zTree.getNodesByParam('id', this.id, null) log('使用zTree===========&gt;', zTree) log('当前角色拥有的权限=============&gt;', node) zTree.checkNode(node, true, false) log('是否选中=========&gt;', node.checked) node.nocheck = true //表示显示checkbox &#125;) &#125; //更新权限树 var updateTree = function() &#123; log('更新权限树===========&gt;') var rid = $('#addPermissionBtn').attr("rid") log('角色rid==========&gt;', rid) var permission_ids = '' //1、获取当前我们已经选中的权限 var nodes = zTree.getCheckedNodes(true) log('nodes=============&gt;', nodes) $.each(nodes, function() &#123; permission_ids += this.id + ',' &#125;) var url = '$&#123;ctp&#125;/permission/role/update?rid=' + rid + '&amp;permission_ids=' + permission_ids $.get(url, updateTreeFn) &#125; //更新权限树回调函数 var updateTreeFn = function(data) &#123; alert(data) log("权限分配成功===========&gt;"); $('#permissModel').modal("hide"); &#125; var addPermissionBtnEvent = function() &#123; $('#addPermissionBtn').click(function() &#123; log('点击分配权限按钮=============&gt;') updateTree() &#125;) &#125; var __main = function() &#123; assignPermissionEvent() addPermissionBtnEvent() &#125; $(function() &#123; __main() &#125;)&lt;/script&gt; 控制层： 123456789101112131415161718192021222324252627282930313233343536//分配权限@RequestMapping("/update") @ResponseBody public String updateRolePermission(@RequestParam("rid") Integer rid, @RequestParam("permission_ids") String permission_ids) &#123; System.out.println("更新权限==========&gt;"); System.out.println(rid); System.out.println(permission_ids); // 先删除该角色所有权限，在为该用户分配权限 boolean flag = rolePermissionService.updatePermission(rid, permission_ids); return flag ? "success" : "fail"; &#125; @RequestMapping("/curPermission/&#123;id&#125;") @ResponseBody public List&lt;TPermission&gt; getCurrentPermission(@PathVariable("id") Integer rid) &#123; System.out.println("当前角色拥有的权限==============&gt;"); List&lt;TPermission&gt; listPermission = permissionService.getPermissionsById(rid); System.out.println(listPermission); return listPermission; &#125;//查出角色拥有的权限、所有权限 @RequestMapping("/json/&#123;id&#125;") @ResponseBody public HashMap&lt;String, List&lt;TPermission&gt;&gt; getAllPermission(@PathVariable("id") Integer rid) &#123; List&lt;TPermission&gt; listPermission = permissionService.getPermissions(); List&lt;TPermission&gt; listCurrentPermission = permissionService.getPermissionsById(rid); HashMap&lt;String, List&lt;TPermission&gt;&gt; map = new HashMap&lt;&gt;(); map.put("listPermission", listPermission); map.put("listCurrentPermission", listCurrentPermission); return map; &#125; 业务层： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 更新权限树 @Override public boolean updatePermission(Integer rid, String permission_ids) &#123; // 删除角色权限 TRolePermissionExample tRolePermissionExample = new TRolePermissionExample(); Criteria criteria = tRolePermissionExample.createCriteria(); criteria.andRoleidEqualTo(rid); int count = mapper.deleteByExample(tRolePermissionExample); // 更新权限 if (permission_ids.contains(",")) &#123; String[] split = permission_ids.split(","); for (String permission_id : split) &#123; int i = Integer.parseInt(permission_id); TRolePermission rolePermission = new TRolePermission(); // 设置权限id rolePermission.setPermissionid(i); // 设置角色id rolePermission.setRoleid(rid); // 保存角色权限关系 mapper.insertSelective(rolePermission); &#125; &#125; else &#123; int i = Integer.parseInt(permission_ids); TRolePermission rolePermission = new TRolePermission(); // 设置权限id rolePermission.setPermissionid(i); // 设置角色id rolePermission.setRoleid(rid); // 保存角色权限关系 mapper.insertSelective(rolePermission); &#125; return true; &#125; // 为角色分配权限，查询所有权限 @Override public List&lt;TPermission&gt; getPermissions() &#123; List&lt;TPermission&gt; list_permission = mapper.selectByExample(null); return list_permission; &#125; @Override public List&lt;TPermission&gt; getPermissionsById(Integer rid) &#123; List&lt;TPermission&gt; list_permission = mapper.getRolePermission(rid); return list_permission; &#125;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>ztree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易邮箱服务器发送电子邮件_搭建James邮件服务器发送电子邮件]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F13%2F%E7%BD%91%E6%98%93%E9%82%AE%E7%AE%B1%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6_%E6%90%AD%E5%BB%BAJames%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1、网易邮箱发送电子邮件 为了安全，网易邮箱开启pop3授权码验证，该授权码可以让客户端进行登录 qq开启授权码 https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;no=1001256&amp;&amp;id=28 实现：JavaMailAPI使用比较麻烦，这里采用的是Apache Commons Email 导入依赖 1234567&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-email --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-email&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 测试：A simple text email 1234567891011121314151617181920212223@Test public void test01() throws Exception &#123; SimpleEmail email = new SimpleEmail(); // 设置主机名，远程服务器的主机名 email.setHostName(&quot;smtp.163.com&quot;); email.setSmtpPort(25); // 设置登陆远程服务器的账号和pop3授权码 email.setAuthentication(&quot;15501892660@163.com&quot;, &quot;xxxxxxx&quot;); // 编写一个邮件 // 设置发送给谁 email.addTo(&quot;782125244@qq.com&quot;); // 设置这个邮件来源于哪里 email.setFrom(&quot;15501892660@163.com&quot;); // 设置邮件主题 email.setSubject(&quot;163发给qq的测试邮件 &quot;); // 设置邮件内容 email.setMsg(&quot;测试邮件&quot;); // 邮件发送 email.send(); &#125; 参考： http://commons.apache.org/proper/commons-email/userguide.html 2、搭建James邮件服务器 下载 https://archive.apache.org/dist/james/server/ quick-start http://james.apache.org/server/quick-start.html 解压 D:\devsoft\apache-james-3.0-beta4 建库 配置数据源 启动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101D:\devsoft\apache-james-3.0-beta4\bin&gt;run.batINFO 09:28:46,331 | org.apache.james.container.spring.context.JamesServerApplicationContext | Refreshing org.apache.james.container.spring.context.JamesServerApplicationContext@153f5a29: startup date [Thu Jan 03 09:28:46 CST 2019]; root of context hierarchyException in thread &quot;main&quot; org.springframework.beans.factory.BeanDefinitionStoreException: Failed to create the JAXB binder; nested exception is javax.xml.bind.JAXBException: Provider com.sun.xml.internal.bind.v2.ContextFactory could not be instantiated: com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition - with linked exception:[com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition] at org.apache.camel.spring.handler.CamelNamespaceHandler$CamelContextBeanDefinitionParser.doParse(CamelNamespaceHandler.java:258) at org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser.parseInternal(AbstractSingleBeanDefinitionParser.java:85) at org.springframework.beans.factory.xml.AbstractBeanDefinitionParser.parse(AbstractBeanDefinitionParser.java:59) at org.springframework.beans.factory.xml.NamespaceHandlerSupport.parse(NamespaceHandlerSupport.java:73) at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1419) at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1409) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:184) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:140) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:111) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.registerBeanDefinitions(XmlBeanDefinitionReader.java:493) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:390) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:334) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:302) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:174) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:209) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:180) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:243) at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:127) at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:93) at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:131) at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:522) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:436) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:139) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:93) at org.apache.james.container.spring.context.JamesServerApplicationContext.&lt;init&gt;(JamesServerApplicationContext.java:39) at org.apache.james.app.spring.JamesAppSpringMain.init(JamesAppSpringMain.java:61) at org.apache.james.app.spring.JamesAppSpringMain.main(JamesAppSpringMain.java:42)Caused by: javax.xml.bind.JAXBException: Provider com.sun.xml.internal.bind.v2.ContextFactory could not be instantiated: com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition - with linked exception:[com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition] at javax.xml.bind.ContextFinder.newInstance(ContextFinder.java:146) at javax.xml.bind.ContextFinder.find(ContextFinder.java:356) at javax.xml.bind.JAXBContext.newInstance(JAXBContext.java:431) at javax.xml.bind.JAXBContext.newInstance(JAXBContext.java:394) at org.apache.camel.spring.handler.CamelNamespaceHandler.createJaxbContext(CamelNamespaceHandler.java:187) at org.apache.camel.spring.handler.CamelNamespaceHandler.getJaxbContext(CamelNamespaceHandler.java:174) at org.apache.camel.spring.handler.CamelNamespaceHandler$CamelContextBeanDefinitionParser.doParse(CamelNamespaceHandler.java:256) ... 26 moreCaused by: com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition at com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException$Builder.check(IllegalAnnotationsException.java:91) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl.getTypeInfoSet(JAXBContextImpl.java:445) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl.&lt;init&gt;(JAXBContextImpl.java:277) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl.&lt;init&gt;(JAXBContextImpl.java:124) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl$JAXBContextBuilder.build(JAXBContextImpl.java:1123) at com.sun.xml.internal.bind.v2.ContextFactory.createContext(ContextFactory.java:147) at com.sun.xml.internal.bind.v2.ContextFactory.createContext(ContextFactory.java:271) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at javax.xml.bind.ContextFinder.newInstance(ContextFinder.java:171) at javax.xml.bind.ContextFinder.newInstance(ContextFinder.java:131) ... 32 moreD:\devsoft\apache-james-3.0-beta4\bin&gt; 123456789101112131415161718192021222324252627282930313233D:\devsoft\apache-james-3.0-beta4\bin&gt;run.batINFO 09:37:44,247 | org.apache.james.container.spring.context.JamesServerApplicationContext | Refreshing org.apache.james.container.spring.context.JamesServerApplicationContext@7ca48474: startup date [Thu Jan 03 09:37:44 CST 2019]; root of context hierarchylog4j:WARN No appenders could be found for logger (org.apache.commons.configuration.ConfigurationUtils).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.INFO 09:37:45,153 | org.apache.james.container.spring.context.JamesServerApplicationContext | Bean &apos;logprovider&apos; of type [class org.apache.james.container.spring.lifecycle.LogProviderImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)INFO 09:37:45,544 | james.mailrepositorystore | JamesMailStore init...INFO 09:37:45,550 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.file.FileMailRepository to handle file protocol requests for repositories with key fileINFO 09:37:45,550 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.jdbc.JDBCMailRepository to handle db protocol requests for repositories with key dbINFO 09:37:45,550 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.jdbc.JDBCMailRepository to handle dbfile protocol requests for repositories with key dbfileINFO 09:37:45,551 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.file.MBoxMailRepository to handle mbox protocol requests for repositories with key mboxINFO 09:37:45,936 | james.dnsservice | Autodiscovery is enabled - trying to discover your system&apos;s DNS ServersINFO 09:37:45,942 | james.dnsservice | Adding autodiscovered server 202.100.192.68INFO 09:37:45,942 | james.dnsservice | Adding autodiscovered server 202.100.199.8INFO 09:37:45,943 | james.dnsservice | DNS Server is: 202.100.192.68INFO 09:37:45,943 | james.dnsservice | DNS Server is: 202.100.199.8INFO 09:37:45,949 | james.dnsservice | Registered cache, resolver and search paths as DNSJava defaults12 James WARN [main] openjpa.Runtime - An error occurred while registering a ClassTransformer with PersistenceUnitInfo: name &apos;James&apos;, root URL [file:/D:/devsoft/apache-james-3.0-beta4/conf/]. The error has been consumed. To see it, set your openjpa.Runtime log level to TRACE. Load-time class transformation will not be available.INFO 09:37:55,187 | james.domainlist | Set autodetect to: trueINFO 09:37:55,187 | james.domainlist | Set autodetectIP to: true28 James INFO [main] openjpa.Runtime - Starting OpenJPA 2.1.052 James INFO [main] openjpa.jdbc.JDBC - Using dictionary class &quot;org.apache.openjpa.jdbc.sql.MySQLDictionary&quot;.Cannot load JDBC driver class &apos;com.mysql.jdbc.Driver&apos;java.lang.ClassNotFoundException: com.mysql.jdbc.Driver at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at org.apache.commons.dbcp.BasicDataSource.createConnectionFactory(BasicDataSource.java:1420) at org.apache.commons.dbcp.BasicDataSource.createDataSource(BasicDataSource.java:1371) at org.apache.commons.dbcp.BasicDataSource.getConnection(BasicDataSource.java:1044) 解决办法 D:\devsoft\apache-james-3.0-beta4\conf\lib：存放自己导入的jar D:\devsoft\apache-james-3.0-beta4\lib：存放James默认jar 复制jaxb-impl-2.1.3.jar，mysql驱动jar包到conf/lib下 设置服务器域名、建立账户 1234567D:\devsoft\apache-james-3.0-beta4\bin&gt; james-cli.bat -h localhost -p 9999 adddomain atguigu.comadddomain command executed sucessfully in 106 ms.D:\devsoft\apache-james-3.0-beta4\bin&gt; james-cli.bat -h localhost -p 9999 adduser test@atguigu.com testadduser command executed sucessfully in 94 ms. 配置Foxmail客户端连接James邮件服务器 测试： 123456789101112131415161718192021222324252627282930/** * 测试james发送邮件 * @Description (TODO这里用一句话描述这个方法的作用) * @throws Exception */ @Test public void test02() throws Exception&#123; SimpleEmail email = new SimpleEmail(); //设置主机名，远程服务器的主机名 email.setHostName("127.0.0.1"); //自定义的ip，一定要手动设置好端口号 email.setSmtpPort(25); //设置登陆远程服务器的密码 email.setAuthentication("test@atguigu.com", "000000"); //编写一个邮件 //设置发送给谁 email.addTo("17512080612@163.com"); //设置这个邮件来源于哪里 email.setFrom("admin@atguigu.com"); //设置邮件主题 email.setSubject("哈哈，给你测试 "); //设置邮件内容 email.setMsg("我能给您发邮件&lt;a href='http://www.atguigu.com'&gt;尚硅谷&lt;/a&gt;"); //邮件发送 email.send(); &#125;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>email</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[帆软报表部署配置_emoss5用户分配角色、角色分配权限]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F12%2F%E5%B8%86%E8%BD%AF%E6%8A%A5%E8%A1%A8%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE_emoss5%E7%94%A8%E6%88%B7%E5%88%86%E9%85%8D%E8%A7%92%E8%89%B2%E3%80%81%E8%A7%92%E8%89%B2%E5%88%86%E9%85%8D%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[1、帆软报表部署 客户端工具sftp下载链接 https://www.netsarang.com/download/down_form.html?code=623 使用sftp https://www.netsarang.com/download/down_xfp6.html?token=dEFiMWxoUEhuNU1hQlMrRG9qU20yZ0Bnc1hKVGJhaHpkY3hBUUNMNFBoaXVn 1）用客户端工具sftp登录到135.125.60.122机子 文件–新建 报表存放路径 12/opt/FineBI/webapps/WebReport/WEB-INF/reportlets 2）菜单配置 基础应用–权限模型–菜单管理 建立菜单层级关系 在资源评价菜单下-建立杜邦报表分析文件夹–建立2018杜邦报表3层目录结构 在2018杜邦报表(1)下配置报表位置引用–填写菜单编码(表名)、排序号、菜单名称(表名中文描述)、菜单URL 菜单URL的配置 2、建员工、建用户、为用户分配角色、为角色分配权限 1）建员工–基础应用–权限模型–员工管理 2）建用户–基础应用–权限模型–用户管理–新增 新建用户之前必须先建员工、角色、部门，在建用户的时候可以为该用户分配角色和菜单权限 3）为用户分配角色–基础应用–权限模型–角色用户设置 先选中角色，然后为该角色添加用户 4）为角色分配权限–基础应用–权限模型–角色管理 先选中角色，然后为该角色勾选拥有的菜单权限]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>emoss</tag>
        <tag>finereport</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维矩阵显示账户类型和资质_ajax异步传参_插入mysql中文乱码]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F11%2F%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E6%98%BE%E7%A4%BA%E8%B4%A6%E6%88%B7%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%B5%84%E8%B4%A8_ajax%E5%BC%82%E6%AD%A5%E4%BC%A0%E5%8F%82_%E6%8F%92%E5%85%A5mysql%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1、二维矩阵显示账号类型和资质 效果： 表结构： 账号类型和资质中间表 资质表 思路： 业务层查出账户和资质中间表、资质表、账户表数据，前端展示图横轴根据账户数据填充，纵轴根据资质数据填充，选择框的确定–根据账户资质中间表数据和选择框上自定义属性绑定的账户名、资质id进行相等比较确定。 前端： 1）单选框勾选关系初始化 2）异步传参(封装成实体) 实体对象必须有get和set方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120 &lt;body&gt; &lt;% //设置导航条上的显示 pageContext.setAttribute("navinfo", "分类管理"); //设置点击高亮效果 pageContext.setAttribute("curUrl", "servicectrl/type/ctrl"); %&gt; &lt;!--引入导航条 --&gt; &lt;%@include file="/WEB-INF/includes/nav-bar.jsp"%&gt; &lt;div class="container-fluid"&gt; &lt;div class="row"&gt; &lt;!--引入树形菜单 --&gt; &lt;%@include file="/WEB-INF/includes/user_menu.jsp"%&gt; &lt;div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main"&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt; &lt;i class="glyphicon glyphicon-th"&gt;&lt;/i&gt; 数据矩阵 &lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;div class="table-responsive"&gt; &lt;table class="table table-bordered"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;名称&lt;/th&gt; &lt;c:forEach items="$&#123;types&#125;" var="type"&gt; &lt;th&gt;$&#123;type&#125;&lt;/th&gt; &lt;/c:forEach&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items="$&#123;certs&#125;" var="cert"&gt; &lt;tr&gt; &lt;td&gt;$&#123;cert.name&#125;&lt;/td&gt; &lt;c:forEach items="$&#123;types&#125;" var="type"&gt; &lt;td&gt;&lt;input class='checkSimple' type="checkbox" type_name='$&#123;type&#125;' cid='$&#123;cert.id&#125;'&gt;&lt;/td&gt; &lt;/c:forEach&gt; &lt;/c:forEach&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%@include file="/WEB-INF/includes/js-file.jsp"%&gt; &lt;!-- 引入树形菜单结构点击时动态显示页面高亮效果的js --&gt; &lt;%@include file="/WEB-INF/includes/common-js.jsp"%&gt; &lt;script type="text/javascript"&gt; $(function() &#123; $(".list-group-item").click(function() &#123; if ($(this).find("ul")) &#123; $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) &#123; $("ul", this).hide("fast"); &#125; else &#123; $("ul", this).show("fast"); &#125; &#125; &#125;) &#125;) $(function() &#123; //页面加载完成获取账户类型和资质的关系 var list_type_cert = '$&#123;list_type_cert_json&#125;' log('list_type_cert', list_type_cert) //string log('list_type_cert type=======&gt;', typeof (list_type_cert)) //JSON.parse(list_type_cert) 字符串转成json对象 $.each(JSON.parse(list_type_cert),function(index, content) &#123; log(index, content, content.accttype,content.certid) $('.checkSimple').each(function() &#123; //attr获取自定义属性值 if ($(this).attr('type_name') == (content.accttype)&amp;&amp; $(this).attr('cid') == (content.certid)) &#123; //设置原生属性值 $(this).prop('checked',true) &#125; &#125;) &#125;) //执行事件 __main() &#125;) //更新 var update_type_cert_event = function() &#123; var tAccountTypeCert = &#123;&#125; log('update_type_cert_event=============&gt;') $('body').on('click', 'input', function() &#123; log('update==========&gt;', this) var flag = $(this).prop('checked') log('flag==========&gt;', flag) accttype = $(this).attr('type_name') certid = $(this).attr('cid') log(accttype, certid) tAccountTypeCert.accttype = accttype tAccountTypeCert.certid = certid tAccountTypeCert.flag = flag var url = '$&#123;ctp&#125;/servicectrl/type/update_type_cert' var data = tAccountTypeCert $.getJSON(url, data, function(result) &#123; log(result) &#125;) &#125;) &#125; var __main = function() &#123; update_type_cert_event() &#125; &lt;/script&gt;&lt;/body&gt; 控制层： 1)接收异步传参实体返回json 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.atguigu.scw.manager.controller.manager;import java.util.Arrays;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import com.atguigu.scw.manager.bean.TAccountTypeCert;import com.atguigu.scw.manager.bean.TCert;import com.atguigu.scw.manager.service.CertService;import com.atguigu.scw.manager.service.CertTypeService;import com.fasterxml.jackson.databind.ObjectMapper;@Controller@RequestMapping("/servicectrl/type")public class TypeController &#123; @Autowired CertService certService; @Autowired CertTypeService cTypeService; private static ObjectMapper MAPPER = new ObjectMapper(); @RequestMapping("/ctrl") public String list(Model model) throws Exception &#123; System.out.println("分类管理界面============&gt;"); // 1、先去数据库查出表格横向的显示数据 List&lt;String&gt; types = Arrays.asList("商业公司", "个体工商户", "个人经营", "政府及非营利组织"); // 2、在查出纵向要显示的标题 List&lt;TCert&gt; certs = certService.getAllCert(); System.out.println("资质===========&gt;"); System.out.println(certs); // 3、查询经营类型与资质关系中间表 // List&lt;TAccountTypeCert&gt; cTypeService.getAllCertType(); List&lt;TAccountTypeCert&gt; list_type_cert = cTypeService.getAllCertType(); System.out.println("经营类型===============&gt;"); System.out.println(list_type_cert); // 4、将数据放到模型域当中 model.addAttribute("types", types); model.addAttribute("certs", certs); // list转json字符串 String list_type_cert_json = MAPPER.writeValueAsString(list_type_cert); System.out.println("经营类型--资质----"); System.out.println(list_type_cert_json); model.addAttribute("list_type_cert_json", list_type_cert_json); return "manager/servicemanager/type"; &#125; @RequestMapping("/update_type_cert") @ResponseBody public String update_type_cert(TAccountTypeCert tAccountTypeCert) &#123; System.out.println("更新经营类型---资质==========&gt;"); System.out.println(tAccountTypeCert); boolean flag = tAccountTypeCert.isFlag(); System.out.println("flag============&gt;"); System.out.println(flag); if (flag) &#123; System.out.println("增加一条记录========&gt;"); int count = cTypeService.updateTypeCert(tAccountTypeCert); &#125; else &#123; System.out.println("移除一条记录========&gt;"); cTypeService.removeTypeCert(tAccountTypeCert); &#125; return "success"; &#125;&#125; 业务层： 1）单表的写读操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.atguigu.scw.manager.service.impl;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.atguigu.scw.manager.bean.TAccountTypeCert;import com.atguigu.scw.manager.bean.TAccountTypeCertExample;import com.atguigu.scw.manager.bean.TAccountTypeCertExample.Criteria;import com.atguigu.scw.manager.dao.TAccountTypeCertMapper;import com.atguigu.scw.manager.service.CertTypeService;@Servicepublic class CertTypeServiceImpl implements CertTypeService &#123; @Autowired TAccountTypeCertMapper mapper; //查询资质和账户中间表 @Override public List&lt;TAccountTypeCert&gt; getAllCertType() &#123; List&lt;TAccountTypeCert&gt; list_type_cert = mapper.selectByExample(null); return list_type_cert; &#125; // 增加经营类型--资质 @Override public int updateTypeCert(TAccountTypeCert tAccountTypeCert) &#123; int count = mapper.insertSelective(tAccountTypeCert); return count; &#125; // 删除经营类型--资质 @Override public int removeTypeCert(TAccountTypeCert tAccountTypeCert) &#123; TAccountTypeCertExample example = new TAccountTypeCertExample(); Criteria criteria = example.createCriteria(); criteria.andAccttypeEqualTo(tAccountTypeCert.getAccttype()); criteria.andCertidEqualTo(tAccountTypeCert.getCertid()); int count = mapper.deleteByExample(example); return count; &#125;&#125; 2、mysql插入中文乱码 1）数据库编码和web.xml配置均为utf-8，Controller读取到的是正确的中文，但是保存到数据库后变成”??” 解决 12&lt;property name="url" value="jdbc:mysql://localhost:3306/scw_0325?useUnicode=true&amp;amp;characterEncoding=UTF-8" &gt;&lt;/property&gt;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ztree树形结构菜单_mybatis分页查询]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F10%2Fztree%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E8%8F%9C%E5%8D%95_mybatis%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[1、二级树形菜单 效果图 表结构 业务层： 二级菜单实现思路： 1）查出父菜单（pid=0），通过遍历父菜单获得父菜单(id)，根据父菜单id值作为条件查出子菜单（子菜单pid=父菜单id），接着整理父子菜单关系；这种不推荐，假如所有菜单为18个，查出父菜单3个封装到集合时需要遍历18次，根据父菜单id作为查询子菜单的条件需要遍历3*18次。 2）一次性查出所有菜单18个，使用程序进行组合，这种推荐，以空间换时间。 封装菜单实体 业务层： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public List&lt;TPermission&gt; getAllMenus() &#123; // 保存父菜单 List&lt;TPermission&gt; menus = new ArrayList&lt;TPermission&gt;(); Map&lt;Integer, TPermission&gt; map = new HashMap&lt;Integer, TPermission&gt;(); // 查询所有菜单 // 参数为null，表示不带条件查询菜单 List&lt;TPermission&gt; list = mapper.selectByExample(null); System.out.println("所有菜单=========&gt;"); System.out.println(list); // 1、将所有菜单都放在map中 // 都是引用，如果从map中拿到这个数据改变以后，map中页面变化 for (TPermission tPermission : list) &#123; map.put(tPermission.getId(), tPermission); &#125; // 2、先封装父菜单，再将子菜单放入到父菜单中 for (TPermission tPermission : list) &#123; if (tPermission.getPid() == 0) &#123; menus.add(tPermission); &#125; else &#123; // tPermission（子菜单），拿到父菜单 Integer pid = tPermission.getPid(); // 拿到父菜单；以pid的值作为map中的菜单id，就是父菜单 TPermission p_menu = map.get(pid); // 拿到当前父菜单的子菜单；子菜单会有一些额外的问题 // 这个list第一次获取是没有的，如果添加上一次以后。这个list是有的 List&lt;TPermission&gt; childs = p_menu.getChilds(); if (childs != null) &#123; // 当前有子菜单 childs.add(tPermission); &#125; else &#123; // 当前没有子菜单 childs = new ArrayList&lt;&gt;(); // 添加当前子菜单 childs.add(tPermission); // 将当前整理好的childs设置进去 p_menu.setChilds(childs); &#125; &#125; &#125; System.out.println("父菜单===========&gt;"); System.out.println(menus); return menus;&#125; 控制层 1）将整理好的父子菜单数据放入到session域中，当前用户的这次会话一直使用，只需要去数据库查询一次 12345678910111213141516171819202122232425@RequestMapping(value = "/main.html")public String toMainPage(HttpSession session) &#123; // 校验 // 判断session中是否有这个用户，如果没有去登陆页面 Object object = session.getAttribute(Constants.LOGIN_USER); if (object == null) &#123; // 用户没登陆 return "redirect:/login.jsp"; &#125; else &#123; // 用户登陆才来到主页，session中没有菜单，或者菜单被我们从session中清除了 if (session.getAttribute(Constants.USER_MENUS) == null) &#123; // 1、查出所有菜单，在页面进行显示 List&lt;TPermission&gt; menus = ps.getAllMenus(); // 2、将查到的菜单放在session域中 // 菜单这些数据没必要每次来到主页，都调用service方法进行查询；放在session用户， // 当前用户的这次会话一直使用，只需要去数据库查一次 session.setAttribute(Constants.USER_MENUS, menus); &#125; return "manager/main"; &#125;&#125; 前台： 1）引入：&lt;%@ taglib prefix=”fn” uri=”http://java.sun.com/jsp/jstl/functions&quot;%&gt;计算后台传过来的list集合的长度：${fn:length(p_menu.childs)} 123456789101112131415161718192021222324252627&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions"%&gt;&lt;div class="col-sm-3 col-md-2 sidebar"&gt; &lt;div class="tree"&gt; &lt;ul style="padding-left: 0px;" class="list-group"&gt; &lt;li class="list-group-item tree-closed"&gt;&lt;a href="main.html"&gt;&lt;i class="glyphicon glyphicon-dashboard"&gt;&lt;/i&gt; 控制面板&lt;/a&gt;&lt;/li&gt; &lt;!-- 遍历父菜单 --&gt; &lt;c:forEach items="$&#123;sessionScope.userMenus&#125;" var="p_menu"&gt; &lt;li class="list-group-item tree-closed"&gt;&lt;span&gt;&lt;i class="$&#123;p_menu.icon&#125;"&gt;&lt;/i&gt;$&#123;p_menu.name&#125; &lt;span class="badge" style="float: right"&gt;$&#123;fn:length(p_menu.childs)&#125;&lt;/span&gt;&lt;/span&gt; &lt;ul style="margin-top: 10px; display: none;"&gt; &lt;!-- 遍历子菜单 --&gt; &lt;c:forEach items="$&#123;p_menu.childs&#125;" var="c_menu"&gt; &lt;li style="height: 30px;"&gt;&lt;a href="$&#123;ctp&#125;/$&#123;c_menu.url&#125;" data-action="$&#123;c_menu.id&#125;"&gt;&lt;i class="$&#123;c_menu.icon&#125;"&gt;&lt;/i&gt;$&#123;c_menu.name&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:forEach&gt; &lt;/ul&gt;&lt;/li&gt; &lt;/c:forEach&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 2、mybatis分页查询 根据用户名或者账号进行查询 效果图： 引入依赖： 123456&lt;!-- 分页 插件 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;&lt;/dependency&gt; 业务层： 1）带条件查询 123456789101112131415161718@Overridepublic List&lt;TUser&gt; getAllUsersByCondition(String str) &#123; System.out.println("UserServiceImpl.getAllUsersByCondition 带条件查询员工============&gt;"); // 查询条件拼接 // 第一次创建的条件，默认使用and连接的 TUserExample tUserExample = new TUserExample(); Criteria criteria = tUserExample.createCriteria(); Criteria criteria2 = tUserExample.createCriteria(); if (!str.trim().equals("")) &#123; criteria.andLoginacctLike("%" + str + "%"); criteria.andUsernameLike("%" + str + "%"); &#125; tUserExample.or(criteria2); List&lt;TUser&gt; list_users_example = userMapper.selectByExample(tUserExample); return list_users_example;&#125; 控制层： 1）mybatis分页插件会对结果集进行包装，必须在查询前设置： PageHelper.startPage(pn, ps); 2）查询后输入框数据回显：model.addAttribute(“sp”, search);（转发） 1234567891011121314151617181920212223242526@RequestMapping("/list")public String users(@RequestParam(value = "pn", defaultValue = "1") Integer pn, @RequestParam(value = "ps", defaultValue = "5") Integer ps, @RequestParam(value = "sp", defaultValue = "") String search, Model model) &#123; System.out.println("UserController.users 用户列表显示页===========&gt;"); System.out.println("前台请求参数[第xxx页，每页显示xxx条数]==========&gt;"); System.out.println(pn); System.out.println(ps); // 分页显示数据,这里设置必须放到查询数据之前，否则前台会有问题 PageHelper.startPage(pn, ps); List&lt;TUser&gt; list_users = userService.getAllUsersByCondition(search); System.out.println("查询到的所有用户列表========&gt;"); System.out.println(list_users); PageInfo&lt;TUser&gt; users = new PageInfo&lt;&gt;(list_users, 5); System.out.println("分页后的数据处理"); System.out.println(users); // 将查询用户列表数据放在请求域中，表单查询参数回显到页面 model.addAttribute("users", users); model.addAttribute("sp", search); return "manager/permission/user";&#125; 前台： 1）为所有分页连接绑定单击事件，让其动态的带上分页的查询参数 123var href = $(this).attr("href") + "&amp;sp="+ $("input[name='sp']").val()&lt;br/&gt;$(this).attr("href", href) 2)全选和全不选函数 1234567891011121314//全选/全不选函数function checkall_reverse(check_all_btn, check_btn) &#123; check_all_btn.click(function() &#123; //如果是原生的属性，使用prop获取比较好 check_btn.prop("checked", $(this).prop("checked")) &#125;) check_btn.click(function() &#123; //当check_btn点满以后check_all_btn勾上，否则不选中 //获取被选中的checkbtn个数 var flag = check_btn.filter(":checked").length == check_btn.length check_all_btn.prop("checked", flag); &#125;)&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html lang="UTF-8"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;&lt;meta name="description" content=""&gt;&lt;meta name="author" content=""&gt;&lt;%@include file="/WEB-INF/includes/css-file.jsp"%&gt;&lt;link rel="stylesheet" href="$&#123;ctp&#125;/css/main.css"&gt;&lt;style&gt;.tree li &#123; list-style-type: none; cursor: pointer;&#125;table tbody tr:nth-child(odd) &#123; background: #F4F4F4;&#125;table tbody td:nth-child(even) &#123; color: #C00;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;% //设置导航条上的显示 pageContext.setAttribute("navinfo", "用户维护"); //设置点击高亮效果 pageContext.setAttribute("curUrl", "permission/user/list"); %&gt; &lt;!-- 引入navbar--&gt; &lt;%@include file="/WEB-INF/includes/nav-bar.jsp"%&gt;&lt;/nav&gt; &lt;div class="container-fluid"&gt; &lt;div class="row"&gt; &lt;!-- 引入树形菜单 --&gt; &lt;%@include file="/WEB-INF/includes/user_menu.jsp"%&gt; &lt;div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main"&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt; &lt;i class="glyphicon glyphicon-th"&gt;&lt;/i&gt; 数据列表 &lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;form class="form-inline" role="form" style="float: left;" action="$&#123;ctp &#125;/permission/user/list" method="post"&gt; &lt;div class="form-group has-feedback"&gt; &lt;div class="input-group"&gt; &lt;div class="input-group-addon"&gt;查询条件&lt;/div&gt; &lt;input class="form-control has-success" type="text" name="sp" placeholder="用户名/账号查询" value="$&#123;sp&#125;"&gt; &lt;/div&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-warning"&gt; &lt;i class="glyphicon glyphicon-search"&gt;&lt;/i&gt; 查询 &lt;/button&gt; &lt;/form&gt; &lt;button type="button" class="btn btn-danger" style="float: right; margin-left: 10px;"&gt; &lt;i class=" glyphicon glyphicon-remove"&gt;&lt;/i&gt; 删除 &lt;/button&gt; &lt;button type="button" class="btn btn-primary" style="float: right;" onclick="window.location.href='add.html'"&gt; &lt;i class="glyphicon glyphicon-plus"&gt;&lt;/i&gt; 新增 &lt;/button&gt; &lt;br&gt; &lt;hr style="clear: both;"&gt; &lt;div class="table-responsive"&gt; &lt;table class="table table-bordered"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th width="30"&gt;#&lt;/th&gt; &lt;th width="30"&gt;&lt;input type="checkbox" id="checkall_btn"&gt;&lt;/th&gt; &lt;th&gt;账号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;邮箱地址&lt;/th&gt; &lt;th width="100"&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items="$&#123;users.list&#125;" var="user"&gt; &lt;tr&gt; &lt;td&gt;$&#123;user.id&#125;&lt;/td&gt; &lt;td&gt;&lt;input type="checkbox" class="single_check"&gt;&lt;/td&gt; &lt;td&gt;$&#123;user.loginacct &#125;&lt;/td&gt; &lt;td&gt;$&#123;user.username &#125;&lt;/td&gt; &lt;td&gt;$&#123;user.email &#125;&lt;/td&gt; &lt;td&gt; &lt;button type="button" class="btn btn-success btn-xs"&gt; &lt;i class=" glyphicon glyphicon-check"&gt;&lt;/i&gt; &lt;/button&gt; &lt;button type="button" class="btn btn-primary btn-xs"&gt; &lt;i class=" glyphicon glyphicon-pencil"&gt;&lt;/i&gt; &lt;/button&gt; &lt;button type="button" class="btn btn-danger btn-xs"&gt; &lt;i class=" glyphicon glyphicon-remove"&gt;&lt;/i&gt; &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td colspan="6" align="center"&gt; &lt;ul class="pagination"&gt; &lt;!-- 即使点击分页连接也应该带上查询条件的值 --&gt; &lt;!-- 给分页超链接绑定单击事件； --&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=1"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;!-- 是否还有前一页 --&gt; &lt;c:if test="$&#123;users.hasPreviousPage&#125;"&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;users.prePage&#125;"&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;!-- 遍历页数 --&gt; &lt;c:forEach items="$&#123;users.navigatepageNums&#125;" var="pn"&gt; &lt;!-- 当前页 --&gt; &lt;c:if test="$&#123;pn==users.pageNum &#125;"&gt; &lt;li class="active"&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;pn&#125;"&gt;$&#123;pn&#125;&lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;c:if test="$&#123;pn != users.pageNum &#125;"&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;pn&#125;"&gt;$&#123;pn &#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;!--是否还有下一页 --&gt; &lt;c:if test="$&#123;users.hasNextPage&#125;"&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;users.nextPage&#125;"&gt;下一页&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;users.pages&#125;"&gt;末页&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%@include file="/WEB-INF/includes/js-file.jsp"%&gt; &lt;!-- 引入树形菜单结构点击时动态显示页面高亮效果的js --&gt; &lt;%@include file="/WEB-INF/includes/common-js.jsp"%&gt; &lt;script type="text/javascript"&gt; $(function() &#123; $(".list-group-item").click(function() &#123; if ($(this).find("ul")) &#123; $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) &#123; $("ul", this).hide("fast"); &#125; else &#123; $("ul", this).show("fast"); &#125; &#125; &#125;); &#125;); $("tbody .btn-success").click(function() &#123; window.location.href = "assignRole.html"; &#125;); $("tbody .btn-primary").click(function() &#123; window.location.href = "edit.html"; &#125;); //当前页面所在的哪个超链接是color:red //他的父list-group-item. tree-closed是没有的 //找到当前页面的a连接 //使用css为某个元素加样式 list-group-item //为所有分页连接绑定单击事件，让其动态的带上分页的查询参数 $(".pagination").find("a").click( function() &#123; //1、获取到查询表单的查询参数 //不禁用默认行为，而是为超链接多拼装上查询条件 //为超链接动态拼装查询条件 var href = $(this).attr("href") + "&amp;sp=" + $("input[name='sp']").val() $(this).attr("href", href) &#125;) //这是调用了抽取过来的方法； checkall_reverse($("#checkall_btn"), $(".single_check")) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>ztree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svn版本控制]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F09%2Fsvn%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1、svn下载 https://sourceforge.net/projects/win32svn/ 2、验证是否安装成功 12C:\Users\libingshen&gt;svn --version 3、创建版本库 12D:\mytest\mysvn\OA&gt;svnadmin create D:\mytest\mysvn\OA 4、启动svn服务 5、验证svn服务是否启动 svn服务监听3690端口 6、svn注册为Windows服务 tip:等号左边没有空格，等号右边有一个空格。 12C:\WINDOWS\system32&gt;sc create MySVNService binpath= &quot;C:\Pmyprogram\svn\bin\svnserve.exe --service -r D:\mytest\mysvn&quot; start= auto depend= Tcpip 原因：每次启动svn服务时必须启动一个cmd窗口，cmd窗口一关闭，svn服务就关闭。 非管理员运行时会失败。 管理员运行 启动、停止、删除svn服务（管理员身份运行cmd） 123456789//启动svn服务C:\WINDOWS\system32&gt;sc start MySVNService//停止服务C:\WINDOWS\system32&gt;sc stop MySVNService//删除服务C:\WINDOWS\system32&gt;sc delete MySVNService 7、检出项目 12D:\mytest\mycheckout&gt;svn checkout svn://localhost/OA MyOA 8、提交文件 –开启匿名权限访问 –先将文件加入版本库，然后提交（需添加提交日志信息，不然报错） svn commit 命令最后可以不指定具体文件，此时表示提交当前工作副本中的所有修改 9、更新 另一个客户端检出项目、更新并提交文件 1234//远程版本库具体位置 svn://localhost/OA//将OA检出到本地的目录 MyOA2D:\mytest\mycheckout&gt;svn checkout svn://localhost/OA MyOA2 10、授权访问版本库 –单版本库开启授权访问 –多版本库开启授权访问 123456在版本库根目录 D:\mytest\mysvn 下创建 commConf 目录将未修改的 authz 和 passwd 文件拷贝到 commConf 目录下修改需要设置权限的版本库的 svnserve.conf 文件①password-db = ../../commConf/passwd②authz-db = ../../commConf/authz passwd：设置访问版本库的用户信息 authz：设置用户访问版本库的权限]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc配置]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F07%2Fspringmvc%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1、springmvc路径跳转配置 目录结构 控制层 123456789101112131415161718192021&lt;!-- 使用注解开发，不用配置controller，需要配置一个组件扫描器 --&gt;&lt;context:component-scan base-package="com.*" /&gt;&lt;!-- 视图解析器 --&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置从项目根目录到指定目录一端路径 ,建议指定浅一点的目录 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"&gt;&lt;/property&gt; &lt;!-- 文件的后缀名 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--将index2.jsp放在/WEB-INF/jsp/目录下，请求index2时不经过controller处理;配置了mvc:view-controller后需要配置mvc:annotation-driven,不然走controller的请求会失效 --&gt;&lt;mvc:view-controller path="/index2" view-name="index2" /&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;!--处理静态资源 --&gt;&lt;mvc:default-servlet-handler/&gt; index.jsp 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page language="java" contentType="text/html; charset=ISO-8859-1" pageEncoding="ISO-8859-1"%&gt;&lt;%@ taglib uri="http://java.sun.com/jstl/core_rt" prefix="c"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="ISO-8859-1"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;% request.setAttribute("path", request.getContextPath());%&gt;&lt;/head&gt;&lt;body&gt; //走controller跳转 &lt;a href="hello"&gt;go controller&lt;/a&gt; &lt;br&gt; //不走controller跳转，在springmvc配置文件中配置了mvc-view;index2.jsp页面需放在/WEB-INF/jsp/目录下 &lt;a href="index2"&gt;not go controller&lt;/a&gt; &lt;br/&gt; //加载静态资源 &lt;a href="$&#123;path&#125;/static/index3.jsp"&gt;load static resource index3.jsp&lt;/a&gt; //加载静态资源，需在springmvc配置文件中配置mvc:default-servlet-handler &lt;script type="text/javascript" src="$&#123;path&#125;/ui/jquery/jquery-1.8.3.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function() &#123; console.log("$&#123;path&#125;") &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、springmvc获取请求参数，封装数据到请求域 前台 123456&lt;form action='testParam' method='get'&gt; 用户名：&lt;input type='text' name='username'&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; 控制层 处理方式一：方法参数为Map或者ModelMap类型，数据封装到Map或者Modelmap类型中，其实就是将数据放入到请求域当中 123456789101112@RequestMapping("/testParam")public String testParam(ModelMap modelMap,HttpServletRequest request) &#123; String username = request.getParameter("username"); System.out.println("接收前台发送过来的请求参数=========&gt;用户名："+username); //modelmap会将数据放到请求域当中 modelMap.put("address", "haikou"); //返回视图 return "hello";&#125; 处理方式二：用ModelAndView作为返回值，可以将数据放到请求域中且指定返回的视图 1234567891011@RequestMapping("/testParam")public ModelAndView testParam(HttpServletRequest request) &#123; String username = request.getParameter("username"); System.out.println("接收前台发送过来的请求参数=========&gt;用户名："+username); //参数为返回的视图 ModelAndView hello =new ModelAndView("hello"); hello.addObject("address", "haikou"); return hello;&#125; 前台获取 1234&lt;!-- 获取后台封装在请求域中的数据 --&gt;地址：$&#123;requestScope.address&#125;&lt;br/&gt;&lt;%=request.getAttribute(&quot;address&quot;)%&gt; 3、springmvc处理文件上传 springmvc.xml增加如下配置 1234567&lt;!--文件上传 --&gt;&lt;bean name="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="defaultEncoding" value="UTF-8"&gt;&lt;/property&gt; &lt;property name="maxUploadSize" value="10240000"&gt;&lt;/property&gt;&lt;/bean&gt; 前台表单提交 123456//必须是post请求，且enctype='multipart/form-data'&lt;form action='testFileUpload' method='post' enctype='multipart/form-data'&gt; 文件：&lt;input type='file' name='file' &gt;&lt;br/&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; 控制层 12345678910@RequestMapping("/testFileUpload")public String testFileUpload(@RequestParam("file")MultipartFile file) throws IOException &#123; //获取文件名 String fileName=file.getOriginalFilename(); //获取流，即可取得内容 InputStream in=file.getInputStream(); System.out.println("文件名===========&gt;"+fileName); return "hello";&#125; 4、springmvc返回json数据 pom.xml加入依赖 12345678910111213141516171819&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; 控制层 12345678910//需要加@ResponseBody注解@RequestMapping("/testJson")@ResponseBodypublic Map testFileUpload() &#123; Map&lt;String, Object&gt; map=new HashMap&lt;&gt;(); map.put("username", "沈利兵"); map.put("sex", "男"); return map;&#125;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my_en]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F06%2Fmy_en%2F</url>
    <content type="text"><![CDATA[###2018/12/14 12345678910111213141516171819202122232425262728293031323334353637383940414243eviction --赶出thorough --彻底fixed --固定notifications --通知traverse graphs --遍历图covers --覆盖block --阻塞Redis Releases --Redis 发布Benchmarks --基准Latency monitoring --延迟监控tune --调整High Availability --高可用性Signals Handling --信号处理Administration --管理troubleshoot --解决Troubleshooting --故障排除command line interface --命令行界面durability --持久力Credits --积分Sponsors --赞助商Trademark --商标Lexicographical order --字典顺序populated --填充reply --答复、回复indicating --指示、说明penultimate --倒数第二treat --对待、视其为abstractions --抽象separately --单独、分别地retrieve --检索、取出bitmaps --位图probabilistic --概率estimate --估计cardinality --基数scared --害怕trivial --不重要的、微不足道的crash course --速成班specification --规范Prerequisites --先决条件clause --条款、子句omit --忽略semantics --语义 ###20181215 参考https://tylermcginnis.com/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/ 123456789101112131415161718192021222324252627opinion --观点properly --正确地strategy --策略interpret --解释authoring --创作form --形式consist of --包括responsibilities --责任spot --点、发现key --关键phases --阶段deserve --值得cement --巩固Hoisting --提升exactly identical --完全相同fairly comfortable --相当熟悉adapt --调整、适应Set up memory space --设置内存空间Execution Stack --执行堆栈Call Stack --调用堆栈intuition --直觉scenario --脚本misunderstood --误解Implicit Binding --隐式绑定Explicit Binding --显示绑定Lexical Binding --词法绑定 ###20181217 参考 https://dev.to/siwalik/async-programming-basics-every-js-developer-should-know-in-2018-a9c 123hence --于是imensely --非常 ###20190117 参考： https://docs.python.org/3/library/stdtypes.html#comparisons 123456Comparisons --比较Comparisons can be chained arbitrarily --比较可以任意连接negated --否定notion --概念、主张raise --养、引发 https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range 12345678ascending --升序restrictions --限制imposed --加强lexicographically --字典顺序multidimensional list --多维列表Immutable Sequence Types --不可变序列类型slice --切片]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>english</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven配置]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F05%2Fmaven%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1、下载： https://maven.apache.org/download.cgi 2、配置path环境变量 3、验证安装是否成功 4、配置本地仓库、阿里镜像、jdk编译版本 配置本地仓库位置 12&lt;localRepository&gt;C:\greensoft\apache-maven-3.5.2\repository&lt;/localRepository&gt; 配置jar包下载阿里远程镜像 1234567&lt;mirror&gt; &lt;id&gt;aliyun-maven&lt;/id&gt; &lt;name&gt;aliyun-maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 配置jdk编译版本 12345678910111213&lt;profile&gt; &lt;id&gt;jdk-1.7&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.7&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 5、eclipse整合maven 使用自己的maven安装包 6、IDEA整合maven]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js面向对象_箭头函数this_数组常用方法]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F04%2Fjs%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this_%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、js面向对象 1)传统的面向对象 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function Person(name, age)&#123; this.name=name; this.age=age; &#125; Person.prototype.showName=function ()&#123; alert('我叫'+this.name); &#125;; Person.prototype.showAge=function ()&#123; alert('我'+this.age+'岁'); &#125;; let p=new Person('blue', 18); p.showName(); p.showAge(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function Person(name, age)&#123; this.name=name; this.age=age; &#125; Person.prototype.showName=function ()&#123; alert('我叫'+this.name); &#125;; Person.prototype.showAge=function ()&#123; alert('我'+this.age+'岁'); &#125;; //------------------------------------------------ function Worker(name, age, job)&#123; //通过call调用父类构造函数 Person.call(this, name, age); this.job=job; &#125; //使得子类实例对象共享父类原型对象上的方法 Worker.prototype=new Person(); //重写子类原型对象的构造，特别恶心 Worker.prototype.constructor=Worker; Worker.prototype.showJob=function ()&#123; alert('我是做：'+this.job); &#125;; let w=new Worker('blue', 18, '打杂的'); w.showName(); w.showAge(); w.showJob(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2）js标准的面向对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /*function Person(name, age)&#123; this.name=name; this.age=age; &#125; Person.prototype.showName=function ()&#123; alert('我叫'+this.name); &#125;; Person.prototype.showAge=function ()&#123; alert('我'+this.age+'岁'); &#125;;*/ //标准面向对象书写方式 class Person&#123; constructor(name, age)&#123; this.name=name; this.age=age; &#125; showName()&#123; alert('我叫'+this.name); &#125; showAge()&#123; alert('我'+this.age+'岁'); &#125; &#125; let p=new Person('blue', 18); p.showName(); p.showAge(); //------------------------------------------------ function Worker(name, age, job)&#123; Person.call(this, name, age); this.job=job; &#125; Worker.prototype=new Person(); Worker.prototype.constructor=Worker; Worker.prototype.showJob=function ()&#123; alert('我是做：'+this.job); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 标准的继承方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /*function Person(name, age)&#123; this.name=name; this.age=age; &#125; Person.prototype.showName=function ()&#123; alert('我叫'+this.name); &#125;; Person.prototype.showAge=function ()&#123; alert('我'+this.age+'岁'); &#125;;*/ //标准面向对象书写方式 class Person&#123; constructor(name, age)&#123; this.name=name; this.age=age; &#125; showName()&#123; alert('我叫'+this.name); &#125; showAge()&#123; alert('我'+this.age+'岁'); &#125; &#125; /*let p=new Person('blue', 18); p.showName(); p.showAge();*/ //------------------------------------------------ /*function Worker(name, age, job)&#123; Person.call(this, name, age); this.job=job; &#125; Worker.prototype=new Person(); Worker.prototype.constructor=Worker; Worker.prototype.showJob=function ()&#123; alert('我是做：'+this.job); &#125;;*/ //标准继承方式，子类通过extends实例化的子类可以访问到父类原型对象的方法 class Worker extends Person&#123; constructor(name, age, job)&#123; //super-超类(父类)，可以访问到构造方法，不需要通过call的方式调用 super(name, age); this.job=job; &#125; showJob()&#123; alert('我是做：'+this.job); &#125; &#125; let w=new Worker('blue', 18, '打杂的'); w.showName(); w.showAge(); w.showJob(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2、箭头函数this 普通函数：根据调用我的人 this老变 箭头函数：根据所在的环境 this恒定 bind——给函数定死一个this 例1： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr = [1, 2, 3]; //箭头函数所处的环境是window arr.a = () =&gt; &#123; console.log(this); &#125;; arr.a(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 输出 例2： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; document.onclick=function ()&#123; let arr=[1,2,3]; //箭头函数所处的环境是document arr.a=()=&gt;&#123; console.log(this); &#125;; arr.a(); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 输出 例3： 箭头函数所处的环境是document，尽管通过bind绑定死了12，但还是输出document，说明箭头函数的this优先级高于bind方式绑定的this 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; document.onclick=function ()&#123; let a=()=&gt;&#123; console.log(this); &#125;; let oBtn=document.getElementById('btn1'); oBtn.onclick=a.bind(12); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="button" value="aaa" id="btn1"&gt; &lt;/body&gt;&lt;/html&gt; 输出 3、数组常用方法 1）map 映射 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[62, 55, 82, 37, 26]; let arr2=arr.map(function (item)&#123; if(item&gt;=60)&#123; return true; &#125;else&#123; return false; &#125; &#125;); //true,false,true,false,false alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 改进1 map参数：回调函数使用箭头函数书写方式 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[62, 55, 82, 37, 26]; let arr2=arr.map((item)=&gt;&#123; if(item&gt;=60)&#123; return true; &#125;else&#123; return false; &#125; &#125;); alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 改进2 如果有且仅有1个参数，()可以省 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[62, 55, 82, 37, 26]; let arr2=arr.map(item=&gt;&#123; if(item&gt;=60)&#123; return true; &#125;else&#123; return false; &#125; &#125;); alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 改进3 如果函数体只有一句话，而且是return，{}可以省 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[62, 55, 82, 37, 26]; let arr2=arr.map(item=&gt;item&gt;=60); alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2）filter过滤 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[12,5,88,37,21,91,17,24]; let arr2=arr.filter(item=&gt;item%2); //5,37,21,91,17 alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 3）forEach 遍历 求和 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[12,5,88,37,21,91,17,24]; let sum=0; arr.forEach(item=&gt;&#123; sum+=item; &#125;); //结果295 alert(sum); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 4）reduce 汇总 参数 tmp:中间结果 item：元素项 index：元素索引 求和 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[12,5,88,37,21,91,17,24]; let sum=arr.reduce((tmp,item,index)=&gt;&#123; console.log(tmp, item, index); return tmp+item; &#125;); console.log(sum); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 输出 求平均 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[12,5,88,37,21,91,17,24]; let sum=arr.reduce((tmp,item,index)=&gt;&#123; return tmp+item; &#125;); //结果36.875 console.log(sum/arr.length); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 5）from 将类数组转换成数组 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; div &#123;width:200px; height:200px; background:#CCC; float:left; margin:10px;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; //DOM对象 let aDiv=document.getElementsByTagName('div'); console.log(aDiv); //数组 let aDiv2=Array.from(aDiv); console.log(aDiv2); Array.from(aDiv).forEach(div=&gt;&#123; div.style.background='yellow'; &#125;); Array.prototype.slice.call(aDiv).forEach(div=&gt;&#123; div.style.background='blue'; &#125;); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 输出]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js开发者经常忽略的基础知识点]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F03%2Fjs%E5%BC%80%E5%8F%91%E8%80%85%E7%BB%8F%E5%B8%B8%E5%BF%BD%E7%95%A5%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1、字符串匹配 匹配所有 1234567891011// Mistake// 踩到坑了var str = "David is an Arsenal fan, which means David is great";str.replace("David", "Darren");// "Darren is an Arsenal fan, which means David is great"// Desired// 符合预期str.replace(/David/g, "Darren");// "Darren is an Arsenal fan, which means Darren is great" 忽略大小写 123str.replace(/david/gi, "Darren");// "Darren will always be an Arsenal fan, which means Darren will always be great" 2、将“类数组”元素（比如 arguments 参数列表、节点列表和属性列表）转换成真正的数组 12345678var nodesArr = Array.prototype.slice.call(document.querySelectorAll("div"));// "true" array of DIVs// 得到一个由 div 元素组成的“真正的”数组var argsArr = Array.prototype.slice.call(arguments);// changes arguments to "true" array// 把 arguments 转换成一个“真正的”数组 克隆数组 1234var clone = myArray.slice(0);// naive clone// 浅克隆 3、数组的sort方法 简单排序 1234[1, 3, 9, 2].sort();// Returns: [1, 2, 3, 9]// 返回 [1, 2, 3, 9] 复杂排序 12345678910111213141516[ &#123; name: "Robin Van PurseStrings", age: 30 &#125;, &#123; name: "Theo Walcott", age: 24 &#125;, &#123; name: "Bacary Sagna", age: 28 &#125;].sort(function(obj1, obj2) &#123; // Ascending: first age less than the previous // 实现增序排列：前者的 age 小于后者 return obj1.age - obj2.age;&#125;); // Returns: // [ // &#123; name: "Theo Walcott", age: 24 &#125;, // &#123; name: "Bacary Sagna", age: 28 &#125;, // &#123; name: "Robin Van PurseStrings", age: 30 &#125; // ] 4、push合并数组 1234567var mergeTo = [4,5,6];var mergeFrom = [7,8,9];Array.prototype.push.apply(mergeTo, mergeFrom);mergeTo; // is: [4, 5, 6, 7, 8, 9] 5、join拼接字符串 1234567var str = [ '&lt;div&gt;', '&lt;button id="lucky-draw"&gt;Lucky Draw&lt;/button&gt;', '&lt;/div&gt;'].join('')log(str) 参考 https://github.com/cssmagic/blog/issues/21]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Inheritance and the Prototype Chain]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F02%2FJavaScript%20Inheritance%20and%20the%20Prototype%20Chain%2F</url>
    <content type="text"><![CDATA[参考： https://tylermcginnis.com/javascript-inheritance-and-the-prototype-chain/ ##JavaScript Inheritance and the Prototype Chain Post This post is designed to be read after you read JavaScript Private and Public Class Fields. Previously we learned how to create an Animal class both in ES5 as well as in ES6. We also learned how to share methods across those classes using JavaScript’s prototype. To review, here’s the code we saw in an earlier post. 12345678910111213141516171819202122function Animal (name, energy) &#123; this.name = name this.energy = energy&#125;Animal.prototype.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Animal.prototype.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Animal.prototype.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125;const leo = new Animal(&apos;Leo&apos;, 7) 123456789101112131415161718192021class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep() &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play() &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;const leo = new Animal(&apos;Leo&apos;, 7) Now let’s say we wanted to start making individual classes for specific animals. For example, what if we wanted to start making a bunch of dog instances. What properties and methods will these dogs have? Well, similar to our Animal class, we could give each dog a name, an energy level, and the ability to eat, sleep, and play. Unique to our Dog class, we could also give them a breed property as well as the ability to bark. In ES5, our Dog class could look something like this 12345678910111213141516171819202122232425262728function Dog (name, energy, breed) &#123; this.name = name this.energy = energy this.breed = breed&#125;Dog.prototype.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Dog.prototype.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Dog.prototype.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125;Dog.prototype.bark = function () &#123; console.log(&apos;Woof-Woof!&apos;) this.energy -= .1&#125;const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;) Alright, well… we just recreated the Animal class and added a few new properties to it. If we wanted to create another animal, say a Cat, at this point we’d again have to create a Cat class, duplicate all the common logic located in the Animal class to it, then add on Cat specific properties just like we did with the Dog class. In fact, we’d have to do this for each different type of animal we created. 12345678function Dog (name, energy, breed) &#123;&#125;function Cat (name, energy, declawed) &#123;&#125;function Giraffe (name, energy, height) &#123;&#125;function Monkey (name, energy, domesticated) &#123;&#125; This work, but it seems wasteful. The Animal class is the perfect base class. What that means is that it has all the properties that each one of our animals has in common. Whether we’re creating a dog, cat, giraffe, or monkey, all of them will have a name, energy level, and the ability to eat, sleep, and play. With that said, is there a way we can utilize the Animal class whenever we create the individual classes for each different animal? Let’s try it out. I’ll paste the Animal class again below for easy reference. 123456789101112131415161718192021222324function Animal (name, energy) &#123; this.name = name this.energy = energy&#125;Animal.prototype.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Animal.prototype.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Animal.prototype.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125;function Dog (name, energy, breed) &#123;&#125; What are some things we know about the Dog constructor function above? First, we know it takes 3 arguments, name, energy, and breed. Second, we know it’s going to be called with the new keyword so we’ll have a this object. And third, we know we need to utilize the Animal function so that any instance of dog will have a name, energy level, and be able to eat, sleep, and play. It’s the third one that’s the tricky one. The way you “utilize” a function is by calling it. So we know that inside of Dog, we want to call Animal. What we need to figure out though is how we can invoke Animal in the context of Dog. What that means it that we want to call Animal with the this keyword from Dog. If we do that correctly, then this inside of the Dog function will have all the properties of Animal (name, energy). If you remember from a previous section, every function in JavaScript has a .call method on it. .call() is a method on every function that allows you to invoke the function specifying in what context the function will be invoked. This sounds like exactly what we need. We want to invoke Animal in the context of Dog. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;) charlie.name // Charlie charlie.energy // 10 charlie.breed // Goldendoodle Solid, we’re half-way there. You’ll notice in the code above that because of this line Animal.call(this, name, energy), every instance of Dog will now have a name and energy property. Again, the reason for that is because it’s as if we ran the Animal function with the this keyword generated from Dog. Then after we added a name and energy property to this, we also added a breed property just as we normally would. Remember the goal here is to have each instance of Dog have not only all the properties of Animal, but also all the methods as well. If you run the code above, you’ll notice that if you try to run charlie.eat(10) you’ll get an error. Currently every instance of Dog will have the properties of Animal (name and energy), but we haven’t done anything to make sure that they also have the methods (play, eat, sleep). Let’s think about how we can solve this. We know that all the Animal’s methods are located on Animal.prototype. What that means is we somehow want to make sure that all instances of Dog will have access to the methods on Animal.prototype. What if we used our good friend Object.create here? If you’ll remember, Object.create allows you to create an object which will delegate to another object on failed lookups. So in our case, the object we want to create is going to be Dog’s prototype and the object we want to delegate to on failed lookups is Animal.prototype. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Now, whenever there’s a failed lookup on an instance of Dog, JavaScript will delegate that lookup to Animal.prototype. If this is still a little fuzzy, re-read A Beginner’s Guide to JavaScript’s Prototype where we talk all about Object.create and JavaScript’s prototype. Let’s look at the full code together then we’ll walk through what happens. function Animal (name, energy) { this.name = name this.energy = energy } Animal.prototype.eat = function (amount) { console.log(`${this.name} is eating.`) this.energy += amount } Animal.prototype.sleep = function (length) { console.log(`${this.name} is sleeping.`) this.energy += length } Animal.prototype.play = function (length) { console.log(`${this.name} is playing.`) this.energy -= length } function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Now we’ve created our base class (Animal) as well as our subclass (Dog), let’s see what it looks like under the hood when we create an instance of Dog. const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;) charlie.name // Charlie charlie.energy // 10 charlie.breed // Goldendoodle Nothing fancy so far, but let’s look at what happens when we invoke a method located on Animal. 1234567891011 charlie.eat(10)/*1) JavaScript checks if charlie has an eat property - it doesn&apos;t.2) JavaScript then checks if Dog.prototype has an eat property - it doesn&apos;t.3) JavaScript then checks if Animal.prototype has an eat property - it does so it calls it.*/ The reason Dog.prototype gets checked is because when we created a new instance of Dog, we used the new keyword. Under the hood, the this object that was created for us delegates to Dog.prototype (seen in comments below). function Dog (name, energy, breed) { // this = Object.create(Dog.prototype) Animal.call(this, name, energy) this.breed = breed // return this } The reason Animal.prototype gets checked is because we overwrote Dog.prototype to delegate to Animal.prototype on failed lookups with this line Dog.prototype = Object.create(Animal.prototype) Now one thing we haven’t talked about is what if Dog has its own methods? Well, that’s a simple solution. Just like with Animal, if we want to share a method across all instances of that class, we add it to the function’s prototype. 123456789101112131415...function Dog (name, energy, breed) &#123; Animal.call(this, name, energy) this.breed = breed&#125;Dog.prototype = Object.create(Animal.prototype)Dog.prototype.bark = function () &#123; console.log(&apos;Woof Woof!&apos;) this.energy -= .1&#125; very nice. There’s just one small addition we need to make. If you remember back to the Beginner’s Guide to JavaScript’s Prototype post, we were able to get access to the instances’ constructor function by using instance.constructor. function Animal (name, energy) { this.name = name this.energy = energy } const leo = new Animal(&apos;Leo&apos;, 7) console.log(leo.constructor) // Logs the constructor function As explained in the previous post, “the reason this works is because any instances of Animal are going to delegate to Animal.prototype on failed lookups. So when you try to access leo.prototype, leo doesn’t have a prototype property so it will delegate that lookup to Animal.prototype which indeed does have a constructor property.” The reason I bring this up is because in our implementation, we overwrote Dog.prototype with an object that delegates to Animal.prototype. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&apos;Woof Woof!&apos;) this.energy -= .1 } What that means is that now, any instances of Dog which log instance.constructor are going to get the Animal constructor rather than the Dog constructor. You can see for yourself by running this code - function Animal (name, energy) { this.name = name this.energy = energy } Animal.prototype.eat = function (amount) { console.log(`${this.name} is eating.`) this.energy += amount } Animal.prototype.sleep = function (length) { console.log(`${this.name} is sleeping.`) this.energy += length } Animal.prototype.play = function (length) { console.log(`${this.name} is playing.`) this.energy -= length } function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&apos;Woof Woof!&apos;) this.energy -= .1 } const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;) console.log(charlie.constructor) Notice it gives you the Animal constructor even though charlie is a direct instance of Dog. Again, we can walk through what’s happening here just like we did above. 1234567891011const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;)console.log(charlie.constructor)/*1) JavaScript checks if charlie has a constructor property - it doesn&apos;t.2) JavaScript then checks if Dog.prototype has a constructor property - it doesn&apos;t because it was deleted when we overwrote Dog.prototype.3) JavaScript then checks if Animal.prototype has a constructor property - it does so it logs that.*/ How can we fix this? Well, it’s pretty simple. We can just add the correct constructor property to Dog.prototype once we overwrite it. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&apos;Woof Woof!&apos;) this.energy -= .1 } Dog.prototype.constructor = Dog At this point if we wanted to make another subclass, say Cat, we’d follow the same pattern. function Cat (name, energy, declawed) { Animal.call(this, name, energy) this.declawed = declawed } Cat.prototype = Object.create(Animal.prototype) Cat.prototype.constructor = Cat Cat.prototype.meow = function () { console.log(&apos;Meow!&apos;) this.energy -= .1 } This concept of having a base class with subclasses that delegate to it is called inheritance and it’s a staple of Object Oriented Programming (OOP). If you’re coming from a different programming language, odds are you’re already familiar with OOP and inheritance. Before ES6 classes, in JavaScript, inheritance was quite the task as you can see above. You need to understand now only when to use inheritance, but also a nice mix of .call, Object.create, this, and FN.prototype - all pretty advanced JS topics. Let’s see how we’d accomplish the same thing using ES6 classes though. First, let’s review what it looks like to go from an ES5 “class” to an ES6 class using our Animal class. function Animal (name, energy) { this.name = name this.energy = energy } Animal.prototype.eat = function (amount) { console.log(`${this.name} is eating.`) this.energy += amount } Animal.prototype.sleep = function (length) { console.log(`${this.name} is sleeping.`) this.energy += length } Animal.prototype.play = function (length) { console.log(`${this.name} is playing.`) this.energy -= length } const leo = new Animal(&apos;Leo&apos;, 7) 123456789101112131415161718192021class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep() &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play() &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;const leo = new Animal(&apos;Leo&apos;, 7) Now that we’ve refactored our Animal constructor function into an ES6 class, the next thing we need to do is figure out how to refactor our base class (Dog). The good news is it’s much more intuitive. For reference, in ES5, here’s what we had. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&apos;Woof Woof!&apos;) this.energy -= .1 } Dog.prototype.constructor = Dog Before we get into inheritance, let’s refactor Dog to use an ES6 class as we learned in a previous post. 12345678910class Dog &#123; constructor(name, energy, breed) &#123; this.breed = breed &#125; bark() &#123; console.log(&apos;Woof Woof!&apos;) this.energy -= .1 &#125;&#125; Looks great. Now, let’s figure out how to make sure that Dog inherits from Animal. The first step we need to make is a pretty straight forward one. With ES6 classes, you can extend a base class with this syntax class Subclass extends Baseclass {} Translated into our example, that would make our Dog class look like this 1234567891011121314151617181920212223242526272829class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep() &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play() &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;class Dog extends Animal &#123; constructor(name, energy, breed) &#123; this.breed = breed &#125; bark() &#123; console.log(&apos;Woof Woof!&apos;) this.energy -= .1 &#125;&#125; In ES5 in order to make sure that every instance of Dog had a name and an energy property, we used .call in order to invoke the Animal constructor function in the context of the Dog instance. Luckily for us, in ES6 it’s much more straight forward. Whenever you are extending a baseclass and you need to invoke that baseclass’ constructor function, you invoke super passing it any arguments it needs. So in our example, our Dog constructor gets refactored to look like this 12345678910111213141516171819202122232425262728293031class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep() &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play() &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;class Dog extends Animal &#123; constructor(name, energy, breed) &#123; super(name, energy) // calls Animal&apos;s constructor this.breed = breed &#125; bark() &#123; console.log(&apos;Woof Woof!&apos;) this.energy -= .1 &#125;&#125; And that’s it. No using .call, no using Object.create, no worrying about resetting constructor on the prototype - just extends the baseclass and make sure to call super. What’s interesting about JavaScript is the same patterns you’ve learned these last few posts are directly caked into the language itself. Previously you learned that the reason all instances of Array have access to the array methods like pop, slice, filter, etc are because all of those methods live on Array.prototype. 123456789101112131415161718192021222324252627282930313233343536console.log(Array.prototype)/* concat: ƒn concat() constructor: ƒn Array() copyWithin: ƒn copyWithin() entries: ƒn entries() every: ƒn every() fill: ƒn fill() filter: ƒn filter() find: ƒn find() findIndex: ƒn findIndex() forEach: ƒn forEach() includes: ƒn includes() indexOf: ƒn indexOf() join: ƒn join() keys: ƒn keys() lastIndexOf: ƒn lastIndexOf() length: 0n map: ƒn map() pop: ƒn pop() push: ƒn push() reduce: ƒn reduce() reduceRight: ƒn reduceRight() reverse: ƒn reverse() shift: ƒn shift() slice: ƒn slice() some: ƒn some() sort: ƒn sort() splice: ƒn splice() toLocaleString: ƒn toLocaleString() toString: ƒn toString() unshift: ƒn unshift() values: ƒn values()*/ You also learned that the reason all instances of Object have access to methods like hasOwnProperty and toString is because those methods live on Object.prototype. 123456789101112console.log(Object.prototype)/* constructor: ƒn Object() hasOwnProperty: ƒn hasOwnProperty() isPrototypeOf: ƒn isPrototypeOf() propertyIsEnumerable: ƒn propertyIsEnumerable() toLocaleString: ƒn toLocaleString() toString: ƒn toString() valueOf: ƒn valueOf()*/ Here’s a challenge for you. With the list of Array methods and Object methods above, why does this code below work? 1234const friends = [&apos;Mikenzi&apos;, &apos;Jake&apos;, &apos;Ean&apos;]friends.hasOwnProperty(&apos;push&apos;) // false If you look at Array.prototype, there isn’t a hasOwnProperty method. Well if there isn’t a hasOwnProperty method located on Array.prototype, how does the friends array in the example above have access to hasOwnProperty? The reason for that is because the Array class extends the Object class. So in our example above, when JavaScript sees that friends doesn’t have a hasOwnProperty property, it checks if Array.prototype does. When Array.prototype doesn’t, it checks if Object.prototype does, then it invokes it. It’s the same process we’ve seen throughout this blog post. JavaScript has two types - Primitive types and Reference types. Primitive types are boolean, number, string, null, and undefined and are immutable. Everything else is a reference type and they all extend Object.prototype. That’s why you can add properties to functions and arrays and that’s why both functions and arrays have access to the methods located on Object.prototype. 12345678function speak()&#123;&#125;speak.woahFunctionsAreLikeObjects = trueconsole.log(speak.woahFunctionsAreLikeObjects) // trueconst friends = [&apos;Mikenzi&apos;, &apos;Jake&apos;, &apos;Ean&apos;]friends.woahArraysAreLikeObjectsToo = trueconsole.log(friends.woahArraysAreLikeObjectsToo) // true –未完待续]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel入门]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F01%2Fbabel%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1、babel Babel is a toolchain that is mainly used to convert ECMAScript 2015+ code into a backwards compatible version of JavaScript in current and older browsers or environments. 参考 https://babeljs.io/setup#installation 1)生成package.json文件(描述项目所需要的各种模块，以及项目的配置信息—比如名称、版本、许可证等元数据) npm init D:\mytest\babel&gt;npm init 2)安装项目依赖 install Babel CLI locally D:\mytest\babel&gt;npm install --save-dev @babel/core @babel/cli 3）添加编译运行脚本命令 &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;babel src -d src_build&quot; }, 结果 4）运行脚本命令 D:\mytest\babel&gt;npm run build 此时并没有成功的将es6的语法转成es5 5）添加.babelrc文件 Great! You’ve configured Babel but you haven’t made it actually do anything. Create a .babelrc config in your project root and enable some plugins. To start, you can use the env preset, which enables transforms for ES2015+ D:\mytest\babel&gt;npm install @babel/preset-env --save-dev 结果 6）重新运行脚本命令 D:\mytest\babel&gt;npm run build 7)使用编译后的js &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&apos;../src_build/1.js&apos;&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; babel官网参考手册 https://babeljs.io/docs/en/usage]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>babel</tag>
        <tag>npm</tag>
      </tags>
  </entry>
</search>

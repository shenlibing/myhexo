<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[github骚操作]]></title>
    <url>%2Fmyhexo%2F2019%2F08%2F26%2Fgithub%E9%AA%9A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[限制搜索in关键词限制搜索范围 命令 说明 xxx in:name 项目名包含xxx的 xxx in:description 项目描述包含xxx的 xxx in:readme 项目的readme文件中包含xxx的 xxx in:name,desciption 项目名包含xxx且项目描述包含xxx的 范围搜索stars或fork数量关键词查找 命令 说明 springboot stars:&gt;=666 要查找stars数不小于666的springboot项目 springboot forks:&gt;500 forks 大于500 springboot forks:100..200 stars:80..100 查找fork在100到200之间 且stars数在80到100之间的springboot项目 awesome加强搜索 命令 说明 awesome springcloud 查找优秀的springcloud项目 项目内搜索打开你想要搜索的项目，然后按一下T键，会跳转到查找列表页 高亮显示一行或多行代码给别人指出关键代码的行号 地址+#L数字 命令 说明 #L18 高亮显示第18行的代码 #L18-L30 高亮显示第18行到30行的代码 区域活跃用户location:地区 language:语言 命令 说明 location:beijing language:java 搜索地区在北京的Java方向的用户]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud]]></title>
    <url>%2Fmyhexo%2F2019%2F08%2F24%2FSpringCloud%2F</url>
    <content type="text"><![CDATA[微服务架构介绍单体架构单体架构也称之为单体系统或者是单体应用。就是一种把系统中所有的功能、模块耦合在一个应用中的架构方式。 单体架构特点 打包成一个独立的单元( 导成一个唯一的jar 包或者是war 包) 会一个进程的方式来运行 单体架构的优点、缺点优点项目易于管理 部署简单 缺点测试成本高可伸缩性差可靠性差迭代困难跨语言程度差团队协作难 微服务架构什么是微服务微服务是一种架构风格。一个大型的复杂软件应用，由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好的完成该任务。 架构风格项目的一种设计模式。 常见的架构风格客户端与服务端的 基于组件模型的架构（EJB) 分层架构（MVC） 面向服务架构（SOA） 微服务特点系统是由多个服务构成 每个服务可以单独独立部署 每个服务之间是松耦合的。服务内部是高内聚的，外部是低耦合的。高内聚就是每个服务只关注完成一个功能。 微服务的优点、缺点优点测试容易可伸缩性强可靠性强跨语言程度会更加灵活团队协作容易系统迭代容易 缺点 运维成本过高，部署数量较多接口兼容多版本分布式系统的复杂性分布式事务 MVC 、RPC 、SOA 、微服务架构之间的区别MVC 架构其实 MVC 架构就是一个单体架构。代表技术：Struts2、SpringMVC、Spring、Mybatis 等等。 RPC 架构RPC(Remote Procedure Call)：远程过程调用。他一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。代表技术：Thrift、Hessian 等等 SOA 架构SOA(Service oriented Architecture):面向服务架构ESB(Enterparise Servce Bus):企业服务总线，服务中介。主要是提供了一个服务于服务之间的交互。ESB 包含的功能如：负载均衡，流量控制，加密处理，服务的监控，异常处理，监控告急等等。代表技术：Mule、WSO2 微服务架构微服务就是一个轻量级的服务治理方案。代表技术：SpringCloud、dubbo 等等 如何设计微服务以及设计原则AKF 拆分原则业界对于可扩展的系统架构设计有一个朴素的理念,就是：通过加机器就可以解决容量和可用性问题 。( 如果一台不行那就两台) 。我是个段子：（ 世界上没有什么事是一顿烧烤不能解决的。如果有，那就两顿 。）这一理念在“云计算”概念疯狂流行的今天，得到了广泛的认可！ 对于一个规模迅速增长的系统而言，容量和性能问题当然是首当其冲的。但是随着时间的向前，系统规模的增长，除了面对性能与容量的问题外，还需要面对功能与模块数量上的增长带来的系统复杂性问题以及业务的变化带来的提供差异化服务问题。而许多系统，在架构设计时并未充分考虑到这些问题，导致系统的重构成为常态，从而影响业务交付能力，还浪费人力财力！对此，《可扩展的艺术》一书提出了一个更加系统的可扩展模型—— AKF 可扩展立方 （Scalability Cube）。这个立方体中沿着三个坐标轴设置分别为：X、Y、Z。 Y 轴(功能) —— 关注应用中功能划分，基于不同的业务拆分X 轴(水平扩展) —— 关注水平扩展，也就是”加机器解决问题”Z 轴(数据分区) —— 关注服务和数据的优先级划分，如按地域划分 Y 轴( 功能)Y 轴扩展会将庞大的整体应用拆分为多个服务。每个服务实现一组相关的功能，如订单管理、客户管理等。在工程上常见的方案是 服务化架构(SOA) 。比如对于一个电子商务平台，我们可以拆分成不同的服务，组成下面这样的架构： 但通过观察上图容易发现，当服务数量增多时，服务调用关系变得复杂。为系统添加一个新功能，要调用的服务数也变得不可控，由此引发了服务管理上的混乱。所以，一般情况下，需要采用服务注册的机制形成服务网关来进行服务治理。系统的架构将变成下图所示： X轴( 水平扩展)X 轴扩展与我们前面朴素理念是一致的，通过绝对平等地复制服务与数据，以解决容量和可用性的问题。其实就是将微服务运行多个实例，做集群加负载均衡的模式。为了提升单个服务的可用性和容量， 对每一个服务进行X 轴扩展划分 。 Z轴( 数据分区)Z 轴扩展通常是指基于请求者或用户独特的需求，进行系统划分，并使得划分出来的子系统是相互隔离但又是完整的。以生产汽车的工厂来举例：福特公司为了发展在中国的业务，或者利用中国的廉价劳动力，在中国建立一个完整的子工厂，与美国工厂一样，负责完整的汽车生产。这就是一种 Z 轴扩展。 工程领域常见的Z 轴扩展有以下两种方案：单元化架构在分布式服务设计领域，一个单元（Cell）就是满足某个分区所有业务操作的自包含闭环。如上面我们说到的 Y 轴扩展的 SOA 架构，客户端对服务端节点的选择一般是随机的，但是，如果在此加上 Z 轴扩展，那服务节点的选择将不再是随机的了，而是每个单元自成一体。如下图： 数据分区为了性能数据安全上的考虑，我们将一个完整的数据集按一定的维度划分出不同的子集。 一个分区（Shard），就是是整体数据集的一个子集。比如用尾号来划分用户，那同样尾号的那部分用户就可以认为是一个分区。数据分区为一般包括以下几种数据划分的方式： 数据类型（如：业务类型） 数据范围（如：时间段，用户 ID） 数据热度（如：用户活跃度，商品热度） 按读写分（如：商品描述，商品库存） 前后端分离原则 何为前后端分离？前后端本来不就分离么？这要从尴尬的 jsp 讲起。分工精细化从来都是蛋糕做大的原则，多个领域工程师最好在不需要接触其他领域知识的情况下合作，才可能使效率越来越高，维护也会变得简单。jsp 的模板技术融合了 html 和 java 代码，使得传统MVC 开发中的前后端在这里如胶似漆，前端做好页面，后端转成模板，发现问题再找前端，前端又看不懂 java 代码……前后端分离的目的就是将这尴尬局面打破。 前后端分离原则，简单来讲就是前端和后端的代码分离，我们推荐的模式是最好采用物理分离的方式部署，进一步促使更彻底的分离。如果继续直接使用服务端模板技术，如：jsp，把 java、js、html、css 都堆到一个页面里，稍微复杂一点的页面就无法维护了。 这种分离方式有几个好处： 前后端技术分离，可以由各自的专家来对各自的领域进行优化，这样前段的用户体验优化效果更好。 分离模式下，前后端交互界面更清晰，就剩下了接口模型，后端的接口简洁明了，更容易维护。 前端多渠道集成场景更容易实现，后端服务无需变更，采用统一的数据和模型，可以支持多个前端：例如：微信 h5 前端、PC 前端、安卓前端、IOS 前端。 无状态服务 对于无状态服务，首先说一下什么是状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个“状态”数据的服务被称为有状态服务，反之称为无状态服务。那么这个无状态服务原则并不是说在微服务架构里就不允许存在状态，表达的真实意思是要把有状态的业务服务改变为无状态的计算类服务，那么状态数据也就相应的迁移到对应的“有状态数据服务”中。 场景说明：例如我们以前在本地内存中建立的数据缓存、Session 缓存，到现在的微服务架构中就应该把这些数据迁移到分布式缓存中存储，让业务服务变成一个无状态的计算节点。迁移后，就可以做到按需动态伸缩，微服务应用在运行时动态增删节点，就不再需要考虑缓存数据如何同步的问题。 RestFul 的通信风格 作为一个原则来讲本来应该是个“无状态通信原则”，在这里我们直接推荐一个实践优选的 Restful 通信风格 ，因为他有很多好处： 无状态协议 HTTP，具备先天优势，扩展能力很强。例如需要安全加密，有现成的成熟方案 HTTPS 即可。 JSON 报文序列化，轻量简单，人与机器均可读，学习成本低，搜索引擎友好。 语言无关，各大热门语言都提供成熟的 Restful API 框架，相对其他的一些RPC 框架生态更完善。 Spring Cloud入门Spring Cloud简介什么是Spring Cloud什么是 SpringCloud：是一个服务治理平台，提供了一些服务框架。包含了：服务注册与发现、配置中心、消息中心 、负载均衡、数据监控等等。 概念定义Spring Cloud 是一个微服务框架，相比 Dubbo 等 RPC 框架, Spring Cloud 提供的全套的分布式系统解决方案。Spring Cloud 对微服务基础框架 Netflix 的多个开源组件进行了封装，同时又实现了和云端平台以及和 Spring Boot 开发框架的集成。 Spring Cloud 为微服务架构开发涉及的 配置管理，服务治理，熔断机制，智能路由，性微代理，控制总线，一次性 token ，全局一致性锁，leader 选举，分布式 session ，集群状态管理等操作提供了一种简单的开发方式。 Spring Cloud 为开发者提供了快速构建 分布式系统的工具，开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。 Spring Cloud 的项目的位置Sping Cloud 是 Spring 的一个顶级项目与 Spring Boot、Spring Data 位于同一位置。 Spring Cloud 的子项目Spring Cloud 包含了很多子项目，如： Spring Cloud Config配置管理工具，支持使用 Git 存储配置内容，支持应用配置的外部化存储，支持客户端配置信息刷新、加解密配置内容等 Spring Cloud Bus事件、消息总线，用于在集群（例如，配置变化事件）中 ：事件、消息总线，用于在集群（例如，配置变化事件）中与 传播状态变化，可与 Spring Cloud Config 联合实现热部署。 Spring Cloud Netflix针对多种 种 Netflix 组件提供的开发工具包，其中包括Eureka 、Hystrix 、Zuul 、Archaius 等。 Netflix Eureka一个基于 rest 服务的服务治理组件，包括服务注册中心、服务注册与服务发现机制的实现，实现了云端负载均衡和中间层服务器的故障转移。 Netflix Hystrix容错管理工具，实现断路器模式，通过控制服务的节点,从而对延迟和故障提供更强大的容错能力。 Netflix Ribbon客户端负载均衡的服务调用组件。 Netflix Feign基于 Ribbon 和 和 Hystrix 的声明式服务调用组件。 Netflix Zuul微服务网关，提供动态路由，访问过滤等服务。 Netflix Archaius配置管理 API ，包含一系列配置管理 API ，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。 Spring Cloud for Cloud Foundry通过 Oauth2 协议绑定服务到CloudFoundry ，CloudFoundry 是 是 VMware 推出的开源 PaaS 云平台。 Spring Cloud Sleuth日志收集工具包，封装了 Dapper,Zipkin 和 和 HTrace操作。 Spring Cloud Data Flow大数据操作工具，通过命令行方式操作数据流。 Spring Cloud Security安全工具包，为你的应用程序添加安全控制，主要指 是指 OAuth2 。 Spring Cloud Consul封装了 Consul 操作，consul 是一个服务发现与配与 置工具，与 Docker 容器可以无缝集成。 Spring Cloud Zookeeper操作 Zookeeper 的工具包，用于使用zookeeper 方式的服务注册和发现。 Spring Cloud Stream数据流操作开发包，封装了与 Redis,Rabbit 、Kafka 等发送接收消息。 Spring Cloud CLI基于 Spring Boot CLI ，可以让你以命令行方式快速建立云组件。 Spring Cloud与Dubbo区别 对比项 dubbo springcloud 出身背景 阿里系核心框架是服务化治理 Spring社区核心框架是Netflix开源微服务架构群体 社区活跃度 相差不多，但是springcloud相对更活跃一些 活跃度 百度指数 2570 999 招聘岗位 636 160 文档质量 集中，健全 较多，内容大部分是英文版本 性能 孰优孰劣？Dubbo VS Spring Cloud性能测试大对决！ 1:3，dubbo的性能优于springcloud 服务注册中心 zookeeper Spring Cloud Netflix Eureka 服务调用方式 PRC REST API 服务网关 无 Spring Cloud Netflix Zuul 断路由 集群容错 Spring Cloud Netflix Hystrix 功能 分布式配置 无 Spring Cloud Config 服务跟踪 无 Spring Cloud Sleuth 消息总线 无 Spring Cloud Bus 数据流 无 Spring Cloud Stream 批量任务 无 Spring Cloud Task Spring Cloud版本常见版本号介绍软件版本号：2.0.2.RELEASE2：主版本号。当功能模块有较大更新或者整体架构发生变化时，主版本号会更新0：次版本号。次版本表示只是局部的一些变动。2：修改版本号。一般是 bug 的修复或者是小的变动RELEASE:希腊字母版本号。次版本号用户标注当前版本的软件处于哪个开发阶段 希腊字母版本号Base：设计阶段。只有相应的设计没有具体的功能实现。Alpha：软件的初级版本。存在较多的 bugBate：表示相对 alpha 有了很大的进步，消除了严重的 bug，还存在一些潜在的 bug。Release：该版本表示最终版。 Spring Cloud 版本号说明为什么 Spring Cloud 版本用的是单词而不是数字？设计的目的是为了更好的管理每个 Spring Cloud 的子项目的清单。避免子的版本号与子项目的版本号混淆。 版本号单词的定义规则采用伦敦的地铁站名称来作为版本号的命名，根据首字母排序，字母顺序靠后的版本号越大。 版本发布计划说明 版本号 版本 用途 BUILD-XXX 开发版 一般是开发团队内部使用 GA 稳定版 内部开发到一定阶段了，各个模块集成后，经过全面测试发现没有问题，可对外发行了。这个时候叫GA(General Availability)。基本上可以使用了。 PRE（M1 M2） 里程碑版 由于GA还不属于公开发行版，里面还有些功能不完善或者bug，于是就有了milestone（里程碑版）。milestone版主要修复了一些bug调整。一个GA后，一般会有多个里程本版。例如 M1 M2 M3…… RC 候选发布版 从BUILD后到GA在到M基本上系统就算定型了，这个时候系统就进入ReleaseCandidate（候选发布版）。该阶段的软件类似于最终发行前的一个观察期，该期间只对一些发现的等级高的bug进行修复。发布RC1 RC2等版本 SR 正式发布版 公开正式发布。正式发布版一般也有多个发布，例如 SR1 SR2 SR3等等，一般是用 Spring Cloud与子项目版本兼容说明 Spring Boot实战RabbitMQ实战Eureka注册中心]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode主题安装]]></title>
    <url>%2Fmyhexo%2F2019%2F08%2F23%2Fvscode%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装主题快捷键Ctrl+Shift+X打开安装插件 搜索Monokai ST3 切换主题 显示效果 安装文件图标扩展插件vscode-icon 鼠标滚轮设置字体大小 打开setting.json文件 修改setting.json,追加&quot;editor.mouseWheelZoom&quot;: true 12345678910&#123; "editor.fontSize": 16, "workbench.statusBar.visible": false, "workbench.colorTheme": "Monokai ST3", "workbench.iconTheme": "vscode-icons", "editor.suggestSelection": "first", "vsintellicode.modify.editor.suggestSelection": "automaticallyOverrodeDefaultValue", "editor.mouseWheelZoom": true, "editor.lineHeight": 24&#125; HTML代码浏览器插件View In Browser 快捷键 快捷键 说明 Shift+Alt+F 代码格式化]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axis2入门]]></title>
    <url>%2Fmyhexo%2F2019%2F08%2F22%2Faxis2%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Axis2安装指南下载Apache Axis2 – Releases 这里主要下载两个 标准二进制发行版，自身作为服务器独立运行，里面包含了大量应用实例 war包应用发行版，可以放到Tomcat运行 解压 axis2-1.7.9-bin.zip解压出来目录结构如下，samples文件夹包含了丰富的入门示例 axis2-1.7.9-war.zip解压出来的是一个web应用，可以放在Tomcat中的webapp下 启动Tomcat将war包部署到Tomcat启动 乱码 修改 修改F:\soft\apache-tomcat-9.0.24\conf\logging.properties文件，开启注释java.util.logging.ConsoleHandler.encoding = UTF-8 访问axis2 Axis2用户指南是什么是基于java实现的客户端与服务端交互的一种web服务，允许你完成以下任务 Send SOAP messages 发送SOAP消息 Receive and process SOAP messages 接收并处理SOAP消息 Create a Web service out of a plain Java class 从普通的java类创建web服务 Create implementation classes for both the server and client using WSDL 使用wsdl创建服务端和客户端的实现类 Easily retrieve the WSDL for a service 容易检索服务的wsdl Send and receive SOAP messages with attachments 发送和接收带附件的SOAP消息 Create or utilize a REST-based Web service 创建或使用基于rest风格的web服务 Create or utilize services that take advantage of WS-Security and WS-Addressing 引擎盖为了理解axis2知道它是如何工作的，你必须对web服务消息的生命周期熟悉。 创建原始的SOAP消息 XML message，包含头和体 transport，协议（HTTP、JMS） Axis2如何处理SOAP消息 Axis2高级用户指南创建web服务有2种方式 code generation使用wsdl生成代码类，然后通过代码创建web服务类（推荐） XML based primary APIs 部署使用wsdl创建和部署web服务,wsdl描述了web服务的精确定义，包括方法名、参数、返回值 2个关键命令java2wsdl把java代码生成wsdl文件 wsdl2java把wsdl文件生成java代码 java2wsdl编译java代码成class字节码 123F:\soft\axis2-1.7.9\samples\quickstart\src\samples\quickstart\service\pojo&gt;javac StockQuoteService.java注: StockQuoteService.java使用了未经检查或不安全的操作。注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。 生成wsdl文件 -cp:生成wsdl的路径 -cn:java类的全类名 -of:生成wsdl的文件名 123456F:\soft\axis2-1.7.9\samples\quickstart\src&gt;java2wsdl.bat -cp . -cn samples.quickstart.service.pojo.StockQuoteService -of StockQuoteService.wsdlUsing AXIS2_HOME: F:\soft\axis2-1.7.9Using JAVA_HOME: C:\dev\Java\jdk1.8.0_211log4j:WARN No appenders could be found for logger (org.apache.axis2.util.Loader).log4j:WARN Please initialize the log4j system properly.F:\soft\axis2-1.7.9\samples\quickstart\src&gt; wsdl2javaAxis2 Web管理员指南登录访问 输入用户名和密码 功能列表：上传服务、查看服务等]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>axis2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ]]></title>
    <url>%2Fmyhexo%2F2019%2F08%2F12%2FActiveMQ%2F</url>
    <content type="text"><![CDATA[入门概述前言在何种场景下使用了消息中间件 为什么要在系统里引入消息中间件 分类MQ消息中间件，天上飞的理念，必然有落地的实现产品 kafka:采用java、Scala rabbitmq：采用erlang rocketmq:采用java activemq:采用java 技术维度 api发送和接收 MQ的高可用性 MQ的集群和容错配置 MQ的持久化 延时发送/定时投递 签收机制 spring整合 产生背景学生请教老师问题无MQ来一个学生，老师解答一个学生的问题，如果有多个学生，需要排队，会产生阻塞 有MQ学生按照老师的要求制定一个模板（格式/约定）,模板内容：问题、提问人、手机、问题正文，每个学生都按照该模板提前将内容准备好，按照先后顺序，将模板内容交个班长，而不再是直接找老师，可以避免了长时间排队等候。 微服务架构微服务架构后，链式调用是我们在写程序时候一般流程，为了完成一个整体功能会将其拆分成多个函数或者是子模块，比如模块A调用模块B，模板B调用模块C，模板C调用模块D。但是在大小分布式应用中，系统间的RPC交互繁杂，一个功能背后要调用上百个接口并非不可能，从单机架构过渡到分布式微服务架构的通例。 系统之间直接调用的这种架构在实际工程落地存在着几个问题 系统之家接口耦合比较严重 面对大流量高并发时，容易被冲垮 等待同步存在性能问题 系统耦合严重每新增一个下游功能，都要对上有的相关接口进行改造 举个例子：加入系统A要发送数据给系统B和C，发送给每个系统的数据可能有差异，因此系统A对要发送给每个系统的数据进行了组装，然后逐一发送； 当代码上线后又新增了一个需求： 把数据也发送给D，新上了一个系统D也要接受A系统的数据。此时就需要修改系统A，让他感知到D系统的存在，同时把数据处理好再由系统A发送数据给系统D。在这个过程中你会看到，每接入一个下游系统，都要对系统A进行代码改造，开发联调的效率很低。 高并发每个接口模块的吞吐能力是有限的，这个上限能力就好像现实生活中的堤坝，当大流量（洪水）来临时，容易被冲垮 举个例子秒杀业务： 上游系统发起下单购买操作，就是一个下单操作 下游系统完成秒杀业务逻辑却包含了以下内容 读取订单 库存检查 库存冻结 余额检查 余额冻结 订单生成 余额扣减 库存扣减 生成流水 余额解冻 库存解冻 等待同步存在性能问题RPC接口基本上是同步调用，整体的服务性能遵循“木桶理论”，即整体系统的耗时取决于链路中最慢的那个接口。 比如A调用B/C/D都是50ms，但此时B又调用了B1，花费2000ms，那么直接就拖累了整个服务性能。 解决根据上述的几个问题，在系统设计时可以明确要达到的目标： 要做到系统解耦，当新的模块接进来时，可以做到代码改动最小；能够解耦 设置流量缓存池，可以让后端系统按照自身吞吐能力进行消费，不被冲垮；能够削峰 强弱依赖梳理能将非关键调用链路的操作异步化并提升整体系统的吞吐能力；能够异步 因此引入了ActiveMq，达到解耦、削峰和异步 消息中间件定义面向消息的中间件Message-oriented middleware (MOM)能够很好的解决以上问题 是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成 通过提供消息传递和消息排队模型在分布式环境下提供应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步等功能 大致的过程是这样： 发送者把消息发送给消息服务器，消息服务器将消息存放在于若干队列/主题中，在合适的时候，消息服务器会将消息转发给接受者，在这个过程中，发送和接受是异步的，也就是发送无需等待，而且发送者和接受者的生命周期也没有必然关系； 尤其在发布/订阅模式下，也可以完成一对多的通信，即让一个消息有多个接受者。 特点采用异步处理模式消息发送者可以发送一个消息而无须等待响应。消息发送者将消息发送到一条虚拟的通道（主题或队列）上； 消息接收者则订阅或监听该通道。一条信息可能最终被转发给一个或多个消息接收者，这些接收者都无须对消息发送至做成同步回应。整个过程都是异步的。 案例： 也就是说，一个系统跟另外一个系统之间进行通信的时候，假如系统A希望发送一个消息给系统B，让他去处理。 但是系统A不关注系统B到底怎么处理或者有没有处理好，所以系统A把消息发送给MQ，然后就不管这条消息的“死活”了，接着系统B从MQ里消费出来即可。至于怎么处理，是否处理完毕，什么时候处理，都是系统B的事，与系统A无关。 这样的一直通向方式，就是所谓的“异步”通向方式对于系统A来说，只要把消息发送给MQ，然后系统B就会异步的去进行处理了，系统A不需要“同步”的等待系统B处理完。这样的好处即所谓的解耦 应用系统之间解耦合发送者和接收者不必了解对方，只需要确认消息 发送者和接收者不必同时在线 ActiveMQ安装和控制台官网下载ActiveMQ Linux安装解压安装123456789101112131415161718[root@192 modules]# lltotal 587972-rw-r--r--. 1 root root 58588039 Aug 3 23:43 apache-activemq-5.15.9-bin.tar.gzdrwxr-xr-x. 9 es es 4096 Jul 9 17:16 elasticsearch-6.3.1-rw-r--r--. 1 root root 91429350 Jul 8 08:42 elasticsearch-6.3.1.tar.gz-rwxrwxrwx. 1 root root 178418154 Jul 7 21:08 jdk-8u202-linux-x64.rpmdrwxrwxr-x. 11 es es 4096 Jun 30 2018 kibana-6.3.1-linux-x86_64-rw-r--r--. 1 root root 205397076 Jul 8 08:42 kibana-6.3.1-linux-x86_64.tar.gz-rw-r--r--. 1 root root 17855952 Jun 8 20:04 MySQL-client-5.5.48-1.linux2.6.x86_64.rpm-rw-r--r--. 1 root root 50372369 Jun 8 20:24 MySQL-server-5.5.48-1.linux2.6.x86_64.rpm[root@192 modules]# pwd/opt/modules[root@192 modules]# tar -zxvf apache-activemq-5.15.9-bin.tar.gz [root@192 modules]# mkdir /myactiveMQ[root@192 modules]# cp -r apache-activemq-5.15.9 /myactiveMQ/[root@192 modules]# ls /myactiveMQ/apache-activemq-5.15.9 普通启动123456789101112131415161718192021222324252627[root@192 bin]# pwd/myactiveMQ/apache-activemq-5.15.9/bin[root@192 bin]# lltotal 152-rwxr-xr-x. 1 root root 21534 Aug 15 14:43 activemq-rwxr-xr-x. 1 root root 6189 Aug 15 14:43 activemq-diag-rw-r--r--. 1 root root 16068 Aug 15 14:43 activemq.jar-rw-r--r--. 1 root root 4946 Aug 15 14:43 envdrwxr-xr-x. 2 root root 4096 Aug 15 14:43 linux-x86-32drwxr-xr-x. 2 root root 4096 Aug 15 14:43 linux-x86-64drwxr-xr-x. 2 root root 4096 Aug 15 14:43 macosx-rw-r--r--. 1 root root 83820 Aug 15 14:43 wrapper.jar[root@192 bin]# ./activemq startINFO: Loading &apos;/myactiveMQ/apache-activemq-5.15.9//bin/env&apos;INFO: Using java &apos;/usr/java/jdk1.8.0_202-amd64/bin/java&apos;INFO: Starting - inspect logfiles specified in logging.properties and log4j.properties to get detailsINFO: pidfile created : &apos;/myactiveMQ/apache-activemq-5.15.9//data/activemq.pid&apos; (pid &apos;4015&apos;)[root@192 bin]# lsof -i:61616COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEjava 4015 root 129u IPv6 26205 0t0 TCP *:61616 (LISTEN)[root@192 bin]# ps -ef|grep activemqroot 4015 1 21 14:46 pts/0 00:00:26 /usr/java/jdk1.8.0_202-amd64/bin/java -Xms64M -Xmx1G -Djava.util.logging.config.file=logging.properties -Djava.security.auth.login.config=/myactiveMQ/apache-activemq-5.15.9//conf/login.config -Dcom.sun.management.jmxremote -Djava.awt.headless=true -Djava.io.tmpdir=/myactiveMQ/apache-activemq-5.15.9//tmp -Dactivemq.classpath=/myactiveMQ/apache-activemq-5.15.9//conf:/myactiveMQ/apache-activemq-5.15.9//../lib/: -Dactivemq.home=/myactiveMQ/apache-activemq-5.15.9/ -Dactivemq.base=/myactiveMQ/apache-activemq-5.15.9/ -Dactivemq.conf=/myactiveMQ/apache-activemq-5.15.9//conf -Dactivemq.data=/myactiveMQ/apache-activemq-5.15.9//data -jar /myactiveMQ/apache-activemq-5.15.9//bin/activemq.jar startroot 4070 3911 0 14:48 pts/0 00:00:00 grep activemq[root@192 bin]# ps -ef|grep activemq|grep -v greproot 4015 1 19 14:46 pts/0 00:00:26 /usr/java/jdk1.8.0_202-amd64/bin/java -Xms64M -Xmx1G -Djava.util.logging.config.file=logging.properties -Djava.security.auth.login.config=/myactiveMQ/apache-activemq-5.15.9//conf/login.config -Dcom.sun.management.jmxremote -Djava.awt.headless=true -Djava.io.tmpdir=/myactiveMQ/apache-activemq-5.15.9//tmp -Dactivemq.classpath=/myactiveMQ/apache-activemq-5.15.9//conf:/myactiveMQ/apache-activemq-5.15.9//../lib/: -Dactivemq.home=/myactiveMQ/apache-activemq-5.15.9/ -Dactivemq.base=/myactiveMQ/apache-activemq-5.15.9/ -Dactivemq.conf=/myactiveMQ/apache-activemq-5.15.9//conf -Dactivemq.data=/myactiveMQ/apache-activemq-5.15.9//data -jar /myactiveMQ/apache-activemq-5.15.9//bin/activemq.jar start[root@192 bin]# netstat -anp|grep 61616tcp 0 0 :::61616 :::* LISTEN 4015/java 普通关闭1234567891011121314151617[root@192 bin]# ./activemq stopINFO: Loading &apos;/myactiveMQ/apache-activemq-5.15.9//bin/env&apos;INFO: Using java &apos;/usr/java/jdk1.8.0_202-amd64/bin/java&apos;INFO: Waiting at least 30 seconds for regular process termination of pid &apos;4015&apos; : Java Runtime: Oracle Corporation 1.8.0_202 /usr/java/jdk1.8.0_202-amd64/jre Heap sizes: current=62976k free=62320k max=932352k JVM args: -Xms64M -Xmx1G -Djava.util.logging.config.file=logging.properties -Djava.security.auth.login.config=/myactiveMQ/apache-activemq-5.15.9//conf/login.config -Dactivemq.classpath=/myactiveMQ/apache-activemq-5.15.9//conf:/myactiveMQ/apache-activemq-5.15.9//../lib/: -Dactivemq.home=/myactiveMQ/apache-activemq-5.15.9/ -Dactivemq.base=/myactiveMQ/apache-activemq-5.15.9/ -Dactivemq.conf=/myactiveMQ/apache-activemq-5.15.9//conf -Dactivemq.data=/myactiveMQ/apache-activemq-5.15.9//dataExtensions classpath: [/myactiveMQ/apache-activemq-5.15.9/lib,/myactiveMQ/apache-activemq-5.15.9/lib/camel,/myactiveMQ/apache-activemq-5.15.9/lib/optional,/myactiveMQ/apache-activemq-5.15.9/lib/web,/myactiveMQ/apache-activemq-5.15.9/lib/extra]ACTIVEMQ_HOME: /myactiveMQ/apache-activemq-5.15.9ACTIVEMQ_BASE: /myactiveMQ/apache-activemq-5.15.9ACTIVEMQ_CONF: /myactiveMQ/apache-activemq-5.15.9/confACTIVEMQ_DATA: /myactiveMQ/apache-activemq-5.15.9/dataConnecting to pid: 4015.Stopping broker: localhost. TERMINATED[root@192 bin]# ps -ef|grep activemq|grep -v grep 带运行日志的启动方式12345678[root@192 bin]# pwd/myactiveMQ/apache-activemq-5.15.9/bin[root@192 bin]# ./activemq start &gt; /myactiveMQ/run_activemq.log[root@192 bin]# cat /myactiveMQ/run_activemq.log INFO: Loading &apos;/myactiveMQ/apache-activemq-5.15.9//bin/env&apos;INFO: Using java &apos;/usr/java/jdk1.8.0_202-amd64/bin/java&apos;INFO: Starting - inspect logfiles specified in logging.properties and log4j.properties to get detailsINFO: pidfile created : &apos;/myactiveMQ/apache-activemq-5.15.9//data/activemq.pid&apos; (pid &apos;4206&apos;) 使用 主要功能：实现高可用、高性能、可伸缩、易用和安全的企业级面向消息服务的系统 异步消息的消费和处理 控制消息的消费顺序 可以和spring/springboot整合简化编码 配置集群容错的MQ集群 查看后台进程 12345ps -ef|grep activemq|grep -v grep // grep -v grep 可以不让显示grep 本来的信息netstat -anp|grep 61616 // activemq 的默认后台端口是61616lsof -i:61616 带运行日志启动 1./activemq start &gt; /myactivemq/myrunmq.log Apache ActiveMQ控制台访问默认的用户名和密码是admin/admin 备注采用61616端口提供JMS服务 采用8161端口提供管理控制台服务 Java编码实现ActiveMQ通讯IDEA建maven工程编写pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.zbiti&lt;/groupId&gt; &lt;artifactId&gt;activemqDemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--activemq所需要的jar--&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.activemq/activemq-all --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt; &lt;version&gt;5.15.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.xbean/xbean-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.xbean&lt;/groupId&gt; &lt;artifactId&gt;xbean-spring&lt;/artifactId&gt; &lt;version&gt;3.16&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit/log4j等基础通用配置--&gt; &lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; JMS编码总体架构 比对 传统jdbc 队列和主题两大模式特性队列：点对点 主题：一对多 在点对点的消息传递域中，目的地被称为队列（queue） 消费生产者代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.zbiti.activemq.queue;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class JmsProduce &#123; public static final String ACTIVEMQ_URL = "tcp://192.168.1.101:61616"; public static final String QUEUE_NAME = "queue01"; public static void main(String[] args) throws JMSException &#123; // 1 创建连接工厂，按照给定的url地址，采用默认的用户名密码 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); // 2 通过连接工厂，获得连接connection并启动访问 Connection connection = activeMQConnectionFactory.createConnection(); connection.start(); // 3 创建会话session // 两个参数，第一个事务，第二个签收 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 4 创建目的地（队列或者是主题） Queue queue = session.createQueue(QUEUE_NAME); // 5 创建消息的生产者 MessageProducer messageProducer = session.createProducer(queue); // 6 通过messageProducer生产3条消息发送到消息队列中 for (int i = 1; i &lt; 4 ; i++) &#123; //7创建字消息 TextMessage textMessage = session.createTextMessage("msg--" + i); //8通过messageProducer发送给mq messageProducer.send(textMessage); &#125; //9关闭资源 messageProducer.close(); session.close(); connection.close(); System.out.println(" **** 消息发送到MQ完成 ****"); &#125;&#125; 控制台查看 控制台说明 字段 说明 备注 Number Of Pending Messages 等待消费的消息 这个是当前未出队的数量。公式=总接收数-总出队数 Number Of Consumers 消费者数量 消费者端的消费数量 Messages Enqueued 进队消息数 进入队列的总数量，包括出队列的。这个数量只增不减 Messages Dequeued 出队消息数 可以理解为是消费者消费掉的数量 总结 当有一个消息进入这个队列时，等待消费的消息是1，进入队列的消息是1。 当消息消费后，等待消费的消息是0，进入队列的消息是1，出队列的消息是1。 再来一条消息时，等待消费的消息是1，进入队列的消息就是2。 消息消费者代码1同步阻塞方式 订阅者或接受者调用messageConsumer.receive();方法来接收消息，receive方法能够在接收到消息之前（或超时之前）将一直阻塞。 1234567891011121314151617181920212223242526272829303132333435363738package com.zbiti.activemq.queue;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class JmsConsumer &#123; public static final String ACTIVEMQ_URL = "tcp://192.168.1.101:61616"; public static final String QUEUE_NAME = "queue01"; // 1对1 的队列 public static void main(String[] args) throws Exception &#123; // 1 创建连接工厂，按照给定的url地址，采用默认的用户名密码 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); // 2 通过连接工厂，获得连接connection并启动访问 Connection connection = activeMQConnectionFactory.createConnection(); connection.start(); // 3 创建会话session // 两个参数，第一个事务，第二个签收 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 4 创建目的地（队列或者是主题） Queue queue = session.createQueue(QUEUE_NAME); //5 创建消费者 MessageConsumer messageConsumer = session.createConsumer(queue); while(true)&#123; TextMessage textMessage = (TextMessage)messageConsumer.receive(); if(null!=textMessage)&#123; System.out.println("***消费者接收到消息："+textMessage.getText()); &#125;else &#123; break; &#125; &#125; messageConsumer.close(); session.close(); connection.close(); &#125;&#125; 输出 123***消费者接收到消息：msg--1***消费者接收到消息：msg--2***消费者接收到消息：msg--3 代码2通过监听的方式来消费消息 System.in.read(); 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.zbiti.activemq.queue;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class JmsConsumer &#123; public static final String ACTIVEMQ_URL = "tcp://192.168.1.101:61616"; public static final String QUEUE_NAME = "queue01"; // 1对1 的队列 public static void main(String[] args) throws Exception &#123; // 1 创建连接工厂，按照给定的url地址，采用默认的用户名密码 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); // 2 通过连接工厂，获得连接connection并启动访问 Connection connection = activeMQConnectionFactory.createConnection(); connection.start(); // 3 创建会话session // 两个参数，第一个事务，第二个签收 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 4 创建目的地（队列或者是主题） Queue queue = session.createQueue(QUEUE_NAME); //5 创建消费者 MessageConsumer messageConsumer = session.createConsumer(queue); messageConsumer.setMessageListener(new MessageListener() &#123; @Override public void onMessage(Message message) &#123; if (null != message &amp;&amp; message instanceof TextMessage) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println("***消费者接收到消息：" + textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); System.in.read(); messageConsumer.close(); session.close(); connection.close(); &#125;&#125; 输出 123***消费者接收到消息：MessageListener--1***消费者接收到消息：MessageListener--2***消费者接收到消息：MessageListener--3 控制台 测试先生产，只启动1号消费者。问题：1号消费者能消费消息吗？ Y 先生产，先启动1号消费者，再启动2号消费者，问题：2号消费者还能消费消息吗？ N 先启动2个消费者，再生产6条消息，问题：消费情况如何？ 一人一半 编码小总结JMS开发的基本步骤 两种消费方式 同步阻塞方式（receive()） 订阅者或接收者调用MessageConsumer的receive()方法来接收消息，receive方法在能接收到消息之前（或超时之前）将一直阻塞。 异步非阻塞方式（监听器onMessage()） 订阅者或接收者通过MessageConsumer的setMessageListener(MessageListener listener)注册一个消息监听器 当消息到达之后，系统自动调用监听器MessageListener的onMessage(Message message)方法。 在发布订阅消息传递域中，目的地被称为主题（topic） 发布主题生产者1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.zbiti.activemq.queue;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class JmsProduce_Topic &#123; public static final String ACTIVEMQ_URL = "tcp://192.168.1.101:61616"; public static final String TOPIC_NAME = "topic01"; public static void main(String[] args) throws JMSException &#123; // 1 创建连接工厂，按照给定的url地址，采用默认的用户名密码 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); // 2 通过连接工厂，获得连接connection并启动访问 Connection connection = activeMQConnectionFactory.createConnection(); connection.start(); // 3 创建会话session // 两个参数，第一个事务，第二个签收 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 4 创建目的地（队列或者是主题） Topic topic = session.createTopic(TOPIC_NAME); // 5 创建消息的生产者 MessageProducer messageProducer = session.createProducer(topic); // 6 通过messageProducer生产3条消息发送到消息队列中 for (int i = 1; i &lt;=3 ; i++) &#123; //7创建字消息 TextMessage textMessage = session.createTextMessage("TOPIC_NAME--" + i); //8通过messageProducer发送给mq messageProducer.send(textMessage); &#125; //9关闭资源 messageProducer.close(); session.close(); connection.close(); System.out.println("****TOPIC_NAME消息发送到MQ完成 ****"); &#125;&#125; 订阅主题消费者12345678910111213141516171819202122232425262728293031323334353637383940414243package com.zbiti.activemq.queue;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class JmsConsumer_Topic &#123; public static final String ACTIVEMQ_URL = "tcp://192.168.1.101:61616"; public static final String TOPIC_NAME = "topic01"; // 1对1 的队列 public static void main(String[] args) throws Exception &#123; System.out.println("我是3号消费者"); // 1 创建连接工厂，按照给定的url地址，采用默认的用户名密码 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); // 2 通过连接工厂，获得连接connection并启动访问 Connection connection = activeMQConnectionFactory.createConnection(); connection.start(); // 3 创建会话session // 两个参数，第一个事务，第二个签收 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 4 创建目的地（队列或者是主题） Topic topic = session.createTopic(TOPIC_NAME); //5 创建消费者 MessageConsumer messageConsumer = session.createConsumer(topic); messageConsumer.setMessageListener((message)-&gt;&#123; if (null != message &amp;&amp; message instanceof TextMessage) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println("***消费者接收到消息：" + textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); System.in.read(); messageConsumer.close(); session.close(); connection.close(); &#125;&#125; 先启动订阅再启动生产，不然发送的消息是废消息消费者1号 消费者2号 消费者3号 生产者 控制台启动3个消费者，生产者发布3条消息，3个消费者均接收到这3条消息 小总结两大模式比较 比较项目 Topic模式队列 Queue模式队列 工作模式 “订阅-发布”模式，如果当前没有订阅者，消息将会被丢弃。如果有多个订阅者，那么这些订阅者都会收到消息 “负载均衡”模式，如果当前没有消费者，消息也不会被丢弃；如果有多个消费者，那么一条消息也只会发送给妻子一个消费者，并且要求消费者A出口信息。 有无状态 无状态 Queue数据默认会在mq服务器上以文件形式保存，比如Active_MQ一般保存在$AMQ_HOME\data\kr-store\data下面。也可以配置DB存储。 传递完整性 如果没有订阅者，消息会被丢弃 消息不会被丢弃 处理效率 由于消息要按照订阅者的数量进行复制，所以除了性能会随着订阅者的增加而明显降低，并且还要结合不太消息协议自身性能差异 由于一条消息只发送给一个消费者，所以就算消费者再多，性能也不会有明显降低。当然不太消息协议的具体性能也是有差异的。 JMS规范和落地产品是什么JavaEEjavaEE是一套使用java进行企业级应用开发的大家一致遵循的13个核心规范工业标准。JavaEE平台提供了一个基于组件的方法来加快设计、开发、装配及部署企业应用程序 JDBC（Java Database）数据库连接 JNDI（Java Naming and Directory Interface）java的命名和目录接口 EJB（Enterprise JavaBean） RMI（Remote Method Invoke）远程方法调用 JAVA IDL（Interface Description Language）/CORBA（Common Object Broker Architecture）接口的定义语言/公用对象请求代理程序体系结构 JSP（Java Server Pages） Servlet XML（Extensible Markup Language）可扩展的标记语言 JMS（Java Message Service）java消息服务 JTA（Java Transition Service）java事务API JTS（Java Transition Service）java事务服务 JavaMail JAF（JavaBean Activation Framework） JMSJava Message Service（Java消息服务是JavaEE中的一个技术） 什么是消息服务 Java消息服务指的是两个应用程序之间进行异步通信的API，它为标准消息协议和消息服务提供了一组通用接口，包括创建、发送、读取消息等，用于支持java应用程序开发。在JavaEE中，当两个应用程序使用JMS进行通信时，它们之间并不是直接相连的，而是通过一个共同的消息收发服务组件关联起来以达到解耦/异步削峰的效果。 MQ中间件的其他落地产品 消息队列的详细比较 特性 ActiveMQ RabbitMQ Kafka RocketMQ PRODUCER-CONSUMER 支持 支持 支持 支持 PUBLISH-SUBSCRIBE 支持 支持 支持 支持 REQUEST-REPLY 支持 支持 - 支持 API完备性 高 高 高 低（静态配置） 多语言支持 支持，java优先 语言无关 支持，java优先 支持 单机吞吐量 万级 万级 十万级 单机万级 消息延迟 - 微秒级 毫秒级 - 可用性 高（主从） 高（主从） 非常高（分布式） 高 消息丢失 - 低 理论上不会丢失 - 消息重复 - 可控制 理论上不会有重复 - 文档的完备性 高 高 高 中 提供快速入门 有 有 有 无 首次部署难度 - 低 中 高 JMS的组成结果和特点JMS provider实现JMS接口和规范的消息中间件，也就是我们的MQ服务器 JMS producer消息生产者，创建和发送JMS消息的客户端应用 JMS consumer消息消费者，接收和处理JMS消息的客户端应用 JMS message消息头JMSDestination消息发送的目的地，主要是指Queue和Topic 1void send(Destination destination, Message message) throws JMSException; JMSDeliveryMode持久模式和非持久模式 一条持久性的消息：应该被传送“一次仅仅一次”，这就意味着如果JMS提供者出现故障，该消息并不会丢失，它会在服务器恢复之后再次传递。 一条非持久的消息：最低会传送一次，这就意味着服务器出现故障，该消息将永远丢失。 1void setDeliveryMode(int deliveryMode) throws JMSException; JMSExpiration设置过期时间 可以设置消息在一点时间后过去，默认是永不过期 消息过期时间，等于Destination的send方法中的timeToLive值加上发送时刻的GMT时间值。 如果timeToLive值等于零，则JMSExpiration被设为零，表示该消息永不过期。 如果发送后，在消息过期时间之后消息还没有被发送到目的地，则该消息被清除。 12void send(Message message, int deliveryMode, int priority, long timeToLive) throws JMSException; JMSPriority优先级 消息优先级，从0-9十个级别，0-4是普通消息，5-9是加急消息。 JMS不要求MQ严格按照这十个优先级发送消息，但必须保证加急消息要先于普通消息到达。默认是4级。 JMSMessageID唯一识别每个消息的标识由MQ产生 123void setDisableMessageID(boolean value) throws JMSException;boolean getDisableMessageID() throws JMSException; 消息属性如果需要除消息头字段以外的值，那么可以使用消息属性 识别、去重、重点标注等操作非常有用的方法 他们是以属性名和属性值对的形式制定的。可以将属性是为消息头的扩展，属性指定一些消息头没有包括的附加信息，比如可以在属性里指定消息选择器。 消息的属性就行可以分配给一条消息的附加消息头一样。他们允许开发者添加有关消息的不透明附加信息。 它们还用于暴露消息选择器在消息过滤时使用的数据。 123TextMessage textMessage = session.createTextMessage("MessageListener--" + i);textMessage.setStringProperty("username","z3");messageProducer.send(textMessage); 消息体封装具体的消息数据5种消息体格式 TextMessage 普通字符串消息，包含一个string MapMessage 一个Map类型的消息，key为string类型，而值为java的基本类型 123MapMessage mapMessage = session.createMapMessage();mapMessage.setString("k1","v1");messageProducer.send(mapMessage); ByteMessage 二进制数组消息，包含一个byte[] StreamMessage java数据流消息，用标注流操作来顺序的填充和读取 ObjectMessage 对象消息，包含一个可序列化的java对象 发送和接收的消息体类型必须一致对应JMS的可靠性持久性PERSISTENT参数设置说明持久化：当服务器宕机，消息依然存在 1messageProducer.setDeliveryMode(DeliveryMode.PERSISTENT); 非持久化：当服务器宕机，消息不存在 1messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT); 持久的Queue持久化消息 这是队列的默认传递模式，此模式保证这些消息只被传送一次和成功使用一次。对于这些消息，可靠性是优先考虑的因素。 可靠性的另一个重要方面是确保持久性消息传送至目标后，消息服务在向消费者传送它们之前不会丢失这些消息。 持久的Topic代码先启动订阅再启动生产 持久的发布主题生产者 持久的订阅主题消费者 消费者 123456789101112131415161718192021222324252627282930313233343536373839package com.zbiti.activemq.queue;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class JmsConsumer_Topic &#123; public static final String ACTIVEMQ_URL = "tcp://192.168.1.101:61616"; public static final String TOPIC_NAME = "topic01"; // 1对1 的队列 public static void main(String[] args) throws Exception &#123; System.out.println("*****z3"); // 1 创建连接工厂，按照给定的url地址，采用默认的用户名密码 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); // 2 通过连接工厂，获得连接connection Connection connection = activeMQConnectionFactory.createConnection(); connection.setClientID("z3"); // 3 创建会话session // 两个参数，第一个事务，第二个签收 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 4 创建目的地（队列或者是主题） Topic topic = session.createTopic(TOPIC_NAME); TopicSubscriber topicSubscriber = session.createDurableSubscriber(topic, "remark....."); connection.start(); //5 创建消费者 Message message = topicSubscriber.receive(); while (null!=message)&#123; TextMessage textMessage = (TextMessage) message; System.out.println("*********收到持久化topic:"+textMessage.getText()); message = topicSubscriber.receive(1000L); &#125; session.close(); connection.close(); &#125;&#125; 生产者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.zbiti.activemq.queue;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class JmsProduce_Topic &#123; public static final String ACTIVEMQ_URL = "tcp://192.168.1.101:61616"; public static final String TOPIC_NAME = "topic01"; public static void main(String[] args) throws JMSException &#123; // 1 创建连接工厂，按照给定的url地址，采用默认的用户名密码 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); // 2 通过连接工厂，获得连接connection Connection connection = activeMQConnectionFactory.createConnection(); // 3 创建会话session // 两个参数，第一个事务，第二个签收 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 4 创建目的地（队列或者是主题） Topic topic = session.createTopic(TOPIC_NAME); // 5 创建消息的生产者 MessageProducer messageProducer = session.createProducer(topic); messageProducer.setDeliveryMode(DeliveryMode.PERSISTENT); connection.start(); // 6 通过messageProducer生产3条消息发送到消息队列中 for (int i = 1; i &lt;=3 ; i++) &#123; //7创建字消息 TextMessage textMessage = session.createTextMessage("TOPIC_NAME--" + i); //8通过messageProducer发送给mq messageProducer.send(textMessage); &#125; //9关闭资源 messageProducer.close(); session.close(); connection.close(); System.out.println("****TOPIC_NAME消息发送到MQ完成 ****"); &#125;&#125; 控制台启动消费者 启动生产者 结论 一定要先运行一次消费者，等于向MQ注册，类似我订阅了这个主题。 然后再运行生产者发送消息，此时，无论消费者是否在线，都会接收到消息，不在线的话，下次连接的时候，会把没有收过来的消息都接收下来。 类似微信公众号订阅发布事务producer提交时的事务false只要执行send，就进入队列中 关闭事务，那第2个签收参数的设置需要有效 true先执行send再执行commit，消息才被真正的提交到队列中 消息需要批量发送，需要缓冲区处理 推荐使用这个可以保证高可用，类似JDBC，如果中间出现异常可以回滚。 事务偏生产者/签收偏消费者签收Acknowledge非事务自动签收（默认） 手动签收客户端调用acknowledge方法手动签收 允许重复消息 事务生产事务开启，只有commit后才能将全部消息变为已消费消息生产者代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.zbiti.activemq.queue;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class JmsProduce_TX &#123; public static final String ACTIVEMQ_URL = "tcp://192.168.1.101:61616"; public static final String QUEUE_NAME = "queue01"; public static void main(String[] args) throws JMSException &#123; // 1 创建连接工厂，按照给定的url地址，采用默认的用户名密码 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); // 2 通过连接工厂，获得连接connection并启动访问 Connection connection = activeMQConnectionFactory.createConnection(); connection.start(); // 3 创建会话session // 两个参数，第一个事务，第二个签收 Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE); // 4 创建目的地（队列或者是主题） Queue queue = session.createQueue(QUEUE_NAME); // 5 创建消息的生产者 MessageProducer messageProducer = session.createProducer(queue); // 6 通过messageProducer生产3条消息发送到消息队列中 for (int i = 1; i &lt; 7; i++) &#123; //7创建字消息 TextMessage textMessage = session.createTextMessage("MessageListener--" + i); messageProducer.send(textMessage); &#125; //9关闭资源 messageProducer.close(); session.commit(); session.close(); connection.close(); System.out.println(" **** 消息发送到MQ完成 ****"); &#125;&#125; 控制台 消息消费者消费者设置了事务并且commit,尽管是手动签收不调用textMessage.acknowledge();，消息也会被消费一次，自动和手动签收没啥区别 代码 12345678910111213141516171819202122232425262728293031323334353637383940package com.zbiti.activemq.queue;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class JmsConsumer_TX &#123; public static final String ACTIVEMQ_URL = "tcp://192.168.1.101:61616"; public static final String QUEUE_NAME = "queue01"; // 1对1 的队列 public static void main(String[] args) throws Exception &#123; // 1 创建连接工厂，按照给定的url地址，采用默认的用户名密码 ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL); // 2 通过连接工厂，获得连接connection并启动访问 Connection connection = activeMQConnectionFactory.createConnection(); connection.start(); // 3 创建会话session // 两个参数，第一个事务，第二个签收 Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE); // 4 创建目的地（队列或者是主题） Queue queue = session.createQueue(QUEUE_NAME); //5 创建消费者 MessageConsumer messageConsumer = session.createConsumer(queue); while(true)&#123; TextMessage textMessage = (TextMessage)messageConsumer.receive(4000L); if(null!=textMessage)&#123; System.out.println("***消费者接收到消息："+textMessage.getText());// textMessage.acknowledge(); &#125;else &#123; break; &#125; &#125; messageConsumer.close(); session.commit(); session.close(); connection.close(); &#125;&#125; 控制台 签收和事务关系在事务性会话中，当一个事务被成功提交则消息被自动签收 如果事务回滚，则消息会被再次传送 非事务性会话中，消息何时被签收取决于创建会话时的应答模式（acknowledgement mode） JMS的点对点总结点对点模型基于队列的，生产者发消息到队列，消费者从队列接收消息，队列的存在使得消息的异步传输成为可能。 和我们平时给朋友发送短信类似。 如果在Session关闭时有部分消息已被收到但还没有被签收（acknowledged），那当消费者下次连接到相同的队列时，这些消息还会被再次接收。 队列可以长久地保存消息直到消费者收到消息。消费者不需要因为担心消息会丢失而时刻和队列保持激活的连接状态，充分体现了异步传输模式的优势 JMS的发布订阅总结JMS Pub/Sub模型定义了如何向一个内容节点发布和订阅消息，这些节点被称作topic 主题可以被认为是消息的传输中介，发布者（publisher）发布消息到主题，订阅者（subscribe）从主题订阅消息。 主题使得消息订阅者和消息发布者保持互相独立，不需要接触即可保证消息的传送。 非持久订阅非持久订阅只有当客户端处于激活状态，也就是和MQ保持连接状态才能收到发送到某个主题的消息。 如果消费者处于离线状态，生产者发送的主题消息将会丢失作废，消费者永远不会收到。 一句话：先要订阅注册才能接收到发布的消息，只给订阅者发布消息 持久订阅当客户端首先向MQ注册一个自己的身份ID识别号，当这个客户端处于离线时，生产者会为这个ID保存所有发送到主题的消息，当客户端再次连接到MQ时会根据消费者的ID得到索引当自己处于离线时发送到主题的消息。 非持久订阅状态下，不能恢复或重新派送一个未签收的消息。 持久订阅才能恢复或重新派送一个未签收的消息。 用哪个当所有消息必须被接收，则用持久订阅。当丢失消息能够被容忍，则用非持久订阅 ActiveMQ的Brokerspring整合ActiveMQActiveMQ的传输协议ActiveMQ的消息存储和持久化高级特性和大厂常考重点]]></content>
  </entry>
  <entry>
    <title><![CDATA[面试题]]></title>
    <url>%2Fmyhexo%2F2019%2F08%2F06%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[阿里巴巴面试1、开发中Java用了比较多的数据结构有哪些? 2、谈谈你对HashMap的理解，底层原理的基本实现，HashMap怎么解决碰撞问题的? 这些数据结构中是线程安全的吗?假如你回答HashMap是线程安全的，接着问你有没有线程安全的map，接下来问了conurren包。 3、对JVM熟不熟悉?简单说说类加载过程，里面执行的哪些操作?问了GC和内存管理，平时在tomect里面有没有进行过相的配置 4、然后问了http协议，get和post的基本区别，接着tcp/ip协议，三次握手，窗口滑动机制。 5、开发中用了那些数据库?回答mysql，储存引擎有哪些?然后问了我悲观锁和乐观锁问题使用场景、分布式集群实现的原理。 6然后问了我springmvc和mybatis的工作原理，有没有看过底层源码? 京东金融面试1、Dubbo超时重试;Dubbo超时时间设置 2、如何保障请求执行顺序 3、分布式事物与分布式锁(扣款不要出现负数) 4、分布式session设置 5、执行某操作，前50次成功，第51次失败a全部回滚b前50次提交第51次抛异常，ab场景分别如何设置Spring(传播性) 6、Zookeeper有哪些用 7、JVM内存模型 8、数据库垂直和水平拆分 9、MyBatis如何分页;如何设置缓存;MySQL分页 10、熟悉IO么?与NIO的区别，阻塞与非阻塞的区别 11、分布式session一致性 12、分布式接口的幂等性设计「不能重复扣款」 美团面试1、最近做的比较熟悉的项目是哪个?画一下项目技术架构图 2、JVM老年代和新生代的比例? 3、YGC和FGC发生的具体场景 4、jstack，jmap，jutil分别的意义?如何线上排查JVM的相关问题? 5、线程池的构造类的方法的5个参数的具体意义? 6、单机上一个线程池正在处理服务如果忽然断电该怎么办?(正在处理和阻塞队列里的请求怎么处理)? 7、使用无界阻塞队列会出现什么问题? 8、接口如何处理重复请求? 9、具体处理方案是什么? 10、如何保证共享变量修改时的原子性? 11、设计一个对外服务的接口实现类，在1,2,3这三个主机(对应不同IP)上实现负载均衡和顺序轮询机制(考虑并发) 滴滴面试1、自我介绍，技术特点 2、兴趣是什么，优势是什么 3、jvm，jre以及jdk三者之间的关系? 4、Dubbo的底层原理，Zookeeper是什么 5、cincurrentMap的机制;TreeMap;Volatil关键字 6、快速排序;广度优先搜索(队列实现) 7、缓存的雪崩以及穿透的理解? 8、HashMap的key可以重复吗? 9、synchronized和lock的区别? 10.开发一个大型网站你会考虑哪些问题? 本次卧底面试得到的结论 通过面试题来看，可以看出目前互联网公司面试考点为： 1.性能调优、算法数据机构 2.高并发下数据安全、接口冪等性、原子性等 3.分布式下协同、已经锁的处理 4.数据库的分库分表、项目之间的垂直拆分 出现频率高的技术点有： HashMap JVM Dubbo Mybatis Zookeeper http tcp/ip online judgeHackerRank LeetCode]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux性能分析]]></title>
    <url>%2Fmyhexo%2F2019%2F08%2F05%2FLinux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[生产环境服务器变慢，诊断思路和性能评估整机：top代码 1234567public class JavaDemo2 &#123; public static void main(String[] args) &#123; while (true)&#123; System.out.println(new java.util.Random().nextInt(77778888)); &#125; &#125;&#125; top命令查看 1234567891011121314151617[root@192 ~]# toptop - 11:28:50 up 7 min, 2 users, load average: 0.73, 0.39, 0.18Tasks: 230 total, 1 running, 229 sleeping, 0 stopped, 0 zombieCpu(s): 1.0%us, 2.3%sy, 0.0%ni, 96.7%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%stMem: 1906280k total, 649948k used, 1256332k free, 21164k buffersSwap: 2097148k total, 0k used, 2097148k free, 203820k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 3672 root 20 0 3158m 94m 11m S 15.6 5.1 0:13.67 java 3397 root 20 0 100m 5388 3396 S 9.3 0.3 0:09.00 sshd 39 root 20 0 0 0 0 S 1.7 0.0 0:00.25 events/4 37 root 20 0 0 0 0 S 1.0 0.0 0:00.39 events/2 35 root 20 0 0 0 0 S 0.3 0.0 0:01.27 events/0 36 root 20 0 0 0 0 S 0.3 0.0 0:00.34 events/1 41 root 20 0 0 0 0 S 0.3 0.0 0:00.24 events/6 [root@192 ~]# uptime11:29:09 up 7 min, 2 users, load average: 0.52, 0.36, 0.18 CPU：vmstat123456[root@192 ~]# vmstat -n 2 3procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 1313028 21228 203868 0 0 54 3 112 1620 0 1 98 0 0 0 0 0 1312732 21228 203896 0 0 0 0 2579 25940 1 3 96 0 0 0 0 0 1312856 21228 203896 0 0 0 0 2677 24290 1 3 97 0 0 id:处于空闲的CPU百分比 wa:系统等待IO的CPU时间百分比 st:来自于一个虚拟机偷取的CPU时间百分比 查看额外的CPU信息 所有CPU核信息 12345678910[root@192 ~]# mpstat -P ALL 2Linux 2.6.32-642.el6.x86_64 (192.168.1.101) 08/05/2019 _x86_64_ (8 CPU)11:42:40 AM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %idle11:42:42 AM all 1.07 0.00 2.89 0.00 0.00 0.00 0.00 0.00 96.0411:42:42 AM 0 0.00 0.00 1.52 0.00 0.00 0.00 0.00 0.00 98.4811:42:42 AM 1 6.09 0.00 9.14 0.00 0.00 0.00 0.00 0.00 84.7711:42:42 AM 2 0.50 0.00 4.02 0.00 0.00 0.00 0.00 0.00 95.4811:42:42 AM 3 1.00 0.00 2.00 0.00 0.00 0.00 0.00 0.00 97.00 每个进程使用CPU的用量分解信息 12345678[root@192 ~]# pidstat -u 1 -p 3790Linux 2.6.32-642.el6.x86_64 (192.168.1.101) 08/05/2019 _x86_64_ (8 CPU)11:45:00 AM PID %usr %system %guest %CPU CPU Command11:45:01 AM 3790 6.00 10.00 0.00 16.00 7 java11:45:02 AM 3790 4.00 11.00 0.00 15.00 7 java11:45:03 AM 3790 9.00 15.00 0.00 24.00 7 java11:45:04 AM 3790 7.00 14.00 0.00 21.00 7 java 内存：free应用程序可用内存数 推荐使用free -m 12345678910[root@192 ~]# free -g total used free shared buffers cachedMem: 1 0 1 0 0 0-/+ buffers/cache: 0 1Swap: 1 0 1[root@192 ~]# free -m total used free shared buffers cachedMem: 1861 553 1308 1 20 199-/+ buffers/cache: 333 1528Swap: 2047 0 2047 查看额外 123456789[root@192 ~]# pidstat -p 3823 -r 2Linux 2.6.32-642.el6.x86_64 (192.168.1.101) 08/05/2019 _x86_64_ (8 CPU)11:51:16 AM PID minflt/s majflt/s VSZ RSS %MEM Command11:51:18 AM 3823 1.00 0.00 3234728 47068 2.47 java11:51:20 AM 3823 2.50 0.00 3234728 47068 2.47 java11:51:22 AM 3823 0.50 0.00 3234728 47068 2.47 java11:51:24 AM 3823 2.50 0.00 3234728 47068 2.47 java11:51:26 AM 3823 0.50 0.00 3234728 47068 2.47 java 硬盘：df查看磁盘剩余空间 12345[root@192 ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/sda2 15G 5.6G 8.4G 41% /tmpfs 931M 72K 931M 1% /dev/shm/dev/sda1 190M 39M 142M 22% /boot 磁盘IO：iostat1234567891011121314[root@192 ~]# iostat -xdk 2 3Linux 2.6.32-642.el6.x86_64 (192.168.1.101) 08/05/2019 _x86_64_ (8 CPU)Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilscd0 0.00 0.00 0.38 0.00 1.50 0.00 8.00 0.00 0.67 0.67 0.00 0.67 0.03sda 34.33 4.94 47.36 3.18 1631.23 32.44 65.84 0.07 1.38 1.22 3.72 0.88 4.43Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilscd0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00sda 0.00 0.00 0.50 0.00 4.00 0.00 16.00 0.00 1.00 1.00 0.00 1.00 0.05Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilscd0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00sda 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 查看额外 1234567891011[root@192 ~]# pidstat -d 2 -p 3485Linux 2.6.32-642.el6.x86_64 (192.168.1.101) 08/05/2019 _x86_64_ (8 CPU)02:16:10 PM PID kB_rd/s kB_wr/s kB_ccwr/s Command02:16:12 PM 3485 0.00 0.00 0.00 java02:16:14 PM 3485 0.00 0.00 0.00 java02:16:16 PM 3485 0.00 0.00 0.00 java02:16:18 PM 3485 0.00 0.00 0.00 java02:16:20 PM 3485 0.00 0.00 0.00 java02:16:22 PM 3485 0.00 0.00 0.00 java02:16:24 PM 3485 0.00 0.00 0.00 java 网络IO：ifstat默认本地没有，需要下载ifstat 安装ifstat 1234567[root@192 ifstat-1.1]# yum install flex byacc libpcap ncurses ncurses-devel libpcap-devel gcc-c++wget http://gael.roualland.free.fr/ifstat/ifstat-1.1.tar.gztar xzvf ifstat-1.1.tar.gzcd ifstat-1.1./configuremakemake install 1234567891011[root@192 ifstat-1.1]# ifstat 1 eth0 KB/s in KB/s out 0.06 0.13 0.06 0.12 0.06 0.12 0.06 0.12 0.06 0.12 0.06 0.12 0.12 0.17 0.06 0.12 生产环境出现CPU占用过高，分析思路和定位1234567public class JavaDemo2 &#123; public static void main(String[] args) &#123; while (true)&#123; System.out.println(new java.util.Random().nextInt(77778888)); &#125; &#125;&#125; 先用top命令找出CPU占比最高的12345678PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 4294 root 20 0 3158m 37m 11m S 16.6 2.0 0:03.28 java 3428 root 20 0 100m 5444 3396 S 14.3 0.3 0:22.85 sshd 35 root 20 0 0 0 0 S 1.0 0.0 0:03.18 events/0 41 root 20 0 0 0 0 S 0.3 0.0 0:00.52 events/6 2012 root 20 0 199m 5192 4288 S 0.3 0.3 0:00.32 ManagementAgent 1 root 20 0 19344 1544 1228 S 0.0 0.1 0:01.83 init 2 root 20 0 0 0 0 S 0.0 0.0 0:00.02 kthreadd ps -ef或者jps进一步定位123[root@192 ifstat-1.1]# jps4320 Jps4294 JavaDemo2 定位到具体线程或者代码1234567891011121314151617181920212223[root@192 ifstat-1.1]# ps -mp 4294 -o THREAD,tid,timeUSER %CPU PRI SCNT WCHAN USER SYSTEM TID TIMEroot 18.6 - - - - - - 00:00:15root 0.0 19 - futex_ - - 4294 00:00:00root 15.6 19 - n_tty_ - - 4295 00:00:13root 0.2 19 - futex_ - - 4296 00:00:00root 0.2 19 - futex_ - - 4297 00:00:00root 0.3 19 - futex_ - - 4298 00:00:00root 0.2 19 - futex_ - - 4299 00:00:00root 0.3 19 - futex_ - - 4300 00:00:00root 0.3 19 - futex_ - - 4301 00:00:00root 0.3 19 - futex_ - - 4302 00:00:00root 0.2 19 - futex_ - - 4303 00:00:00root 0.0 19 - futex_ - - 4304 00:00:00root 0.0 19 - futex_ - - 4305 00:00:00root 0.0 19 - futex_ - - 4306 00:00:00root 0.0 19 - futex_ - - 4307 00:00:00root 0.0 19 - futex_ - - 4308 00:00:00root 0.1 19 - futex_ - - 4309 00:00:00root 0.0 19 - futex_ - - 4310 00:00:00root 0.0 19 - futex_ - - 4311 00:00:00root 0.0 19 - futex_ - - 4312 00:00:00root 0.0 19 - futex_ - - 4313 00:00:00 -m:显示所有的线程 -p: pid进程使用CPU的时间 -o:该参数后是用户自定义格式 线程ID转换为16进制格式（英文小写格式）12[root@192 ifstat-1.1]# printf &quot;%x\n&quot; 429510c7 jstack 进程ID|grep tid(16进制线程ID小写英文) -A60123456789101112131415161718192021222324252627282930313233343536373839404142[root@192 ifstat-1.1]# jstack 4294 | grep 10c7 -A60&quot;main&quot; #1 prio=5 os_prio=0 tid=0x00007f7f68009000 nid=0x10c7 runnable [0x00007f7f6f117000] java.lang.Thread.State: RUNNABLE at java.io.FileOutputStream.writeBytes(Native Method) at java.io.FileOutputStream.write(FileOutputStream.java:326) at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82) at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140) - locked &lt;0x00000000e2e0e6e0&gt; (a java.io.BufferedOutputStream) at java.io.PrintStream.write(PrintStream.java:482) - locked &lt;0x00000000e2e0bbd8&gt; (a java.io.PrintStream) at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221) at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291) at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104) - locked &lt;0x00000000e2e0e800&gt; (a java.io.OutputStreamWriter) at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185) at java.io.PrintStream.newLine(PrintStream.java:546) - eliminated &lt;0x00000000e2e0bbd8&gt; (a java.io.PrintStream) at java.io.PrintStream.println(PrintStream.java:737) - locked &lt;0x00000000e2e0bbd8&gt; (a java.io.PrintStream) at JavaDemo2.main(JavaDemo2.java:4)&quot;VM Thread&quot; os_prio=0 tid=0x00007f7f68080000 nid=0x10d0 runnable &quot;GC task thread#0 (ParallelGC)&quot; os_prio=0 tid=0x00007f7f6801e800 nid=0x10c8 runnable &quot;GC task thread#1 (ParallelGC)&quot; os_prio=0 tid=0x00007f7f68020000 nid=0x10c9 runnable &quot;GC task thread#2 (ParallelGC)&quot; os_prio=0 tid=0x00007f7f68022000 nid=0x10ca runnable &quot;GC task thread#3 (ParallelGC)&quot; os_prio=0 tid=0x00007f7f68024000 nid=0x10cb runnable &quot;GC task thread#4 (ParallelGC)&quot; os_prio=0 tid=0x00007f7f68025800 nid=0x10cc runnable &quot;GC task thread#5 (ParallelGC)&quot; os_prio=0 tid=0x00007f7f68027800 nid=0x10cd runnable &quot;GC task thread#6 (ParallelGC)&quot; os_prio=0 tid=0x00007f7f68029800 nid=0x10ce runnable &quot;GC task thread#7 (ParallelGC)&quot; os_prio=0 tid=0x00007f7f6802b000 nid=0x10cf runnable &quot;VM Periodic Task Thread&quot; os_prio=0 tid=0x00007f7f680e8000 nid=0x10d9 waiting on condition JNI global references: 5 参考 找到最耗CPU的java线程 - - ITeye博客]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2Fmyhexo%2F2019%2F07%2F31%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式非单例123456789101112131415161718192021222324252627public class SingletonDemo &#123; private static SingletonDemo instance = null; private SingletonDemo() &#123; System.out.println(Thread.currentThread().getName() + "\t 我是构造方法SingletonDemo()"); &#125; public static SingletonDemo getInstance() &#123; if (instance == null) &#123; instance = new SingletonDemo(); &#125; return instance; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt;= 10; i++) &#123; new Thread(() -&gt; &#123; SingletonDemo.getInstance(); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 结果 非单例模式，构造方法被调用多次 12342 我是构造方法SingletonDemo()3 我是构造方法SingletonDemo()0 我是构造方法SingletonDemo()1 我是构造方法SingletonDemo() 单例volatile特点：可见性、禁止指令重排、不能保证原子性 synchronized特点：原子性、可见性、不能保证禁止指令重排 原子性：是指一个操作是不可中断的，要全部执行完成，要不就都不执行。线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。 可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。 禁止指令重排：程序执行的顺序按照代码的先后顺序执行。除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save 有可能被优化成load-&gt;save-&gt;add 。这就是可能存在指令重排问题。 被synchronized修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。 被synchronized修饰的代码，在开始执行时会加锁，执行完成后会进行解锁。而为了保证可见性，有一条规则是这样的：对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。 被synchronized修饰的代码是无法禁止指令重排和处理器优化的。如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。由于synchronized修饰的代码，同一时间只能被同一线程访问。那么也就是单线程执行的。所以，可以保证禁止指令重排，但是本身不具备禁止指令重排，有点绕口。 版本一123456789101112131415161718192021222324252627public class SingletonDemo &#123; //加上volatile,禁止指令重排 private static volatile SingletonDemo instance = null; private SingletonDemo() &#123; System.out.println(Thread.currentThread().getName() + "\t 我是构造方法SingletonDemo()"); &#125; public static synchronized SingletonDemo getInstance() &#123; if (instance == null) &#123; instance = new SingletonDemo(); &#125; return instance; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt;= 10; i++) &#123; new Thread(() -&gt; &#123; SingletonDemo.getInstance(); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 结果 单例模式，构造方法只被调用一次 10 我是构造方法SingletonDemo() 版本二123456789101112131415161718192021222324252627282930public class SingletonDemo &#123; //加上volatile,禁止指令重排 private static volatile SingletonDemo instance = null; private SingletonDemo() &#123; System.out.println(Thread.currentThread().getName() + "\t 我是构造方法SingletonDemo()"); &#125; public static SingletonDemo getInstance() &#123; if (instance == null) &#123; //双端检锁机制，加锁前后进行判断 synchronized (SingletonDemo.class) &#123; if (instance == null) &#123; instance = new SingletonDemo(); &#125; &#125; &#125; return instance; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt;= 10; i++) &#123; new Thread(() -&gt; &#123; SingletonDemo.getInstance(); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 结果 单例模式下，构造方法只会被调用一次 11 我是构造方法SingletonDemo() 参考再有人问你synchronized是什么，就把这篇文章发给他。-HollisChuang’s Blog]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的锁]]></title>
    <url>%2Fmyhexo%2F2019%2F07%2F30%2Fjava%E4%B8%AD%E7%9A%84%E9%94%81%2F</url>
    <content type="text"><![CDATA[引言在java单线程中，并不会出现资源抢夺的现象，但是在多线程并发中，会出现资源抢夺现象。为了避免这种情况需要上锁 分类可重入锁，又名递归锁指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁，也即是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。 使用synchronized12345678910111213141516171819202122232425class Phone&#123; public void sendSMS() &#123; System.out.println(Thread.currentThread().getName()+"\t invoked sendSMS()"); sendEmail(); &#125; private void sendEmail() &#123; System.out.println(Thread.currentThread().getName()+"\t ###########invoked sendEmail()"); &#125;&#125;public class ReentrantLockDemo &#123; public static void main(String[] args) &#123; Phone phone = new Phone(); new Thread(()-&gt;&#123; phone.sendSMS(); &#125;,"t1").start(); new Thread(()-&gt;&#123; phone.sendSMS(); &#125;,"t2").start(); &#125;&#125; 结果 1234t1 invoked sendSMS() //t1线程在外层方法获取锁的时候t1 ###########invoked sendEmail() //t1在线程进入内层方法会自动获取锁t2 invoked sendSMS()t2 ###########invoked sendEmail() 使用ReentrantLock1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class Phone implements Runnable &#123; Lock lock = new ReentrantLock(); public void sendSMS() &#123; System.out.println(Thread.currentThread().getName() + "\t invoked sendSMS()"); sendEmail(); &#125; private void sendEmail() &#123; System.out.println(Thread.currentThread().getName() + "\t ###########invoked sendEmail()"); &#125; @Override public void run() &#123; get(); &#125; public void get() &#123; lock.lock(); try&#123; System.out.println(Thread.currentThread().getName() + "\t invoked get()"); set(); &#125;catch (Exception e)&#123; &#125;finally &#123; lock.unlock(); &#125; &#125; private void set() &#123; lock.lock(); try&#123; System.out.println(Thread.currentThread().getName() + "\t invoked set()"); &#125;catch (Exception e)&#123; &#125;finally &#123; lock.unlock(); &#125; &#125;&#125;public class ReentrantLockDemo &#123; public static void main(String[] args) &#123; Phone phone = new Phone(); new Thread(() -&gt; &#123; phone.sendSMS(); &#125;, "t1").start(); new Thread(() -&gt; &#123; phone.sendSMS(); &#125;, "t2").start(); //暂停一会线程 try &#123; TimeUnit.MICROSECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(); System.out.println(); System.out.println(); System.out.println(); Thread t3 = new Thread(phone,"t3"); Thread t4 = new Thread(phone,"t4"); t3.start(); t4.start(); &#125;&#125; 结果 12345678910111213t1 invoked sendSMS()t1 ###########invoked sendEmail()t2 invoked sendSMS()t2 ###########invoked sendEmail()t3 invoked get()t3 invoked set()t4 invoked get()t4 invoked set() 自旋锁CAS循环比较并交换 是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicReference;public class SpinLockDemo &#123; AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;(); public void myLock() &#123; Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName() + "\t come in..."); while (!atomicReference.compareAndSet(null, thread)) &#123; &#125; &#125; public void myUnLock() &#123; Thread thread = Thread.currentThread(); atomicReference.compareAndSet(thread, null); System.out.println(Thread.currentThread().getName() + "\t invoked myUnLock()"); &#125; public static void main(String[] args) &#123; SpinLockDemo spinLockDemo = new SpinLockDemo(); new Thread(() -&gt; &#123; spinLockDemo.myLock(); //暂停一会线程 try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; spinLockDemo.myUnLock(); &#125;, "AA").start(); //暂停一会线程 try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(() -&gt; &#123; spinLockDemo.myLock(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; spinLockDemo.myUnLock(); &#125;, "BB").start(); &#125;&#125; 结果 1234AA come in...BB come in...AA invoked myUnLock()BB invoked myUnLock() 读写锁读时共享资源数据，写时独占资源数据 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行，但是如果有一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写。 读-读能共存 读-写不能共存 写-写不能共存 没有使用读写锁前12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.HashMap;import java.util.Map;import java.util.concurrent.TimeUnit;class MyCache&#123; private volatile Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); public void put(String key, String value) &#123; System.out.println(Thread.currentThread().getName()+"\t 正在写入："+key); //暂停一会线程 try &#123; TimeUnit.MICROSECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; map.put(key,value); System.out.println(Thread.currentThread().getName()+"\t 写入完成："); &#125; public void get(String key) &#123; System.out.println(Thread.currentThread().getName()+"\t 正在读取："); //暂停一会线程 try &#123; TimeUnit.MICROSECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Object result = map.get(key); System.out.println(Thread.currentThread().getName()+"\t 读取完成："+result); &#125;&#125;public class ReadWriteDemo &#123; public static void main(String[] args) &#123; MyCache myCache = new MyCache(); //创建5个线程,写入资源数据 for(int i=1;i&lt;=5;i++)&#123; final int tempInt = i; new Thread(()-&gt;&#123; myCache.put(tempInt+"",tempInt+""); &#125;,String.valueOf(i)).start(); &#125; //创建5个线程,读取资源数据 for(int i=1;i&lt;=5;i++)&#123; final int tempInt = i; new Thread(()-&gt;&#123; myCache.get(tempInt+""); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; 结果 写时并不满足原子性和独占性，整个过程必须是一个完整的统一体，中间不允许被分割，被打断 12345678910111213141516171819205 正在写入：51 正在写入：13 正在写入：32 正在读取：4 正在写入：42 正在写入：21 正在读取：5 正在读取：3 正在读取：4 正在读取：2 写入完成：5 读取完成：55 写入完成：4 读取完成：null2 读取完成：null3 写入完成：1 读取完成：null1 写入完成：3 读取完成：34 写入完成： 使用读写锁后使用ReentrantReadWriteLock 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.util.HashMap;import java.util.Map;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.ReentrantReadWriteLock;class MyCache &#123; private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //读写锁 private ReentrantReadWriteLock rwlock = new ReentrantReadWriteLock(); public void put(String key, String value) &#123; rwlock.writeLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() + "\t 正在写入：" + key); //暂停一会线程 try &#123; TimeUnit.MICROSECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; map.put(key, value); System.out.println(Thread.currentThread().getName() + "\t 写入完成："); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; rwlock.writeLock().unlock(); &#125; &#125; public void get(String key) &#123; rwlock.readLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() + "\t 正在读取："); //暂停一会线程 try &#123; TimeUnit.MICROSECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Object result = map.get(key); System.out.println(Thread.currentThread().getName() + "\t 读取完成：" + result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; rwlock.readLock().unlock(); &#125; &#125;&#125;public class ReadWriteDemo &#123; public static void main(String[] args) &#123; MyCache myCache = new MyCache(); //创建5个线程,写入资源数据 for (int i = 1; i &lt;= 5; i++) &#123; final int tempInt = i; new Thread(() -&gt; &#123; myCache.put(tempInt + "", tempInt + ""); &#125;, String.valueOf(i)).start(); &#125; //创建5个线程,读取资源数据 for (int i = 1; i &lt;= 5; i++) &#123; final int tempInt = i; new Thread(() -&gt; &#123; myCache.get(tempInt + ""); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 结果 12345678910111213141516171819204 正在写入：44 写入完成：2 正在写入：22 写入完成：1 正在写入：11 写入完成：3 正在写入：33 写入完成：5 正在写入：55 写入完成：1 正在读取：4 正在读取：2 正在读取：3 正在读取：5 正在读取：3 读取完成：31 读取完成：15 读取完成：52 读取完成：24 读取完成：4 参考一道面试题比较synchronized和读写锁 - where - ITeye博客]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elastic]]></title>
    <url>%2Fmyhexo%2F2019%2F07%2F08%2Felastic%2F</url>
    <content type="text"><![CDATA[安装elastic下载Elasticsearch 6.3.1 | Elastic 解压1[root@192 modules]# tar -zxvf elasticsearch-6.3.1.tar.gz 启动报错一elasticsearch 为了安全性默认不允许root 用户来启动 1234567891011121314151617[root@192 elasticsearch-6.3.1]# cd bin/[root@192 bin]# ./elasticsearch[2019-07-08T08:45:49,312][WARN ][o.e.b.ElasticsearchUncaughtExceptionHandler] [] uncaught exception in thread [main]org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:140) ~[elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:127) ~[elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:86) ~[elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:124) ~[elasticsearch-cli-6.3.1.jar:6.3.1] at org.elasticsearch.cli.Command.main(Command.java:90) ~[elasticsearch-cli-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:93) ~[elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:86) ~[elasticsearch-6.3.1.jar:6.3.1]Caused by: java.lang.RuntimeException: can not run elasticsearch as root at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:104) ~[elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:171) ~[elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:326) ~[elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:136) ~[elasticsearch-6.3.1.jar:6.3.1] ... 6 more 新建立es用户 123456789101112131415161718[root@192 bin]# useradd es[root@192 bin]# pwd/opt/modules/elasticsearch-6.3.1/bin[root@192 bin]# cd[root@192 ~]# pwd/root[root@192 ~]# cd /opt/modules/elasticsearch-6.3.1[root@192 elasticsearch-6.3.1]# lltotal 460drwxr-xr-x. 3 root root 4096 Jul 8 08:43 bindrwxr-xr-x. 2 root root 4096 Jul 8 08:45 configdrwxr-xr-x. 2 root root 4096 Jun 30 2018 lib-rw-r--r--. 1 root root 13675 Jun 30 2018 LICENSE.txtdrwxr-xr-x. 2 root root 4096 Jul 8 08:45 logsdrwxr-xr-x. 17 root root 4096 Jun 30 2018 modules-rw-r--r--. 1 root root 416018 Jun 30 2018 NOTICE.txtdrwxr-xr-x. 2 root root 4096 Jun 30 2018 plugins-rw-r--r--. 1 root root 8511 Jun 30 2018 README.textile 报错二授权、启动 123456789101112131415161718192021222324252627282930[root@192 elasticsearch-6.3.1]# chown -R es:es ./[root@192 elasticsearch-6.3.1]# lltotal 460drwxr-xr-x. 3 es es 4096 Jul 8 08:43 bindrwxr-xr-x. 2 es es 4096 Jul 8 08:45 configdrwxr-xr-x. 2 es es 4096 Jun 30 2018 lib-rw-r--r--. 1 es es 13675 Jun 30 2018 LICENSE.txtdrwxr-xr-x. 2 es es 4096 Jul 8 08:45 logsdrwxr-xr-x. 17 es es 4096 Jun 30 2018 modules-rw-r--r--. 1 es es 416018 Jun 30 2018 NOTICE.txtdrwxr-xr-x. 2 es es 4096 Jun 30 2018 plugins-rw-r--r--. 1 es es 8511 Jun 30 2018 README.textile[root@192 elasticsearch-6.3.1]# su es[es@192 elasticsearch-6.3.1]$ ./bin/elasticsearch[2019-07-08T08:48:42,989][WARN ][o.e.b.JNANatives ] unable to install syscall filter: java.lang.UnsupportedOperationException: seccomp unavailable: CONFIG_SECCOMP not compiled into kernel, CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER are needed at org.elasticsearch.bootstrap.SystemCallFilter.linuxImpl(SystemCallFilter.java:341) ~[elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.SystemCallFilter.init(SystemCallFilter.java:616) ~[elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.JNANatives.tryInstallSystemCallFilter(JNANatives.java:258) [elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Natives.tryInstallSystemCallFilter(Natives.java:113) [elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:109) [elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:171) [elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:326) [elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:136) [elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:127) [elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:86) [elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:124) [elasticsearch-cli-6.3.1.jar:6.3.1] at org.elasticsearch.cli.Command.main(Command.java:90) [elasticsearch-cli-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:93) [elasticsearch-6.3.1.jar:6.3.1] at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:86) [elasticsearch-6.3.1.jar:6.3.1] 解决 进入/opt/modules/elasticsearch-6.3.1/config目录，修改配置文件 elasticsearch.yml，末尾追加 12bootstrap.memory_lock: falsebootstrap.system_call_filter: false 报错三用户最大文件描述符限制低于 65536 而抛出的异常 用户最大的线程数限制低于 4096 而抛出的异常 系统最大虚拟内存低于 262144 而抛出的异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[es@192 elasticsearch-6.3.1]$ ./bin/elasticsearch[2019-07-08T08:56:38,934][INFO ][o.e.n.Node ] [] initializing ...[2019-07-08T08:56:39,016][INFO ][o.e.e.NodeEnvironment ] [zzp49gD] using [1] data paths, mounts [[/ (rootfs)]], net usable_space [9.2gb], net total_space [14.6gb], types [rootfs][2019-07-08T08:56:39,016][INFO ][o.e.e.NodeEnvironment ] [zzp49gD] heap size [989.8mb], compressed ordinary object pointers [true][2019-07-08T08:56:39,017][INFO ][o.e.n.Node ] [zzp49gD] node name derived from node ID [zzp49gDDT1yAkU_sqvvLdw]; set [node.name] to override[2019-07-08T08:56:39,018][INFO ][o.e.n.Node ] [zzp49gD] version[6.3.1], pid[3815], build[default/tar/eb782d0/2018-06-29T21:59:26.107521Z], OS[Linux/2.6.32-642.el6.x86_64/amd64], JVM[Oracle Corporation/Java HotSpot(TM) 64-Bit Server VM/1.8.0_202/25.202-b08][2019-07-08T08:56:39,018][INFO ][o.e.n.Node ] [zzp49gD] JVM arguments [-Xms1g, -Xmx1g, -XX:+UseConcMarkSweepGC, -XX:CMSInitiatingOccupancyFraction=75, -XX:+UseCMSInitiatingOccupancyOnly, -XX:+AlwaysPreTouch, -Xss1m, -Djava.awt.headless=true, -Dfile.encoding=UTF-8, -Djna.nosys=true, -XX:-OmitStackTraceInFastThrow, -Dio.netty.noUnsafe=true, -Dio.netty.noKeySetOptimization=true, -Dio.netty.recycler.maxCapacityPerThread=0, -Dlog4j.shutdownHookEnabled=false, -Dlog4j2.disable.jmx=true, -Djava.io.tmpdir=/tmp/elasticsearch.KQ6g6BOC, -XX:+HeapDumpOnOutOfMemoryError, -XX:HeapDumpPath=data, -XX:ErrorFile=logs/hs_err_pid%p.log, -XX:+PrintGCDetails, -XX:+PrintGCDateStamps, -XX:+PrintTenuringDistribution, -XX:+PrintGCApplicationStoppedTime, -Xloggc:logs/gc.log, -XX:+UseGCLogFileRotation, -XX:NumberOfGCLogFiles=32, -XX:GCLogFileSize=64m, -Des.path.home=/opt/modules/elasticsearch-6.3.1, -Des.path.conf=/opt/modules/elasticsearch-6.3.1/config, -Des.distribution.flavor=default, -Des.distribution.type=tar][2019-07-08T08:56:40,833][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [aggs-matrix-stats][2019-07-08T08:56:40,834][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [analysis-common][2019-07-08T08:56:40,834][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [ingest-common][2019-07-08T08:56:40,834][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [lang-expression][2019-07-08T08:56:40,834][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [lang-mustache][2019-07-08T08:56:40,834][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [lang-painless][2019-07-08T08:56:40,834][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [mapper-extras][2019-07-08T08:56:40,834][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [parent-join][2019-07-08T08:56:40,834][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [percolator][2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [rank-eval][2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [reindex][2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [repository-url][2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [transport-netty4][2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [tribe][2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-core][2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-deprecation][2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-graph][2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-logstash][2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-ml][2019-07-08T08:56:40,835][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-monitoring][2019-07-08T08:56:40,836][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-rollup][2019-07-08T08:56:40,836][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-security][2019-07-08T08:56:40,836][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-sql][2019-07-08T08:56:40,836][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-upgrade][2019-07-08T08:56:40,836][INFO ][o.e.p.PluginsService ] [zzp49gD] loaded module [x-pack-watcher][2019-07-08T08:56:40,836][INFO ][o.e.p.PluginsService ] [zzp49gD] no plugins loaded[2019-07-08T08:56:43,471][INFO ][o.e.x.s.a.s.FileRolesStore] [zzp49gD] parsed [0] roles from file [/opt/modules/elasticsearch-6.3.1/config/roles.yml][2019-07-08T08:56:43,817][INFO ][o.e.x.m.j.p.l.CppLogMessageHandler] [controller/3894] [Main.cc@109] controller (64 bit): Version 6.3.1 (Build 4d0b8f0a0ef401) Copyright (c) 2018 Elasticsearch BV[2019-07-08T08:56:44,114][DEBUG][o.e.a.ActionModule ] Using REST wrapper from plugin org.elasticsearch.xpack.security.Security[2019-07-08T08:56:44,331][INFO ][o.e.d.DiscoveryModule ] [zzp49gD] using discovery type [zen][2019-07-08T08:56:45,016][INFO ][o.e.n.Node ] [zzp49gD] initialized[2019-07-08T08:56:45,016][INFO ][o.e.n.Node ] [zzp49gD] starting ...[2019-07-08T08:56:45,173][INFO ][o.e.t.TransportService ] [zzp49gD] publish_address &#123;192.168.1.101:9300&#125;, bound_addresses &#123;192.168.1.101:9300&#125;[2019-07-08T08:56:45,196][INFO ][o.e.b.BootstrapChecks ] [zzp49gD] bound or publishing to a non-loopback address, enforcing bootstrap checksERROR: [3] bootstrap checks failed[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536][2]: max number of threads [1024] for user [es] is too low, increase to at least [4096][3]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144][2019-07-08T08:56:45,223][INFO ][o.e.n.Node ] [zzp49gD] stopping ...[2019-07-08T08:56:45,295][INFO ][o.e.n.Node ] [zzp49gD] stopped[2019-07-08T08:56:45,295][INFO ][o.e.n.Node ] [zzp49gD] closing ...[2019-07-08T08:56:45,307][INFO ][o.e.n.Node ] [zzp49gD] closed[2019-07-08T08:56:45,313][INFO ][o.e.x.m.j.p.NativeController] Native controller process has stopped - no new native processes can be started 解决户最大文件描述符限制低于 65536 而抛出的异常 切换到root用户,进入/etc/security/目录，修改limits.conf文件，末尾追加 1234* hard nofile 65536* soft nofile 131072* hard nproc 4096* soft nproc 2048 解决用户最大的线程数限制低于 4096 而抛出的异常 切换到root用户,进入/etc/security/limits.d目录，修改90-nproc.conf文件 12* soft nproc 4096root soft nproc unlimited 解决系统最大虚拟内存低于 262144 而抛出的异常 修改/etc/sysctl.conf文件，末尾追加 12vm.max_map_count=655360fs.file-max=655360 配置访问地址进入/opt/modules/elasticsearch-6.3.1/config目录，修改elasticsearch.yml文件 访问 12345678910111213141516171819[es@192 elasticsearch-6.3.1]$ curl http://192.168.1.101:9200&#123; &quot;name&quot; : &quot;zzp49gD&quot;, &quot;cluster_name&quot; : &quot;elasticsearch&quot;, &quot;cluster_uuid&quot; : &quot;i0I9Oc2gQxOkc-jk4ZvEvw&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;6.3.1&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;tar&quot;, &quot;build_hash&quot; : &quot;eb782d0&quot;, &quot;build_date&quot; : &quot;2018-06-29T21:59:26.107521Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;7.3.1&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125;[es@192 elasticsearch-6.3.1]$ 安装kibana下载Kibana 6.3.1 | Elastic 解压1[root@192 bin]# tar -zxvf kibana-6.3.1-linux-x86_64.tar.gz 修改配置文件进入 1[root@192 bin]# cd kibana-6.3.1-linux-x86_64/config/ 修改kibana.yml配置文件 启动123456789[root@192 bin]# pwd/opt/modules/kibana-6.3.1-linux-x86_64/bin[root@192 bin]# nohup ./kibana &amp;[1] 3665[root@192 bin]# nohup: ignoring input and appending output to `nohup.out&apos;[root@192 bin]# ps -ef | grep noderoot 3665 3615 51 08:45 pts/0 00:00:25 ./../node/bin/node --no-warnings ./../src/cliroot 3685 3615 0 08:46 pts/0 00:00:00 grep node 访问 操作es增删改查ES 简单操作 - ELK - Wiki.Shileizcc.com 增 123456789101112131415161718PUT /movie_index/movie/1&#123; "id":1, "name":"operation red sea", "doubanscore":8.5, "actorList":[ &#123; "id":1,"name":"zhang yi" &#125;, &#123; "id":2,"name":"hai qing" &#125;, &#123; "id":3,"name":"zhang han yu" &#125; ]&#125; 删 1DELETE /movie_index/movie/1 改 和新增一样，PUT既可以新增，也可以修改 123456789101112131415161718PUT /movie_index/movie/1&#123; &quot;id&quot;:2, &quot;name&quot;:&quot;operation red sea&quot;, &quot;doubanscore&quot;:8.5, &quot;actorList&quot;:[ &#123; &quot;id&quot;:1,&quot;name&quot;:&quot;zhang yi&quot; &#125;, &#123; &quot;id&quot;:2,&quot;name&quot;:&quot;hai qing&quot; &#125;, &#123; &quot;id&quot;:3,&quot;name&quot;:&quot;zhang han yu&quot; &#125; ]&#125; 查 1GET /movie_index/_search 安装分词器analysis-ik下载Release v6.3.1 · medcl/elasticsearch-analysis-ik 解压、上传 12345[root@192 ~]# cd /opt/modules/elasticsearch-6.3.1/plugins/[root@192 plugins]# lltotal 4drwxr-xr-x. 3 root root 4096 Jul 10 08:51 elasticsearch-analysis-ik-6.3.1[root@192 plugins]# 重启es123456789101112131415161718192021222324252627282930[root@192 bin]# su es[es@192 bin]$ nohup ./elasticsearch &amp;[1] 4002[es@192 bin]$ nohup: ignoring input and appending output to `nohup.out&apos;[es@192 bin]$ ps -ef|grep elastices 4002 3987 99 08:45 pts/0 00:00:25 /usr/java/jdk1.8.0_202-amd64/bin/java -Xms1g -Xmx1g -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+AlwaysPreTouch -Xss1m -Djava.awt.headless=true -Dfile.encoding=UTF-8 -Djna.nosys=true -XX:-OmitStackTraceInFastThrow -Dio.netty.noUnsafe=true -Dio.netty.noKeySetOptimization=true -Dio.netty.recycler.maxCapacityPerThread=0 -Dlog4j.shutdownHookEnabled=false -Dlog4j2.disable.jmx=true -Djava.io.tmpdir=/tmp/elasticsearch.iMX34Qx6 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=data -XX:ErrorFile=logs/hs_err_pid%p.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime -Xloggc:logs/gc.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=32 -XX:GCLogFileSize=64m -Des.path.home=/opt/modules/elasticsearch-6.3.1 -Des.path.conf=/opt/modules/elasticsearch-6.3.1/config -Des.distribution.flavor=default -Des.distribution.type=tar -cp /opt/modules/elasticsearch-6.3.1/lib/* org.elasticsearch.bootstrap.Elasticsearches 4081 4002 0 08:45 pts/0 00:00:00 /opt/modules/elasticsearch-6.3.1/modules/x-pack/x-pack-ml/platform/linux-x86_64/bin/controlleres 4092 3987 0 08:45 pts/0 00:00:00 grep elastic[es@192 bin]$ kill -9 4002[es@192 bin]$ ps -ef|grep elastices 4235 3987 0 08:54 pts/0 00:00:00 grep elastic[2]+ Killed nohup ./kibana[es@192 bin]$ cd /opt/modules/elasticsearch-6.3.1/bin/[es@192 bin]$ nohup ./elasticsearch &amp;[1] 4238[es@192 bin]$ nohup: ignoring input and appending output to `nohup.out&apos;[es@192 bin]$ ps -ef|grep elastices 4238 3987 99 08:54 pts/0 00:00:15 /usr/java/jdk1.8.0_202-amd64/bin/java -Xms1g -Xmx1g -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+AlwaysPreTouch -Xss1m -Djava.awt.headless=true -Dfile.encoding=UTF-8 -Djna.nosys=true -XX:-OmitStackTraceInFastThrow -Dio.netty.noUnsafe=true -Dio.netty.noKeySetOptimization=true -Dio.netty.recycler.maxCapacityPerThread=0 -Dlog4j.shutdownHookEnabled=false -Dlog4j2.disable.jmx=true -Djava.io.tmpdir=/tmp/elasticsearch.zw6LMXqV -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=data -XX:ErrorFile=logs/hs_err_pid%p.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime -Xloggc:logs/gc.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=32 -XX:GCLogFileSize=64m -Des.path.home=/opt/modules/elasticsearch-6.3.1 -Des.path.conf=/opt/modules/elasticsearch-6.3.1/config -Des.distribution.flavor=default -Des.distribution.type=tar -cp /opt/modules/elasticsearch-6.3.1/lib/* org.elasticsearch.bootstrap.Elasticsearches 4317 4238 0 08:54 pts/0 00:00:00 /opt/modules/elasticsearch-6.3.1/modules/x-pack/x-pack-ml/platform/linux-x86_64/bin/controlleres 4325 3987 0 08:54 pts/0 00:00:00 grep elastic[es@192 bin]$ cd /opt/modules/kibana-6.3.1-linux-x86_64/bin/[es@192 bin]$ nohup ./kibana &amp;[2] 4384[es@192 bin]$ nohup: ignoring input and appending output to `nohup.out&apos;[es@192 bin]$ ps -ef|grep nodees 4384 3987 77 08:55 pts/0 00:00:06 ./../node/bin/node --no-warnings ./../src/clies 4396 3987 0 08:55 pts/0 00:00:00 grep node 重启kibana1234567891011[es@192 bin]$ cd /opt/modules/kibana-6.3.1-linux-x86_64/bin/[es@192 bin]$ nohup ./kibana &amp;[2] 4155[es@192 bin]$ nohup: ignoring input and appending output to `nohup.out&apos;[es@192 bin]$ ps -ef|grep nodees 4155 3987 56 08:46 pts/0 00:00:04 ./../node/bin/node --no-warnings ./../src/clies 4167 3987 0 08:46 pts/0 00:00:00 grep node[es@192 bin]$ kill -9 4155[es@192 bin]$ ps -ef|grep nodees 4237 3987 0 08:54 pts/0 00:00:00 grep node 访问es 访问kibana入分词器前 加入分词器后简易分词器 尽最大可能分词器 es集群克隆克隆一个已经安装好elastic、kibana、analysis-ik的机器 虚拟机—-快照—拍摄快照 虚拟机—管理—克隆—现有快照 修改IP修改克隆后机器102的主机名、IP地址、硬件Mac地址 参考 虚拟机配置静态ip | 小兵兵 集群配置es修改配置文件修改101机器进入/opt/modules/elasticsearch-6.3.1/config目录，修改elasticsearch.yml配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# ======================== Elasticsearch Configuration =========================## NOTE: Elasticsearch comes with reasonable defaults for most settings.# Before you set out to tweak and tune the configuration, make sure you# understand what are you trying to accomplish and the consequences.## The primary way of configuring a node is via this file. This template lists# the most important settings you may want to configure for a production cluster.## Please consult the documentation for further information on configuration options:# https://www.elastic.co/guide/en/elasticsearch/reference/index.html## ---------------------------------- Cluster -----------------------------------## Use a descriptive name for your cluster:#cluster.name: my-application## ------------------------------------ Node ------------------------------------## Use a descriptive name for the node:#node.name: node-1## Add custom attributes to the node:##node.attr.rack: r1## ----------------------------------- Paths ------------------------------------## Path to directory where to store the data (separate multiple locations by comma):#node.master: truenode.data: truepath.data: /opt/data## Path to log files:#path.logs: /opt/logs## ----------------------------------- Memory -----------------------------------## Lock the memory on startup:##bootstrap.memory_lock: true## Make sure that the heap size is set to about half the memory available# on the system and that the owner of the process is allowed to use this# limit.## Elasticsearch performs poorly when the system is swapping the memory.## ---------------------------------- Network -----------------------------------## Set the bind address to a specific IP (IPv4 or IPv6):#network.host: 192.168.1.101## Set a custom port for HTTP:#http.port: 9200transport.tcp.port: 9300## For more information, consult the network module documentation.## --------------------------------- Discovery ----------------------------------## Pass an initial list of hosts to perform discovery when new node is started:# The default list of hosts is ["127.0.0.1", "[::1]"]#discovery.zen.ping.unicast.hosts: ["192.168.1.102"]## Prevent the "split brain" by configuring the majority of nodes (total number of master-eligible nodes / 2 + 1):#discovery.zen.minimum_master_nodes: 2## For more information, consult the zen discovery module documentation.## ---------------------------------- Gateway -----------------------------------## Block initial recovery after a full cluster restart until N nodes are started:##gateway.recover_after_nodes: 3## For more information, consult the gateway module documentation.## ---------------------------------- Various -----------------------------------## Require explicit names when deleting indices:##action.destructive_requires_name: truebootstrap.memory_lock: falsebootstrap.system_call_filter: false 建立数据存储目录、日志目录 12345678910111213141516[root@192 config]# cd /opt/[root@192 opt]# mkdir data[root@192 opt]# mkdir logs[root@192 opt]# lltotal 16drwxr-xr-x. 2 root root 4096 Jul 10 09:58 datadrwxr-xr-x. 2 root root 4096 Jul 10 09:58 logsdrwxr-xr-x. 4 root root 4096 Jul 9 08:42 modulesdrwxr-xr-x. 2 root root 4096 Mar 26 2015 rh[root@192 opt]# chown es:es -R data/ logs/[root@192 opt]# lltotal 16drwxr-xr-x. 2 es es 4096 Jul 10 09:58 datadrwxr-xr-x. 2 es es 4096 Jul 10 09:58 logsdrwxr-xr-x. 4 root root 4096 Jul 9 08:42 modulesdrwxr-xr-x. 2 root root 4096 Mar 26 2015 rh 修改102机器进入/opt/modules/elasticsearch-6.3.1/config目录，修改elasticsearch.yml配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# ======================== Elasticsearch Configuration =========================## NOTE: Elasticsearch comes with reasonable defaults for most settings.# Before you set out to tweak and tune the configuration, make sure you# understand what are you trying to accomplish and the consequences.## The primary way of configuring a node is via this file. This template lists# the most important settings you may want to configure for a production cluster.## Please consult the documentation for further information on configuration options:# https://www.elastic.co/guide/en/elasticsearch/reference/index.html## ---------------------------------- Cluster -----------------------------------## Use a descriptive name for your cluster:#cluster.name: my-application## ------------------------------------ Node ------------------------------------## Use a descriptive name for the node:#node.name: node-2## Add custom attributes to the node:##node.attr.rack: r1## ----------------------------------- Paths ------------------------------------## Path to directory where to store the data (separate multiple locations by comma):#node.master: truenode.data: truepath.data: /opt/data## Path to log files:#path.logs: /opt/logs## ----------------------------------- Memory -----------------------------------## Lock the memory on startup:##bootstrap.memory_lock: true## Make sure that the heap size is set to about half the memory available# on the system and that the owner of the process is allowed to use this# limit.## Elasticsearch performs poorly when the system is swapping the memory.## ---------------------------------- Network -----------------------------------## Set the bind address to a specific IP (IPv4 or IPv6):#network.host: 192.168.1.102## Set a custom port for HTTP:#http.port: 9200transport.tcp.port: 9300## For more information, consult the network module documentation.## --------------------------------- Discovery ----------------------------------## Pass an initial list of hosts to perform discovery when new node is started:# The default list of hosts is ["127.0.0.1", "[::1]"]#discovery.zen.ping.unicast.hosts: ["192.168.1.101"]## Prevent the "split brain" by configuring the majority of nodes (total number of master-eligible nodes / 2 + 1):#discovery.zen.minimum_master_nodes: 2## For more information, consult the zen discovery module documentation.## ---------------------------------- Gateway -----------------------------------## Block initial recovery after a full cluster restart until N nodes are started:##gateway.recover_after_nodes: 3## For more information, consult the gateway module documentation.## ---------------------------------- Various -----------------------------------## Require explicit names when deleting indices:##action.destructive_requires_name: truebootstrap.memory_lock: falsebootstrap.system_call_filter: false 建立数据存储目录、日志目录 12345678910111213141516[root@192 config]# cd /opt/[root@192 opt]# mkdir data[root@192 opt]# mkdir logs[root@192 opt]# lltotal 16drwxr-xr-x. 2 root root 4096 Jul 10 09:58 datadrwxr-xr-x. 2 root root 4096 Jul 10 09:58 logsdrwxr-xr-x. 4 root root 4096 Jul 9 08:42 modulesdrwxr-xr-x. 2 root root 4096 Mar 26 2015 rh[root@192 opt]# chown es:es -R data/ logs/[root@192 opt]# lltotal 16drwxr-xr-x. 2 es es 4096 Jul 10 09:58 datadrwxr-xr-x. 2 es es 4096 Jul 10 09:58 logsdrwxr-xr-x. 4 root root 4096 Jul 9 08:42 modulesdrwxr-xr-x. 2 root root 4096 Mar 26 2015 rh 重启重启101机器12345678910111213[es@192 bin]$ pwd/opt/modules/elasticsearch-6.3.1/bin[es@192 bin]$ ps -ef | grep elastices 3795 3638 0 10:08 pts/0 00:00:00 grep elastic[1]+ Killed nohup ./elasticsearch[es@192 bin]$ nohup ./elasticsearch &amp;[1] 3796[es@192 bin]$ nohup: ignoring input and appending output to `nohup.out&apos;[es@192 bin]$ ps -ef | grep elastices 3796 3638 99 10:09 pts/0 00:00:07 /usr/java/jdk1.8.0_202-amd64/bin/java -Xms1g -Xmx1g -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+AlwaysPreTouch -Xss1m -Djava.awt.headless=true -Dfile.encoding=UTF-8 -Djna.nosys=true -XX:-OmitStackTraceInFastThrow -Dio.netty.noUnsafe=true -Dio.netty.noKeySetOptimization=true -Dio.netty.recycler.maxCapacityPerThread=0 -Dlog4j.shutdownHookEnabled=false -Dlog4j2.disable.jmx=true -Djava.io.tmpdir=/tmp/elasticsearch.wZB2cw0p -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=data -XX:ErrorFile=logs/hs_err_pid%p.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime -Xloggc:logs/gc.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=32 -XX:GCLogFileSize=64m -Des.path.home=/opt/modules/elasticsearch-6.3.1 -Des.path.conf=/opt/modules/elasticsearch-6.3.1/config -Des.distribution.flavor=default -Des.distribution.type=tar -cp /opt/modules/elasticsearch-6.3.1/lib/* org.elasticsearch.bootstrap.Elasticsearches 3875 3796 0 10:09 pts/0 00:00:00 /opt/modules/elasticsearch-6.3.1/modules/x-pack/x-pack-ml/platform/linux-x86_64/bin/controlleres 3881 3638 0 10:09 pts/0 00:00:00 grep elastic 重启102机器12345678910111213[es@192 bin]$ pwd/opt/modules/elasticsearch-6.3.1/bin[es@192 bin]$ ps -ef|grep elastices 4284 3992 0 10:10 pts/1 00:00:00 grep elastic[es@192 bin]$ nohup ./elasticsearch &amp;[1] 4285[es@192 bin]$ nohup: ignoring input and appending output to `nohup.out&apos;[es@192 bin]$ ps -ef|grep elastices 4285 3992 99 10:10 pts/1 00:00:04 /usr/java/jdk1.8.0_202-amd64/bin/java -Xms1g -Xmx1g -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+AlwaysPreTouch -Xss1m -Djava.awt.headless=true -Dfile.encoding=UTF-8 -Djna.nosys=true -XX:-OmitStackTraceInFastThrow -Dio.netty.noUnsafe=true -Dio.netty.noKeySetOptimization=true -Dio.netty.recycler.maxCapacityPerThread=0 -Dlog4j.shutdownHookEnabled=false -Dlog4j2.disable.jmx=true -Djava.io.tmpdir=/tmp/elasticsearch.JmqOtV9r -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=data -XX:ErrorFile=logs/hs_err_pid%p.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime -Xloggc:logs/gc.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=32 -XX:GCLogFileSize=64m -Des.path.home=/opt/modules/elasticsearch-6.3.1 -Des.path.conf=/opt/modules/elasticsearch-6.3.1/config -Des.distribution.flavor=default -Des.distribution.type=tar -cp /opt/modules/elasticsearch-6.3.1/lib/* org.elasticsearch.bootstrap.Elasticsearches 4364 4285 0 10:10 pts/1 00:00:00 /opt/modules/elasticsearch-6.3.1/modules/x-pack/x-pack-ml/platform/linux-x86_64/bin/controlleres 4370 3992 0 10:10 pts/1 00:00:00 grep elastic[es@192 bin]$ ll 访问访问101机器 访问102机器 集群管理工具cerebro插件【head,bigdesk,cerebro[kopf]】安装 下载Releases · lmenezes/cerebro 上传、解压 123456789101112131415161718192021[root@192 modules]# cd /opt/[root@192 opt]# mkdir soft[root@192 opt]# lltotal 20drwxr-xr-x. 3 es es 4096 Jul 10 10:01 datadrwxr-xr-x. 2 es es 4096 Jul 10 10:01 logsdrwxr-xr-x. 4 root root 4096 Jul 10 10:23 modulesdrwxr-xr-x. 2 root root 4096 Mar 26 2015 rhdrwxr-xr-x. 2 root root 4096 Jul 10 10:25 soft[root@192 opt]# cd /opt/modules/[root@192 modules]# lltotal 581928-rw-r--r--. 1 root root 52397010 Jul 10 10:23 cerebro-0.8.3.tgzdrwxr-xr-x. 9 es es 4096 Jul 9 17:16 elasticsearch-6.3.1-rw-r--r--. 1 root root 91429350 Jul 8 08:42 elasticsearch-6.3.1.tar.gz-rwxrwxrwx. 1 root root 178418154 Jul 7 21:08 jdk-8u202-linux-x64.rpmdrwxrwxr-x. 11 es es 4096 Jun 30 2018 kibana-6.3.1-linux-x86_64-rw-r--r--. 1 root root 205397076 Jul 8 08:42 kibana-6.3.1-linux-x86_64.tar.gz-rw-r--r--. 1 root root 17855952 Jun 8 20:04 MySQL-client-5.5.48-1.linux2.6.x86_64.rpm-rw-r--r--. 1 root root 50372369 Jun 8 20:24 MySQL-server-5.5.48-1.linux2.6.x86_64.rpm[root@192 modules]# tar -zxvf cerebro-0.8.3.tgz -C /opt/soft/ 启动12345678910111213[root@192 modules]# cd /opt/soft/[root@192 soft]# lltotal 4drwxr-xr-x. 5 503 games 4096 Apr 5 16:48 cerebro-0.8.3[root@192 soft]# cd cerebro-0.8.3/[root@192 cerebro-0.8.3]# cd bin/[root@192 bin]# lltotal 20-rwxr-xr-x. 1 503 games 9497 Apr 5 16:48 cerebro-rwxr-xr-x. 1 503 games 4970 Apr 5 16:48 cerebro.bat[root@192 bin]# nohup ./cerebro &amp;[1] 4030[root@192 bin]# nohup: ignoring input and appending output to `nohup.out&apos; 访问 测试建立一条数据 启动kibana，访问添加数据 1234567891011[root@192 modules]# cd /opt/modules/kibana-6.3.1-linux-x86_64/bin/[root@192 bin]# lltotal 948-rwxr-xr-x. 1 es es 632 Jun 30 2018 kibana-rwxr-xr-x. 1 es es 588 Jun 30 2018 kibana-keystore-rwxr-xr-x. 1 es es 639 Jun 30 2018 kibana-plugin-rw-------. 1 es es 952696 Jul 10 09:17 nohup.out[root@192 bin]# su es[es@192 bin]$ nohup ./kibana &amp;[1] 4434[es@192 bin]$ nohup: ignoring input and appending output to `nohup.out&apos; cerebro管理工具查看]]></content>
      <categories>
        <category>搜索引擎</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[压力测试工具ab]]></title>
    <url>%2Fmyhexo%2F2019%2F07%2F06%2F%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7ab%2F</url>
    <content type="text"><![CDATA[压力测试工具ab下载Apache Haus Downloads 解压 测试-c代表并发数 -n代表请求总次数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758C:\Users\shenlibing\Downloads\httpd-2.4.34-o102o-x64-vc14\Apache24\bin&gt;ab -n 1000 -c 100 http://jd.com/This is ApacheBench, Version 2.3 &lt;$Revision: 1826891 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org/Benchmarking jd.com (be patient)Completed 100 requestsCompleted 200 requestsCompleted 300 requestsCompleted 400 requestsCompleted 500 requestsCompleted 600 requestsCompleted 700 requestsCompleted 800 requestsCompleted 900 requestsCompleted 1000 requestsFinished 1000 requestsServer Software: jfeServer Hostname: jd.comServer Port: 80Document Path: /Document Length: 165 bytesConcurrency Level: 100Time taken for tests: 88.367 secondsComplete requests: 1000Failed requests: 0Non-2xx responses: 1000Total transferred: 343000 bytesHTML transferred: 165000 bytesRequests per second: 11.32 [#/sec] (mean)Time per request: 8836.697 [ms] (mean)Time per request: 88.367 [ms] (mean, across all concurrent requests)Transfer rate: 3.79 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 51 88 178.8 59 1461Processing: 60 8357 2879.1 7889 14700Waiting: 60 4265 2937.5 3699 12704Total: 121 8445 2893.0 7951 14759Percentage of the requests served within a certain time (ms) 50% 7951 66% 9226 75% 10625 80% 11233 90% 12374 95% 13742 98% 14712 99% 14721 100% 14759 (longest request)C:\Users\shenlibing\Downloads\httpd-2.4.34-o102o-x64-vc14\Apache24\bin&gt;]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>ab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java动态代理]]></title>
    <url>%2Fmyhexo%2F2019%2F07%2F03%2Fjava%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[代理：设计模式代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理 相关的类和接口动态代理机制的主类java.lang.reflect.Proxy：这是 Java 动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象 方法一该方法用于获取指定代理对象所关联的调用处理器 123456789101112131415161718192021222324252627282930313233343536373839/** * Returns the invocation handler for the specified proxy instance. * * @param proxy the proxy instance to return the invocation handler for * @return the invocation handler for the proxy instance * @throws IllegalArgumentException if the argument is not a * proxy instance * @throws SecurityException if a security manager, &lt;em&gt;s&lt;/em&gt;, is present * and the caller's class loader is not the same as or an * ancestor of the class loader for the invocation handler * and invocation of &#123;@link SecurityManager#checkPackageAccess * s.checkPackageAccess()&#125; denies access to the invocation * handler's class. */ @CallerSensitive public static InvocationHandler getInvocationHandler(Object proxy) throws IllegalArgumentException &#123; /* * Verify that the object is actually a proxy instance. */ if (!isProxyClass(proxy.getClass())) &#123; throw new IllegalArgumentException("not a proxy instance"); &#125; final Proxy p = (Proxy) proxy; final InvocationHandler ih = p.h; if (System.getSecurityManager() != null) &#123; Class&lt;?&gt; ihClass = ih.getClass(); Class&lt;?&gt; caller = Reflection.getCallerClass(); if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(), ihClass.getClassLoader())) &#123; ReflectUtil.checkPackageAccess(ihClass); &#125; &#125; return ih; &#125; 方法二该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * Returns the &#123;@code java.lang.Class&#125; object for a proxy class * given a class loader and an array of interfaces. The proxy class * will be defined by the specified class loader and will implement * all of the supplied interfaces. If any of the given interfaces * is non-public, the proxy class will be non-public. If a proxy class * for the same permutation of interfaces has already been defined by the * class loader, then the existing proxy class will be returned; otherwise, * a proxy class for those interfaces will be generated dynamically * and defined by the class loader. * * &lt;p&gt;There are several restrictions on the parameters that may be * passed to &#123;@code Proxy.getProxyClass&#125;: * * &lt;ul&gt; * &lt;li&gt;All of the &#123;@code Class&#125; objects in the * &#123;@code interfaces&#125; array must represent interfaces, not * classes or primitive types. * * &lt;li&gt;No two elements in the &#123;@code interfaces&#125; array may * refer to identical &#123;@code Class&#125; objects. * * &lt;li&gt;All of the interface types must be visible by name through the * specified class loader. In other words, for class loader * &#123;@code cl&#125; and every interface &#123;@code i&#125;, the following * expression must be true: * &lt;pre&gt; * Class.forName(i.getName(), false, cl) == i * &lt;/pre&gt; * * &lt;li&gt;All non-public interfaces must be in the same package; * otherwise, it would not be possible for the proxy class to * implement all of the interfaces, regardless of what package it is * defined in. * * &lt;li&gt;For any set of member methods of the specified interfaces * that have the same signature: * &lt;ul&gt; * &lt;li&gt;If the return type of any of the methods is a primitive * type or void, then all of the methods must have that same * return type. * &lt;li&gt;Otherwise, one of the methods must have a return type that * is assignable to all of the return types of the rest of the * methods. * &lt;/ul&gt; * * &lt;li&gt;The resulting proxy class must not exceed any limits imposed * on classes by the virtual machine. For example, the VM may limit * the number of interfaces that a class may implement to 65535; in * that case, the size of the &#123;@code interfaces&#125; array must not * exceed 65535. * &lt;/ul&gt; * * &lt;p&gt;If any of these restrictions are violated, * &#123;@code Proxy.getProxyClass&#125; will throw an * &#123;@code IllegalArgumentException&#125;. If the &#123;@code interfaces&#125; * array argument or any of its elements are &#123;@code null&#125;, a * &#123;@code NullPointerException&#125; will be thrown. * * &lt;p&gt;Note that the order of the specified proxy interfaces is * significant: two requests for a proxy class with the same combination * of interfaces but in a different order will result in two distinct * proxy classes. * * @param loader the class loader to define the proxy class * @param interfaces the list of interfaces for the proxy class * to implement * @return a proxy class that is defined in the specified class loader * and that implements the specified interfaces * @throws IllegalArgumentException if any of the restrictions on the * parameters that may be passed to &#123;@code getProxyClass&#125; * are violated * @throws SecurityException if a security manager, &lt;em&gt;s&lt;/em&gt;, is present * and any of the following conditions is met: * &lt;ul&gt; * &lt;li&gt; the given &#123;@code loader&#125; is &#123;@code null&#125; and * the caller's class loader is not &#123;@code null&#125; and the * invocation of &#123;@link SecurityManager#checkPermission * s.checkPermission&#125; with * &#123;@code RuntimePermission("getClassLoader")&#125; permission * denies access.&lt;/li&gt; * &lt;li&gt; for each proxy interface, &#123;@code intf&#125;, * the caller's class loader is not the same as or an * ancestor of the class loader for &#123;@code intf&#125; and * invocation of &#123;@link SecurityManager#checkPackageAccess * s.checkPackageAccess()&#125; denies access to &#123;@code intf&#125;.&lt;/li&gt; * &lt;/ul&gt; * @throws NullPointerException if the &#123;@code interfaces&#125; array * argument or any of its elements are &#123;@code null&#125; */@CallerSensitivepublic static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) throws IllegalArgumentException&#123; final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; return getProxyClass0(loader, intfs);&#125; 方法三该方法用于判断指定类对象是否是一个动态代理类 1234567891011121314151617/** * Returns true if and only if the specified class was dynamically * generated to be a proxy class using the &#123;@code getProxyClass&#125; * method or the &#123;@code newProxyInstance&#125; method. * * &lt;p&gt;The reliability of this method is important for the ability * to use it to make security decisions, so its implementation should * not just test if the class in question extends &#123;@code Proxy&#125;. * * @param cl the class to test * @return &#123;@code true&#125; if the class is a proxy class and * &#123;@code false&#125; otherwise * @throws NullPointerException if &#123;@code cl&#125; is &#123;@code null&#125; */public static boolean isProxyClass(Class&lt;?&gt; cl) &#123; return Proxy.class.isAssignableFrom(cl) &amp;&amp; proxyClassCache.containsValue(cl);&#125; 方法四该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * Returns an instance of a proxy class for the specified interfaces * that dispatches method invocations to the specified invocation * handler. * * &lt;p&gt;&#123;@code Proxy.newProxyInstance&#125; throws * &#123;@code IllegalArgumentException&#125; for the same reasons that * &#123;@code Proxy.getProxyClass&#125; does. * * @param loader the class loader to define the proxy class * @param interfaces the list of interfaces for the proxy class * to implement * @param h the invocation handler to dispatch method invocations to * @return a proxy instance with the specified invocation handler of a * proxy class that is defined by the specified class loader * and that implements the specified interfaces * @throws IllegalArgumentException if any of the restrictions on the * parameters that may be passed to &#123;@code getProxyClass&#125; * are violated * @throws SecurityException if a security manager, &lt;em&gt;s&lt;/em&gt;, is present * and any of the following conditions is met: * &lt;ul&gt; * &lt;li&gt; the given &#123;@code loader&#125; is &#123;@code null&#125; and * the caller's class loader is not &#123;@code null&#125; and the * invocation of &#123;@link SecurityManager#checkPermission * s.checkPermission&#125; with * &#123;@code RuntimePermission("getClassLoader")&#125; permission * denies access;&lt;/li&gt; * &lt;li&gt; for each proxy interface, &#123;@code intf&#125;, * the caller's class loader is not the same as or an * ancestor of the class loader for &#123;@code intf&#125; and * invocation of &#123;@link SecurityManager#checkPackageAccess * s.checkPackageAccess()&#125; denies access to &#123;@code intf&#125;;&lt;/li&gt; * &lt;li&gt; any of the given proxy interfaces is non-public and the * caller class is not in the same &#123;@linkplain Package runtime package&#125; * as the non-public interface and the invocation of * &#123;@link SecurityManager#checkPermission s.checkPermission&#125; with * &#123;@code ReflectPermission("newProxyInPackage.&#123;package name&#125;")&#125; * permission denies access.&lt;/li&gt; * &lt;/ul&gt; * @throws NullPointerException if the &#123;@code interfaces&#125; array * argument or any of its elements are &#123;@code null&#125;, or * if the invocation handler, &#123;@code h&#125;, is * &#123;@code null&#125; */@CallerSensitivepublic static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException&#123; Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * Look up or generate the designated proxy class. */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125;&#125; 调用处理器接口java.lang.reflect.Proxy：这是 Java 动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象 核心方法该方法负责集中处理动态代理类上的所有方法调用。第一个参数既是代理类实例，第二个参数是被调用的方法对象第三个方法是调用参数。调用处理器根据这三个参数进行预处理或分派到委托类实例上发射执行 12public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; 创建动态代理版本一实现 InvocationHandler 接口通过实现 InvocationHandler 接口创建自己的调用处理器 创建动态代理类通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类 获得动态代理类的构造函数通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型 创建动态代理类实例通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入 代码123456789101112// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发// 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用InvocationHandler handler = new InvocationHandlerImpl(..); // 通过 Proxy 为包括 Interface 接口在内的一组接口动态创建代理类的类对象Class clazz = Proxy.getProxyClass(classLoader, new Class[] &#123; Interface.class, ... &#125;); // 通过反射从生成的类对象获得构造函数对象Constructor constructor = clazz.getConstructor(new Class[] &#123; InvocationHandler.class &#125;); // 通过构造函数对象创建动态代理类实例Interface Proxy = (Interface)constructor.newInstance(new Object[] &#123; handler &#125;); 版本二简化的动态代理对象创建过程 代码1234567// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发InvocationHandler handler = new InvocationHandlerImpl(..); // 通过 Proxy 直接创建动态代理类实例Interface proxy = (Interface)Proxy.newProxyInstance( classLoader, new Class[] &#123; Interface.class &#125;, handler ); 使用java动态代理Demo1编写接口Advice.java 12345678package com.zbiti.proxy;import java.lang.reflect.Method;public interface Advice &#123; void forwardMethod(Method method); void backMethod(Method method);&#125; 编写接口实现类AdviceImpl.java 12345678910111213141516171819package com.zbiti.proxy;import java.lang.reflect.Method;public class AdviceImpl implements Advice&#123; long beginTime = 0; @Override public void forwardMethod(Method method) &#123; System.out.println("end"); beginTime = System.currentTimeMillis(); &#125; @Override public void backMethod(Method method) &#123; System.out.println("start"); long endTime = System.currentTimeMillis(); System.out.println(method.getName() + " running time of " + (endTime - beginTime)); &#125;&#125; 测试ProxyTest.java 1234567891011121314151617181920212223242526272829303132333435363738package com.zbiti.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.ArrayList;import java.util.Collection;public class ProxyTest &#123; public static void main(String args[])&#123; //创建目标类的实例对象 ArrayList&lt;String&gt; target = new ArrayList&lt;&gt;(); AdviceImpl adviceImpl = new AdviceImpl(); //创建动态类 Collection proxy = (Collection) getProxy(target, adviceImpl); proxy.add("aa"); System.out.println(proxy.size()); System.out.println(proxy.getClass().getName()); &#125; public static Object getProxy(final Object target, final Advice advice)&#123; Object proxy = Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; //动态类通过Invocation类的invoke方法调用目标类所需的方法 public Object invoke(Object proxy, Method method, Object[] args) throws Exception &#123; advice.forwardMethod(method); Object retVal = method.invoke(target, args); advice.backMethod(method); return retVal; &#125; &#125; ); return proxy; &#125;&#125; 结果： 12345678910endstartadd running time of 0endstartsize running time of 01com.sun.proxy.$Proxy0Process finished with exit code 0 Demo2手动实现一个数据库连接池, 没有使用代理模式的情况下如下： MyPool.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.zbiti.proxy;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.util.LinkedList;public class MyPool &#123; // 初始化连接数目 private int init_count = 3; // 最大连接数 private int max_count = 6; // 记录当前使用连接数 private int current_count = 0; // 连接池 （存放所有的初始化连接） private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;(); //1. 构造函数中，初始化连接放入连接池 public MyPool() &#123; // 初始化连接 for (int i = 0; i &lt; init_count; i++) &#123; // 记录当前连接数目 current_count++; // 创建原始的连接对象 Connection con = createConnection(); // 把连接加入连接池 pool.addLast(con); &#125; &#125; //2. 创建一个新的连接的方法 private Connection createConnection() &#123; try &#123; Class.forName("com.mysql.jdbc.Driver"); // 原始的目标对象 Connection con = DriverManager.getConnection("jdbc:mysql://192.168.1.101:3306/cmj", "root", "000000"); return con; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; //3. 获取连接 public Connection getConnection() &#123; // 3.1 判断连接池中是否有连接, 如果有连接，就直接从连接池取出 if (pool.size() &gt; 0) &#123; return pool.removeFirst(); &#125; // 3.2 连接池中没有连接： 判断，如果没有达到最大连接数，创建； if (current_count &lt; max_count) &#123; // 记录当前使用的连接数 current_count++; // 创建连接 return createConnection(); &#125; // 3.3 如果当前已经达到最大连接数，抛出异常 throw new RuntimeException("当前连接已经达到最大连接数目 ！"); &#125; //4. 释放连接 public void realeaseConnection(Connection con) &#123; // 4.1 判断： 池的数目如果小于初始化连接，就放入池中 if (pool.size() &lt; init_count) &#123; pool.addLast(con); &#125; else &#123; try &#123; // 4.2 关闭 current_count--; con.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; // 测试： public static void main(String[] args) throws SQLException &#123; MyPool pool = new MyPool(); System.out.println("当前连接: " + pool.current_count); // 3 // 使用连接 pool.getConnection(); pool.getConnection(); Connection con4 = pool.getConnection(); Connection con3 = pool.getConnection(); Connection con2 = pool.getConnection(); Connection con1 = pool.getConnection(); // 释放连接, 连接放回连接池// pool.realeaseConnection(con1); /* * 希望：当关闭连接的时候，要把连接放入连接池！【当调用Connection接口的close方法时候，希望触发pool.addLast(con);操作】把连接放入连接池 * 解决1：实现Connection接口，重写close方法 connection接口方法太多，都实现太麻烦，放弃 * 解决2：动态代理 */ con1.close(); // 再获取 pool.getConnection(); System.out.println("连接池：" + pool.pool.size()); // 0 System.out.println("当前连接: " + pool.current_count); // 3 &#125;&#125; 使用代理模式 MyPool2.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package com.zbiti.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.util.LinkedList;/** * JDK 动态代理 Object obj = Proxy.newProxyInstance(....)； * 1.参数1：ClassLoader loader ,确定类加载器。程序运行时动态创建类，需要类加载加载到内存。类加载器作用：class文件 --&gt; Class对象 * * 一般情况使用都是当前类的类加载器 * * 类加载器获得方式：MyFactory.class.getClassLoader(); * 2.参数2：Class[] interfaces 代理需要实现的接口们（可能有多个） * * 方式1：userService.getClass().getInterfaces()【此方式只能在代理对象和接口是父子关系时使用】 * * 方式2：new Class[]&#123;UserService.class&#125;【当被代理对象和其实现接口之间是隔代关系时（即祖孙关系）(即:一个一个列出接口) * 3.参数3：InvocationHandler h 请求处理类，代理类方法执行时，需要请求处理类来处理。 * * 一般采用匿名内部类：new InvocationHandler()&#123;&#125; * * 实现方法 invoke ，代理类每一个方法执行一次，将调用一次invoke * 参数1.1：Object proxy ,代理对象（即 proxyService，不是“代理之前对象”），一般不用。 * 参数2.2：Method method ，当前执行的方法 * * 当前调用方法名：method.getName(); * * 执行目标类方法：Object obj = method.invoke(代理之前对象 , args) * 参数3.3：Object[] args * * 当前方法实际参数 */public class MyPool2 &#123; // 初始化连接数目 private int init_count = 3; // 最大连接数 private int max_count = 6; // 记录当前使用连接数 private int current_count = 0; // 连接池 （存放所有的初始化连接） private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;(); //1. 构造函数中，初始化连接放入连接池 public MyPool2() &#123; // 初始化连接 for (int i=0; i&lt;init_count; i++)&#123; // 记录当前连接数目 current_count++; // 创建原始的连接对象 Connection con = createConnection(); // 把连接加入连接池 pool.addLast(con); &#125; &#125; //2. 创建一个新的连接的方法 private Connection createConnection()&#123; try &#123; Class.forName("com.mysql.jdbc.Driver"); // 原始的目标对象 final Connection con = DriverManager.getConnection("jdbc:mysql://192.168.1.101:3306/cmj", "root", "000000"); /**********对con对象代理**************/ // 对con创建其代理对象 Connection proxy = (Connection) Proxy.newProxyInstance( con.getClass().getClassLoader(), // 类加载器 //con.getClass().getInterfaces(), // 当目标对象是一个具体的类的时候 new Class[]&#123;Connection.class&#125;, // 目标对象实现的接口 new InvocationHandler() &#123; // 当调用con对象方法的时候， 自动触发事务处理器 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 方法返回值 Object result = null; // 当前执行的方法的方法名 String methodName = method.getName(); // 判断当执行了close方法的时候，把连接放入连接池 if ("close".equals(methodName)) &#123; System.out.println("begin:当前执行close方法开始！"); // 连接放入连接池 pool.addLast(con); System.out.println("end: 当前连接已经放入连接池了！"); &#125; else &#123; // 调用目标对象方法，注意这里不是代理对象 result = method.invoke(con, args); &#125; return result; &#125; &#125; ); return proxy; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; //3. 获取连接 public Connection getConnection()&#123; // 3.1 判断连接池中是否有连接, 如果有连接，就直接从连接池取出 if (pool.size() &gt; 0)&#123; return pool.removeFirst(); &#125; // 3.2 连接池中没有连接： 判断，如果没有达到最大连接数，创建； if (current_count &lt; max_count) &#123; // 记录当前使用的连接数 current_count++; // 创建连接 return createConnection(); &#125; // 3.3 如果当前已经达到最大连接数，抛出异常 throw new RuntimeException("当前连接已经达到最大连接数目 ！"); &#125; //4. 释放连接 public void realeaseConnection(Connection con) &#123; // 4.1 判断： 池的数目如果小于初始化连接，就放入池中 if (pool.size() &lt; init_count)&#123; pool.addLast(con); &#125; else &#123; try &#123; // 4.2 关闭 current_count--; con.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; // 测试： public static void main(String[] args) throws SQLException &#123; MyPool2 pool = new MyPool2(); System.out.println("当前连接: " + pool.current_count); // 3 // 使用连接 pool.getConnection(); pool.getConnection(); Connection con4 = pool.getConnection(); Connection con3 = pool.getConnection(); Connection con2 = pool.getConnection(); Connection con1 = pool.getConnection(); // 释放连接, 连接放回连接池// pool.realeaseConnection(con1); /* * 希望：当关闭连接的时候，要把连接放入连接池！【当调用Connection接口的close方法时候，希望触发pool.addLast(con);操作】把连接放入连接池 * 解决1：实现Connection接口，重写close方法 * 解决2：动态代理 */ con1.close(); // 再获取 pool.getConnection(); System.out.println("连接池：" + pool.pool.size()); // 0 System.out.println("当前连接: " + pool.current_count); // 3 &#125;&#125; 参考Java 动态代理机制分析及扩展，第 1 部分 Java基础学习(4)——动态代理 - 王泽远的博客 | Crow’s Blog]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringData]]></title>
    <url>%2Fmyhexo%2F2019%2F06%2F15%2FSpringData%2F</url>
    <content type="text"><![CDATA[涉及技术介绍HibernateYour relational data. Objectively. - Hibernate ORM Object/Relational MappingHibernate ORM enables developers to more easily write applications whose data outlives the application process. As an Object/Relational Mapping (ORM) framework, Hibernate is concerned with data persistence as it applies to relational databases (via JDBC). Unfamiliar with the notion of ORM? Read here. JPA ProviderIn addition to its own “native” API, Hibernate is also an implementation of the Java Persistence API (JPA) specification. As such, it can be easily used in any environment supporting JPA including Java SE applications, Java EE application servers, Enterprise OSGi containers, etc. Idiomatic persistenceHibernate enables you to develop persistent classes following natural Object-oriented idioms including inheritance, polymorphism, association, composition, and the Java collections framework. Hibernate requires no interfaces or base classes for persistent classes and enables any class or data structure to be persistent. High PerformanceHibernate supports lazy initialization, numerous fetching strategies and optimistic locking with automatic versioning and time stamping. Hibernate requires no special database tables or fields and generates much of the SQL at system initialization time instead of at runtime. Hibernate consistently offers superior performance over straight JDBC code, both in terms of developer productivity and runtime performance. ScalabilityHibernate was designed to work in an application server cluster and deliver a highly scalable architecture. Hibernate scales well in any environment: Use it to drive your in-house Intranet that serves hundreds of users or for mission-critical applications that serve hundreds of thousands. ReliableHibernate is well known for its excellent stability and quality, proven by the acceptance and use by tens of thousands of Java developers. ExtensibilityHibernate is highly configurable and extensible. JPA 标准Java Persistence API - Wikipedia The Java Persistence API (JPA) is a Java application programming interface specification that describes the management of relational data in applications using Java Platform, Standard Edition and Java Platform, Enterprise Edition. Persistence in this context covers three areas: the API itself, defined in the javax.persistence package the Java Persistence Query Language (JPQL) object/relational metadata Hibernate JPAHibernate 在3.2 以后根据JPA 规范提供了一套操作持久层的 API Spring DataSpring Data Spring Data’s mission is to provide a familiar and consistent, Spring-based programming model for data access while still retaining the special traits of the underlying data store. It makes it easy to use data access technologies, relational and non-relational databases, map-reduce frameworks, and cloud-based data services. This is an umbrella project which contains many subprojects that are specific to a given database. The projects are developed by working together with many of the companies and developers that are behind these exciting technologies. Spring Data JPASpring Data JPA Spring Data JPA, part of the larger Spring Data family, makes it easy to easily implement JPA based repositories. This module deals with enhanced support for JPA based data access layers. It makes it easier to build Spring-powered applications that use data access technologies. Implementing a data access layer of an application has been cumbersome for quite a while. Too much boilerplate code has to be written to execute simple queries as well as perform pagination, and auditing. Spring Data JPA aims to significantly improve the implementation of data access layers by reducing the effort to the amount that’s actually needed. As a developer you write your repository interfaces, including custom finder methods, and Spring will provide the implementation automatically. Spring Data RedisSpring Data Redis Spring Data Redis, part of the larger Spring Data family, provides easy configuration and access to Redis from Spring applications. It offers both low-level and high-level abstractions for interacting with the store, freeing the user from infrastructural concerns. Spring 整合 Hibernate导入jar包spring jar包spring-iocspring-beans-4.2.0.RELEASE.jar spring-context-4.2.0.RELEASE.jar spring-core-4.2.0.RELEASE.jar spring-expression-4.2.0.RELEASE.jar spring-aopaopalliance.jar aspectjrt.jar aspectjweaver.jar spring-aop-4.2.0.RELEASE.jar spring-aspects-4.2.0.RELEASE.jar spring-jdbcspring-jdbc-4.2.0.RELEASE.jar spring-tx-4.2.0.RELEASE.jar spring-ormspring-orm-4.2.0.RELEASE.jar spring-testspring-test-4.2.0.RELEASE.jar apache-loggingcommons-logging-1.1.1.jar hibernate jar包hibernate-coreantlr-2.7.7.jar dom4j-1.6.1.jar geronimo-jta_1.1_spec-1.1.1.jar hibernate-commons-annotations-5.0.1.Final.jar hibernate-core-5.0.7.Final.jar hibernate-jpa-2.1-api-1.0.0.Final.jar jandex-2.0.0.Final.jar javassist-3.18.1-GA.jar jboss-logging-3.3.0.Final.jar mysqql-drivermysql-connector-java-5.1.7-bin.jar c3p0连接池c3p0-0.9.2.1.jar hibernate-c3p0-5.0.7.Final.jar mchange-commons-java-0.2.3.4.jar spring整合hibernate编写配置文件 配置读取properties文件的工具类 配置c3p0数据库连接池 配置Hibernate的SeesionFactory 配置Hibernate的事务管理器 配置开启注解事务处理 配置springIOC的注解扫描 applicationContext.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 配置读取properties文件的工具类 --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!-- 配置c3p0数据库连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver.class&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt; &lt;!-- 配置Hibernate的SeesionFactory --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- hibernateProperties属性：配置与hibernate相关的内容，如显示sql语句，开启正向工程 --&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;!-- 显示当前执行的sql语句 --&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;!-- 开启正向工程 --&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 扫描实体所在的包 --&gt; &lt;property name="packagesToScan"&gt; &lt;list&gt; &lt;value&gt;com.bjsxt.pojo&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Hibernate的事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory"/&gt; &lt;/bean&gt; &lt;!-- 配置开启注解事务处理 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;!-- 配置springIOC的注解扫描 --&gt; &lt;context:component-scan base-package="com.bjsxt"/&gt;&lt;/beans&gt; hibernate完成CRUD创建数据库 编写实体类Users.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.bjsxt.pojo;import java.io.Serializable;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;@Entity@Table(name="t_users")public class Users implements Serializable&#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY)//strategy=GenerationType.IDENTITY 自增长 @Column(name="userid") private Integer userid; @Column(name="username") private String username; @Column(name="userage") private Integer userage; public Integer getUserid() &#123; return userid; &#125; public void setUserid(Integer userid) &#123; this.userid = userid; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Integer getUserage() &#123; return userage; &#125; public void setUserage(Integer userage) &#123; this.userage = userage; &#125; @Override public String toString() &#123; return "Users [userid=" + userid + ", username=" + username + ", userage=" + userage + "]"; &#125; &#125; 修改配置文件添加 HibernateTemplate，修改applicationContext.xml配置文件 1234&lt;!-- 配置HiberanteTemplate对象 --&gt;&lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate5.HibernateTemplate"&gt; &lt;property name="sessionFactory" ref="sessionFactory"/&gt;&lt;/bean&gt; 编写接口UsersDao.java 1234567891011121314package com.bjsxt.dao;import java.util.List;import com.bjsxt.pojo.Users;public interface UsersDao &#123; void insertUsers(Users users); void updateUsers(Users users); void deleteUsers(Users users); Users selectUsersById(Integer userid); &#125; 编写实现类UsersDaoImpl.java 123456789101112131415161718192021222324252627282930313233343536373839404142package com.bjsxt.dao.impl;import java.util.List;import org.hibernate.Query;import org.hibernate.Session;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.orm.hibernate5.HibernateTemplate;import org.springframework.stereotype.Repository;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;@Repositorypublic class UsersDaoImpl implements UsersDao &#123; @Autowired private HibernateTemplate hibernateTemplate; @Override public void insertUsers(Users users) &#123; this.hibernateTemplate.save(users); &#125; @Override public void updateUsers(Users users) &#123; this.hibernateTemplate.update(users); &#125; @Override public void deleteUsers(Users users) &#123; this.hibernateTemplate.delete(users); &#125; @Override public Users selectUsersById(Integer userid) &#123; return this.hibernateTemplate.get(Users.class, userid); &#125;&#125; 编写测试代码UsersDaoImplTest.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.bjsxt.test;import java.util.List;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class UsersDaoImplTest &#123; @Autowired private UsersDao usersDao; /** * 添加用户 */ @Test @Transactional// 在测试类对于事务提交方式默认的是回滚。 @Rollback(false)//取消自动回滚 public void testInsertUsers()&#123; Users users = new Users(); users.setUserage(20); users.setUsername("张三"); this.usersDao.insertUsers(users); &#125; /** * 更新用户 */ @Test @Transactional @Rollback(false) public void testUpdateUsers()&#123; Users users = new Users(); users.setUserid(2); users.setUserage(22); users.setUsername("李四"); this.usersDao.updateUsers(users); &#125; /** * 根据userid查询用户 */ @Test public void testSelectUsersById()&#123; Users users = this.usersDao.selectUsersById(2); System.out.println(users); &#125; /** * 删除用户 */ @Test @Transactional @Rollback(false) public void testDeleteUsers()&#123; Users users = new Users(); users.setUserid(2); this.usersDao.deleteUsers(users); &#125; &#125; HQL查询HQL：Hibernate Query LanguageHQL的语法：就是将原来的 sql语句中的表与字段名称换成对象与属性的名称就可以了 修改接口添加查询方法 1List&lt;Users&gt; selectUserByName(String username); 修改实现类实现查询方法 12345678910@Overridepublic List&lt;Users&gt; selectUserByName(String username) &#123; //getCurrentSession:当前session必须要有事务边界，且只能处理唯一的一个事务。当事务提交或者回滚后session自动失效 //openSession:每次都会打开一个新的session.加入每次使用多次。则获得的是不同session对象。使用完毕后我们需要手动的调用colse方法关闭sessionSession session = this.hibernateTemplate.getSessionFactory().getCurrentSession();//sql:select * from t_users where username = Query query = session.createQuery("from Users where username = :abc");Query queryTemp = query.setString("abc",username); return queryTemp.list();&#125; 编写测试代码测试HQL查询 1234567891011/** * HQL测试 */@Test@Transactionalpublic void testSelectUserByName()&#123; List&lt;Users&gt; list = this.usersDao.selectUserByName("张三"); for (Users users : list) &#123; System.out.println(users); &#125;&#125; SQL查询修改接口添加查询方法 1List&lt;Users&gt; selectUserByNameUseSQL(String username); 修改实现类实现查询方法 123456@Overridepublic List&lt;Users&gt; selectUserByNameUseSQL(String username) &#123; Session session = this.hibernateTemplate.getSessionFactory().getCurrentSession(); Query query = session.createSQLQuery("select * from t_users where username = ?").addEntity(Users.class).setString(0, username); return query.list();&#125; 编写测试代码测试SQL查询 1234567891011/** * SQL测试 */@Test@Transactionalpublic void testSelectUserByNameUseSQL()&#123; List&lt;Users&gt; list = this.usersDao.selectUserByNameUseSQL("张三"); for (Users users : list) &#123; System.out.println(users); &#125;&#125; QBC查询QBC：Query By Criteria 修改接口添加查询方法 1List&lt;Users&gt; selectUserByNameUseCriteria(String username); 修改实现类实现接口查询方法 12345678@Overridepublic List&lt;Users&gt; selectUserByNameUseCriteria(String username) &#123; Session session = this.hibernateTemplate.getSessionFactory().getCurrentSession(); //sql:select * from t_users where username = 张三 Criteria c = session.createCriteria(Users.class); c.add(Restrictions.eq("username", username)); return c.list();&#125; 编写测试代码测试QBC查询 1234567891011/** * Criteria测试 */@Test@Transactionalpublic void testSelectUserByNameUseCriteria()&#123; List&lt;Users&gt; list = this.usersDao.selectUserByNameUseCriteria("张三"); for (Users users : list) &#123; System.out.println(users); &#125;&#125; Spring整合Hibernate JPAJPA：由 Sun公司提供了一对对于持久层操作的标准(接口+文档)Hibernate:是 Gavin King开发的一套对于持久层操作的自动的ORM框架。Hibernate JPA:是在Hibernate3.2版本那种提供了对于 JPA的标准的实现。提供了一套按照 JPA 标准来实现持久层开发的 API 导入jar包在项目中导入 HIbernateJPA相关的 jar hibernate-entitymanager-5.0.7.Final.jar 修改配置文件修改applicationContext.xml配置文件 配置读取properties文件的工具类 配置c3p0数据库连接池 Spring整合JPA 配置EntityManagerFactory 配置jpa的事务管理器 配置开启注解事务处理 配置springIOC的注解扫描 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 配置读取properties文件的工具类 --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!-- 配置c3p0数据库连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver.class&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt; &lt;!-- Spring整合JPA 配置EntityManagerFactory--&gt; &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="jpaVedorAdapter"&gt; &lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"&gt; &lt;!-- hibernate相关的属性的注入 --&gt; &lt;!-- 配置数据库类型 --&gt; &lt;property name="database" value="MYSQL"/&gt; &lt;!-- 正向工程 自动创建表 --&gt; &lt;property name="generateDdl" value="true"/&gt; &lt;!-- 显示执行的SQL --&gt; &lt;property name="showSql" value="true"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 扫描实体的包 --&gt; &lt;property name="packagesToScan"&gt; &lt;list&gt; &lt;value&gt;com.bjsxt.pojo&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置jpa的事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager"&gt; &lt;property name="entityManagerFactory" ref="entityManagerFactory"/&gt; &lt;/bean&gt; &lt;!-- 配置开启注解事务处理 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;!-- 配置springIOC的注解扫描 --&gt; &lt;context:component-scan base-package="com.bjsxt"/&gt;&lt;/beans&gt; Hibernate JPA的CRUD编写实体类Users.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.bjsxt.pojo;import java.io.Serializable;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;@Entity@Table(name="t_users")public class Users implements Serializable&#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY)//strategy=GenerationType.IDENTITY 自增长 @Column(name="userid") private Integer userid; @Column(name="username") private String username; @Column(name="userage") private Integer userage; public Integer getUserid() &#123; return userid; &#125; public void setUserid(Integer userid) &#123; this.userid = userid; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Integer getUserage() &#123; return userage; &#125; public void setUserage(Integer userage) &#123; this.userage = userage; &#125; @Override public String toString() &#123; return "Users [userid=" + userid + ", username=" + username + ", userage=" + userage + "]"; &#125; &#125; 编写接口UsersDao.java 1234567891011121314package com.bjsxt.dao;import java.util.List;import com.bjsxt.pojo.Users;public interface UsersDao &#123; void insertUsers(Users users); void updateUsers(Users users); void deleteUsers(Users users); Users selectUsersById(Integer userid);&#125; 编写实现类UsersDaoImpl.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.bjsxt.dao.impl;import java.util.List;import javax.persistence.EntityManager;import javax.persistence.PersistenceContext;import org.hibernate.Criteria;import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.criterion.Restrictions;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.orm.hibernate5.HibernateTemplate;import org.springframework.stereotype.Repository;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;@Repositorypublic class UsersDaoImpl implements UsersDao &#123; @PersistenceContext(name="entityManagerFactory") private EntityManager entityManager; @Override public void insertUsers(Users users) &#123; this.entityManager.persist(users); &#125; @Override public void updateUsers(Users users) &#123; this.entityManager.merge(users); &#125; @Override public void deleteUsers(Users users) &#123; Users u = this.selectUsersById(users.getUserid()); this.entityManager.remove(u); &#125; @Override public Users selectUsersById(Integer userid) &#123; return this.entityManager.find(Users.class, userid); &#125;&#125; 编写测试代码UsersDaoImplTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.bjsxt.test;import java.util.List;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class UsersDaoImplTest &#123; @Autowired private UsersDao usersDao; /** * 添加用户 */ @Test @Transactional// 在测试类对于事务提交方式默认的是回滚。 @Rollback(false)//取消自动回滚 public void testInsertUsers()&#123; Users users = new Users(); users.setUserage(24); users.setUsername("王小丽"); this.usersDao.insertUsers(users); &#125; /** * 更新用户 */ @Test @Transactional @Rollback(false) public void testUpdateUsers()&#123; Users users = new Users(); users.setUserid(5); users.setUserage(22); users.setUsername("王五"); this.usersDao.updateUsers(users); &#125; /** * 根据userid查询用户 */ @Test public void testSelectUsersById()&#123; Users users = this.usersDao.selectUsersById(4); System.out.println(users); &#125; /** * 删除用户 */ @Test @Transactional @Rollback(false) public void testDeleteUsers()&#123; Users users = new Users(); users.setUserid(4); this.usersDao.deleteUsers(users); &#125;&#125; HQL查询修改接口添加HQL查询方法 1List&lt;Users&gt; selectUserByName(String username); 修改实现类实现HQL查询接口方法 1234@Overridepublic List&lt;Users&gt; selectUserByName(String username) &#123; return this.entityManager.createQuery(" from Users where username = :abc").setParameter("abc", username).getResultList();&#125; 修改测试代码测试HQL查询 1234567891011/** * HQL测试 */@Test@Transactionalpublic void testSelectUserByName()&#123; List&lt;Users&gt; list = this.usersDao.selectUserByName("王五"); for (Users users : list) &#123; System.out.println(users); &#125;&#125; SQL查询修改接口添加SQL查询方法 1List&lt;Users&gt; selectUserByNameUseSQL(String username); 修改实现类实现SQL查询接口方法 12345@Overridepublic List&lt;Users&gt; selectUserByNameUseSQL(String username) &#123; //在Hibernate JPA中 如果通过？方式来帮顶参数，那么他的查数是从1开始的。而hibernate中是从0开始的。 return this.entityManager.createNativeQuery("select * from t_users where username = ?", Users.class).setParameter(1, username).getResultList();&#125; 修改测试代码测试SQL查询 1234567891011/** * SQL测试 */@Test@Transactionalpublic void testSelectUserByNameUseSQL()&#123; List&lt;Users&gt; list = this.usersDao.selectUserByNameUseSQL("王五"); for (Users users : list) &#123; System.out.println(users); &#125;&#125; QBC查询修改接口添加QBC查询方法 1List&lt;Users&gt; selectUserByNameUseCriteria(String username); 修改实现类实现QBC查询接口方法 1234567891011121314151617@Overridepublic List&lt;Users&gt; selectUserByNameUseCriteria(String username) &#123; //CriteriaBuilder对象：创建一个CriteriaQuery,创建查询条件。 CriteriaBuilder builber = this.entityManager.getCriteriaBuilder(); //CriteriaQuery对象：执行查询的Criteria对象 //select * from t_users CriteriaQuery&lt;Users&gt; query = builber.createQuery(Users.class); //获取要查询的实体类的对象 Root&lt;Users&gt; root = query.from(Users.class); //封装查询条件 Predicate cate = builber.equal(root.get("username"), username); //select * from t_users where username = 张三 query.where(cate); //执行查询 TypedQuery&lt;Users&gt; typeQuery = this.entityManager.createQuery(query); return typeQuery.getResultList();&#125; 修改测试代码测试QBC查询 1234567891011/** * Criteria测试 */@Test@Transactionalpublic void testSelectUserByNameUseCriteria()&#123; List&lt;Users&gt; list = this.usersDao.selectUserByNameUseCriteria("王五"); for (Users users : list) &#123; System.out.println(users); &#125;&#125; Spring Data JPASpring Data JPA：Spring Data JPA 是spring data项目下的一个模块。提供了一套基于JPA标准操作数据库的简化方案。底层默认的是依赖 Hibernate JPA来实现的。Spring Data JPA的技术特点：我们只需要定义接口并集成Spring Data JPA中所提供的接口就可以了。不需要编写接口实现类。 入门导入jar包在spring整合hibernate、hibernate JPA的基础jar包上添加 spring-data-commons-1.11.0.RELEASE.jar spring-data-jpa-1.9.0.RELEASE.jar slf4j-api-1.6.1.jar slf4j-log4j12-1.7.2.jar log4j-1.2.16.jar 修改配置文件 JPA命名空间xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot; Spring Data JPA 的配置&lt;jpa:repositories base-package=&quot;com.bjsxt.dao&quot;/&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jpa="http://www.springframework.org/schema/data/jpa" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 配置读取properties文件的工具类 --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!-- 配置c3p0数据库连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver.class&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt; &lt;!-- Spring整合JPA 配置EntityManagerFactory--&gt; &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="jpaVendorAdapter"&gt; &lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"&gt; &lt;!-- hibernate相关的属性的注入 --&gt; &lt;!-- 配置数据库类型 --&gt; &lt;property name="database" value="MYSQL"/&gt; &lt;!-- 正向工程 自动创建表 --&gt; &lt;property name="generateDdl" value="true"/&gt; &lt;!-- 显示执行的SQL --&gt; &lt;property name="showSql" value="true"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 扫描实体的包 --&gt; &lt;property name="packagesToScan"&gt; &lt;list&gt; &lt;value&gt;com.bjsxt.pojo&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Hibernate的事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager"&gt; &lt;property name="entityManagerFactory" ref="entityManagerFactory"/&gt; &lt;/bean&gt; &lt;!-- 配置开启注解事务处理 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;!-- 配置springIOC的注解扫描 --&gt; &lt;context:component-scan base-package="com.bjsxt"/&gt; &lt;!-- Spring Data JPA 的配置 --&gt; &lt;!-- base-package：扫描dao接口所在的包 --&gt; &lt;jpa:repositories base-package="com.bjsxt.dao"/&gt;&lt;/beans&gt; 编写DAO1234567891011package com.bjsxt.dao;import org.springframework.data.jpa.repository.JpaRepository;import com.bjsxt.pojo.Users;public interface UsersDao extends JpaRepository&lt;Users, Integer&gt; &#123; &#125; 编写测试代码 JUnit单元测试，事务默认是回滚的 12345678910111213141516171819202122232425262728293031323334353637package com.bjsxt.test;import java.util.List;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class UsersDaoImplTest &#123; @Autowired private UsersDao usersDao; /** * 添加用户 */ @Test @Transactional// 在测试类对于事务提交方式默认的是回滚。 @Rollback(false)//取消自动回滚 public void testInsertUsers()&#123; Users users = new Users(); users.setUserage(24); users.setUsername("张三"); this.usersDao.save(users); &#125; &#125; 接口继承结构 运行原理 入门编写测试代码时，我们注入了接口UsersDao,自己并没有实现save但是可以直接调用，实际上通过工厂对象JpaRepositoryFactory帮我们生成了代理对象 123456789101112131415@PersistenceContext(name="entityManagerFactory")private EntityManager em;@Testpublic void test1()&#123;//org.springframework.data.jpa.repository.support.SimpleJpaRepository@fba8bf//System.out.println(this.usersDao);//class com.sun.proxy.$Proxy29 代理对象 是基于 JDK 的动态代理方式创建的//System.out.println(this.usersDao.getClass());JpaRepositoryFactory factory = new JpaRepositoryFactory(em);//getRepository(UsersDao.class);可以帮助我们为接口生成实现类。而这个实现类是 SimpleJpaRepository 的对象//要求：该接口必须要是继承 Repository 接口UsersDao ud = factory.getRepository(UsersDao.class);System.out.println(ud);System.out.println(ud.getClass());&#125; Repository接口Repository 接口是 Spring Data JPA 中为我我们提供的所有接口中的顶层接口Repository提供了两种查询方式的支持 基于方法名称命名规则查询 基于@Query 注解查询 方法名称命名规则查询 规则：findBy(关键字)+属性名称(属性名称的首字母大写)+查询条件(首字母大写) 关键字 方法命名 sql where 子句 And findByNameAndPwd where name= ? and pwd =? Or findByNameOrSex where name= ? or sex=? Is,Equal findById,findByIdEquals where id= ? Between findByIdBetween where id between ? and ? LessThan findByIdLessThan where id &lt; ? LessThanEqual findByIdLessThanEquals where id &lt;= ? GreaterThan findByIdGreaterThan where id &gt; ? GreaterThanEqual findByIdGreaterThanEquals where id &gt; = ? After findByIdAfter where id &gt; ? Before findByIdBefore where id &lt; ? IsNull findByNameIsNull where name is null isNotNull,NotNull findByNameNotNull where name is not null Like findByNameLike whre name like ? NotLike findByNameNotLike where name not like ? StartingWith findByNameStartingWith where name like ‘?%’ EndingWith findByNameEndingWith where name like ‘%?’ Containing findByNameContaining where name like ‘%?%’ OrderBy findByIdOrderByXDesc where id=? order by x desc Not findByNameNot where name &lt;&gt; ? In findByIdIn(Collection&lt;?&gt; c) where id in (?) NotIn findByIdNotIn(Collection&lt;?&gt; c) where id not in (?) True findByAaaTue where aaa = true False findByAaaFalse where aaa = false IgnoreCase findByNameIgnoreCase where UPPER(name)=UPPER(?) 编写接口 UsersDao.java 123456789101112131415161718192021package com.bjsxt.dao;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.repository.Repository;import com.bjsxt.pojo.Users;/** * Repository接口讲解 * @author Administrator * */public interface UsersDao extends Repository&lt;Users, Integer&gt; &#123; List&lt;Users&gt; findByUsernameIs(String string); List&lt;Users&gt; findByUsernameLike(String string); List&lt;Users&gt; findByUsernameAndUserageGreaterThanEqual(String name,Integer age);&#125; 编写测试类 RepositoryTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.bjsxt.test;import java.util.List;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;/** * Repository接口测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class RepositoryTest &#123; @Autowired private UsersDao usersDao; /** * 需求：使用用户名作为查询条件 */ @Test public void test1()&#123; /** * 判断相等的条件，有三种表示方式 * 1,什么都不写，默认的就是做相等判断 * 2,Is * 3,Equal */ List&lt;Users&gt; list = this.usersDao.findByUsernameIs("王五"); for (Users users : list) &#123; System.out.println(users); &#125; &#125; /** * 需求：根据用户姓名做Like处理 * Like:条件关键字 */ @Test public void test2()&#123; List&lt;Users&gt; list = this.usersDao.findByUsernameLike("王%"); for (Users users : list) &#123; System.out.println(users); &#125; &#125; /** * 需求：查询名称为王五，并且他的年龄大于等于22岁 */ @Test public void test3()&#123; List&lt;Users&gt; list = this.usersDao.findByUsernameAndUserageGreaterThanEqual("王五", 22); for (Users users : list) &#123; System.out.println(users); &#125; &#125;&#125; @Query 注解的查询JPQL语句查询JPQL：通过 Hibernate 的HQL演变过来的。他和 HQL语法及其相似 编写接口 @Query(value=&quot;from Users where username = ?&quot;)—&gt;表：实体对象，字段：属性 UsersDao.java 12345678910111213141516171819202122232425262728package com.bjsxt.dao;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import org.springframework.data.repository.Repository;import com.bjsxt.pojo.Users;/** * Repository接口讲解 * @author Administrator * */public interface UsersDao extends Repository&lt;Users, Integer&gt; &#123; //使用@Query注解查询 @Query(value="from Users where username = ?") List&lt;Users&gt; queryUserByNameUseJPQL(String name); @Query("from Users where username like ?") List&lt;Users&gt; queryUserByLikeNameUseJPQL(String name); @Query("from Users where username = ? and userage &gt;= ?") List&lt;Users&gt; queryUserByNameAndAge(String name,Integer age);&#125; 编写测试类RepositoryTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.bjsxt.test;import java.util.List;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;/** * Repository接口测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class RepositoryTest &#123; @Autowired private UsersDao usersDao; /** * 测试@Query查询 JPQL */ @Test public void test4()&#123; List&lt;Users&gt; list = this.usersDao.queryUserByNameUseJPQL("王五"); for (Users users : list) &#123; System.out.println(users); &#125; &#125; /** * 测试@Query查询 JPQL */ @Test public void test5()&#123; List&lt;Users&gt; list = this.usersDao.queryUserByLikeNameUseJPQL("王%"); for (Users users : list) &#123; System.out.println(users); &#125; &#125; /** * 测试@Query查询 JPQL */ @Test public void test6()&#123; List&lt;Users&gt; list = this.usersDao.queryUserByNameAndAge("王五", 22); for (Users users : list) &#123; System.out.println(users); &#125; &#125; &#125; SQL语句查询 原生SQL书写方式，nativeQuery=true表示不转义SQL 编写接口UsersDao.java 1234567891011121314151617181920212223242526272829package com.bjsxt.dao;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import org.springframework.data.repository.Repository;import com.bjsxt.pojo.Users;/** * Repository接口讲解 * @author Administrator * */public interface UsersDao extends Repository&lt;Users, Integer&gt; &#123; //使用@Query注解查询SQL //nativeQuery:默认的是false.表示不开启sql查询。是否对value中的语句做转义。 @Query(value="select * from t_users where username = ?",nativeQuery=true) List&lt;Users&gt; queryUserByNameUseSQL(String name); @Query(value="select * from t_users where username like ?",nativeQuery=true) List&lt;Users&gt; queryUserByLikeNameUseSQL(String name); @Query(value="select * from t_users where username = ? and userage &gt;= ?",nativeQuery=true) List&lt;Users&gt; queryUserByNameAndAgeUseSQL(String name,Integer age);&#125; 编写测试类RepositoryTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.bjsxt.test;import java.util.List;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;/** * Repository接口测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class RepositoryTest &#123; @Autowired private UsersDao usersDao; /** * 测试@Query查询 SQL */ @Test public void test7()&#123; List&lt;Users&gt; list = this.usersDao.queryUserByNameUseSQL("王五"); for (Users users : list) &#123; System.out.println(users); &#125; &#125; /** * 测试@Query查询 SQL */ @Test public void test8()&#123; List&lt;Users&gt; list = this.usersDao.queryUserByLikeNameUseSQL("王%"); for (Users users : list) &#123; System.out.println(users); &#125; &#125; /** * 测试@Query查询 SQL */ @Test public void test9()&#123; List&lt;Users&gt; list = this.usersDao.queryUserByNameAndAgeUseSQL("王五", 22); for (Users users : list) &#123; System.out.println(users); &#125; &#125;&#125; @Query注解的更新编写接口123456789101112131415161718192021222324package com.bjsxt.dao;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Modifying;import org.springframework.data.jpa.repository.Query;import org.springframework.data.repository.Repository;import com.bjsxt.pojo.Users;/** * Repository接口讲解 * @author Administrator * */public interface UsersDao extends Repository&lt;Users, Integer&gt; &#123; @Query("update Users set userage = ? where userid = ?") @Modifying //@Modifying当前语句是一个更新语句 void updateUserAgeById(Integer age,Integer id); &#125; 编写测试类12345678910111213141516171819202122232425262728293031323334353637package com.bjsxt.test;import java.util.List;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;/** * Repository接口测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class RepositoryTest &#123; @Autowired private UsersDao usersDao; /** * 测试@Query update */ @Test @Transactional @Rollback(false) public void test10()&#123; this.usersDao.updateUserAgeById(24, 5); &#125;&#125; CrudRepository接口编写接口UsersDao.java 12345678910111213141516package com.bjsxt.dao;import org.springframework.data.repository.CrudRepository;import com.bjsxt.pojo.Users;/** * CrudRepository接口讲解 * @author Administrator * */public interface UsersDao extends CrudRepository&lt;Users, Integer&gt; &#123; &#125; 编写测试类RepositoryTest.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.bjsxt.test;import java.util.ArrayList;import java.util.List;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;/** * CrudRepository接口测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class RepositoryTest &#123; @Autowired private UsersDao usersDao; /** * 添加单条数据 */ @Test public void test1()&#123; Users user = new Users(); user.setUserage(21); user.setUsername("赵小丽"); this.usersDao.save(user); &#125; /** * 批量添加数据 */ @Test public void test2()&#123; Users user = new Users(); user.setUserage(21); user.setUsername("赵小丽"); Users user1 = new Users(); user1.setUserage(25); user1.setUsername("王小虎"); List&lt;Users&gt; list= new ArrayList&lt;&gt;(); list.add(user); list.add(user1); this.usersDao.save(list); &#125; /** * 根据ID查询单条数据 */ @Test public void test3()&#123; Users users = this.usersDao.findOne(13); System.out.println(users); &#125; /** * 查询全部数据 */ @Test public void test4()&#123; List&lt;Users&gt; list = (List&lt;Users&gt;)this.usersDao.findAll(); for (Users users : list) &#123; System.out.println(users); &#125; &#125; /** * 删除数据 */ @Test public void test5()&#123; this.usersDao.delete(13); &#125; /** * 更新数据 方式一 */ @Test public void test6()&#123; Users user = this.usersDao.findOne(12); user.setUsername("王小红"); this.usersDao.save(user); &#125; /** * 更新数据 方式二 */ @Test @Transactional @Rollback(false) public void test7()&#123; Users user = this.usersDao.findOne(12);//持久化状态的 user.setUsername("王小小"); &#125;&#125; PagingAndSortingRepository接口分页编写接口UsersDao.java 1234567891011121314151617package com.bjsxt.dao;import org.springframework.data.repository.CrudRepository;import org.springframework.data.repository.PagingAndSortingRepository;import com.bjsxt.pojo.Users;/** * PagingAndSortingRepository接口讲解 * @author Administrator * */public interface UsersDao extends PagingAndSortingRepository&lt;Users, Integer&gt;&#123; &#125; 编写测试代码RepositoryTest.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.bjsxt.test;import java.util.ArrayList;import java.util.List;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;/** * PagingAndSortingRepository接口测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class RepositoryTest &#123; @Autowired private UsersDao usersDao; /** * 分页 */ @Test public void test1()&#123; int page = 2; //page:当前页的索引。注意索引都是从0开始的。 int size = 3;// size:每页显示3条数据 Pageable pageable= new PageRequest(page, size); Page&lt;Users&gt; p = this.usersDao.findAll(pageable); System.out.println("数据的总条数："+p.getTotalElements()); System.out.println("总页数："+p.getTotalPages()); List&lt;Users&gt; list = p.getContent(); for (Users users : list) &#123; System.out.println(users); &#125; &#125;&#125; 排序编写接口UsersDao.java 1234567891011121314151617package com.bjsxt.dao;import org.springframework.data.repository.CrudRepository;import org.springframework.data.repository.PagingAndSortingRepository;import com.bjsxt.pojo.Users;/** * PagingAndSortingRepository接口讲解 * @author Administrator * */public interface UsersDao extends PagingAndSortingRepository&lt;Users, Integer&gt;&#123; &#125; 编写测试代码RepositoryTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.bjsxt.test;import java.util.ArrayList;import java.util.List;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.domain.Sort.Direction;import org.springframework.data.domain.Sort.Order;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.TestPropertySource;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;/** * PagingAndSortingRepository接口测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class RepositoryTest &#123; @Autowired private UsersDao usersDao; /** * 对单列做排序处理 */ @Test public void test2()&#123; //Sort:该对象封装了排序规则以及指定的排序字段(对象的属性来表示) //direction:排序规则 //properties:指定做排序的属性 Sort sort = new Sort(Direction.DESC,"userid"); List&lt;Users&gt; list = (List&lt;Users&gt;)this.usersDao.findAll(sort); for (Users users : list) &#123; System.out.println(users); &#125; &#125; /** * 多列的排序处理 */ @Test public void test3()&#123; //Sort:该对象封装了排序规则以及指定的排序字段(对象的属性来表示) //direction:排序规则 //properties:指定做排序的属性 Order order1 = new Order(Direction.DESC,"userage"); Order order2 = new Order(Direction.ASC,"username"); Sort sort = new Sort(order1,order2); List&lt;Users&gt; list = (List&lt;Users&gt;)this.usersDao.findAll(sort); for (Users users : list) &#123; System.out.println(users); &#125; &#125;&#125; JpaRepository接口JpaRepository接口是我们开发时使用的最多的接口。其特点是可以帮助我们将其他接口的方法的返回值做适配处理。可以使得我们在开发时更方便的使用这些方法。 编写接口UsersDao.java 123456789101112131415161718package com.bjsxt.dao;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.repository.CrudRepository;import org.springframework.data.repository.PagingAndSortingRepository;import com.bjsxt.pojo.Users;/** * JpaRepository接口讲解 * @author Administrator * */public interface UsersDao extends JpaRepository&lt;Users, Integer&gt;&#123; &#125; 编写测试类RepositoryTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.bjsxt.test;import java.util.ArrayList;import java.util.List;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.domain.Sort.Direction;import org.springframework.data.domain.Sort.Order;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.TestPropertySource;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;/** * JpaRepository接口测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class RepositoryTest &#123; @Autowired private UsersDao usersDao; /** * 查询全部数据 */ @Test public void test1()&#123; List&lt;Users&gt; list = this.usersDao.findAll(); for (Users users : list) &#123; System.out.println(users); &#125; &#125;&#125; JpaSpecificationExecutor接口完成多条件查询，并且支持分页与排序 单条件查询编写接口 JpaSpecificationExecutor&lt;Users&gt;:不能单独使用，需要配合着jpa中的其他接口一起使用 UsersDao.java 12345678910111213141516171819package com.bjsxt.dao;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;import org.springframework.data.repository.CrudRepository;import org.springframework.data.repository.PagingAndSortingRepository;import com.bjsxt.pojo.Users;/** * JpaSpecificationExecutor接口讲解 * @author Administrator *注意：JpaSpecificationExecutor&lt;Users&gt;:不能单独使用，需要配合着jpa中的其他接口一起使用 */public interface UsersDao extends JpaRepository&lt;Users, Integer&gt;,JpaSpecificationExecutor&lt;Users&gt;&#123; &#125; 编写测试类RepositoryTest.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.bjsxt.test;import java.util.ArrayList;import java.util.List;import javax.persistence.criteria.CriteriaBuilder;import javax.persistence.criteria.CriteriaQuery;import javax.persistence.criteria.Predicate;import javax.persistence.criteria.Root;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.domain.Sort.Direction;import org.springframework.data.domain.Sort.Order;import org.springframework.data.jpa.domain.Specification;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.TestPropertySource;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;/** * JpaSpecificationExecutor接口测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class RepositoryTest &#123; @Autowired private UsersDao usersDao; /** * 需求：根据用户姓名查询数据 */ @Test public void test1()&#123; Specification&lt;Users&gt; spec = new Specification&lt;Users&gt;() &#123; /** * @return Predicate:定义了查询条件 * @param Root&lt;Users&gt; root:根对象。封装了查询条件的对象 * @param CriteriaQuery&lt;?&gt; query:定义了一个基本的查询。一般不使用 * @param CriteriaBuilder cb:创建一个查询条件 */ @Override public Predicate toPredicate(Root&lt;Users&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Predicate pre = cb.equal(root.get("username"), "王五"); return pre; &#125; &#125;; List&lt;Users&gt; list = this.usersDao.findAll(spec); for (Users users : list) &#123; System.out.println(users); &#125; &#125;&#125; 多条件查询方式一编写接口UsersDao.java 12345678910111213141516171819package com.bjsxt.dao;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;import org.springframework.data.repository.CrudRepository;import org.springframework.data.repository.PagingAndSortingRepository;import com.bjsxt.pojo.Users;/** * JpaSpecificationExecutor接口讲解 * @author Administrator *注意：JpaSpecificationExecutor&lt;Users&gt;:不能单独使用，需要配合着jpa中的其他接口一起使用 */public interface UsersDao extends JpaRepository&lt;Users, Integer&gt;,JpaSpecificationExecutor&lt;Users&gt;&#123; &#125; 编写测试类RepositoryTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.bjsxt.test;import java.util.ArrayList;import java.util.List;import javax.persistence.criteria.CriteriaBuilder;import javax.persistence.criteria.CriteriaQuery;import javax.persistence.criteria.Predicate;import javax.persistence.criteria.Root;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.domain.Sort.Direction;import org.springframework.data.domain.Sort.Order;import org.springframework.data.jpa.domain.Specification;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.TestPropertySource;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;/** * JpaSpecificationExecutor接口测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class RepositoryTest &#123; @Autowired private UsersDao usersDao; /** * 多条件查询 方式一 * 需求：使用用户姓名以及年龄查询数据 */ @Test public void test2()&#123; Specification&lt;Users&gt; spec = new Specification&lt;Users&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Users&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; List&lt;Predicate&gt; list = new ArrayList&lt;&gt;(); list.add(cb.equal(root.get("username"),"王五")); list.add(cb.equal(root.get("userage"),24)); //此时条件之间是没有任何关系的。 Predicate[] arr = new Predicate[list.size()]; return cb.and(list.toArray(arr)); &#125; &#125;; List&lt;Users&gt; list = this.usersDao.findAll(spec); for (Users users : list) &#123; System.out.println(users); &#125; &#125; &#125; 方式二编写接口UsersDao.java 12345678910111213141516171819package com.bjsxt.dao;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;import org.springframework.data.repository.CrudRepository;import org.springframework.data.repository.PagingAndSortingRepository;import com.bjsxt.pojo.Users;/** * JpaSpecificationExecutor接口讲解 * @author Administrator *注意：JpaSpecificationExecutor&lt;Users&gt;:不能单独使用，需要配合着jpa中的其他接口一起使用 */public interface UsersDao extends JpaRepository&lt;Users, Integer&gt;,JpaSpecificationExecutor&lt;Users&gt;&#123; &#125; 编写测试类RepositoryTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.bjsxt.test;import java.util.ArrayList;import java.util.List;import javax.persistence.criteria.CriteriaBuilder;import javax.persistence.criteria.CriteriaQuery;import javax.persistence.criteria.Predicate;import javax.persistence.criteria.Root;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.domain.Sort.Direction;import org.springframework.data.domain.Sort.Order;import org.springframework.data.jpa.domain.Specification;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.TestPropertySource;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;/** * JpaSpecificationExecutor接口测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class RepositoryTest &#123; @Autowired private UsersDao usersDao; /** * 多条件查询 方式二 * 需求：使用用户姓名或者年龄查询数据 */ @Test public void test3()&#123; Specification&lt;Users&gt; spec = new Specification&lt;Users&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Users&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; return cb.or(cb.equal(root.get("username"),"王五"),cb.equal(root.get("userage"), 25)); &#125; &#125;; List&lt;Users&gt; list = this.usersDao.findAll(spec); for (Users users : list) &#123; System.out.println(users); &#125; &#125; &#125; 分页编写接口UsersDao.java 12345678910111213141516171819package com.bjsxt.dao;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;import org.springframework.data.repository.CrudRepository;import org.springframework.data.repository.PagingAndSortingRepository;import com.bjsxt.pojo.Users;/** * JpaSpecificationExecutor接口讲解 * @author Administrator *注意：JpaSpecificationExecutor&lt;Users&gt;:不能单独使用，需要配合着jpa中的其他接口一起使用 */public interface UsersDao extends JpaRepository&lt;Users, Integer&gt;,JpaSpecificationExecutor&lt;Users&gt;&#123; &#125; 编写测试类RepositoryTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.bjsxt.test;import java.util.ArrayList;import java.util.List;import javax.persistence.criteria.CriteriaBuilder;import javax.persistence.criteria.CriteriaQuery;import javax.persistence.criteria.Predicate;import javax.persistence.criteria.Root;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.domain.Sort.Direction;import org.springframework.data.domain.Sort.Order;import org.springframework.data.jpa.domain.Specification;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.TestPropertySource;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;/** * JpaSpecificationExecutor接口测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class RepositoryTest &#123; @Autowired private UsersDao usersDao; /** * 需求：查询王姓用户，并且做分页处理 */ @Test public void test4()&#123; //条件 Specification&lt;Users&gt; spec = new Specification&lt;Users&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Users&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; return cb.like(root.get("username").as(String.class), "王%"); &#125; &#125;; //分页 Pageable pageable = new PageRequest(2, 2); Page&lt;Users&gt; page = this.usersDao.findAll(spec, pageable); System.out.println("总条数："+page.getTotalElements()); System.out.println("总页数："+page.getTotalPages()); List&lt;Users&gt; list = page.getContent(); for (Users users : list) &#123; System.out.println(users); &#125; &#125; &#125; 排序编写接口UsersDao.java 12345678910111213141516171819package com.bjsxt.dao;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;import org.springframework.data.repository.CrudRepository;import org.springframework.data.repository.PagingAndSortingRepository;import com.bjsxt.pojo.Users;/** * JpaSpecificationExecutor接口讲解 * @author Administrator *注意：JpaSpecificationExecutor&lt;Users&gt;:不能单独使用，需要配合着jpa中的其他接口一起使用 */public interface UsersDao extends JpaRepository&lt;Users, Integer&gt;,JpaSpecificationExecutor&lt;Users&gt;&#123; &#125; 编写测试类RepositoryTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.bjsxt.test;import java.util.ArrayList;import java.util.List;import javax.persistence.criteria.CriteriaBuilder;import javax.persistence.criteria.CriteriaQuery;import javax.persistence.criteria.Predicate;import javax.persistence.criteria.Root;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.domain.Sort.Direction;import org.springframework.data.domain.Sort.Order;import org.springframework.data.jpa.domain.Specification;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.TestPropertySource;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;/** * JpaSpecificationExecutor接口测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class RepositoryTest &#123; @Autowired private UsersDao usersDao; /** * 需求：查询数据库中王姓的用户，并且根据用户id做倒序排序 */ @Test public void test5()&#123; //条件 Specification&lt;Users&gt; spec = new Specification&lt;Users&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Users&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; return cb.like(root.get("username").as(String.class), "王%"); &#125; &#125;; //排序 Sort sort = new Sort(Direction.DESC,"userid"); List&lt;Users&gt; list = this.usersDao.findAll(spec, sort); for (Users users : list) &#123; System.out.println(users); &#125; &#125; &#125; 分页与排序编写接口UsersDao.java 12345678910111213141516171819package com.bjsxt.dao;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;import org.springframework.data.repository.CrudRepository;import org.springframework.data.repository.PagingAndSortingRepository;import com.bjsxt.pojo.Users;/** * JpaSpecificationExecutor接口讲解 * @author Administrator *注意：JpaSpecificationExecutor&lt;Users&gt;:不能单独使用，需要配合着jpa中的其他接口一起使用 */public interface UsersDao extends JpaRepository&lt;Users, Integer&gt;,JpaSpecificationExecutor&lt;Users&gt;&#123; &#125; 编写测试类RepositoryTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.bjsxt.test;import java.util.ArrayList;import java.util.List;import javax.persistence.criteria.CriteriaBuilder;import javax.persistence.criteria.CriteriaQuery;import javax.persistence.criteria.Predicate;import javax.persistence.criteria.Root;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.domain.Sort.Direction;import org.springframework.data.domain.Sort.Order;import org.springframework.data.jpa.domain.Specification;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.TestPropertySource;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;/** * JpaSpecificationExecutor接口测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class RepositoryTest &#123; @Autowired private UsersDao usersDao; /** * 需求：查询数据库中王姓的用户，做分页处理，并且根据用户id做倒序排序 */ @Test public void test6()&#123; //排序等定义 Sort sort = new Sort(Direction.DESC,"userid"); //分页的定义 Pageable pageable = new PageRequest(2,2, sort); //查询条件 Specification&lt;Users&gt; spec = new Specification&lt;Users&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Users&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; return cb.like(root.get("username").as(String.class), "王%"); &#125; &#125;; Page&lt;Users&gt; page = this.usersDao.findAll(spec, pageable); System.out.println("总条数："+page.getTotalElements()); System.out.println("总页数："+page.getTotalPages()); List&lt;Users&gt; list = page.getContent(); for (Users users : list) &#123; System.out.println(users); &#125; &#125; &#125; 自定义 Repository 接口编写接口UsersRepository.java 12345678package com.bjsxt.dao;import com.bjsxt.pojo.Users;public interface UsersRepository &#123; public Users findUserById(Integer userid);&#125; 使用接口UsersDao.java 123456789101112131415161718package com.bjsxt.dao;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;import org.springframework.data.repository.CrudRepository;import org.springframework.data.repository.PagingAndSortingRepository;import com.bjsxt.pojo.Users;/** * 用户自定义Repository接口讲解 * @author Administrator */public interface UsersDao extends JpaRepository&lt;Users, Integer&gt;,JpaSpecificationExecutor&lt;Users&gt;,UsersRepository&#123; &#125; 编写接口实现类UsersDaoImpl.java 12345678910111213141516171819package com.bjsxt.dao;import javax.persistence.EntityManager;import javax.persistence.PersistenceContext;import com.bjsxt.pojo.Users;public class UsersDaoImpl implements UsersRepository &#123; @PersistenceContext(name="entityManagerFactory") private EntityManager em; @Override public Users findUserById(Integer userid) &#123; System.out.println("MyRepository......"); return this.em.find(Users.class, userid); &#125;&#125; 编写测试类RepositoryTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.bjsxt.test;import java.util.ArrayList;import java.util.List;import javax.persistence.criteria.CriteriaBuilder;import javax.persistence.criteria.CriteriaQuery;import javax.persistence.criteria.Predicate;import javax.persistence.criteria.Root;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.domain.Sort.Direction;import org.springframework.data.domain.Sort.Order;import org.springframework.data.jpa.domain.Specification;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.TestPropertySource;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Users;/** * JpaRepository接口测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class RepositoryTest &#123; @Autowired private UsersDao usersDao; /** * 需求：根据用户ID查询数据 */ @Test public void test1()&#123; Users users = this.usersDao.findUserById(5); System.out.println(users); &#125;&#125; 多表操作一对一需求：用户与角色的一对一的关联关系用户：一方角色：一方 编写Users实体Users.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.bjsxt.pojo;import java.io.Serializable;import javax.persistence.CascadeType;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.JoinColumn;import javax.persistence.OneToOne;import javax.persistence.Table;@Entity@Table(name="t_users")public class Users implements Serializable&#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY)//strategy=GenerationType.IDENTITY 自增长 @Column(name="userid") private Integer userid; @Column(name="username") private String username; @Column(name="userage") private Integer userage; public Roles getRoles() &#123; return roles; &#125; public void setRoles(Roles roles) &#123; this.roles = roles; &#125; @OneToOne(cascade=CascadeType.PERSIST) //@JoinColumn：就是维护一个外键 @JoinColumn(name="roles_id") private Roles roles; public Integer getUserid() &#123; return userid; &#125; public void setUserid(Integer userid) &#123; this.userid = userid; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Integer getUserage() &#123; return userage; &#125; public void setUserage(Integer userage) &#123; this.userage = userage; &#125; @Override public String toString() &#123; return "Users [userid=" + userid + ", username=" + username + ", userage=" + userage + "]"; &#125; &#125; 编写Roles实体123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.bjsxt.pojo;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.OneToOne;import javax.persistence.Table;@Entity@Table(name="t_roles")public class Roles &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name="roleid") private Integer roleid; @Column(name="rolename") private String rolename; @OneToOne(mappedBy="roles") private Users users; public Users getUsers() &#123; return users; &#125; public void setUsers(Users users) &#123; this.users = users; &#125; public Integer getRoleid() &#123; return roleid; &#125; public void setRoleid(Integer roleid) &#123; this.roleid = roleid; &#125; public String getRolename() &#123; return rolename; &#125; public void setRolename(String rolename) &#123; this.rolename = rolename; &#125; @Override public String toString() &#123; return "Roles [roleid=" + roleid + ", rolename=" + rolename + "]"; &#125; &#125; 编写测试类OneToOneTest.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Roles;import com.bjsxt.pojo.Users;/** * 一对一关联关系测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class OneToOneTest &#123; @Autowired private UsersDao usersDao; /** * 添加用户同时添加角色 */ @Test public void test1()&#123; //创建角色 Roles roles = new Roles(); roles.setRolename("管理员"); //创建用户 Users users = new Users(); users.setUserage(30); users.setUsername("赵小刚"); //建立关系 users.setRoles(roles); roles.setUsers(users); //保存数据 this.usersDao.save(users); &#125; /** * 根据用户ID查询用户，同时查询用户角色 */ @Test public void test2()&#123; Users users = this.usersDao.findOne(13); System.out.println("用户信息："+users); Roles roles = users.getRoles(); System.out.println(roles); &#125;&#125; 一对多需求：从角色到用户的一对多的关联关系角色：一方用户：多方 编写Users实体Users.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.bjsxt.pojo;import java.io.Serializable;import javax.persistence.CascadeType;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.JoinColumn;import javax.persistence.ManyToOne;import javax.persistence.OneToOne;import javax.persistence.Table;@Entity@Table(name="t_users")public class Users implements Serializable&#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY)//strategy=GenerationType.IDENTITY 自增长 @Column(name="userid") private Integer userid; @Column(name="username") private String username; @Column(name="userage") private Integer userage; @ManyToOne(cascade=CascadeType.PERSIST) @JoinColumn(name="roles_id") private Roles roles; public Roles getRoles() &#123; return roles; &#125; public void setRoles(Roles roles) &#123; this.roles = roles; &#125; public Integer getUserid() &#123; return userid; &#125; public void setUserid(Integer userid) &#123; this.userid = userid; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Integer getUserage() &#123; return userage; &#125; public void setUserage(Integer userage) &#123; this.userage = userage; &#125; @Override public String toString() &#123; return "Users [userid=" + userid + ", username=" + username + ", userage=" + userage + "]"; &#125; &#125; 编写Roles实体Roles.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.bjsxt.pojo;import java.util.HashSet;import java.util.Set;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.OneToMany;import javax.persistence.OneToOne;import javax.persistence.Table;@Entity@Table(name="t_roles")public class Roles &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name="roleid") private Integer roleid; @Column(name="rolename") private String rolename; @OneToMany(mappedBy="roles") private Set&lt;Users&gt; users = new HashSet&lt;&gt;(); public Set&lt;Users&gt; getUsers() &#123; return users; &#125; public void setUsers(Set&lt;Users&gt; users) &#123; this.users = users; &#125; public Integer getRoleid() &#123; return roleid; &#125; public void setRoleid(Integer roleid) &#123; this.roleid = roleid; &#125; public String getRolename() &#123; return rolename; &#125; public void setRolename(String rolename) &#123; this.rolename = rolename; &#125; @Override public String toString() &#123; return "Roles [roleid=" + roleid + ", rolename=" + rolename + "]"; &#125; &#125; 编写测试类OneToManyTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.dao.UsersDao;import com.bjsxt.pojo.Roles;import com.bjsxt.pojo.Users;/** * 一对多的关联关系测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class OneToManyTest &#123; @Autowired private UsersDao usersDao; /** * 添加用户同时添加角色 */ @Test public void test1()&#123; //创建角色 Roles roles = new Roles(); roles.setRolename("管理员"); //创建用户 Users users =new Users(); users.setUserage(30); users.setUsername("小王"); //建立关系 roles.getUsers().add(users); users.setRoles(roles); //保存数据 this.usersDao.save(users); &#125; /** * 根据用户ID查询用户信息，同时查询角色 */ @Test public void test2()&#123; Users users = this.usersDao.findOne(14); System.out.println("用户姓名："+users.getUsername()); Roles roles = users.getRoles(); System.out.println(roles); &#125;&#125; 多对多双向的一对多 需求：一个角色可以拥有多个菜单，一个菜单可以分配多个角色。多对多的关联关系角色：多方菜单：多方 编写Roles实体Roles.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.bjsxt.pojo;import java.util.HashSet;import java.util.Set;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.JoinColumn;import javax.persistence.JoinTable;import javax.persistence.ManyToMany;import javax.persistence.OneToMany;import javax.persistence.OneToOne;import javax.persistence.Table;@Entity@Table(name="t_roles")public class Roles &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name="roleid") private Integer roleid; @Column(name="rolename") private String rolename; @ManyToMany //@JoinTable:配置中间表信息 //joinColumns:建立当前表在中间表中的外键字段 @JoinTable(name="t_roles_menus",joinColumns=@JoinColumn(name="role_id"),inverseJoinColumns=@JoinColumn(name="menu_id")) private Set&lt;Menus&gt; menus = new HashSet&lt;&gt;(); public Set&lt;Menus&gt; getMenus() &#123; return menus; &#125; public void setMenus(Set&lt;Menus&gt; menus) &#123; this.menus = menus; &#125; public Integer getRoleid() &#123; return roleid; &#125; public void setRoleid(Integer roleid) &#123; this.roleid = roleid; &#125; public String getRolename() &#123; return rolename; &#125; public void setRolename(String rolename) &#123; this.rolename = rolename; &#125; @Override public String toString() &#123; return "Roles [roleid=" + roleid + ", rolename=" + rolename + "]"; &#125; &#125; 编写Menus实体Menus.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.bjsxt.pojo;import java.util.HashSet;import java.util.Set;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.ManyToMany;import javax.persistence.Table;@Entity@Table(name="t_menus")public class Menus &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name="menusid") private Integer menusid; @Column(name="menusname") private String menusname; @Column(name="menusurl") private String menusurl; @Column(name="fatherid") private Integer fatherid; @ManyToMany(mappedBy="menus") private Set&lt;Roles&gt; roles = new HashSet&lt;&gt;(); public Set&lt;Roles&gt; getRoles() &#123; return roles; &#125; public void setRoles(Set&lt;Roles&gt; roles) &#123; this.roles = roles; &#125; public Integer getMenusid() &#123; return menusid; &#125; public void setMenusid(Integer menusid) &#123; this.menusid = menusid; &#125; public String getMenusname() &#123; return menusname; &#125; public void setMenusname(String menusname) &#123; this.menusname = menusname; &#125; public String getMenusurl() &#123; return menusurl; &#125; public void setMenusurl(String menusurl) &#123; this.menusurl = menusurl; &#125; public Integer getFatherid() &#123; return fatherid; &#125; public void setFatherid(Integer fatherid) &#123; this.fatherid = fatherid; &#125; @Override public String toString() &#123; return "Menus [menusid=" + menusid + ", menusname=" + menusname + ", menusurl=" + menusurl + ", fatherid=" + fatherid + "]"; &#125;&#125; 编写测试类ManyToManyTest.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.bjsxt.test;import java.util.Set;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.dao.RolesDao;import com.bjsxt.pojo.Menus;import com.bjsxt.pojo.Roles;/** * 多对多关联关系测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class ManyToManyTest &#123; @Autowired private RolesDao rolesDao; /** * 添加角色同时添加菜单 */ @Test public void test1()&#123; //创建角色对象 Roles roles = new Roles(); roles.setRolename("超级管理员"); //创建菜单对象 XXX管理平台 ---&gt;用户管理 Menus menus = new Menus(); menus.setMenusname("XXX管理平台"); menus.setFatherid(-1); menus.setMenusurl(null); //用户管理菜单 Menus menus1 = new Menus(); menus1.setMenusname("用户管理"); menus1.setFatherid(1); menus1.setMenusurl(null); //建立关系 roles.getMenus().add(menus); roles.getMenus().add(menus1); menus.getRoles().add(roles); menus1.getRoles().add(roles); //保存数据 this.rolesDao.save(roles); &#125; /** * 查询Roles */ @Test public void test2()&#123; Roles roles = this.rolesDao.findOne(3); System.out.println("角色信息："+roles); Set&lt;Menus&gt; menus = roles.getMenus(); for (Menus menus2 : menus) &#123; System.out.println("菜单信息："+menus2); &#125; &#125;&#125; Spring Data RedisSpring Data Redis Spring Data Redis, part of the larger Spring Data family, provides easy configuration and access to Redis from Spring applications. It offers both low-level and high-level abstractions for interacting with the store, freeing the user from infrastructural concerns. 安装环境Redis 版本：3.0.0环境：Linux 步骤安装 gcc 编译器1yum install gcc-c++ 解压安装包1tar -zxf redis-3.0.0.tar.gz 进入解压目录进行编译12cd redis-3.0.0make 将 Redis 安装到指定目录1make PREFIX=/usr/local/redis install 启动 Redis 前置启动 1默认的是前置启动：./redis-server 后置启动 先将 redis.conf 文件拷贝到 redis 的安装目录cp redis.conf /usr/local/redis/bin 编辑 redis.conf 文件修改：daemonize yes 启动：./redis-server redis.conf 查看 redis 进程：ps aux|grep redis 关闭后置启动的 Redis：./redis-cli shutdown 搭建整合环境创建项目导入jar包spring-iocspring-beans-4.2.0.RELEASE.jar spring-context-4.2.0.RELEASE.jar spring-core-4.2.0.RELEASE.jar spring-expression-4.2.0.RELEASE.jar spring-aopaopalliance.jar aspectjrt.jar aspectjweaver.jar spring-aop-4.2.0.RELEASE.jar spring-aspects-4.2.0.RELEASE.jar spring-jdbcspring-jdbc-4.2.0.RELEASE.jar(这里没有用到) spring-tx-4.2.0.RELEASE.jar spring-orm这里不需要用到 spring testspring-tx-4.2.0.RELEASE.jar apache-loggingcommons-logging-1.1.1.jar spring-data-rediscommons-pool2-2.3.jar jedis-2.7.2.jar spring-data-redis-1.6.0.RELEASE.jar 编写配置文件 配置读取properties文件的工具类 Jedis连接池 Jedis连接工厂:创建Jedis对象的工厂 Redis模板对象:是SpringDataRedis提供的用户操作Redis的对象 applicationContext.xml 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置读取properties文件的工具类 --&gt; &lt;context:property-placeholder location="classpath:redis.properties"/&gt; &lt;!-- Jedis连接池 --&gt; &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;property name="maxTotal" value="$&#123;redis.pool.maxtTotal&#125;"/&gt; &lt;property name="maxIdle" value="$&#123;redis.pool.maxtIdle&#125;"/&gt; &lt;property name="minIdle" value="$&#123;redis.pool.minIdle&#125;"/&gt; &lt;/bean&gt; &lt;!-- Jedis连接工厂:创建Jedis对象的工厂 --&gt; &lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt; &lt;!-- IP地址 --&gt; &lt;property name="hostName" value="$&#123;redis.hostname&#125;"/&gt; &lt;!-- 端口 --&gt; &lt;property name="port" value="$&#123;redis.port&#125;"/&gt; &lt;!-- 连接池 --&gt; &lt;property name="poolConfig" ref="poolConfig"/&gt; &lt;/bean&gt; &lt;!-- Redis模板对象:是SpringDataRedis提供的用户操作Redis的对象 --&gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate"&gt; &lt;!-- 默认的序列化器：序列化器就是根据规则将存储的数据中的key与value做字符串的序列化处理 --&gt; &lt;!-- keySerializer、valueSerializer：对应的是Redis中的String类型 --&gt; &lt;!-- hashKeySerializer、hashValueSerializer：对应的是Redis中的Hash类型 --&gt; &lt;property name="keySerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"&gt;&lt;/bean&gt; &lt;/property&gt; &lt;property name="valueSerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"&gt;&lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; redis.properties 123456redis.pool.maxtTotal=20redis.pool.maxIdle=10redis.pool.minIdle=5redis.hostname=192.168.70.129redis.port=6379 编写测试类RedisTest.java 123456789101112131415161718192021222324252627282930313233343536373839package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * Redis测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class RedisTest &#123; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; /** * 添加键值对 */ @Test public void test1()&#123; this.redisTemplate.opsForValue().set("key", "test"); &#125; /** * 获取redis中的数据 */ @Test public void test2()&#123; String str = (String)this.redisTemplate.opsForValue().get("key"); System.out.println(str); &#125;&#125; 存储实体对象编写实体类要实现序列化接口Serializable Users.java 123456789101112131415161718192021222324252627282930313233package com.bjsxt.pojo;import java.io.Serializable;public class Users implements Serializable&#123; private Integer id; private String name; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Users [id=" + id + ", name=" + name + ", age=" + age + "]"; &#125; &#125; 编写测试类默认序列化StringRedisSerializer在配置文件applicationContext.xml中指定，测试的时候可以更换序列化器 RedisTest.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.JdkSerializationRedisSerializer;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.pojo.Users;/** * Redis测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class RedisTest &#123; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; /** * 添加Users */ @Test public void test3()&#123; Users users = new Users(); users.setAge(30); users.setId(1); users.setName("张三"); //更换序列化器 this.redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer()); this.redisTemplate.opsForValue().set("users", users); &#125; /** * 获取Users * */ @Test public void test4()&#123; //更换序列化器 this.redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer()); Users users = (Users)this.redisTemplate.opsForValue().get("users"); System.out.println(users); &#125;&#125; 以 JSON格式存储对象导入jar包jackson-annotations-2.8.0.jar jackson-core-2.8.10.jar jackson-databind-2.8.10.jar 编写实体类实现序列化接口 Users.java 123456789101112131415161718192021222324252627282930313233package com.bjsxt.pojo;import java.io.Serializable;public class Users implements Serializable&#123; private Integer id; private String name; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Users [id=" + id + ", name=" + name + ", age=" + age + "]"; &#125; &#125; 编写测试类设置json序列化器this.redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Users.class)); RedisTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.JdkSerializationRedisSerializer;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.pojo.Users;/** * Redis测试 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class RedisTest &#123; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; /** * 添加Users JSON格式 */ @Test public void test5()&#123; Users users = new Users(); users.setAge(23); users.setId(2); users.setName("李四"); this.redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Users.class)); this.redisTemplate.opsForValue().set("usersjson", users); &#125; /** * 获取Uesrs JSON格式 */ @Test public void test6()&#123; this.redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Users.class)); Users users = (Users)this.redisTemplate.opsForValue().get("usersjson"); System.out.println(users); &#125;&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>springdata</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dubbo]]></title>
    <url>%2Fmyhexo%2F2019%2F06%2F13%2Fdubbo%2F</url>
    <content type="text"><![CDATA[dubbo环境搭建安装zookeeper下载zookeeperIndex of /dist/zookeeper/zookeeper-3.4.13 解压 修改配置文件进入C:\Users\shenlibing\Downloads\zookeeper-3.4.13\conf将conf下的zoo_sample.cfg复制一份改名为zoo.cfg即可 dataDir 临时数据存储的目录（可写相对路径） clientPort=2181 zookeeper的端口号 测试 开启服务端 开启客户端 安装dubbo-admin管理控制台dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。 但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。 下载dubbo-adminapache/dubbo-admin at master 解压 修改dubbo-admin配置 指定zookeeper地址 打包dubbo-admin1mvn clean package -Dmaven.test.skip=true 运行dubbo-admin1java -jar dubbo-admin-0.0.1-SNAPSHOT.jar 访问http://localhost:7001，默认使用`root/root `登陆 dubbo-helloworld创建订单服务web模块 用户服务service模块 分包版本一 order-service-consumer订单消费层 user-service-provider用户服务提供层 版本二将公共的地址实体、订单接口、用户接口提取到公共接口层，新建一个公共接口层 gmall-interface公共接口层 order-service-consumer订单消费层 user-service-provider用户服务提供层 代码公共接口层代码UserAddress.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.atguigu.gmall.bean;import java.io.Serializable;/** * 用户地址 * @author lfy * */public class UserAddress implements Serializable &#123; private Integer id; private String userAddress; //用户地址 private String userId; //用户id private String consignee; //收货人 private String phoneNum; //电话号码 private String isDefault; //是否为默认地址 Y-是 N-否 public UserAddress() &#123; super(); // TODO Auto-generated constructor stub &#125; public UserAddress(Integer id, String userAddress, String userId, String consignee, String phoneNum, String isDefault) &#123; super(); this.id = id; this.userAddress = userAddress; this.userId = userId; this.consignee = consignee; this.phoneNum = phoneNum; this.isDefault = isDefault; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUserAddress() &#123; return userAddress; &#125; public void setUserAddress(String userAddress) &#123; this.userAddress = userAddress; &#125; public String getUserId() &#123; return userId; &#125; public void setUserId(String userId) &#123; this.userId = userId; &#125; public String getConsignee() &#123; return consignee; &#125; public void setConsignee(String consignee) &#123; this.consignee = consignee; &#125; public String getPhoneNum() &#123; return phoneNum; &#125; public void setPhoneNum(String phoneNum) &#123; this.phoneNum = phoneNum; &#125; public String getIsDefault() &#123; return isDefault; &#125; public void setIsDefault(String isDefault) &#123; this.isDefault = isDefault; &#125; &#125; OrderService.java 123456789101112131415package com.atguigu.gmall.service;import java.util.List;import com.atguigu.gmall.bean.UserAddress;public interface OrderService &#123; /** * 初始化订单 * @param userId */ public List&lt;UserAddress&gt; initOrder(String userId);&#125; UserService.java 123456789101112131415161718192021package com.atguigu.gmall.service;import java.util.List;import com.atguigu.gmall.bean.UserAddress;/** * 用户服务 * @author lfy * */public interface UserService &#123; /** * 按照用户id返回所有的收货地址 * @param userId * @return */ public List&lt;UserAddress&gt; getUserAddressList(String userId);&#125; 订单消费层代码OrderServiceImpl.java 1234567891011121314151617181920212223242526272829303132333435package com.atguigu.gmall.service.impl;import java.util.List;import com.atguigu.gmall.bean.UserAddress;import com.atguigu.gmall.service.OrderService;import com.atguigu.gmall.service.UserService;/** * 1、将服务提供者注册到注册中心（暴露服务） * 1）、导入dubbo依赖（2.6.2）\操作zookeeper的客户端(curator) * 2）、配置服务提供者 * * 2、让服务消费者去注册中心订阅服务提供者的服务地址 * @author lfy * */public class OrderServiceImpl implements OrderService &#123; UserService userService; @Override public List&lt;UserAddress&gt; initOrder(String userId) &#123; // TODO Auto-generated method stub System.out.println("用户id："+userId); //1、查询用户的收货地址 List&lt;UserAddress&gt; addressList = userService.getUserAddressList(userId); for (UserAddress userAddress : addressList) &#123; System.out.println(userAddress.getUserAddress()); &#125; return addressList; &#125; &#125; 用户服务提供层代码UserServiceImpl.java 123456789101112131415161718package com.atguigu.gmall.service.impl;import java.util.Arrays;import java.util.List;import com.atguigu.gmall.bean.UserAddress;import com.atguigu.gmall.service.UserService;public class UserServiceImpl implements UserService &#123; @Override public List&lt;UserAddress&gt; getUserAddressList(String userId) &#123; UserAddress address1 = new UserAddress(1, "北京市昌平区宏福科技园综合楼3层", "1", "李老师", "010-56253825", "Y"); UserAddress address2 = new UserAddress(2, "深圳市宝安区西部硅谷大厦B座3层（深圳分校）", "1", "王老师", "010-56253825", "N"); return Arrays.asList(address1,address2); &#125;&#125; 依赖配置订单消费层需要引用公共接口层 pom.xml 12345678910111213&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt; &lt;artifactId&gt;order-service-consumer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt; &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 用户服务提供层需要引用公共接口层 pom.xml 1234567891011121314&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt; &lt;artifactId&gt;user-service-provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt; &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; dubbo通信为了让订单消费层和用户服务提供层可以通信，使用dubbo进行配置 用户服务提供层导入依赖 导入dubbo依赖（2.6.2） 操作zookeeper的客户端(curator)依赖 1234567891011121314151617181920212223242526272829&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt; &lt;artifactId&gt;user-service-provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt; &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 引入dubbo --&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 注册中心使用的是zookeeper，引入操作zookeeper的客户端端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 配置服务提供者新建provider.xml文件 指定当前服务/应用的名字 指定注册中心的位置 指定通信规则（通信协议？通信端口） 暴露服务 provider.xml 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!-- 1、指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） --&gt; &lt;dubbo:application name="user-service-provider"&gt;&lt;/dubbo:application&gt; &lt;!-- 2、指定注册中心的位置 --&gt; &lt;!-- &lt;dubbo:registry address="zookeeper://127.0.0.1:2181"&gt;&lt;/dubbo:registry&gt; --&gt; &lt;dubbo:registry protocol="zookeeper" address="127.0.0.1:2181"&gt;&lt;/dubbo:registry&gt; &lt;!-- 3、指定通信规则（通信协议？通信端口） --&gt; &lt;dubbo:protocol name="dubbo" port="20882"&gt;&lt;/dubbo:protocol&gt; &lt;!-- 4、暴露服务 ref：指向服务的真正的实现对象 --&gt; &lt;dubbo:service interface="com.atguigu.gmall.service.UserService" ref="userServiceImpl"&gt; &lt;/dubbo:service&gt; &lt;!-- 服务的实现 --&gt; &lt;bean id="userServiceImpl" class="com.atguigu.gmall.service.impl.UserServiceImpl"&gt;&lt;/bean&gt; &lt;/beans&gt; 测试服务提供者新建MainApplication.java MainApplication.java 1234567891011121314151617package com.atguigu.gmall;import java.io.IOException;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApplication &#123; public static void main(String[] args) throws IOException &#123; ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext("provider.xml"); ioc.start(); System.in.read(); &#125;&#125; 在dubbo控制台进行查看,可以看到有一个服务提供者 订单消费层导入依赖pom.xml 12345678910111213141516171819202122232425262728&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt; &lt;artifactId&gt;order-service-consumer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.gmall&lt;/groupId&gt; &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 引入dubbo --&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 注册中心使用的是zookeeper，引入操作zookeeper的客户端端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 配置订单消费者新建consumer.xml文件 consumer.xml 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://dubbo.apache.org/schema/dubbo" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;context:component-scan base-package="com.atguigu.gmall.service.impl"&gt;&lt;/context:component-scan&gt; &lt;dubbo:application name="order-service-consumer"&gt;&lt;/dubbo:application&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181"&gt;&lt;/dubbo:registry&gt; &lt;!--声明需要调用的远程服务的接口；生成远程服务代理 --&gt; &lt;dubbo:reference interface="com.atguigu.gmall.service.UserService" id="userService"&gt; &lt;/dubbo:reference&gt; &lt;/beans&gt; 测试订单消费者新建MainApplication.java MainApplication.java 12345678910111213141516171819202122package com.atguigu.gmall;import java.io.IOException;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.atguigu.gmall.service.OrderService;public class MainApplication &#123; @SuppressWarnings("resource") public static void main(String[] args) throws IOException &#123; ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("consumer.xml"); OrderService orderService = applicationContext.getBean(OrderService.class); orderService.initOrder("1"); System.out.println("调用完成...."); System.in.read(); &#125;&#125; 运行MainApplication.java 扫描订单消费层 修改订单消费代码，将消费实现加入到容器，并把UserService注入进来 查看dubbo控制台，服务数：1，应用数：2，提供者数：1，消费者数：1 安装dubbo-monitor-simple简单的监控中心 下载apache/dubbo-admin at master 解压 修改配置文件进入C:\Users\shenlibing\Downloads\dubbo-admin-master\dubbo-monitor-simple\src\main\resources\conf目录，编辑dubbo.properties 打包1mvn clean package -Dmaven.test.skip=true 解压解压dubbo-monitor-simple-2.0.0-assembly.tar.gz—&gt;dubbo-monitor-simple-2.0.0-assembly.tar—&gt;dubbo-monitor-simple-2.0.0 运行 访问http://localhost:8080,如下图所示]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql]]></title>
    <url>%2Fmyhexo%2F2019%2F06%2F08%2Fmysql%2F</url>
    <content type="text"><![CDATA[安装下载MySQL :: Download MySQL Community Server (Archived Versions) rzsz1[root@192 modules]# yum -y install lrzsz 上传1234[root@192 modules]# lltotal 66632-rw-r--r--. 1 root root 17855952 Jun 8 20:04 MySQL-client-5.5.48-1.linux2.6.x86_64.rpm-rw-r--r--. 1 root root 50372369 Jun 8 20:24 MySQL-server-5.5.48-1.linux2.6.x86_64.rpm 卸载方式一123[root@192 modules]# rpm -qa | grep -i mysqlmysql-libs-5.1.73-7.el6.x86_64[root@192 modules]# rpm -e --nodeps mysql-libs-5.1.73-7.el6.x86_64 方式二1[root@192 modules]# yum -y remove mysql-libs-5.1.73-7.el6.x86_64 如果提示“GPG keys...”安装失败，解决方案：rpm -ivh rpm软件名 --force --nodoeps 服务端1234567891011121314151617181920212223[root@192 modules]# rpm -ivh MySQL-server-5.5.48-1.linux2.6.x86_64.rpm warning: MySQL-server-5.5.48-1.linux2.6.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEYPreparing... ########################################### [100%] 1:MySQL-server ########################################### [100%]190608 20:32:37 [Note] /usr/sbin/mysqld (mysqld 5.5.48) starting as process 26375 ...190608 20:32:37 [Note] /usr/sbin/mysqld (mysqld 5.5.48) starting as process 26382 ...PLEASE REMEMBER TO SET A PASSWORD FOR THE MySQL root USER !To do so, start the server, then issue the following commands:/usr/bin/mysqladmin -u root password &apos;new-password&apos;/usr/bin/mysqladmin -u root -h 192.168.1.101 password &apos;new-password&apos;Alternatively you can run:/usr/bin/mysql_secure_installationwhich will also give you the option of removing the testdatabases and anonymous user created by default. This isstrongly recommended for production servers.See the manual for more instructions.Please report any problems at http://bugs.mysql.com/ 客户端1234[root@192 modules]# rpm -ivh MySQL-client-5.5.48-1.linux2.6.x86_64.rpm warning: MySQL-client-5.5.48-1.linux2.6.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEYPreparing... ########################################### [100%] 1:MySQL-client ########################################### [100%] 验证12[root@192 mysql]# mysqladmin --versionmysqladmin Ver 8.42 Distrib 5.5.48, for Linux on x86_64 启动服务方式一12[root@192 mysql]# service mysql start;Starting MySQL.. [ OK ] 方式二 在计算机reboot后 登陆MySQL : mysql可能会报错： &quot;/var/lib/mysql/mysql.sock不存在&quot; 原因：是Mysql服务没有启动 解决 ： 启动服务 每次使用前 手动启动服务 /etc/init.d/mysql start 开机自启 chkconfig mysql on ,chkconfig mysql off 12[root@192 modules]# /etc/init.d/mysql startStarting MySQL.. [ OK ] 方式三 开启自启mysql服务 123[root@192 mysql]# chkconfig mysql on[root@192 mysql]# chkconfig mysql --listmysql 0:off 1:off 2:on 3:on 4:on 5:on 6:off 关闭服务12[root@192 mysql]# service mysql stopShutting down MySQL... [ OK ] 重启服务123[root@192 mysql]# service mysql restart;Shutting down MySQL. [ OK ]Starting MySQL.. [ OK ] 检查开机是否自动启动mysql服务1[root@192 mysql]# ntsysv 修改密码1[root@192 modules]# /usr/bin/mysqladmin -u root password &apos;000000&apos; 连接123456789101112131415[root@192 modules]# mysql -uroot -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.5.48 MySQL Community Server (GPL)Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; 授权1234mysql&gt; grant all privileges on *.* to root@&apos;%&apos; identified by &quot;000000&quot;;Query OK, 0 rows affected (0.00 sec)mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.00 sec) 坑 客户端连接不上 关闭防火墙 123456[root@192 ~]# service iptables stop;iptables: Setting chains to policy ACCEPT: filter [ OK ]iptables: Flushing firewall rules: [ OK ]iptables: Unloading modules: [ OK ][root@192 ~]# service iptables status;iptables: Firewall is not running. rpm安装mysql，找不到/etc/my.cnf 复制/usr/share/mysql目录下的my-huge.cnf文件到/etc目录，并改名为my.cnf即可 1[root@192 mysql]# cp /usr/share/mysql/my-huge.cnf /etc/my.cnf 数据库存放目录123456[root@192 mysql]# ps -ef|grep mysqlroot 5790 3618 0 14:13 pts/1 00:00:00 mysql -uroot -proot 5802 4605 0 14:24 pts/3 00:00:00 mysql -uroot -proot 7266 1 0 14:46 pts/0 00:00:00 /bin/sh /usr/bin/mysqld_safe --datadir=/var/lib/mysql --pid-file=/var/lib/mysql/192.168.1.101.pidmysql 7615 7266 0 14:46 pts/0 00:00:00 /usr/sbin/mysqld --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib64/mysql/plugin --user=mysql --log-error=/var/lib/mysql/192.168.1.101.err --pid-file=/var/lib/mysql/192.168.1.101.pid --socket=/var/lib/mysql/mysql.sock --port=3306root 7672 4519 0 15:02 pts/0 00:00:00 grep mysql 数据库目录datadir=/var/lib/mysql pid文件目录：--pid-file=/var/lib/mysql/bigdata01.pid MySQL核心目录 /var/lib/mysql :mysql 安装目录 /usr/share/mysql: 配置文件 /usr/bin：命令目录（mysqladmin、mysqldump等） /etc/init.d/mysql启停脚本 MySQL配置文件 my-huge.cnf 高端服务器 1-2G内存 my-large.cnf 中等规模 my-medium.cnf 一般 my-small.cnf 较小 但是，以上配置文件mysql默认不能识别，默认只能识别/etc/my.cnf，因此需要拷贝一份以上配置文件 1[root@192 mysql]# cp /usr/share/mysql/my-huge.cnf /etc/my.cnf 注意：mysql5.5默认配置文件/etc/my.cnf；Mysql5.6默认配置文件/etc/mysql-default.cnf mysql字符编码查看字符编码1234567891011121314mysql&gt; show variables like &apos;%char%&apos;;+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | latin1 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | latin1 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.00 sec) 安装NPPFTP设置—导入—-导入插件 修改字符编码为utf8编辑配置文件vim /etc/my.cnf，追加 123456789[mysql]default-character-set=utf8[client]default-character-set=utf8[mysqld]character_set_server=utf8character_set_client=utf8collation_server=utf8_general_ci 再次查看字符编码 1234567891011121314mysql&gt; show variables like &apos;%char%&apos;;+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.00 sec) 清屏 Ctrl+L system clear SQL语句查询步步深入：MySQL架构总览-&gt;查询执行流程-&gt;SQL解析顺序 - AnnsShadoW - 博客园 语法顺序 SELECT FROM LEFT JOIN ON WHERE GROUP BY HAVING ORDER BY LIMIT 执行顺序1SELECT * FROM user LEFT JOIN order ON user.id = order.uid WHERE order.price &gt; 1000 GROUP BY user.name HAVING count(1) &gt; 5 ORDER BY user.name LIMIT 0,10 FROM（将最近的两张表，进行笛卡尔积），得到临时结果集VT1 ON（将VT1按照它的条件进行过滤）—VT2 LEFT JOIN（保留左表的记录）—VT3 WHERE（过滤VT3中的记录）–VT4…VTn GROUP BY（对VT4的记录进行分组）—VT5 HAVING（对VT5中的记录进行过滤）—VT6 SELECT（对VT6中的记录，选取指定的列）–VT7 ORDER BY（对VT7的记录进行排序）–游标 LIMIT（对排序之后的值进行分页） WHERE条件执行顺序（影响性能） MYSQL：从左往右去执行WHERE条件的。 Oracle：从右往左去执行WHERE条件的。 结论：写WHERE条件的时候，优先级高的部分要去编写过滤力度最大的条件语句。 多表之间关系一对一一对多从表是：分类表。从表中，应该有一个字段去关联主表，而这个关联字段就是主键。 主表是：商品表。主表中，应该有一个字段去关联从表，而这个关联字段就是外键。 在互联网项目中，一般情况下，不建议建立外键关系。 多对多 双向的一对多 存储引擎 存储引擎是针对表的,MySQL 5.5之后，默认的存储引擎由MyISAM变为InnoDB。 查询数据库支持哪些引擎12345678910111213141516mysql&gt; show engines;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine | Support | Comment | Transactions | XA | Savepoints |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO || MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO || CSV | YES | CSV storage engine | NO | NO | NO || BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO || MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO || InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES || ARCHIVE | YES | Archive storage engine | NO | NO | NO || MyISAM | YES | MyISAM storage engine | NO | NO | NO || FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+9 rows in set (0.00 sec) 查看当前使用的引擎12345678mysql&gt; show variables like &apos;%storage_engine%&apos; ;+------------------------+--------+| Variable_name | Value |+------------------------+--------+| default_storage_engine | InnoDB || storage_engine | InnoDB |+------------------------+--------+2 rows in set (0.00 sec) 指定数据库对象的引擎1234567create table tb( id int(4) auto_increment , name varchar(5), dept varchar(5) , primary key(id) )ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 ; 日志文件、数据文件日志位置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647mysql&gt; SHOW GLOBAL VARIABLES LIKE &apos;%log%&apos;;+-----------------------------------------+----------------------------------+| Variable_name | Value |+-----------------------------------------+----------------------------------+| back_log | 50 || binlog_cache_size | 32768 || binlog_direct_non_transactional_updates | OFF || binlog_format | MIXED || binlog_stmt_cache_size | 32768 || expire_logs_days | 0 || general_log | OFF || general_log_file | /var/lib/mysql/192.log || innodb_flush_log_at_trx_commit | 1 || innodb_locks_unsafe_for_binlog | OFF || innodb_log_buffer_size | 8388608 || innodb_log_file_size | 5242880 || innodb_log_files_in_group | 2 || innodb_log_group_home_dir | ./ || innodb_mirrored_log_groups | 1 || log | OFF || log_bin | ON || log_bin_trust_function_creators | OFF || log_error | /var/lib/mysql/192.168.1.101.err || log_output | FILE || log_queries_not_using_indexes | OFF || log_slave_updates | OFF || log_slow_queries | OFF || log_warnings | 1 || max_binlog_cache_size | 18446744073709547520 || max_binlog_size | 1073741824 || max_binlog_stmt_cache_size | 18446744073709547520 || max_relay_log_size | 0 || relay_log | || relay_log_index | || relay_log_info_file | relay-log.info || relay_log_purge | ON || relay_log_recovery | OFF || relay_log_space_limit | 0 || slow_query_log | OFF || slow_query_log_file | /var/lib/mysql/192-slow.log || sql_log_bin | ON || sql_log_off | OFF || sync_binlog | 0 || sync_relay_log | 0 || sync_relay_log_info | 0 |+-----------------------------------------+----------------------------------+41 rows in set (0.00 sec) 二进制日志 记录了数据库所有的ddl语句和dml语句，但不包括select语句内容 用于恢复数据 12345678mysql&gt; SHOW VARIABLES LIKE &apos;log_bin%&apos;;+---------------------------------+-------+| Variable_name | Value |+---------------------------------+-------+| log_bin | ON || log_bin_trust_function_creators | OFF |+---------------------------------+-------+2 rows in set (0.00 sec) 错误日志1234567mysql&gt; SHOW VARIABLES LIKE &apos;log_error%&apos;;+---------------+----------------------------------+| Variable_name | Value |+---------------+----------------------------------+| log_error | /var/lib/mysql/192.168.1.101.err |+---------------+----------------------------------+1 row in set (0.00 sec) 查询日志12345678mysql&gt; SHOW VARIABLES LIKE &apos;general_log%&apos;;+------------------+------------------------+| Variable_name | Value |+------------------+------------------------+| general_log | OFF || general_log_file | /var/lib/mysql/192.log |+------------------+------------------------+2 rows in set (0.00 sec) 慢查询日志12345678910111213141516mysql&gt; SHOW VARIABLES LIKE &apos;slow_query_log%&apos;;+---------------------+-----------------------------+| Variable_name | Value |+---------------------+-----------------------------+| slow_query_log | OFF || slow_query_log_file | /var/lib/mysql/192-slow.log |+---------------------+-----------------------------+2 rows in set (0.00 sec)mysql&gt; SHOW VARIABLES LIKE &apos;long_query_time%&apos;;+-----------------+-----------+| Variable_name | Value |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+1 row in set (0.00 sec) 数据位置1234567mysql&gt; SHOW VARIABLES LIKE &apos;%datadir%&apos;;+---------------+-----------------+| Variable_name | Value |+---------------+-----------------+| datadir | /var/lib/mysql/ |+---------------+-----------------+1 row in set (0.00 sec) SQL优化B-tree - Wikipedia MySQL :: MySQL 5.5 Reference Manual :: 8 Optimization MySQL索引背后的数据结构及算法原理 BTree和B+Tree详解 SQL优化， 主要就是 在优化索引，索引就 相当于书的目录 索引(index)是帮助MYSQL高效获取数据的数据结构。索引是数据结构（树：B树(默认)、Hash树…） B树索引 select * from student where age = 33如果不加索引，从上往下查找需要查找5次，而加了索引，查找的节点处于第三层，所以只需要查找3次 B+Tree Btree数据全部放在叶子节点 分类 主键索引： 不能重复，是一种特殊的唯一索引，不允许有空值 唯一索引 ：不能重复，允许为空值 单值索引 ： 单列， age ;一个表可以多个单值索引,name。 组合索引 ：多个列构成的索引 ，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。 创建索引如果一个字段是主键primary key，则该字段默认就是主键索引,需要注意的是DDL语句会自动提交,我们不需要手动commit 方式一create 索引类型 索引名 on 表(字段) 单值索引 1create index dept_index on tb(dept); 唯一索引 1create unique index name_index on tb(name) ; 组合索引 1create index dept_name_index on tb(dept,name); 方式二alter table 表名 索引类型 索引名（字段） 单值索引 1alter table tb add index dept_index(dept) ; 唯一索引 1alter table tb add unique index name_index(name); 组合索引 1alter table tb add index dept_name_index(dept,name); 删除索引drop index 索引名 on 表名 ; 1drop index name_index on tb ; 查询索引 show index from 表名 ; show index from 表名 \G 12345678mysql&gt; show index from tb;+-------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+-------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| tb | 0 | PRIMARY | 1 | id | A | 0 | NULL | NULL | | BTREE | | || tb | 1 | dept_index | 1 | dept | A | NULL | NULL | NULL | YES | BTREE | | |+-------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+2 rows in set (0.00 sec) 优势 提高查询效率（降低IO使用率） 降低CPU使用率 （...order by age desc,因为 B树索引 本身就是一个 好排序的结构，因此在排序时 可以直接使用） 弊端 索引本身很大， 可以存放在内存/硬盘（通常为 硬盘） 索引不是所有情况均适用 少量数据 频繁更新的字段 很少使用的字段 索引会降低增删改的效率（增删改 查） 建议 尽量创建组合索引（组合索引其实会默认按照最左前缀原则帮我们创建多组索引） 组合索引（id,name,sex）会帮我们创建多组索引—–&gt;[id],[id,name],[id,sex],[id,name,sex],[name,sex] SQL故障排除 慢查询日志:MySQL提供的一种日志记录，用于记录MySQL种响应时间超过阀值的SQL语句 （long_query_time，默认10秒） 慢查询日志默认是关闭的；建议一般开发调优时是打开，而最终部署时关闭。 性能优化思路 首先需要使用慢查询功能，去获取所有查询时间比较长的SQL语句 其次使用explain命令去查看有问题的SQL的执行计划 最后可以使用show profile[s] 查看有问题的SQL的性能使用情况 查看慢查询临时开启方式一1234567891011121314151617181920mysql&gt; show variables like &apos;%slow_query_log%&apos; ;+---------------------+-----------------------------+| Variable_name | Value |+---------------------+-----------------------------+| slow_query_log | OFF || slow_query_log_file | /var/lib/mysql/192-slow.log |+---------------------+-----------------------------+2 rows in set (0.00 sec)mysql&gt; set global slow_query_log = ON;Query OK, 0 rows affected (0.00 sec)mysql&gt; show variables like &apos;%slow_query_log%&apos; ;+---------------------+-----------------------------+| Variable_name | Value |+---------------------+-----------------------------+| slow_query_log | ON || slow_query_log_file | /var/lib/mysql/192-slow.log |+---------------------+-----------------------------+2 rows in set (0.00 sec) 方式二1234567891011121314151617181920mysql&gt; show variables like &apos;%slow_query_log%&apos; ;+---------------------+-----------------------------+| Variable_name | Value |+---------------------+-----------------------------+| slow_query_log | OFF || slow_query_log_file | /var/lib/mysql/192-slow.log |+---------------------+-----------------------------+2 rows in set (0.00 sec)mysql&gt; set global slow_query_log = 1 ;Query OK, 0 rows affected (0.00 sec)mysql&gt; show variables like &apos;%slow_query_log%&apos; ;+---------------------+-----------------------------+| Variable_name | Value |+---------------------+-----------------------------+| slow_query_log | ON || slow_query_log_file | /var/lib/mysql/192-slow.log |+---------------------+-----------------------------+2 rows in set (0.00 sec) 永久开启编辑/etc/my.cnf 中追加配置： 1234vi /etc/my.cnf [mysqld]slow_query_log=1slow_query_log_file=/var/lib/mysql/localhost-slow.log 查看慢查询阀值1234567mysql&gt; show variables like &apos;%long_query_time%&apos; ;+-----------------+-----------+| Variable_name | Value |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+1 row in set (0.00 sec) 临时设置阀值 设置完毕后，重新登陆后起效 （不需要重启服务） 123456789101112131415161718192021222324252627282930313233343536373839404142mysql&gt; show variables like &apos;%long_query_time%&apos; ;+-----------------+-----------+| Variable_name | Value |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+1 row in set (0.00 sec)mysql&gt; set global long_query_time = 5 ;Query OK, 0 rows affected (0.00 sec)mysql&gt; show variables like &apos;%long_query_time%&apos; ;+-----------------+-----------+| Variable_name | Value |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+1 row in set (0.00 sec)mysql&gt; exit;Bye[root@192 ~]# mysql -uroot -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.5.48-log MySQL Community Server (GPL)Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; show variables like &apos;%long_query_time%&apos; ;+-----------------+----------+| Variable_name | Value |+-----------------+----------+| long_query_time | 5.000000 |+-----------------+----------+1 row in set (0.00 sec) 永久设置阀值编辑/etc/my.cnf中追加配置： 123vi /etc/my.cnf [mysqld]long_query_time=3 查看SQL执行计划explain +SQL语句 1234567mysql&gt; explain select * from tb ;+----+-------------+-------+--------+---------------+------+---------+------+------+---------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+--------+---------------+------+---------+------+------+---------------------+| 1 | SIMPLE | tb | system | NULL | NULL | NULL | NULL | 0 | const row not found |+----+-------------+-------+--------+---------------+------+---------+------+------+---------------------+1 row in set (0.00 sec) id : 编号 select_type ：查询类型 table ：表 type ：类型 possible_keys ：预测用到的索引 key ：实际使用的索引 key_len ：实际使用索引的长度 ref :表之间的引用 rows ：通过索引查询到的数据量 Extra :额外的信息 表结构 课程表(course) 教师表(teacher) 教师课程描述表(teacherCard) 准备数据1234567891011121314151617181920212223242526272829303132create table course(cid int(3),cname varchar(20),tid int(3));create table teacher(tid int(3),tname varchar(20),tcid int(3));create table teacherCard(tcid int(3),tcdesc varchar(200));insert into course values(1,'java',1);insert into course values(2,'html',1);insert into course values(3,'sql',2);insert into course values(4,'web',3);insert into teacher values(1,'tz',1);insert into teacher values(2,'tw',2);insert into teacher values(3,'tl',3);insert into teacherCard values(1,'tzdesc') ;insert into teacherCard values(2,'twdesc') ;insert into teacherCard values(3,'tldesc') ; idid值相同 id值相同，从上往下 顺序执行。 数据小的表优先查询 用wehre连接表之间的关系，表的执行顺序是因数量的个数改变而改变，当教师表新插入3条数据，教师表变成了最后执行的原因是遵循笛卡儿积，尽管3*4*6=72和6*4*3=72最终的条数是一样的，但是它们的中间结果是不一样的，查询3*4=12条效率明显比6*4=24高 查询课程编号为2或教师证编号为3的老师信息 1234567891011121314151617181920212223242526272829mysql&gt; EXPLAIN select * from teacher t,course c,teacherCard tc where t.tid=c.tid and t.tcid=tc.tcid and (c.cid=2 or tc.tcid=3);+----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+| 1 | SIMPLE | t | ALL | NULL | NULL | NULL | NULL | 3 | || 1 | SIMPLE | tc | ALL | NULL | NULL | NULL | NULL | 3 | Using where; Using join buffer || 1 | SIMPLE | c | ALL | NULL | NULL | NULL | NULL | 4 | Using where; Using join buffer |+----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+3 rows in set (0.00 sec)mysql&gt; insert into teacher values(4,'ts',2);Query OK, 1 row affected (0.01 sec)mysql&gt; insert into teacher values(5,'tw',3);Query OK, 1 row affected (0.01 sec)mysql&gt; insert into teacher values(6,'tl',3);Query OK, 1 row affected (0.00 sec)mysql&gt; EXPLAIN select * from teacher t,course c,teacherCard tc where t.tid=c.tid and t.tcid=tc.tcid and (c.cid=2 or tc.tcid=3);+----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+| 1 | SIMPLE | tc | ALL | NULL | NULL | NULL | NULL | 3 | || 1 | SIMPLE | c | ALL | NULL | NULL | NULL | NULL | 4 | Using where; Using join buffer || 1 | SIMPLE | t | ALL | NULL | NULL | NULL | NULL | 6 | Using where; Using join buffer |+----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+3 rows in set (0.00 sec) id值不同 id值越大越优先查询 (本质上在嵌套子查询时，先查内层 再查外层) 查询教授SQL课程的老师的描述（desc） 1234567891011121314151617181920212223mysql&gt; explain select tc.tcdesc from teacherCard tc,course c,teacher t where c.tid = t.tid -&gt; and t.tcid = tc.tcid and c.cname = 'sql' ;+----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+| 1 | SIMPLE | tc | ALL | NULL | NULL | NULL | NULL | 3 | || 1 | SIMPLE | c | ALL | NULL | NULL | NULL | NULL | 4 | Using where; Using join buffer || 1 | SIMPLE | t | ALL | NULL | NULL | NULL | NULL | 6 | Using where; Using join buffer |+----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+3 rows in set (0.01 sec)mysql&gt; explain select tc.tcdesc from teacherCard tc where tc.tcid = -&gt; (select t.tcid from teacher t where t.tid = -&gt; (select c.tid from course c where c.cname = 'sql') -&gt; );+----+-------------+-------+------+---------------+------+---------+------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+------+---------------+------+---------+------+------+-------------+| 1 | PRIMARY | tc | ALL | NULL | NULL | NULL | NULL | 3 | Using where || 2 | SUBQUERY | t | ALL | NULL | NULL | NULL | NULL | 6 | Using where || 3 | SUBQUERY | c | ALL | NULL | NULL | NULL | NULL | 4 | Using where |+----+-------------+-------+------+---------------+------+---------+------+------+-------------+3 rows in set (0.00 sec) id值有相同，又有不同 id值越大越优先；id值相同，从上往下 顺序执行 子查询+多表 12345678910mysql&gt; explain select t.tname ,tc.tcdesc from teacher t,teacherCard tc where t.tcid= tc.tcid -&gt; and t.tid = (select c.tid from course c where cname = 'sql') ;+----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+| 1 | PRIMARY | tc | ALL | NULL | NULL | NULL | NULL | 3 | || 1 | PRIMARY | t | ALL | NULL | NULL | NULL | NULL | 6 | Using where; Using join buffer || 2 | SUBQUERY | c | ALL | NULL | NULL | NULL | NULL | 4 | Using where |+----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+3 rows in set (0.00 sec) select_type查询类型 PRIMARY:包含子查询SQL中的 主查询 （最外层） SUBQUERY：包含子查询SQL中的 子查询 （非最外层） simple:简单查询（不包含子查询、union） derived:衍生查询(使用到了临时表) 在from子查询中只有一张表 12345678mysql&gt; explain select cr.cname from ( select * from course where tid in (1,2) ) cr ;+----+-------------+------------+------+---------------+------+---------+------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+------------+------+---------------+------+---------+------+------+-------------+| 1 | PRIMARY | &lt;derived2&gt; | ALL | NULL | NULL | NULL | NULL | 3 | || 2 | DERIVED | course | ALL | NULL | NULL | NULL | NULL | 4 | Using where |+----+-------------+------------+------+---------------+------+---------+------+------+-------------+2 rows in set (0.00 sec) 在from子查询中， 如果有table1 union table2 ，则table1 就是derived,table2就是union 12345678910mysql&gt; explain select cr.cname from ( select * from course where tid = 1 union select * from course where tid = 2 ) cr ;+----+--------------+------------+------+---------------+------+---------+------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+--------------+------------+------+---------------+------+---------+------+------+-------------+| 1 | PRIMARY | &lt;derived2&gt; | ALL | NULL | NULL | NULL | NULL | 3 | || 2 | DERIVED | course | ALL | NULL | NULL | NULL | NULL | 4 | Using where || 3 | UNION | course | ALL | NULL | NULL | NULL | NULL | 4 | Using where || NULL | UNION RESULT | &lt;union2,3&gt; | ALL | NULL | NULL | NULL | NULL | NULL | |+----+--------------+------------+------+---------------+------+---------+------+------+-------------+4 rows in set (0.00 sec) union:上例 union result :告知开发人员，那些表之间存在union查询 type索引类型、类型 对type进行优化的前提：有索引 system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL 比较常见的system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all,其中system,const只是理想情况；实际能达到 的是ref&gt;range system 可以忽略: 只有一条数据的系统表 ；或 衍生表只有一条数据的主查询 12345678910111213141516171819202122232425262728293031323334353637383940mysql&gt; create table test01 -&gt; ( -&gt; tid int(3), -&gt; tname varchar(20) -&gt; );Query OK, 0 rows affected (0.01 sec)mysql&gt; mysql&gt; insert into test01 values(1,'a') ;Query OK, 1 row affected (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&gt; show tables;+---------------+| Tables_in_kkb |+---------------+| course || lock || tb || teacher || teacherCard || test01 || user |+---------------+7 rows in set (0.00 sec)mysql&gt; alter table test01 add constraint tid_pk primary key(tid) ;Query OK, 1 row affected (0.02 sec)Records: 1 Duplicates: 0 Warnings: 0mysql&gt; explain select * from (select * from test01 )t where tid =1 ;+----+-------------+------------+--------+---------------+------+---------+------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+------------+--------+---------------+------+---------+------+------+-------+| 1 | PRIMARY | &lt;derived2&gt; | system | NULL | NULL | NULL | NULL | 1 | || 2 | DERIVED | test01 | ALL | NULL | NULL | NULL | NULL | 1 | |+----+-------------+------------+--------+---------------+------+---------+------+------+-------+2 rows in set (0.00 sec) const仅仅能查到一条数据的SQL ,用于Primary key或unique索引 （类型 与索引类型有关） 1234567891011121314151617181920212223242526272829303132mysql&gt; explain select tid from test01 where tid =1 ;+----+-------------+--------+-------+---------------+---------+---------+-------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+-------+---------------+---------+---------+-------+------+-------------+| 1 | SIMPLE | test01 | const | PRIMARY | PRIMARY | 4 | const | 1 | Using index |+----+-------------+--------+-------+---------------+---------+---------+-------+------+-------------+1 row in set (0.00 sec)mysql&gt; alter table test01 drop primary key ;Query OK, 1 row affected (0.02 sec)Records: 1 Duplicates: 0 Warnings: 0mysql&gt; explain select tid from test01 where tid =1 ;+----+-------------+--------+------+---------------+------+---------+------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+---------------+------+---------+------+------+-------------+| 1 | SIMPLE | test01 | ALL | NULL | NULL | NULL | NULL | 1 | Using where |+----+-------------+--------+------+---------------+------+---------+------+------+-------------+1 row in set (0.00 sec)mysql&gt; create index test01_index on test01(tid) ;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; explain select tid from test01 where tid =1 ;+----+-------------+--------+------+---------------+--------------+---------+-------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+---------------+--------------+---------+-------+------+-------------+| 1 | SIMPLE | test01 | ref | test01_index | test01_index | 4 | const | 1 | Using index |+----+-------------+--------+------+---------------+--------------+---------+-------+------+-------------+1 row in set (0.00 sec) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#### eq_ref唯一性索引：对于每个索引键的查询，返回匹配唯一行数据（有且只有1个，不能多 、不能0）```sqlmysql&gt; select * from teacher;+------+-------+------+| tid | tname | tcid |+------+-------+------+| 1 | tz | 1 || 2 | tw | 2 || 3 | tl | 3 |+------+-------+------+3 rows in set (0.00 sec)mysql&gt; select * from teacherCard;+------+--------+| tcid | tcdesc |+------+--------+| 1 | tzdesc || 2 | twdesc || 3 | tldesc |+------+--------+3 rows in set (0.00 sec)mysql&gt; explain select t.tcid from teacher t,teacherCard tc where t.tcid = tc.tcid ;+----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+| 1 | SIMPLE | t | ALL | NULL | NULL | NULL | NULL | 3 | || 1 | SIMPLE | tc | ALL | NULL | NULL | NULL | NULL | 3 | Using where; Using join buffer |+----+-------------+-------+------+---------------+------+---------+------+------+--------------------------------+2 rows in set (0.00 sec)mysql&gt; alter table teacherCard add constraint pk_tcid primary key(tcid);Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; alter table teacher add constraint uk_tcid unique index(tcid) ;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; explain select t.tcid from teacher t,teacherCard tc where t.tcid = tc.tcid ;+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------------+| 1 | SIMPLE | t | index | uk_tcid | uk_tcid | 5 | NULL | 3 | Using index || 1 | SIMPLE | tc | eq_ref | PRIMARY | PRIMARY | 4 | kkb.t.tcid | 1 | Using index |+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------------+2 rows in set (0.00 sec) 以上SQL，用到的索引是 t.tcid,即teacher表中的tcid字段； 如果teacher表的数据个数 和 连接查询的数据个数一致（都是3条数据），则有可能满足eq_ref级别；否则无法满足。 ref非唯一性索引，对于每个索引键的查询，返回匹配的所有行（0行或者多行） 123456789101112131415161718192021222324252627282930313233343536373839mysql&gt; insert into teacher values(4,'tz',4) ;Query OK, 1 row affected (0.00 sec)mysql&gt; insert into teacherCard values(4,'tz222');Query OK, 1 row affected (0.00 sec)mysql&gt; select * from teacher;+------+-------+------+| tid | tname | tcid |+------+-------+------+| 1 | tz | 1 || 2 | tw | 2 || 3 | tl | 3 || 4 | tz | 4 |+------+-------+------+4 rows in set (0.00 sec)mysql&gt; select * from teacherCard;+------+--------+| tcid | tcdesc |+------+--------+| 1 | tzdesc || 2 | twdesc || 3 | tldesc || 4 | tz222 |+------+--------+4 rows in set (0.00 sec)mysql&gt; alter table teacher add index index_name (tname) ;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; explain select * from teacher where tname = 'tz';+----+-------------+---------+------+---------------+------------+---------+-------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+---------+------+---------------+------------+---------+-------+------+-------------+| 1 | SIMPLE | teacher | ref | index_name | index_name | 63 | const | 2 | Using where |+----+-------------+---------+------+---------------+------------+---------+-------+------+-------------+1 row in set (0.00 sec) range检索指定范围的行 ,where后面是一个范围查询 between &lt; &gt;= 特殊的情况，in有时候会失效 ，从而转为 无索引，进行全表扫描all) 12345678910111213141516171819202122232425262728293031323334353637383940mysql&gt; alter table teacher add index tid_index (tid) ;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; select * from teacher;+------+-------+------+| tid | tname | tcid |+------+-------+------+| 1 | tz | 1 || 2 | tw | 2 || 3 | tl | 3 || 4 | tz | 4 |+------+-------+------+4 rows in set (0.00 sec)mysql&gt; show index from teacher;+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| teacher | 0 | uk_tcid | 1 | tcid | A | 4 | NULL | NULL | YES | BTREE | | || teacher | 1 | index_name | 1 | tname | A | 4 | NULL | NULL | YES | BTREE | | || teacher | 1 | tid_index | 1 | tid | A | 4 | NULL | NULL | YES | BTREE | | |+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+3 rows in set (0.00 sec)mysql&gt; explain select t.* from teacher t where t.tid in (1,2) ;+----+-------------+-------+------+---------------+------+---------+------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+------+---------------+------+---------+------+------+-------------+| 1 | SIMPLE | t | ALL | tid_index | NULL | NULL | NULL | 4 | Using where |+----+-------------+-------+------+---------------+------+---------+------+------+-------------+1 row in set (0.00 sec)mysql&gt; explain select t.* from teacher t where t.tid &lt;3 ;+----+-------------+-------+-------+---------------+-----------+---------+------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+-------+---------------+-----------+---------+------+------+-------------+| 1 | SIMPLE | t | range | tid_index | tid_index | 5 | NULL | 1 | Using where |+----+-------------+-------+-------+---------------+-----------+---------+------+------+-------------+1 row in set (0.00 sec) index查询全部索引中数据，tid 是索引， 只需要扫描索引表，不需要所有表中的所有数据 12345678910111213141516171819202122232425262728mysql&gt; show index from teacher;+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| teacher | 0 | uk_tcid | 1 | tcid | A | 4 | NULL | NULL | YES | BTREE | | || teacher | 1 | index_name | 1 | tname | A | 4 | NULL | NULL | YES | BTREE | | || teacher | 1 | tid_index | 1 | tid | A | 4 | NULL | NULL | YES | BTREE | | |+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+3 rows in set (0.00 sec)mysql&gt; select * from teacher;+------+-------+------+| tid | tname | tcid |+------+-------+------+| 1 | tz | 1 || 2 | tw | 2 || 3 | tl | 3 || 4 | tz | 4 |+------+-------+------+4 rows in set (0.00 sec)mysql&gt; explain select tid from teacher;+----+-------------+---------+-------+---------------+-----------+---------+------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+---------+-------+---------------+-----------+---------+------+------+-------------+| 1 | SIMPLE | teacher | index | NULL | tid_index | 5 | NULL | 4 | Using index |+----+-------------+---------+-------+---------------+-----------+---------+------+------+-------------+1 row in set (0.00 sec) all查询全部表中的数据 123456789101112131415161718192021mysql&gt; show index from course;Empty set (0.00 sec)mysql&gt; select * from course;+------+-------+------+| cid | cname | tid |+------+-------+------+| 1 | java | 1 || 2 | html | 1 || 3 | sql | 2 || 4 | web | 3 |+------+-------+------+4 rows in set (0.00 sec)mysql&gt; explain select * from course;+----+-------------+--------+------+---------------+------+---------+------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+---------------+------+---------+------+------+-------+| 1 | SIMPLE | course | ALL | NULL | NULL | NULL | NULL | 4 | |+----+-------------+--------+------+---------------+------+---------+------+------+-------+1 row in set (0.00 sec) possible_keys可能用到的索引，是一种预测，不准 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152mysql&gt; alter table course add index cname_index (cname);Query OK, 0 rows affected (0.04 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; select * from course;+------+-------+------+| cid | cname | tid |+------+-------+------+| 1 | java | 1 || 2 | html | 1 || 3 | sql | 2 || 4 | web | 3 |+------+-------+------+4 rows in set (0.00 sec)mysql&gt; show index from course;+--------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+--------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| course | 1 | cname_index | 1 | cname | A | 4 | NULL | NULL | YES | BTREE | | |+--------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+1 row in set (0.00 sec)mysql&gt; show index from teacher;+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| teacher | 0 | uk_tcid | 1 | tcid | A | 4 | NULL | NULL | YES | BTREE | | || teacher | 1 | index_name | 1 | tname | A | 4 | NULL | NULL | YES | BTREE | | || teacher | 1 | tid_index | 1 | tid | A | 4 | NULL | NULL | YES | BTREE | | |+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+3 rows in set (0.00 sec)mysql&gt; show index from teacherCard;+-------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+-------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| teacherCard | 0 | PRIMARY | 1 | tcid | A | 4 | NULL | NULL | | BTREE | | |+-------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+1 row in set (0.00 sec)mysql&gt; explain select t.tname ,tc.tcdesc from teacher t,teacherCard tc -&gt; where t.tcid= tc.tcid -&gt; and t.tid = (select c.tid from course c where cname = &apos;sql&apos;) ;+----+-------------+-------+--------+-------------------+-------------+---------+------------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+--------+-------------------+-------------+---------+------------+------+-------------+| 1 | PRIMARY | t | ref | uk_tcid,tid_index | tid_index | 5 | const | 1 | Using where || 1 | PRIMARY | tc | eq_ref | PRIMARY | PRIMARY | 4 | kkb.t.tcid | 1 | || 2 | SUBQUERY | c | ref | cname_index | cname_index | 63 | | 1 | Using where |+----+-------------+-------+--------+-------------------+-------------+---------+------------+------+-------------+3 rows in set (0.00 sec) 如果 possible_key/key是NULL，则说明没用索引 123456789101112131415161718192021222324mysql&gt; explain select tc.tcdesc from teacherCard tc,course c,teacher t where c.tid = t.tid -&gt; and t.tcid = tc.tcid and c.cname = 'sql' ;+----+-------------+-------+--------+-------------------+-------------+---------+------------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+--------+-------------------+-------------+---------+------------+------+-------------+| 1 | SIMPLE | c | ref | cname_index | cname_index | 63 | const | 1 | Using where || 1 | SIMPLE | t | ref | uk_tcid,tid_index | tid_index | 5 | kkb.c.tid | 1 | Using where || 1 | SIMPLE | tc | eq_ref | PRIMARY | PRIMARY | 4 | kkb.t.tcid | 1 | |+----+-------------+-------+--------+-------------------+-------------+---------+------------+------+-------------+3 rows in set (0.00 sec)mysql&gt; drop index cname_index on course;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; explain select tc.tcdesc from teacherCard tc,course c,teacher t where c.tid = t.tid and t.tcid = tc.tcid and c.cname = 'sql';+----+-------------+-------+--------+-------------------+---------+---------+------------+------+--------------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+--------+-------------------+---------+---------+------------+------+--------------------------------+| 1 | SIMPLE | c | ALL | NULL | NULL | NULL | NULL | 4 | Using where || 1 | SIMPLE | t | ALL | uk_tcid,tid_index | NULL | NULL | NULL | 4 | Using where; Using join buffer || 1 | SIMPLE | tc | eq_ref | PRIMARY | PRIMARY | 4 | kkb.t.tcid | 1 | |+----+-------------+-------+--------+-------------------+---------+---------+------------+------+--------------------------------+3 rows in set (0.00 sec) key实际使用到的索引 key_len utf8:1个字符3个字节 gbk:1个字符2个字节 latin:1个字符1个字节 索引的长度, 用于判断复合索引是否被完全使用,key_len为60，在utf8：1个字符占3个字节 1234567891011121314151617mysql&gt; create table test_kl -&gt; ( -&gt; name char(20) not null default '' -&gt; );Query OK, 0 rows affected (0.01 sec)mysql&gt; alter table test_kl add index index_name(name) ;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; explain select * from test_kl where name ='' ; +----+-------------+---------+------+---------------+------------+---------+-------+------+--------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+---------+------+---------------+------------+---------+-------+------+--------------------------+| 1 | SIMPLE | test_kl | ref | index_name | index_name | 60 | const | 1 | Using where; Using index |+----+-------------+---------+------+---------------+------------+---------+-------+------+--------------------------+1 row in set (0.01 sec) 如果索引字段可以为Null,则会使用1个字节用于标识。因此key_len为61 123456789101112131415mysql&gt; alter table test_kl add column name1 char(20) ;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; alter table test_kl add index index_name1(name1) ;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; explain select * from test_kl where name1 ='' ; +----+-------------+---------+------+---------------+-------------+---------+-------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+---------+------+---------------+-------------+---------+-------+------+-------------+| 1 | SIMPLE | test_kl | ref | index_name1 | index_name1 | 61 | const | 1 | Using where |+----+-------------+---------+------+---------------+-------------+---------+-------+------+-------------+1 row in set (0.00 sec) 增加一个复合索引 ,根据最左前缀原则，两次key_len分别为121和60 123456789101112131415161718192021222324252627282930313233343536mysql&gt; drop index index_name on test_kl ;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; drop index index_name1 on test_kl ;Query OK, 0 rows affected (0.00 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; alter table test_kl add index name_name1_index (name,name1) ; Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; show index from test_kl;+---------+------------+------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+---------+------------+------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| test_kl | 1 | name_name1_index | 1 | name | A | 0 | NULL | NULL | | BTREE | | || test_kl | 1 | name_name1_index | 2 | name1 | A | 0 | NULL | NULL | YES | BTREE | | |+---------+------------+------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+2 rows in set (0.00 sec)mysql&gt; explain select * from test_kl where name1 = '' ;+----+-------------+---------+-------+---------------+------------------+---------+------+------+--------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+---------+-------+---------------+------------------+---------+------+------+--------------------------+| 1 | SIMPLE | test_kl | index | NULL | name_name1_index | 121 | NULL | 1 | Using where; Using index |+----+-------------+---------+-------+---------------+------------------+---------+------+------+--------------------------+1 row in set (0.00 sec)mysql&gt; explain select * from test_kl where name = '' ;+----+-------------+---------+------+------------------+------------------+---------+-------+------+--------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+---------+------+------------------+------------------+---------+-------+------+--------------------------+| 1 | SIMPLE | test_kl | ref | name_name1_index | name_name1_index | 60 | const | 1 | Using where; Using index |+----+-------------+---------+------+------------------+------------------+---------+-------+------+--------------------------+1 row in set (0.00 sec) 索引字段为可变varchar类型,用2个字节 标识可变长度,1字节标识Null,因此20*3=60 + 1(null) +2(用2个字节 标识可变长度) =63 123456789101112131415mysql&gt; alter table test_kl add column name2 varchar(20) ; Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; alter table test_kl add index name2_index (name2) ;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; explain select * from test_kl where name2 = '' ;+----+-------------+---------+------+---------------+-------------+---------+-------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+---------+------+---------------+-------------+---------+-------+------+-------------+| 1 | SIMPLE | test_kl | ref | name2_index | name2_index | 63 | const | 1 | Using where |+----+-------------+---------+------+---------------+-------------+---------+-------+------+-------------+1 row in set (0.00 sec) ref表之间的引用，注意与type中的ref值区分 指明当前表所参照的字段select ....where a.c = b.x ;(其中b.x可以是常量，const) 12345678910111213141516171819202122mysql&gt; desc course;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| cid | int(3) | YES | | NULL | || cname | varchar(20) | YES | | NULL | || tid | int(3) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec)mysql&gt; alter table course add index tid_index (tid) ;Query OK, 0 rows affected (0.04 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; explain select * from course c,teacher t where c.tid = t.tid and t.tname ='tw' ;+----+-------------+-------+------+----------------------+------------+---------+-----------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+------+----------------------+------------+---------+-----------+------+-------------+| 1 | SIMPLE | t | ref | index_name,tid_index | index_name | 63 | const | 1 | Using where || 1 | SIMPLE | c | ref | tid_index | tid_index | 5 | kkb.t.tid | 1 | Using where |+----+-------------+-------+------+----------------------+------------+---------+-----------+------+-------------+2 rows in set (0.00 sec) rows被索引优化查询的 数据个数 (实际通过索引而查询到的 数据个数) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657mysql&gt; select * from course;+------+-------+------+| cid | cname | tid |+------+-------+------+| 1 | java | 1 || 2 | html | 1 || 3 | sql | 2 || 4 | web | 3 |+------+-------+------+4 rows in set (0.00 sec)mysql&gt; select * from teacher;+------+-------+------+| tid | tname | tcid |+------+-------+------+| 1 | tz | 1 || 2 | tw | 2 || 3 | tl | 3 || 4 | tz | 4 |+------+-------+------+4 rows in set (0.00 sec)mysql&gt; show index from course;+--------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+--------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| course | 1 | tid_index | 1 | tid | A | 4 | NULL | NULL | YES | BTREE | | |+--------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+1 row in set (0.00 sec)mysql&gt; show index from teacher;+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| teacher | 0 | uk_tcid | 1 | tcid | A | 4 | NULL | NULL | YES | BTREE | | || teacher | 1 | index_name | 1 | tname | A | 4 | NULL | NULL | YES | BTREE | | || teacher | 1 | tid_index | 1 | tid | A | 4 | NULL | NULL | YES | BTREE | | |+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+3 rows in set (0.00 sec)mysql&gt; select * from course c,teacher t where c.tid = t.tid and t.tname = 'tz';+------+-------+------+------+-------+------+| cid | cname | tid | tid | tname | tcid |+------+-------+------+------+-------+------+| 1 | java | 1 | 1 | tz | 1 || 2 | html | 1 | 1 | tz | 1 |+------+-------+------+------+-------+------+2 rows in set (0.00 sec)mysql&gt; explain select * from course c,teacher t where c.tid = t.tid and t.tname = 'tz';+----+-------------+-------+------+----------------------+------------+---------+-----------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+------+----------------------+------------+---------+-----------+------+-------------+| 1 | SIMPLE | t | ref | index_name,tid_index | index_name | 63 | const | 2 | Using where || 1 | SIMPLE | c | ref | tid_index | tid_index | 5 | kkb.t.tid | 1 | Using where |+----+-------------+-------+------+----------------------+------------+---------+-----------+------+-------------+2 rows in set (0.00 sec) Extrausing filesortusing filesort ： 性能消耗大；需要“额外”的一次排序（查询） 。常见于 order by 语句中。 对于单索引， 如果排序和查找是同一个字段，则不会出现using filesort；如果排序和查找不是同一个字段，则会出现using filesort；，平常使用的话，where哪些字段，就order by那些字段 1234567891011121314151617181920212223242526272829mysql&gt; create table test02 -&gt; ( -&gt; a1 char(3), -&gt; a2 char(3), -&gt; a3 char(3), -&gt; index idx_a1(a1), -&gt; index idx_a2(a2), -&gt; index idx_a3(a3) -&gt; );Query OK, 0 rows affected (0.01 sec)mysql&gt; select * from test02 where a1 ='' order by a1 ;Empty set (0.00 sec)mysql&gt; explain select * from test02 where a1 ='' order by a1 ;+----+-------------+--------+------+---------------+--------+---------+-------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+---------------+--------+---------+-------+------+-------------+| 1 | SIMPLE | test02 | ref | idx_a1 | idx_a1 | 10 | const | 1 | Using where |+----+-------------+--------+------+---------------+--------+---------+-------+------+-------------+1 row in set (0.00 sec)mysql&gt; explain select * from test02 where a1 ='' order by a2 ;+----+-------------+--------+------+---------------+--------+---------+-------+------+-----------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+---------------+--------+---------+-------+------+-----------------------------+| 1 | SIMPLE | test02 | ref | idx_a1 | idx_a1 | 10 | const | 1 | Using where; Using filesort |+----+-------------+--------+------+---------------+--------+---------+-------+------+-----------------------------+1 row in set (0.00 sec) 复合索引：不能跨列（最佳左前缀），where和order by按照复合索引的顺序使用，不要跨列或无序使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758mysql&gt; drop index idx_a1 on test02;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; drop index idx_a2 on test02;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; drop index idx_a3 on test02;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; mysql&gt; alter table test02 add index idx_a1_a2_a3 (a1,a2,a3) ;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; show index from test02;+--------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+--------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| test02 | 1 | idx_a1_a2_a3 | 1 | a1 | A | 0 | NULL | NULL | YES | BTREE | | || test02 | 1 | idx_a1_a2_a3 | 2 | a2 | A | 0 | NULL | NULL | YES | BTREE | | || test02 | 1 | idx_a1_a2_a3 | 3 | a3 | A | 0 | NULL | NULL | YES | BTREE | | |+--------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+3 rows in set (0.00 sec)mysql&gt; explain select *from test02 where a1='' order by a3 ;+----+-------------+--------+------+---------------+--------------+---------+-------+------+------------------------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+---------------+--------------+---------+-------+------+------------------------------------------+| 1 | SIMPLE | test02 | ref | idx_a1_a2_a3 | idx_a1_a2_a3 | 10 | const | 1 | Using where; Using index; Using filesort |+----+-------------+--------+------+---------------+--------------+---------+-------+------+------------------------------------------+1 row in set (0.00 sec)mysql&gt; explain select *from test02 where a2='' order by a3 ;+----+-------------+--------+-------+---------------+--------------+---------+------+------+------------------------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+-------+---------------+--------------+---------+------+------+------------------------------------------+| 1 | SIMPLE | test02 | index | NULL | idx_a1_a2_a3 | 30 | NULL | 1 | Using where; Using index; Using filesort |+----+-------------+--------+-------+---------------+--------------+---------+------+------+------------------------------------------+1 row in set (0.00 sec)mysql&gt; explain select *from test02 where a1='' order by a2 ;+----+-------------+--------+------+---------------+--------------+---------+-------+------+--------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+---------------+--------------+---------+-------+------+--------------------------+| 1 | SIMPLE | test02 | ref | idx_a1_a2_a3 | idx_a1_a2_a3 | 10 | const | 1 | Using where; Using index |+----+-------------+--------+------+---------------+--------------+---------+-------+------+--------------------------+1 row in set (0.00 sec)mysql&gt; explain select *from test02 where a2='' order by a1 ; +----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+| 1 | SIMPLE | test02 | index | NULL | idx_a1_a2_a3 | 30 | NULL | 1 | Using where; Using index |+----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+1 row in set (0.00 sec) using temporaryusing temporary:性能损耗大 ，用到了临时表。一般出现在group by 语句中。 查询那些列，就根据那些列 group by 123456789101112131415mysql&gt; explain select a1 from test02 where a1 in ('1','2','3') group by a1 ;+----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+| 1 | SIMPLE | test02 | index | idx_a1_a2_a3 | idx_a1_a2_a3 | 30 | NULL | 1 | Using where; Using index |+----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+1 row in set (0.00 sec)mysql&gt; explain select a1 from test02 where a1 in ('1','2','3') group by a2 ;+----+-------------+--------+-------+---------------+--------------+---------+------+------+-----------------------------------------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+-------+---------------+--------------+---------+------+------+-----------------------------------------------------------+| 1 | SIMPLE | test02 | index | idx_a1_a2_a3 | idx_a1_a2_a3 | 30 | NULL | 1 | Using where; Using index; Using temporary; Using filesort |+----+-------------+--------+-------+---------------+--------------+---------+------+------+-----------------------------------------------------------+1 row in set (0.00 sec) using index性能提升; 索引覆盖（覆盖索引）。原因：不读取原文件，只从索引文件中获取数据 （不需要回表查询） 123456789101112131415161718192021222324252627282930313233mysql&gt; show index from test02;+--------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+--------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| test02 | 1 | idx_a1_a2_a3 | 1 | a1 | A | 0 | NULL | NULL | YES | BTREE | | || test02 | 1 | idx_a1_a2_a3 | 2 | a2 | A | 0 | NULL | NULL | YES | BTREE | | || test02 | 1 | idx_a1_a2_a3 | 3 | a3 | A | 0 | NULL | NULL | YES | BTREE | | |+--------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+3 rows in set (0.01 sec)mysql&gt; explain select a1,a2 from test02 where a1='' or a2= '' ; +----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+| 1 | SIMPLE | test02 | index | idx_a1_a2_a3 | idx_a1_a2_a3 | 30 | NULL | 1 | Using where; Using index |+----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+1 row in set (0.00 sec)mysql&gt; drop index idx_a1_a2_a3 on test02;Query OK, 0 rows affected (0.00 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; alter table test02 add index idx_a1_a2(a1,a2) ;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; explain select a1,a3 from test02 where a1='' or a3= '' ;+----+-------------+--------+------+---------------+------+---------+------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+---------------+------+---------+------+------+-------------+| 1 | SIMPLE | test02 | ALL | idx_a1_a2 | NULL | NULL | NULL | 1 | Using where |+----+-------------+--------+------+---------------+------+---------+------+------+-------------+1 row in set (0.00 sec) 如果用到了索引覆盖(using index时)，会对possible_keys和key造成影响： 如果没有where，则索引只出现在key中；如果有where，则索引 出现在key和possible_keys中。 12345678910111213141516mysql&gt; explain select a1,a2 from test02 where a1='' or a2= '' ;+----+-------------+--------+-------+---------------+-----------+---------+------+------+--------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+-------+---------------+-----------+---------+------+------+--------------------------+| 1 | SIMPLE | test02 | index | idx_a1_a2 | idx_a1_a2 | 20 | NULL | 1 | Using where; Using index |+----+-------------+--------+-------+---------------+-----------+---------+------+------+--------------------------+1 row in set (0.00 sec)mysql&gt; mysql&gt; explain select a1,a2 from test02 ;+----+-------------+--------+-------+---------------+-----------+---------+------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+-------+---------------+-----------+---------+------+------+-------------+| 1 | SIMPLE | test02 | index | NULL | idx_a1_a2 | 20 | NULL | 1 | Using index |+----+-------------+--------+-------+---------------+-----------+---------+------+------+-------------+1 row in set (0.00 sec) 查看SQL性能使用情况1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677mysql&gt; select @@profiling;+-------------+| @@profiling |+-------------+| 0 |+-------------+1 row in set (0.00 sec)mysql&gt; set profiling=1; Query OK, 0 rows affected (0.00 sec)mysql&gt; select @@profiling;+-------------+| @@profiling |+-------------+| 1 |+-------------+1 row in set (0.00 sec)mysql&gt; select sleep(20);+-----------+| sleep(20) |+-----------+| 0 |+-----------+1 row in set (20.00 sec)mysql&gt; show profiles;+----------+-------------+--------------------+| Query_ID | Duration | Query |+----------+-------------+--------------------+| 1 | 0.00007700 | select @@profiling || 2 | 20.00080200 | select sleep(20) |+----------+-------------+--------------------+2 rows in set (0.00 sec)mysql&gt; show profile;+----------------------+-----------+| Status | Duration |+----------------------+-----------+| starting | 0.000033 || checking permissions | 0.000002 || Opening tables | 0.000004 || init | 0.000006 || optimizing | 0.000002 || executing | 0.000006 || User sleep | 20.000621 || end | 0.000012 || query end | 0.000002 || closing tables | 0.000002 || freeing items | 0.000042 || logging slow query | 0.000003 || logging slow query | 0.000065 || cleaning up | 0.000004 |+----------------------+-----------+14 rows in set (0.00 sec)mysql&gt; show profile cpu,swaps for query 2;+----------------------+-----------+----------+------------+-------+| Status | Duration | CPU_user | CPU_system | Swaps |+----------------------+-----------+----------+------------+-------+| starting | 0.000033 | 0.000000 | 0.000000 | 0 || checking permissions | 0.000002 | 0.000000 | 0.000000 | 0 || Opening tables | 0.000004 | 0.000000 | 0.000000 | 0 || init | 0.000006 | 0.000000 | 0.000000 | 0 || optimizing | 0.000002 | 0.000000 | 0.000000 | 0 || executing | 0.000006 | 0.000000 | 0.000000 | 0 || User sleep | 20.000621 | 0.006000 | 0.005999 | 0 || end | 0.000012 | 0.000000 | 0.000000 | 0 || query end | 0.000002 | 0.000000 | 0.000000 | 0 || closing tables | 0.000002 | 0.000000 | 0.000000 | 0 || freeing items | 0.000042 | 0.000000 | 0.000000 | 0 || logging slow query | 0.000003 | 0.000000 | 0.000000 | 0 || logging slow query | 0.000065 | 0.000000 | 0.000000 | 0 || cleaning up | 0.000004 | 0.000000 | 0.000000 | 0 |+----------------------+-----------+----------+------------+-------+14 rows in set (0.00 sec) 参考我以为我对Mysql索引很了解，直到我遇到了阿里的面试官-HollisChuang’s Blog]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5特性_CSS3基础_HTML5移动端基础_touch事件基础_touch多点触摸事件]]></title>
    <url>%2Fmyhexo%2F2019%2F05%2F25%2FHTML5%E7%89%B9%E6%80%A7-CSS3%E5%9F%BA%E7%A1%80-HTML5%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%9F%BA%E7%A1%80-touch%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80-touch%E5%A4%9A%E7%82%B9%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[HTML5定位geolocation PC端,主要是获取IP地址进行定位，精度非常差 移动端，主要通过GPS定位，精度很高 geolocation getCurrentPosition 获取位置(1次) 坐标信息 res.coords watchPosition 不断获取位置 clearWatch 定位.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .bmap &#123;width:600px; height:400px; border:1px solid black&#125; &lt;/style&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=1.2"&gt;&lt;/script&gt; &lt;script&gt; window.onload=function ()&#123; var oBtn=document.getElementById('btn1'); oBtn.onclick=function ()&#123; //getCurrentPosition(成功, 失败, 参数) navigator.geolocation.getCurrentPosition(function (res)&#123; console.log(res.coords); alert('成功'); //创建和初始化地图函数： function initMap()&#123; createMap();//创建地图 setMapEvent();//设置地图事件 addMapControl();//向地图添加控件 addMapOverlay();//向地图添加覆盖物 &#125; function createMap()&#123; map = new BMap.Map("bmap"); map.centerAndZoom(new BMap.Point(res.coords.longitude,res.coords.latitude),15); &#125; function setMapEvent()&#123; map.enableScrollWheelZoom(); map.enableKeyboard(); map.enableDragging(); map.enableDoubleClickZoom() &#125; function addClickHandler(target,window)&#123; target.addEventListener("click",function()&#123; target.openInfoWindow(window); &#125;); &#125; function addMapOverlay()&#123; var markers = [ &#123;content:"来找我啊",title:"我的位置",imageOffset: &#123;width:0,height:3&#125;,position:&#123;lat:res.coords.latitude,lng:res.coords.longitude&#125;&#125; ]; for(var index = 0; index &lt; markers.length; index++ )&#123; var point = new BMap.Point(markers[index].position.lng,markers[index].position.lat); var marker = new BMap.Marker(point,&#123;icon:new BMap.Icon("http://api.map.baidu.com/lbsapi/createmap/images/icon.png",new BMap.Size(20,25),&#123; imageOffset: new BMap.Size(markers[index].imageOffset.width,markers[index].imageOffset.height) &#125;)&#125;); var label = new BMap.Label(markers[index].title,&#123;offset: new BMap.Size(25,5)&#125;); var opts = &#123; width: 200, title: markers[index].title, enableMessage: false &#125;; var infoWindow = new BMap.InfoWindow(markers[index].content,opts); marker.setLabel(label); addClickHandler(marker,infoWindow); map.addOverlay(marker); &#125;; &#125; //向地图添加控件 function addMapControl()&#123; var scaleControl = new BMap.ScaleControl(&#123;anchor:BMAP_ANCHOR_BOTTOM_LEFT&#125;); scaleControl.setUnit(BMAP_UNIT_IMPERIAL); map.addControl(scaleControl); var navControl = new BMap.NavigationControl(&#123;anchor:BMAP_ANCHOR_TOP_LEFT,type:BMAP_NAVIGATION_CONTROL_LARGE&#125;); map.addControl(navControl); var overviewControl = new BMap.OverviewMapControl(&#123;anchor:BMAP_ANCHOR_BOTTOM_RIGHT,isOpen:true&#125;); map.addControl(overviewControl); &#125; var map; initMap(); &#125;, function (err)&#123; alert('失败'); &#125;); &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="button" value="定位" id="btn1"&gt; &lt;div class="bmap" id="bmap"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 百度地图生成器 创建地图-百度地图生成器 定位中心点 设置地图 添加标注 获取代码 src=&quot;http://api.map.baidu.com/api?v=1.2&quot;版本用1.2，不然需要申请密钥，麻烦 bmap.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;meta name="keywords" content="百度地图,百度地图API，百度地图自定义工具，百度地图所见即所得工具" /&gt; &lt;meta name="description" content="百度地图API自定义地图，帮助用户在可视化操作下生成百度地图" /&gt; &lt;title&gt;百度地图API自定义地图&lt;/title&gt; &lt;!--引用百度地图API--&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=1.2"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--百度地图容器--&gt; &lt;div style="width:700px;height:550px;border:#ccc solid 1px;font-size:12px" id="map"&gt;&lt;/div&gt; &lt;p style="color:red;font-weight:600"&gt;地图生成工具基于百度地图JS api v2.0版本开发，使用请申请密匙。 &lt;a href="http://developer.baidu.com/map/index.php?title=jspopular/guide/introduction" style="color:#2f83c7" target="_blank"&gt;了解如何申请密匙&lt;/a&gt; &lt;a href="http://lbsyun.baidu.com/apiconsole/key?application=key" style="color:#2f83c7" target="_blank"&gt;申请密匙&lt;/a&gt; &lt;/p&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; //创建和初始化地图函数： function initMap()&#123; createMap();//创建地图 setMapEvent();//设置地图事件 addMapControl();//向地图添加控件 addMapOverlay();//向地图添加覆盖物 &#125; function createMap()&#123; map = new BMap.Map("map"); map.centerAndZoom(new BMap.Point(116.403963,39.917167),15); &#125; function setMapEvent()&#123; map.enableScrollWheelZoom(); map.enableKeyboard(); map.enableDragging(); map.enableDoubleClickZoom() &#125; function addClickHandler(target,window)&#123; target.addEventListener("click",function()&#123; target.openInfoWindow(window); &#125;); &#125; function addMapOverlay()&#123; var markers = [ &#123;content:"来找我啊",title:"我的位置",imageOffset: &#123;width:0,height:3&#125;,position:&#123;lat:39.914898,lng:116.404035&#125;&#125; ]; for(var index = 0; index &lt; markers.length; index++ )&#123; var point = new BMap.Point(markers[index].position.lng,markers[index].position.lat); var marker = new BMap.Marker(point,&#123;icon:new BMap.Icon("http://api.map.baidu.com/lbsapi/createmap/images/icon.png",new BMap.Size(20,25),&#123; imageOffset: new BMap.Size(markers[index].imageOffset.width,markers[index].imageOffset.height) &#125;)&#125;); var label = new BMap.Label(markers[index].title,&#123;offset: new BMap.Size(25,5)&#125;); var opts = &#123; width: 200, title: markers[index].title, enableMessage: false &#125;; var infoWindow = new BMap.InfoWindow(markers[index].content,opts); marker.setLabel(label); addClickHandler(marker,infoWindow); map.addOverlay(marker); &#125;; &#125; //向地图添加控件 function addMapControl()&#123; var scaleControl = new BMap.ScaleControl(&#123;anchor:BMAP_ANCHOR_BOTTOM_LEFT&#125;); scaleControl.setUnit(BMAP_UNIT_IMPERIAL); map.addControl(scaleControl); var navControl = new BMap.NavigationControl(&#123;anchor:BMAP_ANCHOR_TOP_LEFT,type:BMAP_NAVIGATION_CONTROL_LARGE&#125;); map.addControl(navControl); var overviewControl = new BMap.OverviewMapControl(&#123;anchor:BMAP_ANCHOR_BOTTOM_RIGHT,isOpen:true&#125;); map.addControl(overviewControl); &#125; var map; initMap(); &lt;/script&gt;&lt;/html&gt; localStorage cookie 存储内容比较小，只有4K 浏览器和服务器共享 localStorage 存储内容比较大，有5M 永久存储 浏览器独享，存在跨域问题 主要用途：记录用户名、保存草稿 sessionStorage 会话期间存储，浏览器一关就没了 存和取localStorage.html 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //localStorage.a=12; //存 //alert(localStorage.a); //取 console.log(localStorage); //localStorage.b=5; //localStorage.c=99; //遍历 /*for(let name in localStorage)&#123; alert(`$&#123;name&#125;: $&#123;localStorage[name]&#125;`); &#125;*/ for(let i=0;i&lt;localStorage.length;i++)&#123; let key=localStorage.key(i); alert(`$&#123;key&#125;: $&#123;localStorage[key]&#125;`); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 删除localStorage2.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; delete localStorage.a; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; WebWorker 多进程，更充分发挥计算机资源（内存×、IO×、网络×、CPU√），这里指CPU 主进程也称为UI进程 子进程也称为工作进程，子进程不能再创建子进程 不能控制UI的东西，但是可以进行数据交互 也存在跨域问题 实现 发送数据oW.postMessage({n1: 25, n2: 99}) 接收数据oW.onmessage=function 1.js 1234567this.onmessage=function (ev)&#123; let &#123;n1, n2&#125;=ev.data; let result=n1+n2; this.postMessage(result);&#125;; webworker.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let oW=new Worker('1.js'); oW.onmessage=function (ev)&#123; alert(ev.data); &#125;; oW.postMessage(&#123;n1: 25, n2: 99&#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; webworker2.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let oW=new Worker('1.js'); oW.onmessage=function (ev)&#123; alert(ev.data); &#125;; oW.postMessage(document); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; canvascanvas 位图,放大会失真 HTML5标准 SVG 矢量图，可以无限缩放 不是HTML5的东西，是一个独立标准 VML 矢量图，可以无限缩放 IE的矢量图，搭配SVG可以解决所有浏览器兼容 实现 路径操作,相当于PS的选区操作，没有效果，还需后续操作，需要闭合，一定要用closePath 边线 stroke() 填充fill() 版本一canvas.html 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; body &#123;background: black; text-align:center;&#125; #c1 &#123;background:#fff;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; let oC=document.getElementById('c1'); //图形上下文——接口：所有绘图方法、属性 let gd=oC.getContext('2d'); //路径操作——类似PS的选区 //起点 gd.moveTo(470, 81); gd.lineTo(778, 236); gd.lineTo(532, 411); gd.lineTo(312, 259); gd.lineTo(470, 81); //? gd.stroke(); //gd.fill(); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="c1" width="800" height="600"&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt; 版本二 手动闭合gd.lineTo(470, 81)，如果有线宽lineWidth的话，会导致闭合不完整，推荐使用自带的闭合方法closePath canvas2.html 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; body &#123;background: black; text-align:center;&#125; #c1 &#123;background:#fff;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; let oC=document.getElementById('c1'); //图形上下文——接口：所有绘图方法、属性 let gd=oC.getContext('2d'); //路径操作——类似PS的选区 //起点 gd.moveTo(470, 81); gd.lineTo(778, 236); gd.lineTo(532, 411); gd.lineTo(312, 259); //gd.lineTo(470, 81); //? gd.closePath(); gd.lineWidth=20; gd.stroke(); //gd.fill(); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="c1" width="800" height="600"&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt; 版本三 线宽：lineWidth 线色：strokeStyle 填充颜色：fillStyle canvas3.html 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; body &#123;background: black; text-align:center;&#125; #c1 &#123;background:#fff;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; let oC=document.getElementById('c1'); //图形上下文——接口：所有绘图方法、属性 let gd=oC.getContext('2d'); //路径操作——类似PS的选区 //起点 gd.moveTo(470, 81); gd.lineTo(778, 236); gd.lineTo(532, 411); gd.lineTo(312, 259); //gd.lineTo(470, 81); //? gd.closePath(); //gd.lineWidth=20; //gd.strokeStyle='green'; //gd.stroke(); gd.fillStyle='yellow'; gd.fill(); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="c1" width="800" height="600"&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt; CSS3基础圆角 CSS3圆角只需设置一个属性border-radius（含义是”边框半径”） 版本一 border-radius属性提供一个值，就能同时设置四个圆角的半径 圆角的”水平半径”（horizontal radius）和”垂直半径”（vertical radius）都设置为10px 圆角.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:300px; height:300px; background:#CCC; margin:10px auto 0; border-radius:10px;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本二 4个角的水平半径是10px,垂直半径是50px 圆角2.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:300px; height:300px; background:#CCC; margin:10px auto 0; border-radius:10px/50px;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本三 用斜杠区分，第一组值表示水平半径，第二组值表示垂直半径 圆角3.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:300px; height:300px; background:#CCC; margin:10px auto 0; border-radius:10px 50px 100px 200px/200px 100px 50px 10px;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617border-radius: 1em/5em;/* 等价于： */border-top-left-radius: 1em 5em;border-top-right-radius: 1em 5em;border-bottom-right-radius: 1em 5em;border-bottom-left-radius: 1em 5em;border-radius: 4px 3px 6px / 2px 4px;/* 等价于： */border-top-left-radius: 4px 2px;border-top-right-radius: 3px 4px;border-bottom-right-radius: 6px 2px;border-bottom-left-radius: 3px 4px; 版本四 4个角，水平半径是宽度的50%和垂直半径是高度的50% 圆角4.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:300px; height:300px; background:#CCC; margin:10px auto 0; border-radius:50%;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 阴影 文字阴影text-shadow 盒模型阴影box-shadow 版本一 文字阴影，text-shadow:5px 50px 1px red,水平5px,垂直50px,阴影程度1px,阴影颜色红色 阴影.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:300px; height:300px; background:#CCC; margin:10px auto 0; text-shadow:5px 50px 1px red&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; 这是一些字 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本二 阴影类型 inset投影为内阴影，可选 X轴偏移量5px Y轴偏移量50px 阴影模糊半径5px 阴影扩展半径，可选 阴影颜色红色 阴影2.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:300px; height:300px; background:#CCC; margin:10px auto 0; box-shadow:inset 5px 50px 5px red&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; 这是一些字 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本三阴影3.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:300px; height:300px; background:#CCC; margin:10px auto 0; box-shadow:2px 2px 2px black&#125; .box:active &#123;box-shadow:inset 2px 2px 2px black&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; 这是一些字 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本四 box-shadow:2px 2px 20px 50px black，分别代表水平偏移2px,垂直偏移2px,阴影模糊度20px,阴影扩展半径50px，阴影颜色黑色 阴影4.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:300px; height:300px; background:#CCC; margin:10px auto 0; box-shadow:2px 2px 20px 50px black&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; 这是一些字 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 渐变使用 CSS 渐变 - Web 开发者指南 | MDN 类型 线性渐变Linear Gradients 径向渐变Radial Gradients 圆锥渐变conic-gradient 渐变属于背景图片中的一种 版本一 要创建最基本的渐变类型，只需指定两种颜色即可。 这些被称为色标。 至少指定两个色标， 渐变.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123; width:300px; height:300px; background:#CCC; margin:10px auto 0; background-image:-webkit-linear-gradient(red, green); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本二 使用多种颜色渐变，默认情况下，所设置颜色会均匀分布在渐变路径中 渐变2.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123; width:300px; height:300px; background:#CCC; margin:10px auto 0; background-image:-webkit-linear-gradient(red, green, yellow, black, blue, green); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本三 -webkit-linear-gradient(red 50%, green 50%)红色占50%，绿色占50%，即没有渐变效果 渐变3.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123; width:300px; height:300px; background:#CCC; margin:10px auto 0; background-image:-webkit-linear-gradient(red 50%, green 50%); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本四 径向渐变 一个中心点向外围进行颜色渐变 -webkit-radial-gradient(left top, 100px 100px, red 30%, green 30%)渐变中心点在left top 4.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123; width:300px; height:300px; background:#CCC; margin:10px auto 0; background-image:-webkit-radial-gradient(left top, 100px 100px, red 30%, green 30%); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; rgba rgba色彩模式与RGB相同，只是在GB模式上新增了Alpha透明度 R：红色值。正整数 0 - 255| 百分数0.0% - 100.0% G：绿色值 B：蓝色值 A：Alpha透明度,取值0~1之间。 rgba.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; body &#123;background:#F0F&#125; .box &#123; width:300px; height:300px; background:rgba(0,0,0,0.1); margin:10px auto 0; color:white; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; 放一些文字 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; transform transform一定要加初始值 类型 translate 平移 rotate 旋转 scale 缩放 skew 倾斜 版本一 点击时，顺时针旋转90度 transform-rotate.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123; width:300px; height:300px; background:#CCC; margin:100px auto 0; transition:1s all ease; transform:rotate(0deg); &#125; .box:active&#123;transform:rotate(90deg);&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; 放一些文字 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本二 点击时,元素在 X轴上拉伸2倍，在 Y轴上拉伸2部 transform-scale.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123; width:300px; height:300px; background:#CCC; margin:100px auto 0; transition:1s all ease; transform:scale(1,1); &#125; .box:active&#123;transform:scale(2,2);&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; 放一些文字 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本三transform-scale2.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123; width:300px; height:300px; background:#CCC; margin:100px auto 0; transition:1s all ease; transform:scale(1,1); &#125; .box:active&#123;transform:scale(1,-1);&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; 放一些文字 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本四transform-scale3.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123; width:300px; height:300px; background:#CCC; margin:100px auto 0; transition:1s all ease; transform:scale(1,1); &#125; .box:active&#123;transform:scale(1,0);&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; 放一些文字 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本五 设置 X轴和 Y轴的倾斜角度 transform-skew.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123; width:300px; height:300px; background:#CCC; margin:100px auto 0; transition:1s all ease; transform:skew(0,0); &#125; .box:active&#123;transform:skew(0,30deg);&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; 放一些文字 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本六 元素沿着 X轴正方向平移100px，沿着 Y轴正方向平移 200px transform-translate.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123; width:300px; height:300px; background:#CCC; margin:100px auto 0; transition:1s all ease; transform:translate(0,0); &#125; .box:active&#123;transform:translate(100px,200px);&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; 放一些文字 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本七 CSS3的样式不改变盒模型 盒模型，物体占据的空间 CSS3样式(尤其是translate)不会引起重排、重绘，性能更高 DOM操作——越大越慢 重排 重绘 不改变盒模型.html 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; * &#123;margin:0; padding:0; list-style:none&#125; #ul1 li &#123;float:left; width:200px; height:200px; background:#CCC; margin:10px; transition:1s all ease; transform:scale(1); border:1px solid black; box-shadow:0 0 5px 40px black;&#125; #ul1 li:active &#123;transform:scale(2)&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="ul1"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; transform高级版本一 可以多个变换一起用，{transform:scale(2,1) rotate(45deg)}先旋转45度，再横向拉伸2倍，顺序是”反的”，看似是反的，其实是正的：矩阵乘法 多个变换一起用.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123; width:200px; height:200px; background:#CCC; margin:100px auto 0; &#125; .box:active &#123;transform:scale(2,1) rotate(45deg)&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt;aaa&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本二 2d rotate translate 3d rotateX/rotateY/rotateZ translateX/translateY/translateZ 景深/透视perspective,数值越小代表3d效果越明显 3d变换.html 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123; width:200px; height:200px; background:#CCC; margin:100px auto 0; transition: 1s all ease; transform:perspective(10000px) rotateY(0); &#125; .box:active &#123;transform:perspective(10000px) rotateY(60deg);&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt;aaa&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 动画transition 使用 CSS transitions - CSS（层叠样式表） | MDN 简单、容易、方便，比较常用 版本一 transition:1s all ease时间、样式、形式 transition.html 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:200px; height:200px; background:#CCC; margin:100px auto 0; transition:1s all ease&#125; /*.box:active &#123;width:400px; height:400px; background:yellow; font-size:30px;&#125;*/ &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; let oBox=document.getElementsByClassName('box')[0]; oBox.onclick=function ()&#123; this.style.width='400px'; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; sdfasdf &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本二transition2.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123; width:200px; height:200px; background:#CCC; margin:100px auto 0; transition:1s all ease &#125; .box:active &#123;width:400px; height:400px; background:yellow; font-size:30px;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; sdfasdf &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本三transition3.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123; width:200px; height:200px; background:#CCC; margin:100px auto 0; transition:5s all ease &#125; .box:active &#123;width:400px; height:400px; background:yellow; font-size:30px;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; sdfasdf &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; animation animation - CSS（层叠样式表） | MDN 强大、麻烦 ，复杂的链式动画 版本一 定义@keyframes aaa 调用 animation.html 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; @keyframes aaa &#123; 0%&#123;width:200px;height:200px;font-size:14px;background:#CCC&#125; 25%&#123;width:400px; height:200px; font-size:14px; background:#CCC;&#125; 50%&#123;width:400px; height:400px; font-size:14px; background:#CCC;&#125; 75%&#123;width:400px; height:400px; font-size:30px; background:#CCC;&#125; 100%&#123;width:400px; height:400px; font-size:30px; background:red;&#125; &#125; .box &#123;width:200px; height:200px; background:#CCC; margin:100px auto 0;&#125; .box:active &#123; animation-name: aaa; animation-duration: 10s; animation-timing-function:ease; /* animation-fill-mode: ; animation-delay: ; animation-iteration-count: ; animation-direction: ; animation-play-state: ; */ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; sdfasdf &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本二animation2.html 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; @keyframes aaa &#123; 0%&#123;width:200px;height:200px;font-size:14px;background:#CCC&#125; 25%&#123;width:400px; height:200px; font-size:14px; background:#CCC;&#125; 50%&#123;width:400px; height:400px; font-size:14px; background:#CCC;&#125; 75%&#123;width:400px; height:400px; font-size:30px; background:#CCC;&#125; 100%&#123;width:400px; height:400px; font-size:30px; background:red;&#125; &#125; .box &#123; width:200px; height:200px; background:#CCC; margin:100px auto 0; animation-name: aaa; animation-duration: 2s; animation-timing-function:ease; animation-fill-mode:forwards; animation-iteration-count:infinite; animation-direction:alternate; &#125; .box:active &#123; animation-play-state:paused; /* animation-delay: 2s; */ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; sdfasdf &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本三animation3.html 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; @keyframes aaa &#123; 0%&#123;transform:rotate(0)&#125; 10%&#123;transform:rotate(-20deg)&#125; 20%&#123;transform:rotate(20deg)&#125; 30%&#123;transform:rotate(0deg)&#125; 70%&#123;transform:rotate(360deg)&#125; 80%&#123;transform:rotate(340deg)&#125; 90%&#123;transform:rotate(380deg)&#125; 100%&#123;transform:rotate(360deg)&#125; &#125; .box &#123; width:200px; height:200px; background:#CCC; margin:100px auto 0; &#125; .box:hover &#123; animation-name: aaa; animation-duration: 1s; animation-timing-function:ease; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; sdfasdf &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本四animation4.html 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; @keyframes aaa &#123; 0%&#123;transform:rotate(0)&#125; 10%&#123;transform:rotate(-20deg)&#125; 20%&#123;transform:rotate(20deg)&#125; 30%&#123;transform:rotate(0deg)&#125; 70%&#123;transform:rotate(360deg)&#125; 80%&#123;transform:rotate(340deg)&#125; 90%&#123;transform:rotate(380deg)&#125; 100%&#123;transform:rotate(360deg)&#125; &#125; .box &#123; width:200px; height:200px; background:#CCC; margin:100px auto 0; &#125; .active &#123; animation-name: aaa; animation-duration: 2s; animation-timing-function:ease; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box" onclick="this.className='box active';"&gt; sdfasdf &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; HTML5移动端基础transform 3D X/Y/Z坐标轴 透视 perspective,只需要给最外层(根父元素)加一次 preserve-3d添加在子元素的直接父元素，使得子元素可以脱离元素，每个需要自己出来的地方都得加 版本一 transform:perspective(700px) rotateZ(0deg);要有初始值 perspective(700px)要有透视，才能产生3d效果 Z轴旋转，圆圈顺时针旋转 坐标轴.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:200px; height:200px; background: #CCC; border:1px solid black; margin:100px auto 0; transition:1s all ease; transform:perspective(700px) rotateZ(0deg);&#125; .box:active &#123;transform:perspective(700px) rotateZ(90deg);&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; 文字 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本二 X轴旋转，前后旋转 坐标轴2.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:200px; height:200px; background: #CCC; border:1px solid black; margin:100px auto 0; transition:1s all ease; transform:perspective(700px) rotateX(0deg);&#125; .box:active &#123;transform:perspective(700px) rotateX(90deg);&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; 文字 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本三 Y轴旋转，左右旋转 坐标轴3.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:200px; height:200px; background: #CCC; border:1px solid black; margin:100px auto 0; transition:1s all ease; transform:perspective(700px) rotateY(0deg);&#125; .box:active &#123;transform:perspective(700px) rotateY(90deg);&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; 文字 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本四 transform:perspective(700px) rotateX(60deg) rotateZ(40deg)只有用了transform,就必须指定初始值，点击前的transform和点击后的transform 父元素.box处于最外层，给自己加perspective(700px)景深,使得自己产生透视效果 为了让子元素脱离父元素产生3d效果，需要给父元素加上transform-style: preserve-3d;，因此.child元素为了脱离父元素.box,需要给父元素.box加上transform-style: preserve-3d;；同样，.child2元素为了脱离父元素.child元素，需要给父元素.child加上transform-style: preserve-3d;； 点击元素child向上平移100高度，.child:active {transform: translateZ(100px)} 点击元素child2向上平移50高度，.child:active {transform: translateZ(50px)} 坐标轴4.html 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123; width:200px; height:200px; background: #CCC; border:1px solid black; margin:100px auto 0; transform:perspective(700px) rotateX(60deg) rotateZ(40deg); /*给父级去掉限制*/ transform-style: preserve-3d; &#125; .child &#123; width:100%; height:100%; background:yellow; transition:1s all ease; transform: translateZ(0px); transform-style: preserve-3d; &#125; .child:active &#123;transform: translateZ(100px)&#125; .child2 &#123; width:100%; height:50%; background:green; transition:1s all ease; transform: translateZ(0); &#125; .child2:active &#123;transform: translateZ(50px);&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;div class="child"&gt; &lt;div class="child2"&gt; 文字 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本五3D盒子.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:200px; height:200px; position: relative; margin:150px auto 0; transition:5s all ease; transform: perspective(700px) rotateX(0deg) rotateY(0deg); transform-style: preserve-3d;&#125; .box div &#123;width:198px; height:198px; border:1px solid black; position:absolute; left:0; top:0; background:rgba(0,255,0,0.5)&#125; .box:active &#123;transform: perspective(700px) rotateX(360deg) rotateY(180deg);&#125; .box div.front &#123;transform: translateZ(100px);&#125; .box div.back &#123;transform: translateZ(-100px);&#125; .box div.left &#123;transform: rotateY(-90deg) translateZ(100px);&#125; .box div.right &#123;transform: rotateY(90deg) translateZ(100px);&#125; .box div.top &#123;transform: rotateX(90deg) translateZ(100px);&#125; .box div.down &#123;transform: rotateX(-90deg) translateZ(100px);&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;div class="front"&gt;前&lt;/div&gt; &lt;div class="back"&gt;后&lt;/div&gt; &lt;div class="top"&gt;上&lt;/div&gt; &lt;div class="down"&gt;下&lt;/div&gt; &lt;div class="left"&gt;左&lt;/div&gt; &lt;div class="right"&gt;右&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本六 点击元素.box盒子向右旋转180度transform:perspective(700px) rotateY(180deg); 元素.front向上平移transform:translateZ(1px);,使得该元素放置在上面transform:translateZ(1px); 元素.back向下平移transform:translateZ(-1px) scaleX(-1);，使得该元素放置在下面 翻转.html 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123; width:200px; height:300px; border:1px solid black; margin:100px auto 0; position: relative; transform-style: preserve-3d; transition:1s all ease; transform:perspective(700px) rotateY(0); &#125; .box:active &#123;transform:perspective(700px) rotateY(180deg);&#125; .box div &#123;position: absolute; left:0; top:0; width:100%; height:100%;&#125; .box div.front &#123;background:yellow; transform:translateZ(1px);&#125; .box div.back &#123;background:green; transform:translateZ(-1px) scaleX(-1);&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;div class="front"&gt;前&lt;/div&gt; &lt;div class="back"&gt;后&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本七 第二页.child旋转中心轴靠左transform-origin:left; 点击第二页.child向左旋转180度transform:rotateY(-180deg) 翻书.html 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:600px; height:400px; margin:100px auto 0; position: relative; transform-style:preserve-3d; transform: perspective(700px) rotateX(20deg)&#125; .box .page &#123;width:298px; height:398px; background:white; border:1px solid black; position:absolute; top:0;&#125; .box .page1 &#123;left:0;&#125; .box .page4 &#123;right:0;&#125; .box .child &#123;width:300px; height:400px; position:absolute; left:50%; top:0; transform-style:preserve-3d; transform-origin:left;&#125; .box .page2 &#123;transform: translateZ(1px);&#125; .box .page3 &#123;transform: translateZ(-1px) scaleX(-1);&#125; .box .child &#123;transition:1s all ease; transform:rotateY(0deg)&#125; .box:active .child &#123;transform:rotateY(-180deg)&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;div class="page page1"&gt; 3月5日，深圳市住房公积金管理中心公众号发文称，从2018年1月起，深圳市住建局联合市规划国土委推出六项维护公积金缴存职工购房权益的措施，在全市范围内开展专项整治行动，对拒绝职工使用公积金贷款购房的房地产开发商和中介机构依法查处。 &lt;/div&gt; &lt;div class="child"&gt; &lt;div class="page page2"&gt; 据深圳市住房公积金管理中心介绍，从行动开始到3月初，全市有21个新建商品房项目到市公积金中心办理了公积金贷款房源入库工作，新建商品房项目入库率达到95%。 &lt;/div&gt; &lt;div class="page page3"&gt; 文中明确，开发商不得拒绝公积金贷款。深圳市规划国土委将加强市场监管，要求房地产开发企业在销售商品房时，提供不拒绝购房人使用公积金贷款的书面承诺，并在项目销售现场对外公示。 &lt;/div&gt; &lt;/div&gt; &lt;div class="page page4"&gt; 与此同时，房地产开发企业和房屋销售中介机构拒绝公积金贷款，或者房地产开发企业未在楼盘销售现场公示不拒绝购房人使用公积金贷款书面承诺的，职工可电话举报违规楼盘。 &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 移动端开发 移动端适配：font-size设置的思考 - axl234 - 博客园 移动端适配版本一 viewport的宽度等于物理设备上的真实分辨率，不允许用户缩放 移动端页面.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no,maximum-scale=1.0,minimum-scale=1.0"&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="button" name="" value="按钮"&gt; &lt;/body&gt;&lt;/html&gt; 盒模型 box-sizing - CSS（层叠样式表） | MDN box-sizing 属性, 默认,属性值是content-box,意味着该盒子是一个普通盒子,盒子的width=width + padding + border，如果你设置一个元素的宽为 100px，那么这个元素的内容区会有100px宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中 属性值是border-box ,告诉浏览器你设置的边框和内边距的值是包含在width内的 版本一盒模型.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:200px; height:200px; background:#CCC; box-sizing:border-box; padding:10px; border:10px solid black;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; dfsdfdsf &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本二 设置box-sizing:border-box;元素li不会被挤到第二排 border-box.html 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; * &#123;margin:0; padding:0; list-style: none;&#125; ul &#123;overflow:hidden;&#125; ul li &#123;width:20%; float:left; box-sizing:border-box; border:5px solid black; padding:10px;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;bbb&lt;/li&gt; &lt;li&gt;ccc&lt;/li&gt; &lt;li&gt;ddd&lt;/li&gt; &lt;li&gt;eee&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; flex-弹性盒模型 具备border-box的能力 对border、padding和margin都好用,可以使得盒子根据比例自适应 浮动，可以使得元素排在一行，但是需要清除浮动 flex弹性盒模型可以使得元素排放置一行，自适应 跟max-width、min-width配合 版本一弹性盒模型.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; * &#123;margin:0; padding:0; list-style:none&#125; #ul1 &#123;display:flex;&#125; #ul1 li &#123;flex:1; border:10px solid black; padding:10px; margin:20px;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="ul1"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 版本二 第一个li设置style=&quot;min-width:400px;&quot;，屏幕缩小时，第一个li的最小宽度为400px 弹性盒模型2.html 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; * &#123;margin:0; padding:0; list-style:none&#125; #ul1 &#123;display:flex;&#125; #ul1 li &#123;flex:1; border:1px solid black;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="ul1"&gt; &lt;li style="min-width:400px;"&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 版本三 中间固定，两边自适应 弹性盒模型3.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; * &#123;margin:0; padding:0; list-style:none&#125; #ul1 &#123;display:flex;&#125; #ul1 li &#123;flex:1; border:1px solid black;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="ul1"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li style="max-width:500px; min-width:500px;"&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; rem px设置了多少就是多少 em相对于自身字体大小 rem相对于root字体大小即相对于html的font-size，在不同的屏幕尺寸下，只需要调整HTML元素的font-size 方便、性能高, 一切尺寸都用rem,推荐使用 touch事件基础 触摸事件 - Web API 接口参考 | MDN 移动端布局 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; flex 使用rem,绝对不要用px HTML5标签 有特殊作用无法替代的标签 canvas画图 video播放视频 input输入框 form表单，收集数据并提交到后台 其它的标签没啥区别，HTML5的大部分新标签仅仅只是为了更加的语义化，用合适的标签装合适的东西 新标签：section、header、footer、nav、aside、figure、legend div和section二者之间没啥区别，一个没有语义，一个有语义 CSS3实现slideUp版本一 点击按钮时，判断盒子.box是否包含.slideUp类名，有则取消，没有则添加 transition:0.5s all ease设置动画时间0.5s 1.html 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:200px; height:200px; background:#CCC; border:1px solid black; transition:0.5s all ease&#125; .slideUp &#123;height:0px;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; let oBtn=document.getElementById('btn1'); let oDiv=document.getElementById('div1'); oBtn.onclick=function ()&#123; if(Array.from(oDiv.classList).includes('slideUp'))&#123; oDiv.className='box'; &#125;else&#123; oDiv.className='box slideUp'; &#125; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="button" value="按钮" id="btn1"&gt; &lt;div id="div1" class="box"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; touch事件手指触摸 PC端,主要有mouse事件，只能有一个，就算笔记本插入2个鼠标，移动也只有一个光标点 mousedown move up 移动端，主要是touch事件，支持多点触摸 touchstart touchmove touchend 版本一 Touch Event规范中的几个重要事件 touchstart 手指触摸屏幕时触发，即使已经有手指在屏幕上也会触发 touchmove手指在屏幕滑动时触发 touchend手指从屏幕时移开时触发。 每一个事件处理程序都有一个ev的参数对象,该对象描述了当前触摸的相关信息，通过这样一个对象，能够获取到当前触碰的坐标，触碰的手指个数等等 为了手指再屏幕滑动、移开时可以解绑，滑动、移开事件采用有名函数fnMove、fnEnd,而不是匿名函数 clientX：触摸目标在视口中的x坐标 clientY：触摸目标在视口中的y坐标。 touch事件.html 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="width=device-width"&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:200px; height:200px; background:#CCC; position:absolute; left:0; top:0;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; let oBox=document.getElementsByClassName('box')[0]; oBox.addEventListener('touchstart', function (ev)&#123; let disX=ev.targetTouches[0].clientX-oBox.offsetLeft; let disY=ev.targetTouches[0].clientY-oBox.offsetTop; function fnMove(ev)&#123; oBox.style.left=ev.targetTouches[0].clientX-disX+'px'; oBox.style.top=ev.targetTouches[0].clientY-disY+'px'; &#125; function fnEnd()&#123; oBox.removeEventListener('touchmove', fnMove, false); oBox.removeEventListener('touchend', fnEnd, false); &#125; oBox.addEventListener('touchmove', fnMove, false); oBox.addEventListener('touchend', fnEnd, false); &#125;, false); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本二 通过transform来获取手势移动时的横、纵坐标值，但是通过getComputedStyle(oBox, false).transform获取transform值是一个矩阵点的值，不利于计算，我们可以用一个变量来存横、纵坐标值oBox.style.transform=`translate(${x}px,${y}px) 获取transform.html 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;transform:translateX(100px) rotate(30deg);&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; let oBox=document.querySelector('.box'); //matrix(0.707107, 0.707107, -0.707107, 0.707107, 0, 0) alert(getComputedStyle(oBox, false).transform); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; touch事件2.html 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="width=device-width"&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:200px; height:200px; background:#CCC; transform:translate(0px,0px);&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; let oBox=document.getElementsByClassName('box')[0]; let x=0,y=0; oBox.addEventListener('touchstart', function (ev)&#123; let disX=ev.targetTouches[0].clientX-x; let disY=ev.targetTouches[0].clientY-y; function fnMove(ev)&#123; x=ev.targetTouches[0].clientX-disX; y=ev.targetTouches[0].clientY-disY; oBox.style.transform=`translate($&#123;x&#125;px,$&#123;y&#125;px)`; &#125; function fnEnd()&#123; oBox.removeEventListener('touchmove', fnMove, false); oBox.removeEventListener('touchend', fnEnd, false); &#125; oBox.addEventListener('touchmove', fnMove, false); oBox.addEventListener('touchend', fnEnd, false); &#125;, false); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 方向锁定 用户超出手势移动超过5px,确定方向 方向锁定.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="width=device-width"&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:200px; height:200px; background:#CCC; transform:translate(0px,0px);&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; let oBox=document.getElementsByClassName('box')[0]; let x=0,y=0; oBox.addEventListener('touchstart', function (ev)&#123; let dir=''; let disX=ev.targetTouches[0].clientX-x; let disY=ev.targetTouches[0].clientY-y; let startX=ev.targetTouches[0].clientX; let startY=ev.targetTouches[0].clientY; function fnMove(ev)&#123; if(dir=='')&#123; //等待方向确定——用户超出5px if(Math.abs(ev.targetTouches[0].clientX-startX)&gt;=5)&#123; dir='x'; &#125;else if(Math.abs(ev.targetTouches[0].clientY-startY)&gt;=5)&#123; dir='y'; &#125; &#125;else&#123; if(dir=='x')&#123; x=ev.targetTouches[0].clientX-disX; &#125;else if(dir=='y')&#123; y=ev.targetTouches[0].clientY-disY; &#125; oBox.style.transform=`translate($&#123;x&#125;px,$&#123;y&#125;px)`; &#125; &#125; function fnEnd()&#123; oBox.removeEventListener('touchmove', fnMove, false); oBox.removeEventListener('touchend', fnEnd, false); &#125; oBox.addEventListener('touchmove', fnMove, false); oBox.addEventListener('touchend', fnEnd, false); &#125;, false); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 淘宝 rem值的确定，设计稿基准宽度/基准字体大小 假设，设计稿基准宽度：480px,基准字体大小：10px，即可得出header的width：48rem 移动端，不同的手机显示的字体大小是不一样的，那么该如何设置字体font-size的字体值rem呢 公式$$480/10=clientWidth/真实fontsize===》真实fontsize=clientWidth/48$$ 求绝对值Math.abs(x);函数返回指定数字 x的绝对值 版本一淘宝.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name="viewport" content="width=device-width"&gt; &lt;style media="screen"&gt; * &#123;margin:0; padding:0; list-style:none;&#125; html &#123;font-size:10px&#125; header &#123;width:48rem;height:5.5rem;background:#fe5400; overflow:hidden; position:relative; z-index:99;&#125; header h1 &#123;width:4.4rem; height:3.7rem; background:url(img/logo.png) no-repeat; text-indent:-9999rem; background-size:100% 100%; margin-left:0.6rem; margin-top:1rem;&#125; /*banner*/ .banner &#123;width:48rem; height:15rem; position:relative; overflow:hidden;&#125; .banner ul &#123;width:999rem; height:15rem; overflow:hidden; transform:translateX(0rem);&#125; .banner ul li &#123;width:48rem; height:15rem; float:left;&#125; .banner ul li img &#123;width:100%; height:100%;&#125; .banner ol &#123;position: absolute; right:0; bottom: 1.3rem;&#125; .banner ol li &#123;width:1rem; height:1rem; border:1px solid #333; background:white; border-radius:50%; margin:0 0.4rem; opacity:0.6; float:left;&#125; .banner ol li.active &#123;background:#ff5501; border:1px solid #d0a793; opacity:1&#125; /**/ .page_content &#123;background:white; position:relative; top:-5rem;&#125; .load &#123;height:5rem; line-height:5rem; text-align:center; font-size:2rem;&#125; &lt;/style&gt; &lt;script&gt; window.onresize=function ()&#123; document.documentElement.style.fontSize=document.documentElement.clientWidth/48+'px'; &#125;; window.onresize(); window.onload=function ()&#123; let oBanner=document.querySelector('.banner'); let oBannerUl=oBanner.children[0]; let oPageContent=document.querySelector('.page_content'); let x=0,y=0; oBanner.addEventListener('touchstart', function (ev)&#123; let startX=ev.targetTouches[0].clientX; let startY=ev.targetTouches[0].clientY; let disX=startX-x; let disY=startY-y; let dir=''; function fnMove(ev)&#123; if(dir=='')&#123; if(Math.abs(ev.targetTouches[0].clientX-startX)&gt;=5)&#123; dir='x'; &#125;else if(Math.abs(ev.targetTouches[0].clientY-startY)&gt;=5)&#123; dir='y'; &#125; &#125;else&#123; if(dir=='x')&#123; x=ev.targetTouches[0].clientX-disX; &#125;else&#123; y=ev.targetTouches[0].clientY-disY; &#125; oBannerUl.style.transform=`translateX($&#123;x&#125;px)`; if(y&gt;0)&#123; oPageContent.style.transform=`translateY($&#123;y/3&#125;px)`; &#125;else&#123; oPageContent.style.transform=`translateY($&#123;y&#125;px)`; &#125; &#125; &#125; function fnEnd()&#123; oBanner.removeEventListener('touchmove', fnMove, false); oBanner.removeEventListener('touchend', fnEnd, false); if(y&gt;0)&#123; y=0; oPageContent.style.transition='0.3s all ease'; oPageContent.style.transform=`translateY(0px)`; &#125; &#125; oBanner.addEventListener('touchmove', fnMove, false); oBanner.addEventListener('touchend', fnEnd, false); &#125;, false); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;h1&gt;淘宝网&lt;/h1&gt; &lt;/header&gt; &lt;div class="load"&gt; 下拉刷新 &lt;/div&gt; &lt;div class="page_content"&gt; &lt;section class="banner"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src="img/banner1.jpg" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/banner2.jpg" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/banner1.jpg" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/banner2.jpg" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/banner1.jpg" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/banner2.jpg" /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li class="active"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;nav&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本二 为了实现轮播，尾巴追加第一个元素，头追加最后一个元素 oBannerUl.appendChildoBannerUl.insertBefore 淘宝2.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name="viewport" content="width=device-width"&gt; &lt;style media="screen"&gt; * &#123;margin:0; padding:0; list-style:none;&#125; html &#123;font-size:10px&#125; header &#123;width:48rem;height:5.5rem;background:#fe5400; overflow:hidden; position:relative; z-index:99;&#125; header h1 &#123;width:4.4rem; height:3.7rem; background:url(img/logo.png) no-repeat; text-indent:-9999rem; background-size:100% 100%; margin-left:0.6rem; margin-top:1rem;&#125; /*banner*/ .banner &#123;width:48rem; height:15rem; position:relative; overflow:hidden;&#125; .banner ul &#123;width:999rem; height:15rem; overflow:hidden; transform:translateX(-48rem);&#125; .banner ul li &#123;width:48rem; height:15rem; float:left;&#125; .banner ul li img &#123;width:100%; height:100%;&#125; .banner ol &#123;position: absolute; right:0; bottom: 1.3rem;&#125; .banner ol li &#123;width:1rem; height:1rem; border:1px solid #333; background:white; border-radius:50%; margin:0 0.4rem; opacity:0.6; float:left;&#125; .banner ol li.active &#123;background:#ff5501; border:1px solid #d0a793; opacity:1&#125; /**/ .page_content &#123;background:white; position:relative; top:-5rem;&#125; .load &#123;height:5rem; line-height:5rem; text-align:center; font-size:2rem;&#125; &lt;/style&gt; &lt;script&gt; window.onresize=function ()&#123; document.documentElement.style.fontSize=document.documentElement.clientWidth/48+'px'; &#125;; window.onresize(); window.onload=function ()&#123; let oBanner=document.querySelector('.banner'); let oBannerUl=oBanner.children[0]; let oBannerUlLi=oBannerUl.children; let oPageContent=document.querySelector('.page_content'); let oLoad=document.querySelector('.load'); let aOlLi=document.querySelectorAll('.banner ol li'); // oBannerUl.appendChild(oBannerUlLi[0].cloneNode(true)); oBannerUl.insertBefore(oBannerUlLi[oBannerUlLi.length-2].cloneNode(true), oBannerUlLi[0]); let x=-oBannerUlLi[0].offsetWidth,y=0; oBanner.addEventListener('touchstart', function (ev)&#123; oPageContent.style.transition='none'; oBannerUl.style.transition='none'; let startX=ev.targetTouches[0].clientX; let startY=ev.targetTouches[0].clientY; let disX=startX-x; let disY=startY-y; let dir=''; function fnMove(ev)&#123; if(dir=='')&#123; if(Math.abs(ev.targetTouches[0].clientX-startX)&gt;=5)&#123; dir='x'; &#125;else if(Math.abs(ev.targetTouches[0].clientY-startY)&gt;=5)&#123; dir='y'; &#125; &#125;else&#123; if(dir=='x')&#123; x=ev.targetTouches[0].clientX-disX; &#125;else&#123; y=ev.targetTouches[0].clientY-disY; &#125; oBannerUl.style.transform=`translateX($&#123;x&#125;px)`; if(y&gt;0)&#123; oPageContent.style.transform=`translateY($&#123;y/3&#125;px)`; if(y&gt;200)&#123; oLoad.innerHTML='松手'; &#125;else&#123; oLoad.innerHTML='下拉刷新'; &#125; &#125;else&#123; oPageContent.style.transform=`translateY($&#123;y&#125;px)`; &#125; &#125; &#125; function fnEnd()&#123; oBanner.removeEventListener('touchmove', fnMove, false); oBanner.removeEventListener('touchend', fnEnd, false); if(y&gt;0)&#123; y=0; oPageContent.style.transition='0.3s all ease'; oPageContent.style.transform=`translateY(0px)`; &#125; // let n=Math.round(-x/oBannerUl.children[0].offsetWidth); x=-n*oBannerUl.children[0].offsetWidth; console.log(n); oBannerUl.style.transition='0.3s all ease'; oBannerUl.style.transform=`translateX($&#123;x&#125;px)`; Array.from(aOlLi).forEach((li,index)=&gt;&#123; li.className=index==n?'active':''; &#125;) &#125; oBanner.addEventListener('touchmove', fnMove, false); oBanner.addEventListener('touchend', fnEnd, false); &#125;, false); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;h1&gt;淘宝网&lt;/h1&gt; &lt;/header&gt; &lt;div class="load"&gt; 下拉刷新 &lt;/div&gt; &lt;div class="page_content"&gt; &lt;section class="banner"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src="img/banner1.jpg" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/banner2.jpg" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/banner1.jpg" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/banner2.jpg" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/banner1.jpg" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/banner2.jpg" /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li class="active"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;nav&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML5 CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[upload和FileReade]]></title>
    <url>%2Fmyhexo%2F2019%2F05%2F24%2Fupload%E5%92%8CFileReade%2F</url>
    <content type="text"><![CDATA[上传进度前台版本一 HTML5标签自带的进度条标签&lt;meter&gt; 上传进度oAjax.upload.onprogress 上传进度.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; window.onload=function ()&#123; let oF=document.getElementById('f1'); let oBtn=document.getElementById('btn1'); oBtn.onclick=function ()&#123; let data=new FormData(); Array.from(oF.files).forEach(file=&gt;&#123; data.append('f1', file); &#125;); // let oAjax=new XMLHttpRequest(); //POST oAjax.open('POST', `http://localhost:8080/api`, true); oAjax.upload.onprogress=function (ev)&#123; let oM=document.getElementById('m1'); oM.value=100*ev.loaded/ev.total; &#125;; oAjax.send(data); /* oAjax.onreadystatechange=function ()&#123; if(oAjax.readyState==4)&#123; if(oAjax.status&gt;=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304)&#123; alert('成功'); &#125;else&#123; alert('失败'); &#125; &#125; &#125;;*/ &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;meter id="m1" value="" min="0" max="100" style="width:500px;"&gt;&lt;/meter&gt;&lt;br&gt; &lt;input type="file" id="f1" multiple /&gt;&lt;br&gt; &lt;input type="button" value="提交" id="btn1"&gt; &lt;/body&gt;&lt;/html&gt; 版本二 自己创建进度条标签 绑定事件监听oAjax.upload.addEventListener 上传进度2.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .parent &#123;width:500px; height:20px; border:1px solid black;&#125; .child &#123;width:0; height:100%; background:green;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; let oF=document.getElementById('f1'); let oBtn=document.getElementById('btn1'); oBtn.onclick=function ()&#123; let data=new FormData(); Array.from(oF.files).forEach(file=&gt;&#123; data.append('f1', file); &#125;); // let oAjax=new XMLHttpRequest(); //POST oAjax.open('POST', `http://localhost:8080/api`, true); console.log(oAjax); oAjax.upload.addEventListener('progress', function (ev)&#123; /*let oM=document.getElementById('m1'); oM.value=100*ev.loaded/ev.total;*/ let oChild=document.getElementsByClassName('child')[0]; oChild.style.width=100*ev.loaded/ev.total+'%'; &#125;, false); oAjax.send(data); /* oAjax.onreadystatechange=function ()&#123; if(oAjax.readyState==4)&#123; if(oAjax.status&gt;=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304)&#123; alert('成功'); &#125;else&#123; alert('失败'); &#125; &#125; &#125;;*/ &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;/div&gt; &lt;/div&gt; &lt;input type="file" id="f1" multiple /&gt;&lt;br&gt; &lt;input type="button" value="提交" id="btn1"&gt; &lt;/body&gt;&lt;/html&gt; 版本三 下载进度oAjax.onprogress 下载进度.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .parent &#123;width:500px; height:20px; border:1px solid black;&#125; .child &#123;width:0; height:100%; background:green;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; let oF=document.getElementById('f1'); let oBtn=document.getElementById('btn1'); oBtn.onclick=function ()&#123; let data=new FormData(); Array.from(oF.files).forEach(file=&gt;&#123; data.append('f1', file); &#125;); // let oAjax=new XMLHttpRequest(); //POST oAjax.open('POST', `http://localhost:8080/api`, true); oAjax.onprogress=function (ev)&#123; console.log(ev); &#125;; oAjax.upload.addEventListener('progress', function (ev)&#123; /*let oM=document.getElementById('m1'); oM.value=100*ev.loaded/ev.total;*/ let oChild=document.getElementsByClassName('child')[0]; oChild.style.width=100*ev.loaded/ev.total+'%'; &#125;, false); oAjax.send(data); /* oAjax.onreadystatechange=function ()&#123; if(oAjax.readyState==4)&#123; if(oAjax.status&gt;=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304)&#123; alert('成功'); &#125;else&#123; alert('失败'); &#125; &#125; &#125;;*/ &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;/div&gt; &lt;/div&gt; &lt;input type="file" id="f1" multiple /&gt;&lt;br&gt; &lt;input type="button" value="提交" id="btn1"&gt; &lt;/body&gt;&lt;/html&gt; 版本四 下载进度绑定事件监听document.addEventListener 下载进度2.html 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .parent &#123;width:500px; height:20px; border:1px solid black;&#125; .child &#123;width:0; height:100%; background:green;&#125; &lt;/style&gt; &lt;script&gt; document.addEventListener('progress', function ()&#123; console.log('a'); &#125;, false); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form id="form1" action="http://localhost:8080/api" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" multiple&gt; &lt;input type="submit" value="上传"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 后台 解决跨域，判断请求头中是否携带req.headers[&#39;origin&#39;]字段 express_server.js 1234567891011121314151617181920212223242526272829303132333435363738394041const express=require('express'); //主体const body=require('body-parser'); //接收普通POST数据const multer=require('multer'); //接收文件POST数据const mysql=require('mysql');let db=mysql.createPool(&#123;host: 'localhost', port: 3309, user: 'root', password: '', database: '20180208'&#125;);let server=express();server.listen(8080);//中间件server.use(body.urlencoded(&#123;extended: false&#125;));let multerObj=multer(&#123;dest: './upload/'&#125;);server.use(multerObj.any());//处理请求server.use('/api', (req, res)=&gt;&#123; if(req.headers['origin']=='null' || req.headers['origin'].startsWith('http://localhost'))&#123; res.setHeader('Access-Control-Allow-Origin', '*'); &#125; let arr=[]; req.files.forEach(file=&gt;&#123; arr.push(`('$&#123;file.originalname&#125;', '$&#123;file.filename&#125;', $&#123;Math.floor(Date.now()/1000)&#125;)`); &#125;); let sql=`INSERT INTO image_table (originalname, filename, time) VALUES$&#123;arr.join(',')&#125;`; //console.log(sql); db.query(sql, (err)=&gt;&#123; if(err)&#123; res.send('不OK'); &#125;else&#123; res.send("OK"); &#125; &#125;);&#125;);//server.use(express.static('./www/')); 上传进度条实现注意 oAjax.upload.onprogress必须放在oAjax.send(data)前面 服务器必须能处理OPTIONS请求，oAjax加了upload会发送OPTIONS和POST2次请求 对于通用服务器，我们不用担心，他们会自己进行处理 对于NodeJS服务，使用express框架，使用server.use 拖拽上传 拖拽松手事件drop 绑定事件监听阻止默认行为，ev.preventDefault() 按钮阻止默认行为，return false 获取文件ev.dataTransfer.files 数据封装，使用FormData封装文件数据 发送，oAjax.send(data) 文件拖拽.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; * &#123;margin:0; padding:0&#125; .box &#123;width:400px; height:200px; background:#CCC; border:1px solid black; line-height:200px; position:absolute; left:50%; top:50%; margin-left:-200px; margin-top:-100px; text-align:center; display:none;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; let oBox=document.querySelector('.box'); let timer; document.addEventListener('dragover', (ev)=&gt;&#123; clearTimeout(timer); oBox.style.display='block'; timer=setTimeout(function ()&#123; oBox.style.display='none'; &#125;, 300); ev.preventDefault(); &#125;, false); oBox.addEventListener('dragenter', ()=&gt;&#123; oBox.innerHTML='请松手'; &#125;, false); oBox.addEventListener('dragleave', ()=&gt;&#123; oBox.innerHTML='请把文件拖到这儿'; &#125;, false); oBox.addEventListener('drop', (ev)=&gt;&#123; let data=new FormData(); Array.from(ev.dataTransfer.files).forEach(file=&gt;&#123; data.append('f1', file); &#125;); let oAjax=new XMLHttpRequest(); //POST oAjax.open('POST', `http://localhost:8080/api`, true); oAjax.upload.addEventListener('progress', function (ev)&#123; let oM=document.querySelector('#m1'); oM.value=100*ev.loaded/ev.total; &#125;, false); oAjax.send(data); ev.preventDefault(); oAjax.onreadystatechange=function ()&#123; if(oAjax.readyState==4)&#123; if(oAjax.status&gt;=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304)&#123; alert('成功'); &#125;else&#123; alert('失败'); &#125; &#125; &#125;; &#125;, false); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;meter id="m1" min="0" max="100" style="width:100%;"&gt;&lt;/meter&gt; &lt;div class="box"&gt; 请把文件拖到这儿 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 读取文件FileReader前台版本一 文件读取 方法reader.readAsDataURL(file)可以将图片文件转换为base64编码 传输数据可以通过二进制和base64来传输 base64可以把二进制数据表现成字符串 只要能出现地址src的地方，都能用Base64 一般小图标不要引用地址，直接放个base64可以优化网络性能 维护麻烦，base64编码会把文件体积变大 当读取操作成功完成时调用reader.onload 读取文件.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; * &#123;margin:0; padding:0&#125; .box &#123;width:400px; height:200px; background:#CCC; border:1px solid black; line-height:200px; position:absolute; left:50%; top:50%; margin-left:-200px; margin-top:-100px; text-align:center; display:none;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; let oBox=document.querySelector('.box'); let timer; document.addEventListener('dragover', (ev)=&gt;&#123; clearTimeout(timer); oBox.style.display='block'; timer=setTimeout(function ()&#123; oBox.style.display='none'; &#125;, 300); ev.preventDefault(); &#125;, false); oBox.addEventListener('dragenter', ()=&gt;&#123; oBox.innerHTML='请松手'; &#125;, false); oBox.addEventListener('dragleave', ()=&gt;&#123; oBox.innerHTML='请把文件拖到这儿'; &#125;, false); oBox.addEventListener('drop', (ev)=&gt;&#123; let file=ev.dataTransfer.files[0]; //读取文件 let reader=new FileReader(); reader.onload=function ()&#123; document.write(reader.result); &#125;; //base64 reader.readAsDataURL(file); ev.preventDefault(); &#125;, false); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; 请把文件拖到这儿 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本二 判断文件类型，file.type.startsWith(&#39;image/&#39;) 读取文件2.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; * &#123;margin:0; padding:0; list-style: none&#125; .box &#123;width:400px; height:200px; background:#CCC; border:1px solid black; line-height:200px; position:absolute; left:50%; top:50%; margin-left:-200px; margin-top:-100px; text-align:center; display:none;&#125; .img_list &#123;overflow:hidden;&#125; .img_list li &#123;float:left; width:200px; height:200px; border:3px solid #666; margin:10px; position:relative;&#125; .img_list li img &#123;width:100%; height:100%;&#125; .img_list li .del_btn &#123;position:absolute; right:0; top:0;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; let oUl=document.querySelector('.img_list'); let oBox=document.querySelector('.box'); let timer; document.addEventListener('dragover', (ev)=&gt;&#123; clearTimeout(timer); oBox.style.display='block'; timer=setTimeout(function ()&#123; oBox.style.display='none'; &#125;, 300); ev.preventDefault(); &#125;, false); oBox.addEventListener('dragenter', ()=&gt;&#123; oBox.innerHTML='请松手'; &#125;, false); oBox.addEventListener('dragleave', ()=&gt;&#123; oBox.innerHTML='请把文件拖到这儿'; &#125;, false); oBox.addEventListener('drop', (ev)=&gt;&#123; Array.from(ev.dataTransfer.files).forEach(file=&gt;&#123; if(!file.type.startsWith('image/'))&#123; return; &#125; let reader=new FileReader(); reader.onload=function ()&#123; let oLi=document.createElement('li'); oLi.file=file; oLi.innerHTML='&lt;img src="a.png" alt=""&gt;&lt;a href="javascript:;" class="del_btn"&gt;删除&lt;/a&gt;'; let oImg=oLi.children[0]; oImg.src=this.result; let oBtnDel=oLi.children[1]; oBtnDel.onclick=function ()&#123; oUl.removeChild(oLi); &#125;; oUl.appendChild(oLi); &#125;; reader.readAsDataURL(file); &#125;); ev.preventDefault(); &#125;, false); //真的上传 let oBtnUpload=document.querySelector('#btn_upload'); oBtnUpload.onclick=function ()&#123; let data=new FormData(); Array.from(oUl.children).forEach(li=&gt;&#123; data.append('f1', li.file); &#125;); // let oAjax=new XMLHttpRequest(); //POST oAjax.open('POST', `http://localhost:8080/api`, true); oAjax.send(data); oAjax.onreadystatechange=function ()&#123; if(oAjax.readyState==4)&#123; if(oAjax.status&gt;=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304)&#123; alert('成功'); &#125;else&#123; alert('失败'); &#125; &#125; &#125;; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class="img_list"&gt; &lt;!--&lt;li&gt; &lt;img src="a.png" alt=""&gt; &lt;a href="javascript:;" class="del_btn"&gt;删除&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="b.png" alt=""&gt; &lt;a href="javascript:;" class="del_btn"&gt;删除&lt;/a&gt; &lt;/li&gt;--&gt; &lt;/ul&gt; &lt;input type="button" name="" value="上传" id="btn_upload"&gt; &lt;div class="box"&gt; 请把文件拖到这儿 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 版本三 以二进制数据的形式存储数据，reader.readAsArrayBuffer(file) 以字符串形式存储的二进制数据，readAsBinaryString 图片(以及其他二进制数据)，readAsDataURL 将文件读取为文本，readAsText 读取文件3.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; * &#123;margin:0; padding:0; list-style: none&#125; .box &#123;width:400px; height:200px; background:#CCC; border:1px solid black; line-height:200px; position:absolute; left:50%; top:50%; margin-left:-200px; margin-top:-100px; text-align:center; display:none;&#125; .img_list &#123;overflow:hidden;&#125; .img_list li &#123;float:left; width:200px; height:200px; border:3px solid #666; margin:10px; position:relative;&#125; .img_list li img &#123;width:100%; height:100%;&#125; .img_list li .del_btn &#123;position:absolute; right:0; top:0;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; let oUl=document.querySelector('.img_list'); let oBox=document.querySelector('.box'); let timer; document.addEventListener('dragover', (ev)=&gt;&#123; clearTimeout(timer); oBox.style.display='block'; timer=setTimeout(function ()&#123; oBox.style.display='none'; &#125;, 300); ev.preventDefault(); &#125;, false); oBox.addEventListener('dragenter', ()=&gt;&#123; oBox.innerHTML='请松手'; &#125;, false); oBox.addEventListener('dragleave', ()=&gt;&#123; oBox.innerHTML='请把文件拖到这儿'; &#125;, false); oBox.addEventListener('drop', (ev)=&gt;&#123; let file=ev.dataTransfer.files[0]; let reader=new FileReader(); console.log(reader); reader.onload=function ()&#123; console.log(this.result); &#125;; reader.readAsArrayBuffer(file); ev.preventDefault(); &#125;, false); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; 请把文件拖到这儿 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 后台将读取的文件入库 连接数据库mysql.createPool 批量插入 express_server.js 1234567891011121314151617181920212223242526272829303132333435363738394041const express=require('express'); //主体const body=require('body-parser'); //接收普通POST数据const multer=require('multer'); //接收文件POST数据const mysql=require('mysql');let db=mysql.createPool(&#123;host: 'localhost', port: 3309, user: 'root', password: '', database: '20180208'&#125;);let server=express();server.listen(8080);//中间件server.use(body.urlencoded(&#123;extended: false&#125;));let multerObj=multer(&#123;dest: './upload/'&#125;);server.use(multerObj.any());//处理请求server.use('/api', (req, res)=&gt;&#123; if(req.headers['origin']=='null' || req.headers['origin'].startsWith('http://localhost'))&#123; res.setHeader('Access-Control-Allow-Origin', '*'); &#125; let arr=[]; req.files.forEach(file=&gt;&#123; arr.push(`('$&#123;file.originalname&#125;', '$&#123;file.filename&#125;', $&#123;Math.floor(Date.now()/1000)&#125;)`); &#125;); let sql=`INSERT INTO image_table (originalname, filename, time) VALUES$&#123;arr.join(',')&#125;`; //console.log(sql); db.query(sql, (err)=&gt;&#123; if(err)&#123; res.send('不OK'); &#125;else&#123; res.send("OK"); &#125; &#125;);&#125;);//server.use(express.static('./www/')); ajax版本 ajax2.0携带有oAjax.upload属性 ajax版本.html 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .parent &#123;width:500px; height:20px; border:1px solid black;&#125; .child &#123;width:0; height:100%; background:green;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; var oBtn=document.getElementById('btn1'); oBtn.onclick=function ()&#123; var oAjax=new XMLHttpRequest(); if(oAjax.upload)&#123; alert('2.0'); &#125;else&#123; alert('1.0'); &#125; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="button" value="提交" id="btn1"&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle11g安装_客户端工具管理oracle数据库]]></title>
    <url>%2Fmyhexo%2F2019%2F05%2F20%2Foracle11g%E5%AE%89%E8%A3%85-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E5%85%B7%E7%AE%A1%E7%90%86oracle%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[oracle11g安装单机版集群版客户端工具管理oracle数据库web方式管理工具sql developer下载使用设置字体工具-&gt;首选项-&gt;代码编辑器-&gt;字体 设置日期工具-&gt;首选项-&gt;数据库-&gt;NLS-&gt;日期格式 工具默认的日期格式DD-MON-RR DD-MON-RR 修改为: YYYY-MM-DD HH24:MI:SS 代码格式化Ctrl+F7 运行F9或者Ctrl+Enter PL\SQL下载配置TNS]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdk多版本设置]]></title>
    <url>%2Fmyhexo%2F2019%2F05%2F19%2Fjdk%E5%A4%9A%E7%89%88%E6%9C%AC%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[jdk多版本设置Windows安装jdk1.6 jdk1.7 jdk1.8 删除或者重命名 C:\Windows\System32下的java.exe、javaw.exe、javaws.exe C:\Program Files (x86)\Common Files\Oracle\Java\javapath下的java.exe、javaw.exe、javaws.exe 配置自己的jdk环境变量 Linux]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax2.0的FormData和跨域Cors]]></title>
    <url>%2Fmyhexo%2F2019%2F05%2F15%2FAjax2-0%E7%9A%84FormData%E5%92%8C%E8%B7%A8%E5%9F%9FCors%2F</url>
    <content type="text"><![CDATA[formdata前台浏览器ajax2.0的东西 入门 set(key, value) 会覆盖 append(key, value) 不覆盖 get(key)=&gt;value delete(key) 1.html 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let data=new FormData(); data.set('user', 'blue'); data.append('user', 'blue2'); console.log(data.getAll('user')); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 控制提交数据原生实现前台2.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; window.onload=function ()&#123; let oUser=document.getElementById('user'); let oPass=document.getElementById('pass'); let oBtn=document.getElementById('btn1'); oBtn.onclick=function ()&#123; let data=new FormData(); data.set('user', oUser.value); data.set('pass', oPass.value); // let oAjax=new XMLHttpRequest(); //GET let arr=[]; data.forEach((value, key)=&gt;&#123; arr.push(`$&#123;encodeURIComponent(key)&#125;=$&#123;encodeURIComponent(value)&#125;`); &#125;); oAjax.open('GET', `http://localhost:8080/api?$&#123;arr.join('&amp;')&#125;`, true); oAjax.setRequestHeader('my-origin-blue', window.location.hostname); oAjax.send(); //POST /*oAjax.open('POST', `http://localhost:8080/api`, true); oAjax.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); oAjax.send(data);*/ oAjax.onreadystatechange=function ()&#123; if(oAjax.readyState==4)&#123; if(oAjax.status&gt;=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304)&#123; alert('成功:'+oAjax.responseText); &#125;else&#123; alert('失败'); &#125; &#125; &#125;; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 用户：&lt;input type="text" id="user" /&gt;&lt;br&gt; 密码：&lt;input type="password" id="pass" /&gt;&lt;br&gt; &lt;input type="button" value="提交" id="btn1"&gt; &lt;/body&gt;&lt;/html&gt; 后台server.js 123456789101112131415161718192021222324252627const http=require('http');const urlLib=require('url');const querystring=require('querystring');http.createServer((req, res)=&gt;&#123; console.log(req.headers['my-origin-blue']); //if(req.headers['origin']=='null' || /^https?:\/\/(\w+\.)+abc\.com/.test(req.headers['origin']))&#123; if(req.headers['origin']=='null' || req.headers['origin'].startsWith('http://localhost'))&#123; res.setHeader('Access-Control-Allow-Origin', '*'); &#125; let &#123;pathname: url, query: get&#125;=urlLib.parse(req.url, true); let arr=[]; req.on('data', data=&gt;&#123; arr.push(data); &#125;); req.on('end', ()=&gt;&#123; let post=querystring.parse(Buffer.concat(arr).toString()); console.log(url, get, post); res.write('asdfasdf'); res.end(); &#125;);&#125;).listen(8080); 文件上传express框架实现安装依赖package.json 123456789101112131415161718&#123; "name": "2018-2-6", "version": "1.0.0", "description": "", "main": "1.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "node server.js" &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "body-parser": "^1.18.2", "express": "^4.16.2", "multer": "^1.3.0" &#125;&#125; 前台3.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; window.onload=function ()&#123; let oUser=document.getElementById('user'); let oPass=document.getElementById('pass'); let oF=document.getElementById('f1'); let oBtn=document.getElementById('btn1'); oBtn.onclick=function ()&#123; let data=new FormData(); data.set('user', oUser.value); data.set('pass', oPass.value); Array.from(oF.files).forEach(file=&gt;&#123; data.append('f1', file); &#125;); // let oAjax=new XMLHttpRequest(); //POST oAjax.open('POST', `http://localhost:8080/api`, true); oAjax.send(data); oAjax.onreadystatechange=function ()&#123; if(oAjax.readyState==4)&#123; if(oAjax.status&gt;=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304)&#123; alert('成功'); &#125;else&#123; alert('失败'); &#125; &#125; &#125;; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 用户：&lt;input type="text" id="user" /&gt;&lt;br&gt; 密码：&lt;input type="password" id="pass" /&gt;&lt;br&gt; 头像：&lt;input type="file" id="f1" multiple /&gt;&lt;br&gt; &lt;input type="button" value="提交" id="btn1"&gt; &lt;/body&gt;&lt;/html&gt; 后台express_server.js 123456789101112131415161718192021222324252627282930const express=require('express'); //主体const body=require('body-parser'); //接收普通POST数据const multer=require('multer'); //接收文件POST数据//let server=http.createServer((req, res)=&gt;&#123;&#125;);//server.listen(8080);let server=express();server.listen(8080);//中间件server.use(body.urlencoded(&#123;extended: false&#125;));let multerObj=multer(&#123;dest: './upload/'&#125;);server.use(multerObj.any());//处理请求server.post('/api', (req, res)=&gt;&#123; if(req.headers['origin']=='null' || req.headers['origin'].startsWith('http://localhost'))&#123; res.setHeader('Access-Control-Allow-Origin', '*'); &#125; res.send("OK"); console.log(req.body); //普通POST数据 console.log(req.files); //文件POST数据，req.files来自于multer&#125;);//server.use(express.static('./www/')); cors跨域早期跨域解决方案是使用jsonp ajax1.0的时代，浏览器请求服务器的时候，请求头并不会携带origin,对于跨域的解决方案是使用其它的手段。 ajax2.0以后，浏览器请求服务器，请求头中会有origin ,服务器接到请求要验证请求头中的origin认不认识 认识的话则进行设置res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); 浏览器接收服务器的响应后，查看响应头中Access-Control-Allow-Origin是否进行了设置，如果设置了*，则表示允许本次请求后成功处理响应。 关键代码 文件拖拽 ondragenter 拖着东西进入 ondragleave 拖着东西离开 ondragover 悬停 ondrop 松手 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:400px; height:150px; border:1px solid black; background:#CCC; position: absolute; margin-left: -200px; margin-top: -75px; left:50%; top:50%; text-align:center; line-height:150px;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; let oBox=document.querySelector('.box'); oBox.ondragenter=function ()&#123; oBox.innerHTML='松手上传'; &#125;; oBox.ondragleave=function ()&#123; oBox.innerHTML='请拖到这里'; &#125;; oBox.ondragover=function ()&#123; //只要鼠标还没松手、并且还没离开，一直不停发生 console.log("aaaa"); //ondragover不阻止默认事件，ondrop不会触发 return false; &#125;; oBox.ondrop=function (ev)&#123; //alert('松手'); let data=new FormData(); Array.from(ev.dataTransfer.files).forEach(file=&gt;&#123; data.append('f1', file); &#125;); // let oAjax=new XMLHttpRequest(); //POST oAjax.open('POST', `http://localhost:8080/api`, true); oAjax.send(data); oAjax.onreadystatechange=function ()&#123; if(oAjax.readyState==4)&#123; if(oAjax.status&gt;=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304)&#123; alert('上传成功'); &#125;else&#123; alert('上传失败'); &#125; &#125; &#125;; return false; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; 请拖到这里 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ajax2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[websocket原理]]></title>
    <url>%2Fmyhexo%2F2019%2F05%2F12%2Fwebsocket%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[websocket 双向通信 性能高 WebSocket是前台的东西，是HTML5带的一种东西 只有前台有WebSocket这个东西 后台没有，后台有Socket 使用socket.io实现WebSocket引入依赖123456789101112131415&#123; "name": "2018-2-3", "version": "1.0.0", "description": "", "main": "server.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "node server.js" &#125;, "author": "", "license": "ISC", "devDependencies": &#123; "socket.io": "^2.0.4" &#125;&#125; 前台1.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; #ul1 &#123;width:400px; height:300px; border:1px solid black; overflow:auto;&#125; #ul1 li.me &#123;color:green&#125; .err_box &#123;width:100%; height:20px; line-height: 20px; text-align:center; color:red; display:none&#125; &lt;/style&gt; &lt;script src="http://localhost:8080/socket.io/socket.io.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; let sock=io.connect('ws://localhost:8080/'); sock.on('connect', ()=&gt;&#123; console.log('已连接'); document.getElementsByClassName('err_box')[0].style.display='none'; &#125;); sock.on('disconnect', ()=&gt;&#123; console.log('已断开'); document.getElementsByClassName('err_box')[0].style.display='block'; &#125;); //聊天室 window.onload=function ()&#123; let oTxt=document.getElementById('txt1'); let oBtn=document.getElementById('btn1'); let oUl=document.getElementById('ul1'); oBtn.onclick=function ()&#123; sock.emit('msg', oTxt.value); let oLi=document.createElement('li'); oLi.innerHTML=oTxt.value; oLi.className='me'; oTxt.value=''; oUl.appendChild(oLi); &#125;; sock.on('msg', str=&gt;&#123; let oLi=document.createElement('li'); oLi.innerHTML=str; oUl.appendChild(oLi); &#125;); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="err_box"&gt; 无法连接到服务器，请检查网络 &lt;/div&gt; &lt;ul id="ul1"&gt;&lt;/ul&gt; &lt;textarea rows="4" cols="60" id="txt1"&gt;&lt;/textarea&gt; &lt;input type="button" value="发送" id="btn1"&gt; &lt;/body&gt;&lt;/html&gt; 后台server.js 123456789101112131415161718192021222324252627282930313233343536const http=require('http');const io=require('socket.io');let httpServer=http.createServer((req, res)=&gt;&#123;&#125;);httpServer.listen(8080);//let wsServer=io.listen(httpServer);let aSock=[];wsServer.on('connection', sock=&gt;&#123; aSock.push(sock); //断开连接 sock.on('disconnect', ()=&gt;&#123; let n=aSock.indexOf(sock); if(n!=-1)&#123; aSock.splice(n, 1); &#125; &#125;); sock.on('msg', str=&gt;&#123; aSock.forEach(s=&gt;&#123; if(s!=sock)&#123; s.emit('msg', str); &#125; &#125;); &#125;);&#125;);setInterval(function ()&#123; console.log(aSock.length);&#125;, 500); 原生WebSocket实现前台raw_client.html 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let sock=new WebSocket('ws://localhost:8080/'); sock.emit=function (name, ...args)&#123; alert(JSON.stringify(&#123;name, data: [...args]&#125;)); sock.send(JSON.stringify(&#123;name, data: [...args]&#125;)); &#125;; //连上了 sock.onopen=function ()&#123; alert('连接上了'); //发送数据 sock.emit('msg', 12, 5); &#125;; //有数据 sock.onmessage=function ()&#123; alert('有消息过来'); &#125;; //断开了 sock.onclose=function ()&#123; alert('断了'); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 后台建立连接原始数据1234567891011121314GET / HTTP/1.1Host: localhost:8080Connection: UpgradePragma: no-cacheCache-Control: no-cacheUpgrade: websocketOrigin: file://Sec-WebSocket-Version: 13User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, likeGecko) Chrome/65.0.3315.4 Safari/537.36Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7,es;q=0.6,fr;q=0.5,pt;q=0.4Sec-WebSocket-Key: +0jgXtYyVeG28Gn1CLUKIg==Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits 分析原始数据 第一行删掉 12345678910111213Host: localhost:8080Connection: UpgradePragma: no-cacheCache-Control: no-cacheUpgrade: websocketOrigin: file://Sec-WebSocket-Version: 13User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, likeGecko) Chrome/65.0.3315.4 Safari/537.36Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7,es;q=0.6,fr;q=0.5,pt;q=0.4Sec-WebSocket-Key: +0jgXtYyVeG28Gn1CLUKIg==Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits 舍弃第一行和最后两行 lines=lines.slice(1, lines.length-2); 每行数据用”: “切开 代码raw_server.js 引入net模块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const http=require('http');const net=require('net'); //TCP 原生Socketconst crypto=require('crypto');/*let server=http.createServer((req, res)=&gt;&#123; console.log('连接');&#125;);server.listen(8080);*/let server=net.createServer(sock=&gt;&#123; console.log('连接'); //数据过来——握手只有一次 sock.once('data', data=&gt;&#123; console.log('hand shake start...'); let str=data.toString(); let lines=str.split('\r\n'); //舍弃第一行和最后两行 lines=lines.slice(1, lines.length-2); //切开 let headers=&#123;&#125;; lines.forEach(line=&gt;&#123; let [key, val]=line.split(': '); headers[key.toLowerCase()]=val; &#125;); //console.log(headers); if(headers['upgrade']!='websocket')&#123; console.log('其他协议', headers['upgrade']); sock.end(); &#125;else if(headers['sec-websocket-version']!=13)&#123; console.log('版本不对', headers['sec-websocket-version']); sock.end(); &#125;else&#123; let key=headers['sec-websocket-key']; let mask='258EAFA5-E914-47DA-95CA-C5AB0DC85B11'; //sha1(key+mask)-&gt;base64=&gt;client let hash=crypto.createHash('sha1'); hash.update(key+mask); let key2=hash.digest('base64'); sock.write(`HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: $&#123;key2&#125;\r\n\r\n`); console.log('hand shake end'); //真正的数据 sock.on('data', data=&gt;&#123; console.log('有数据'); console.log(data); &#125;); &#125; &#125;); //断开了 sock.on('end', ()=&gt;&#123; console.log('客户端已断开'); &#125;);&#125;);server.listen(8080); 解析真正数据真正数据 1234567891011121381 9c 11 2d f8 bd 数据.....10000001 10011100 00010001 00101101 11111000 1011110111 2d f8 bd6a 0f 96 dc 7c 48 da 87 33 40 8b da 33 01 da d9 70 59 99 9f 2b 76 c9 8f 3d 18 a5 c01 000 0001 1 0011100 00010001 00101101 11111000 10111101F RSV opcode M payload masking-keyI A 28个字N S K 帧结构1234567891011121314151617181920212223242526272829 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7+-+-+-+-+-------+-+-------------+-------------------------------+|F|R|R|R| opcode|M| Payload len | Extended payload length ||I|S|S|S| (4) |A| (7) | (16/64) ||N|V|V|V| |S| | (if payload len==126/127) || |1|2|3| |K| | |+-+-+-+-+-------+-+-------------+-------------------------------+| Extended payload length continued, if payload len == 127 |+-------------------------------+-------------------------------+| |Masking-key, if MASK set to 1 |+-------------------------------+-------------------------------+| Masking-key (continued) | Payload Data |+-------------------------------+-------------------------------+| Payload Data continued ... |+---------------------------------------------------------------+| Payload Data continued ... |+---------------------------------------------------------------+FIN 1bit 是否最后一帧RSV 3bit 预留Opcode 4bit 帧类型Mask 1bit 掩码，是否加密数据，默认必须置为1Payload 7bit 长度Masking-key 1 or 4 bit 掩码Payload data (x + y) bytes 数据Extension data x bytes 扩展数据Application data y bytes 程序数据 传递数据单位1位(bit)8位等于1字节(byte) 代码raw_server2.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const http=require('http');const net=require('net'); //TCP 原生Socketconst crypto=require('crypto');/*let server=http.createServer((req, res)=&gt;&#123; console.log('连接');&#125;);server.listen(8080);*/let server=net.createServer(sock=&gt;&#123; console.log('连接'); //数据过来——握手只有一次 sock.once('data', data=&gt;&#123; console.log('hand shake start...'); let str=data.toString(); let lines=str.split('\r\n'); //舍弃第一行和最后两行 lines=lines.slice(1, lines.length-2); //切开 let headers=&#123;&#125;; lines.forEach(line=&gt;&#123; let [key, val]=line.split(': '); headers[key.toLowerCase()]=val; &#125;); //console.log(headers); if(headers['upgrade']!='websocket')&#123; console.log('其他协议', headers['upgrade']); sock.end(); &#125;else if(headers['sec-websocket-version']!=13)&#123; console.log('版本不对', headers['sec-websocket-version']); sock.end(); &#125;else&#123; let key=headers['sec-websocket-key']; let mask='258EAFA5-E914-47DA-95CA-C5AB0DC85B11'; //sha1(key+mask)-&gt;base64=&gt;client let hash=crypto.createHash('sha1'); hash.update(key+mask); let key2=hash.digest('base64'); sock.write(`HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: $&#123;key2&#125;\r\n\r\n`); console.log('hand shake end'); //真正的数据 sock.on('data', data=&gt;&#123; console.log('有数据'); let FIN=data[0]&amp;0x001; let opcode=data[0]&amp;0x0F0; let mask=data[1]&amp;0x001; let payload=data[1]&amp;0x0FE; console.log(FIN, opcode); console.log(mask, payload); &#125;); &#125; &#125;); //断开了 sock.on('end', ()=&gt;&#123; console.log('客户端已断开'); &#125;);&#125;);server.listen(8080); 总结流程引入net模块握手12客户端:version:13、sec-websocket-key:xxxxx、sha1(key+mask)=&gt;base64服务端:101 Switching Protocols、sec-websocket-accept: base64 客户端 onopen onmessage onclose 服务端 net.createServer(sock=&gt;{}); sock.once(‘data’, 握手); sock.on(‘data’, 数据请求); sock.on(‘end’); 数据帧解析参考WebSocket 实战 WebSocket - Wikipedia]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUC多线程并发、JVM和GC]]></title>
    <url>%2Fmyhexo%2F2019%2F05%2F07%2FJUC%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E3%80%81JVM%E5%92%8CGC%2F</url>
    <content type="text"><![CDATA[Callable接口Runnable和Callable的区别 Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的 Callable规定的方法是call(),Runnable规定的方法是run() Callable的任务执行后可返回值，而Runnable的任务是不能返回值(是void) call方法可以抛出异常，run方法不可以 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。 加入线程池运行，Runnable使用ExecutorService的execute方法，Callable使用submit方法。 Callable接口callable有个&lt;V&gt;,这个V就是call函数的返回值类型 12345678910111213141516171819202122232425262728293031package java.util.concurrent;/** * A task that returns a result and may throw an exception. * Implementors define a single method with no arguments called * &#123;@code call&#125;. * * &lt;p&gt;The &#123;@code Callable&#125; interface is similar to &#123;@link * java.lang.Runnable&#125;, in that both are designed for classes whose * instances are potentially executed by another thread. A * &#123;@code Runnable&#125;, however, does not return a result and cannot * throw a checked exception. * * &lt;p&gt;The &#123;@link Executors&#125; class contains utility methods to * convert from other common forms to &#123;@code Callable&#125; classes. * * @see Executor * @since 1.5 * @author Doug Lea * @param &lt;V&gt; the result type of method &#123;@code call&#125; */@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; FutureTask类12345678910111213141516171819202122232425/** * A cancellable asynchronous computation. This class provides a base * implementation of &#123;@link Future&#125;, with methods to start and cancel * a computation, query to see if the computation is complete, and * retrieve the result of the computation. The result can only be * retrieved when the computation has completed; the &#123;@code get&#125; * methods will block if the computation has not yet completed. Once * the computation has completed, the computation cannot be restarted * or cancelled (unless the computation is invoked using * &#123;@link #runAndReset&#125;). * * &lt;p&gt;A &#123;@code FutureTask&#125; can be used to wrap a &#123;@link Callable&#125; or * &#123;@link Runnable&#125; object. Because &#123;@code FutureTask&#125; implements * &#123;@code Runnable&#125;, a &#123;@code FutureTask&#125; can be submitted to an * &#123;@link Executor&#125; for execution. * * &lt;p&gt;In addition to serving as a standalone class, this class provides * &#123;@code protected&#125; functionality that may be useful when creating * customized task classes. * * @since 1.5 * @author Doug Lea * @param &lt;V&gt; The result type returned by this FutureTask's &#123;@code get&#125; methods */public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; 12345678910111213/** * Creates a &#123;@code FutureTask&#125; that will, upon running, execute the * given &#123;@code Callable&#125;. * * @param callable the callable task * @throws NullPointerException if the callable is null */public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable&#125; RunnableFuture接口12345678910111213141516171819package java.util.concurrent;/** * A &#123;@link Future&#125; that is &#123;@link Runnable&#125;. Successful execution of * the &#123;@code run&#125; method causes completion of the &#123;@code Future&#125; * and allows access to its results. * @see FutureTask * @see Executor * @since 1.6 * @author Doug Lea * @param &lt;V&gt; The result type returned by this Future's &#123;@code get&#125; method */public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run();&#125; 测试12345678910111213141516171819202122232425262728public class CallableTest &#123; public static void main(String[] args) throws Exception &#123; MyThread mt = new MyThread(); FutureTask&lt;Integer&gt; result = new FutureTask&lt;Integer&gt;(mt); new Thread(result).start(); // 获取运算结果是同步过程，即 call 方法执行完成，才能获取结果 Integer sum = result.get(); System.out.println(sum); &#125;&#125;class MyThread implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; int sum = 0; for (int i = 1; i &lt;= 100; i++) &#123; sum += i; &#125; return sum; &#125; &#125; 当某个请求需要在后端完成 N 次统计结果时，我们就可以使用该方式创建 N 个线程进行（并行）统计，而不需要同步等待其他统计操作完成后才统计另一个结果。 线程池线程池3个常用方式Executors.newFixedThreadPool 123456789101112131415161718192021/** * Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue. At any point, at most * &#123;@code nThreads&#125; threads will be active processing tasks. * If additional tasks are submitted when all threads are active, * they will wait in the queue until a thread is available. * If any thread terminates due to a failure during execution * prior to shutdown, a new one will take its place if needed to * execute subsequent tasks. The threads in the pool will exist * until it is explicitly &#123;@link ExecutorService#shutdown shutdown&#125;. * * @param nThreads the number of threads in the pool * @return the newly created thread pool * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125; */public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; Executors.newSingleThreadExecutor 12345678910111213141516171819/** * Creates an Executor that uses a single worker thread operating * off an unbounded queue. (Note however that if this single * thread terminates due to a failure during execution prior to * shutdown, a new one will take its place if needed to execute * subsequent tasks.) Tasks are guaranteed to execute * sequentially, and no more than one task will be active at any * given time. Unlike the otherwise equivalent * &#123;@code newFixedThreadPool(1)&#125; the returned executor is * guaranteed not to be reconfigurable to use additional threads. * * @return the newly created single-threaded Executor */public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; Executors.newCachedThreadPool 123456789101112131415161718192021/** * Creates a thread pool that creates new threads as needed, but * will reuse previously constructed threads when they are * available. These pools will typically improve the performance * of programs that execute many short-lived asynchronous tasks. * Calls to &#123;@code execute&#125; will reuse previously constructed * threads if available. If no existing thread is available, a new * thread will be created and added to the pool. Threads that have * not been used for sixty seconds are terminated and removed from * the cache. Thus, a pool that remains idle for long enough will * not consume any resources. Note that pools with similar * properties but different details (for example, timeout parameters) * may be created using &#123;@link ThreadPoolExecutor&#125; constructors. * * @return the newly created thread pool */public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 线程池7大参数Java 多线程开发之 Callable 与线程池（三） - 后端 - 掘金 int corePoolSize 线程池核心线程个数，默认线程池线程个数为 0，只有接到任务才新建线程 int maximumPoolSize 线程池最大线程数量 long keepAliveTime 线程池空闲时，线程存活的时间，当线程池中的线程数大于 corePoolSize 时才会起作用 TimeUnit unit 时间单位 BlockingQueue workQueue 阻塞队列，当达到线程数达到 corePoolSize 时，将任务放入队列等待线程处理 ThreadFactory threadFactory 线程工厂 RejectedExecutionHandler handler 线程拒绝策略，当队列满了并且线程个数达到 maximumPoolSize 后采取的策略 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters and default thread factory. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; * or &#123;@code handler&#125; is null */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);&#125;/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @param threadFactory the factory to use when the executor * creates a new thread * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; * or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 线程池的合理配置获取系统设备处理器核数1Runtime.getRuntime().availableProcessors() 考虑因素CPU密集型线程数 = CPU可用核心数/(1 - 阻塞系数)，其中阻塞系数的取值在0和1之间 IO密集型线程池的工作原理 execute方法执行逻辑核心线程数如果当前运行的线程少于corePoolSize，则会创建新的线程来执行新的任务 加入阻塞队列如果运行的线程个数等于或者大于corePoolSize，则会将提交的任务存放到阻塞队列workQueue中 扩容如果当前workQueue队列已满的话，则会创建新的线程来执行任务 拒绝策略如果线程个数已经超过了maximumPoolSize，则会使用饱和策略RejectedExecutionHandler来进行处理 JVM常见故障StackOverflowError123456789public class StackOverflowErrorDemo &#123; public static void main(String[] args) &#123; stackOverflowError(); &#125; private static void stackOverflowError() &#123; stackOverflowError(); &#125;&#125; 结果 1234Exception in thread &quot;main&quot; java.lang.StackOverflowError at StackOverflowErrorDemo.stackOverflowError(StackOverflowErrorDemo.java:7) at StackOverflowErrorDemo.stackOverflowError(StackOverflowErrorDemo.java:7) at StackOverflowErrorDemo.stackOverflowError(StackOverflowErrorDemo.java:7) Java heap space12345678910111213import java.util.Random;public class JavaHeapSpaceDemo &#123; public static void main(String[] args) &#123; String str = "abc"; while (true)&#123; str+=str+new Random().nextInt(111111)+new Random().nextInt(222222); str.intern(); &#125; &#125;&#125; 运行 配置参数 结果 123456Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3332) at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124) at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448) at java.lang.StringBuilder.append(StringBuilder.java:136) at JavaHeapSpaceDemo.main(JavaHeapSpaceDemo.java:9) GC overhead limit exceededGC回收时间过长时会抛出OutOfMemoryError。过长的定义是，超过98%的时间用来做GC并且回收了不到2%的堆内存 连续多次GC都只回收了不到2%的极端情况下才会抛出。假如不抛出GC overhead limit 错误会发生什么情况呢？ 那就是GC清理的这么点内存很快会再次填满，迫使GC再次致谢，这样就形成了恶性循环，CPU使用率一直是100%，而GC却没有任何成果 1234567891011121314151617181920212223import java.util.ArrayList;import java.util.List;public class GCOverheadDemo &#123; public static void main(String[] args) &#123; int i = 0; List&lt;String&gt; list = new ArrayList&lt;&gt;(); try &#123; while (true) &#123; list.add(String.valueOf(++i).intern()); &#125; &#125; catch (Exception e) &#123; System.out.println("**************i:" + i); e.printStackTrace(); throw e; &#125; &#125;&#125; 运行参数配置 结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;480K(2560K)] 2048K-&gt;916K(9728K), 0.0043924 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 2528K-&gt;480K(2560K)] 2964K-&gt;2709K(9728K), 0.0022096 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 2528K-&gt;504K(2560K)] 4757K-&gt;4835K(9728K), 0.0028678 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 2552K-&gt;488K(2560K)] 6883K-&gt;6764K(9728K), 0.0032660 secs] [Times: user=0.06 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 488K-&gt;0K(2560K)] [ParOldGen: 6276K-&gt;6188K(7168K)] 6764K-&gt;6188K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0784031 secs] [Times: user=0.25 sys=0.00, real=0.08 secs] [Full GC (Ergonomics) [PSYoungGen: 2048K-&gt;738K(2560K)] [ParOldGen: 6188K-&gt;7039K(7168K)] 8236K-&gt;7777K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0437521 secs] [Times: user=0.19 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2048K-&gt;2046K(2560K)] [ParOldGen: 7039K-&gt;7039K(7168K)] 9087K-&gt;9086K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0405225 secs] [Times: user=0.28 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2048K-&gt;2047K(2560K)] [ParOldGen: 7039K-&gt;7039K(7168K)] 9087K-&gt;9087K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0315932 secs] [Times: user=0.13 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7039K-&gt;7039K(7168K)] 9087K-&gt;9087K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0350043 secs] [Times: user=0.23 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7041K-&gt;7041K(7168K)] 9089K-&gt;9089K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0343159 secs] [Times: user=0.25 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7043K-&gt;7043K(7168K)] 9091K-&gt;9091K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0335877 secs] [Times: user=0.33 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7044K-&gt;7044K(7168K)] 9092K-&gt;9092K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0324352 secs] [Times: user=0.20 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7046K-&gt;7046K(7168K)] 9094K-&gt;9094K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0329995 secs] [Times: user=0.20 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7048K-&gt;7048K(7168K)] 9096K-&gt;9096K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0342704 secs] [Times: user=0.14 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7050K-&gt;7050K(7168K)] 9098K-&gt;9098K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0336287 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7051K-&gt;7051K(7168K)] 9099K-&gt;9099K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0324847 secs] [Times: user=0.22 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7053K-&gt;7053K(7168K)] 9101K-&gt;9101K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0342784 secs] [Times: user=0.22 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7055K-&gt;7055K(7168K)] 9103K-&gt;9103K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0334541 secs] [Times: user=0.33 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7057K-&gt;7057K(7168K)] 9105K-&gt;9105K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0341891 secs] [Times: user=0.22 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7058K-&gt;7058K(7168K)] 9106K-&gt;9106K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0302677 secs] [Times: user=0.19 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7060K-&gt;7060K(7168K)] 9108K-&gt;9108K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0326491 secs] [Times: user=0.19 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7062K-&gt;7062K(7168K)] 9110K-&gt;9110K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0327378 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7064K-&gt;7064K(7168K)] 9112K-&gt;9112K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0325700 secs] [Times: user=0.09 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7065K-&gt;7065K(7168K)] 9113K-&gt;9113K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0322844 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7067K-&gt;7067K(7168K)] 9115K-&gt;9115K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0269232 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7069K-&gt;7069K(7168K)] 9117K-&gt;9117K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0343916 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7071K-&gt;7071K(7168K)] 9119K-&gt;9119K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0329739 secs] [Times: user=0.09 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7072K-&gt;7072K(7168K)] 9120K-&gt;9120K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0311813 secs] [Times: user=0.05 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7074K-&gt;7074K(7168K)] 9122K-&gt;9122K(9728K), [Metaspace: 3225K-&gt;3225K(1056768K)], 0.0385086 secs] [Times: user=0.05 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7078K-&gt;7058K(7168K)] 9126K-&gt;9106K(9728K), [Metaspace: 3228K-&gt;3228K(1056768K)], 0.0489022 secs] [Times: user=0.17 sys=0.00, real=0.05 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7060K-&gt;7060K(7168K)] 9108K-&gt;9108K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0297955 secs] [Times: user=0.14 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7061K-&gt;7061K(7168K)] 9109K-&gt;9109K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0277327 secs] [Times: user=0.06 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7063K-&gt;7063K(7168K)] 9111K-&gt;9111K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0337749 secs] [Times: user=0.25 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7065K-&gt;7065K(7168K)] 9113K-&gt;9113K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0274153 secs] [Times: user=0.06 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7067K-&gt;7067K(7168K)] 9115K-&gt;9115K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0325819 secs] [Times: user=0.16 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7069K-&gt;7069K(7168K)] 9117K-&gt;9117K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0353046 secs] [Times: user=0.19 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7070K-&gt;7070K(7168K)] 9118K-&gt;9118K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0310516 secs] [Times: user=0.22 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7072K-&gt;7072K(7168K)] 9120K-&gt;9120K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0344718 secs] [Times: user=0.13 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7074K-&gt;7074K(7168K)] 9122K-&gt;9122K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0291248 secs] [Times: user=0.09 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7076K-&gt;7076K(7168K)] 9124K-&gt;9124K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0330405 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7078K-&gt;7078K(7168K)] 9126K-&gt;9126K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0394979 secs] [Times: user=0.16 sys=0.00, real=0.04 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7079K-&gt;7079K(7168K)] 9127K-&gt;9127K(9728K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0327822 secs] [Times: user=0.16 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7083K-&gt;7081K(7168K)] 9131K-&gt;9129K(9728K), [Metaspace: 3233K-&gt;3233K(1056768K)], 0.0320142 secs] [Times: user=0.17 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7083K-&gt;7083K(7168K)] 9131K-&gt;9131K(9728K), [Metaspace: 3234K-&gt;3234K(1056768K)], 0.0321638 secs] [Times: user=0.19 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7088K-&gt;7088K(7168K)] 9136K-&gt;9136K(9728K), [Metaspace: 3234K-&gt;3234K(1056768K)], 0.0324113 secs] [Times: user=0.11 sys=0.00, real=0.03 secs] [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7090K-&gt;7090K(7168K)] 9138K-&gt;9138K(9728K), [Metaspace: 3234K-&gt;3234K(1056768K)], 0.0362137 secs] [Times: user=0.11 sys=0.00, real=0.04 secs] Exception in thread &quot;main&quot; [Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;0K(2560K)] [ParOldGen: 7112K-&gt;633K(7168K)] 9160K-&gt;633K(9728K), [Metaspace: 3269K-&gt;3269K(1056768K)], 0.0058288 secs] [Times: user=0.11 sys=0.00, real=0.01 secs] java.lang.OutOfMemoryError: GC overhead limit exceeded at java.lang.Integer.toString(Integer.java:403) at java.lang.String.valueOf(String.java:3099) at GCOverheadDemo.main(GCOverheadDemo.java:13)Heap PSYoungGen total 2560K, used 126K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000) eden space 2048K, 6% used [0x00000000ffd00000,0x00000000ffd1fa60,0x00000000fff00000) from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) to space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) ParOldGen total 7168K, used 633K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000) object space 7168K, 8% used [0x00000000ff600000,0x00000000ff69e6f8,0x00000000ffd00000) Metaspace used 3334K, capacity 4500K, committed 4864K, reserved 1056768K class space used 360K, capacity 388K, committed 512K, reserved 1048576K Direct buffer memory元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。 写NIO程序经常使用ByteBuffer来读取或者写入数据，这是一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后统一一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一下场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 ByteBuffer.allocate(capability)第一种方式分配JVM堆内存，属于GC管辖范围，由于需要拷贝索引速度相对较慢。 ByteBuffer.allocateDirect(capability)第二种方式是分配OS本地内存，不属于GC管辖范围，由于不需要内存拷贝索引速度相对较快。 但如果不断分配本地内存，堆内存很少使用，那么JVM久不需要执行GC，DirectByteBuffer对象们就不会被回收，这时候堆内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemory，那程序就直接崩溃了。 12345678910111213import java.nio.ByteBuffer;public class DriectBufferMemoryDemo &#123; public static void main(String[] args) &#123; System.out.println("配置的maxDirectMemory:"+sun.misc.VM.maxDirectMemory()/(double)1024/1024+"MB"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; ByteBuffer buffer = ByteBuffer.allocateDirect(6 * 1024 * 1024); &#125;&#125; 运行参数配置 1-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m 结果 123456789101112131415161718配置的maxDirectMemory:5.0MB[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;488K(2560K)] 2048K-&gt;892K(9728K), 0.0008431 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (System.gc()) [PSYoungGen: 1269K-&gt;504K(2560K)] 1673K-&gt;1132K(9728K), 0.0010115 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 504K-&gt;0K(2560K)] [ParOldGen: 628K-&gt;1028K(7168K)] 1132K-&gt;1028K(9728K), [Metaspace: 3741K-&gt;3741K(1056768K)], 0.0091449 secs] [Times: user=0.13 sys=0.00, real=0.01 secs] Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory at java.nio.Bits.reserveMemory(Bits.java:694) at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123) at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311) at DriectBufferMemoryDemo.main(DriectBufferMemoryDemo.java:11)Heap PSYoungGen total 2560K, used 49K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000) eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0c5d0,0x00000000fff00000) from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) to space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) ParOldGen total 7168K, used 1028K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000) object space 7168K, 14% used [0x00000000ff600000,0x00000000ff7011b0,0x00000000ffd00000) Metaspace used 3772K, capacity 4536K, committed 4864K, reserved 1056768K class space used 414K, capacity 428K, committed 512K, reserved 1048576K unable to create new native thread高并发请求服务器时，经常出现如下异常： java.lang.OutOfMemoryError: unable to create new native thread，准确地讲该native thread异常与对应的平台有关 导致原因： 你的应用创建了太多线程了，一个应用进程创建多个线程，超过系统承载极限 你的应用创建超过这个数量，就会报java.lang.OutOfMemoryError: unable to create new native thread 解决办法： 想办法降低你应用程序创建线程的数量，分析应用是否真的需要创建这么多线程，如果不是，改代码将线程数降到最低 对于有的应用，确实需要创建很多线程，远超过Linux系统的默认1024个线程的限制，可以通过修改Linux服务器配置，扩大Linux默认限制 1234567891011121314public class UnableCreateNewThreadDemo &#123; public static void main(String[] args) &#123; for(int i = 1;;i++)&#123; System.out.println("********** i = "+i); new Thread(()-&gt;&#123; try &#123; Thread.sleep(Integer.MAX_VALUE); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 编译运行 1234567891011121314[es@192 tmp]$ javac -d . UnableCreateNewThreadDemo.java [es@192 tmp]$ java UnableCreateNewThreadDemo********** i = 4075********** i = 4076Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread at java.lang.Thread.start0(Native Method) at java.lang.Thread.start(Thread.java:717) at UnableCreateNewThreadDemo.main(UnableCreateNewThreadDemo.java:11) ^CJava HotSpot(TM) 64-Bit Server VM warning: Exception java.lang.OutOfMemoryError occurred dispatching signal SIGINT to handler- the VM may need to be forcibly terminated^CJava HotSpot(TM) 64-Bit Server VM warning: Exception java.lang.OutOfMemoryError occurred dispatching signal SIGINT to handler- the VM may need to be forcibly terminatedJava HotSpot(TM) 64-Bit Server VM warning: Exception java.lang.OutOfMemoryError occurred dispatching signal SIGTERM to handler- the VM may need to be forcibly terminated^CJava HotSpot(TM) 64-Bit Server VM warning: Exception java.lang.OutOfMemoryError occurred dispatching signal SIGINT to handler- the VM may need to be forcibly terminatedKilled 以root用户登录开启另外一个终端 1234[root@192 ~]# jps8257 Jps4120 UnableCreateNewThreadDemo[root@192 ~]# kill -9 4120 修改用户线程数 123[root@192 ~]# ulimit -u4096[root@192 ~]# vim /etc/security/limits.d/90-nproc.conf MetaspaceJava8及之后的版本使用Metaspace来替代永久代。 Metaspace是方法区在HotSpot的实现，它与永久代最大的区别在于：Metaspace并不在虚拟机内存中而是使用本地内存，也即在java8中，classe metadata（the virtual machines internal presentation of java class），被存储在叫做Metaspace的native memory 永久代（java8后被元空间Metaspace取代了）存放了一下信息： 虚拟机加载类信息 常量池 静态变量 即时编译后的代码 模拟Metaspace空间溢出，我们不断生成类往元空间灌，类占据的空间总是会超过Metaspace指定的空间大小的 123456789101112131415161718192021222324252627282930313233343536import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class MetaspaceOOMTest &#123; public static void main(String[] args) &#123; int i = 0; try &#123; while (true) &#123; i++; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMTest.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; return methodProxy.invokeSuper(o, args); &#125; &#125;); enhancer.create(); &#125; &#125; catch (Exception e) &#123; System.out.println("*************多少次后发生了异常：" + i); e.printStackTrace(); &#125; &#125; static class OOMTest &#123; &#125;&#125; 运行配置参数 1-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8深入剖析与实战]]></title>
    <url>%2Fmyhexo%2F2019%2F05%2F04%2Fjava8%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[函数式接口 定义 如果一个接口只有一个抽象方法，那么该接口就是一个函数式接口 如果在某个接口上声明了FunctionalInterface注解，那么编译器就会按照函数式接口的定义来要求该接口 如果某个接口只有一个抽象方法，但我们并没有给该接口声明FunctionalInterface注解，那么编译器依旧会将该接口看作是函数式接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * * * */package java.lang;import java.lang.annotation.*;/** * An informative annotation type used to indicate that an interface * type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as * defined by the Java Language Specification. * * Conceptually, a functional interface has exactly one abstract * method. Since &#123;@linkplain java.lang.reflect.Method#isDefault() * default methods&#125; have an implementation, they are not abstract. If * an interface declares an abstract method overriding one of the * public methods of &#123;@code java.lang.Object&#125;, that also does * &lt;em&gt;not&lt;/em&gt; count toward the interface's abstract method count * since any implementation of the interface will have an * implementation from &#123;@code java.lang.Object&#125; or elsewhere. * * &lt;p&gt;Note that instances of functional interfaces can be created with * lambda expressions, method references, or constructor references. * * &lt;p&gt;If a type is annotated with this annotation type, compilers are * required to generate an error message unless: * * &lt;ul&gt; * &lt;li&gt; The type is an interface type and not an annotation type, enum, or class. * &lt;li&gt; The annotated type satisfies the requirements of a functional interface. * &lt;/ul&gt; * * &lt;p&gt;However, the compiler will treat any interface meeting the * definition of a functional interface as a functional interface * regardless of whether or not a &#123;@code FunctionalInterface&#125; * annotation is present on the interface declaration. * * @jls 4.3.2. The Class Object * @jls 9.8 Functional Interfaces * @jls 9.4.3 Interface Method Body * @since 1.8 */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface FunctionalInterface &#123;&#125; Runnable接口 函数式接口的创建 lambda表达式、方法引用、构造函数引用 Note that instances of functional interfaces can be created withlambda expressions, method references, or constructor references. Stream流 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129/* * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * * * */package java.util.stream;import java.nio.charset.Charset;import java.nio.file.Files;import java.nio.file.Path;import java.util.Arrays;import java.util.Collection;import java.util.Comparator;import java.util.Iterator;import java.util.Objects;import java.util.Optional;import java.util.Spliterator;import java.util.Spliterators;import java.util.concurrent.ConcurrentHashMap;import java.util.function.BiConsumer;import java.util.function.BiFunction;import java.util.function.BinaryOperator;import java.util.function.Consumer;import java.util.function.Function;import java.util.function.IntFunction;import java.util.function.Predicate;import java.util.function.Supplier;import java.util.function.ToDoubleFunction;import java.util.function.ToIntFunction;import java.util.function.ToLongFunction;import java.util.function.UnaryOperator;/** * A sequence of elements supporting sequential and parallel aggregate * operations. The following example illustrates an aggregate operation using * &#123;@link Stream&#125; and &#123;@link IntStream&#125;: * * &lt;pre&gt;&#123;@code * int sum = widgets.stream() * .filter(w -&gt; w.getColor() == RED) * .mapToInt(w -&gt; w.getWeight()) * .sum(); * &#125;&lt;/pre&gt; * * In this example, &#123;@code widgets&#125; is a &#123;@code Collection&lt;Widget&gt;&#125;. We create * a stream of &#123;@code Widget&#125; objects via &#123;@link Collection#stream Collection.stream()&#125;, * filter it to produce a stream containing only the red widgets, and then * transform it into a stream of &#123;@code int&#125; values representing the weight of * each red widget. Then this stream is summed to produce a total weight. * * &lt;p&gt;In addition to &#123;@code Stream&#125;, which is a stream of object references, * there are primitive specializations for &#123;@link IntStream&#125;, &#123;@link LongStream&#125;, * and &#123;@link DoubleStream&#125;, all of which are referred to as "streams" and * conform to the characteristics and restrictions described here. * * &lt;p&gt;To perform a computation, stream * &lt;a href="package-summary.html#StreamOps"&gt;operations&lt;/a&gt; are composed into a * &lt;em&gt;stream pipeline&lt;/em&gt;. A stream pipeline consists of a source (which * might be an array, a collection, a generator function, an I/O channel, * etc), zero or more &lt;em&gt;intermediate operations&lt;/em&gt; (which transform a * stream into another stream, such as &#123;@link Stream#filter(Predicate)&#125;), and a * &lt;em&gt;terminal operation&lt;/em&gt; (which produces a result or side-effect, such * as &#123;@link Stream#count()&#125; or &#123;@link Stream#forEach(Consumer)&#125;). * Streams are lazy; computation on the source data is only performed when the * terminal operation is initiated, and source elements are consumed only * as needed. * * &lt;p&gt;Collections and streams, while bearing some superficial similarities, * have different goals. Collections are primarily concerned with the efficient * management of, and access to, their elements. By contrast, streams do not * provide a means to directly access or manipulate their elements, and are * instead concerned with declaratively describing their source and the * computational operations which will be performed in aggregate on that source. * However, if the provided stream operations do not offer the desired * functionality, the &#123;@link #iterator()&#125; and &#123;@link #spliterator()&#125; operations * can be used to perform a controlled traversal. * * &lt;p&gt;A stream pipeline, like the "widgets" example above, can be viewed as * a &lt;em&gt;query&lt;/em&gt; on the stream source. Unless the source was explicitly * designed for concurrent modification (such as a &#123;@link ConcurrentHashMap&#125;), * unpredictable or erroneous behavior may result from modifying the stream * source while it is being queried. * * &lt;p&gt;Most stream operations accept parameters that describe user-specified * behavior, such as the lambda expression &#123;@code w -&gt; w.getWeight()&#125; passed to * &#123;@code mapToInt&#125; in the example above. To preserve correct behavior, * these &lt;em&gt;behavioral parameters&lt;/em&gt;: * &lt;ul&gt; * &lt;li&gt;must be &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt; * (they do not modify the stream source); and&lt;/li&gt; * &lt;li&gt;in most cases must be &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * (their result should not depend on any state that might change during execution * of the stream pipeline).&lt;/li&gt; * &lt;/ul&gt; * * &lt;p&gt;Such parameters are always instances of a * &lt;a href="../function/package-summary.html"&gt;functional interface&lt;/a&gt; such * as &#123;@link java.util.function.Function&#125;, and are often lambda expressions or * method references. Unless otherwise specified these parameters must be * &lt;em&gt;non-null&lt;/em&gt;. * * &lt;p&gt;A stream should be operated on (invoking an intermediate or terminal stream * operation) only once. This rules out, for example, "forked" streams, where * the same source feeds two or more pipelines, or multiple traversals of the * same stream. A stream implementation may throw &#123;@link IllegalStateException&#125; * if it detects that the stream is being reused. However, since some stream * operations may return their receiver rather than a new stream object, it may * not be possible to detect reuse in all cases. * * &lt;p&gt;Streams have a &#123;@link #close()&#125; method and implement &#123;@link AutoCloseable&#125;, * but nearly all stream instances do not actually need to be closed after use. * Generally, only streams whose source is an IO channel (such as those returned * by &#123;@link Files#lines(Path, Charset)&#125;) will require closing. Most streams * are backed by collections, arrays, or generating functions, which require no * special resource management. (If a stream does require closing, it can be * declared as a resource in a &#123;@code try&#125;-with-resources statement.) * * &lt;p&gt;Stream pipelines may execute either sequentially or in * &lt;a href="package-summary.html#Parallelism"&gt;parallel&lt;/a&gt;. This * execution mode is a property of the stream. Streams are created * with an initial choice of sequential or parallel execution. (For example, * &#123;@link Collection#stream() Collection.stream()&#125; creates a sequential stream, * and &#123;@link Collection#parallelStream() Collection.parallelStream()&#125; creates * a parallel one.) This choice of execution mode may be modified by the * &#123;@link #sequential()&#125; or &#123;@link #parallel()&#125; methods, and may be queried with * the &#123;@link #isParallel()&#125; method. * * @param &lt;T&gt; the type of the stream elements * @since 1.8 * @see IntStream * @see LongStream * @see DoubleStream * @see &lt;a href="package-summary.html"&gt;java.util.stream&lt;/a&gt; */public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123; /** * Returns a stream consisting of the elements of this stream that match * the given predicate. * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate * operation&lt;/a&gt;. * * @param predicate a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * predicate to apply to each element to determine if it * should be included * @return the new stream */ Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); /** * Returns a stream consisting of the results of applying the given * function to the elements of this stream. * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate * operation&lt;/a&gt;. * * @param &lt;R&gt; The element type of the new stream * @param mapper a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function to apply to each element * @return the new stream */ &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); /** * Returns an &#123;@code IntStream&#125; consisting of the results of applying the * given function to the elements of this stream. * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt; * intermediate operation&lt;/a&gt;. * * @param mapper a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function to apply to each element * @return the new stream */ IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper); /** * Returns a &#123;@code LongStream&#125; consisting of the results of applying the * given function to the elements of this stream. * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate * operation&lt;/a&gt;. * * @param mapper a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function to apply to each element * @return the new stream */ LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper); /** * Returns a &#123;@code DoubleStream&#125; consisting of the results of applying the * given function to the elements of this stream. * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate * operation&lt;/a&gt;. * * @param mapper a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function to apply to each element * @return the new stream */ DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper); /** * Returns a stream consisting of the results of replacing each element of * this stream with the contents of a mapped stream produced by applying * the provided mapping function to each element. Each mapped stream is * &#123;@link java.util.stream.BaseStream#close() closed&#125; after its contents * have been placed into this stream. (If a mapped stream is &#123;@code null&#125; * an empty stream is used, instead.) * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate * operation&lt;/a&gt;. * * @apiNote * The &#123;@code flatMap()&#125; operation has the effect of applying a one-to-many * transformation to the elements of the stream, and then flattening the * resulting elements into a new stream. * * &lt;p&gt;&lt;b&gt;Examples.&lt;/b&gt; * * &lt;p&gt;If &#123;@code orders&#125; is a stream of purchase orders, and each purchase * order contains a collection of line items, then the following produces a * stream containing all the line items in all the orders: * &lt;pre&gt;&#123;@code * orders.flatMap(order -&gt; order.getLineItems().stream())... * &#125;&lt;/pre&gt; * * &lt;p&gt;If &#123;@code path&#125; is the path to a file, then the following produces a * stream of the &#123;@code words&#125; contained in that file: * &lt;pre&gt;&#123;@code * Stream&lt;String&gt; lines = Files.lines(path, StandardCharsets.UTF_8); * Stream&lt;String&gt; words = lines.flatMap(line -&gt; Stream.of(line.split(" +"))); * &#125;&lt;/pre&gt; * The &#123;@code mapper&#125; function passed to &#123;@code flatMap&#125; splits a line, * using a simple regular expression, into an array of words, and then * creates a stream of words from that array. * * @param &lt;R&gt; The element type of the new stream * @param mapper a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function to apply to each element which produces a stream * of new values * @return the new stream */ &lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper); /** * Returns an &#123;@code IntStream&#125; consisting of the results of replacing each * element of this stream with the contents of a mapped stream produced by * applying the provided mapping function to each element. Each mapped * stream is &#123;@link java.util.stream.BaseStream#close() closed&#125; after its * contents have been placed into this stream. (If a mapped stream is * &#123;@code null&#125; an empty stream is used, instead.) * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate * operation&lt;/a&gt;. * * @param mapper a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function to apply to each element which produces a stream * of new values * @return the new stream * @see #flatMap(Function) */ IntStream flatMapToInt(Function&lt;? super T, ? extends IntStream&gt; mapper); /** * Returns an &#123;@code LongStream&#125; consisting of the results of replacing each * element of this stream with the contents of a mapped stream produced by * applying the provided mapping function to each element. Each mapped * stream is &#123;@link java.util.stream.BaseStream#close() closed&#125; after its * contents have been placed into this stream. (If a mapped stream is * &#123;@code null&#125; an empty stream is used, instead.) * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate * operation&lt;/a&gt;. * * @param mapper a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function to apply to each element which produces a stream * of new values * @return the new stream * @see #flatMap(Function) */ LongStream flatMapToLong(Function&lt;? super T, ? extends LongStream&gt; mapper); /** * Returns an &#123;@code DoubleStream&#125; consisting of the results of replacing * each element of this stream with the contents of a mapped stream produced * by applying the provided mapping function to each element. Each mapped * stream is &#123;@link java.util.stream.BaseStream#close() closed&#125; after its * contents have placed been into this stream. (If a mapped stream is * &#123;@code null&#125; an empty stream is used, instead.) * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate * operation&lt;/a&gt;. * * @param mapper a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function to apply to each element which produces a stream * of new values * @return the new stream * @see #flatMap(Function) */ DoubleStream flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt; mapper); /** * Returns a stream consisting of the distinct elements (according to * &#123;@link Object#equals(Object)&#125;) of this stream. * * &lt;p&gt;For ordered streams, the selection of distinct elements is stable * (for duplicated elements, the element appearing first in the encounter * order is preserved.) For unordered streams, no stability guarantees * are made. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;stateful * intermediate operation&lt;/a&gt;. * * @apiNote * Preserving stability for &#123;@code distinct()&#125; in parallel pipelines is * relatively expensive (requires that the operation act as a full barrier, * with substantial buffering overhead), and stability is often not needed. * Using an unordered stream source (such as &#123;@link #generate(Supplier)&#125;) * or removing the ordering constraint with &#123;@link #unordered()&#125; may result * in significantly more efficient execution for &#123;@code distinct()&#125; in parallel * pipelines, if the semantics of your situation permit. If consistency * with encounter order is required, and you are experiencing poor performance * or memory utilization with &#123;@code distinct()&#125; in parallel pipelines, * switching to sequential execution with &#123;@link #sequential()&#125; may improve * performance. * * @return the new stream */ Stream&lt;T&gt; distinct(); /** * Returns a stream consisting of the elements of this stream, sorted * according to natural order. If the elements of this stream are not * &#123;@code Comparable&#125;, a &#123;@code java.lang.ClassCastException&#125; may be thrown * when the terminal operation is executed. * * &lt;p&gt;For ordered streams, the sort is stable. For unordered streams, no * stability guarantees are made. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;stateful * intermediate operation&lt;/a&gt;. * * @return the new stream */ Stream&lt;T&gt; sorted(); /** * Returns a stream consisting of the elements of this stream, sorted * according to the provided &#123;@code Comparator&#125;. * * &lt;p&gt;For ordered streams, the sort is stable. For unordered streams, no * stability guarantees are made. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;stateful * intermediate operation&lt;/a&gt;. * * @param comparator a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * &#123;@code Comparator&#125; to be used to compare stream elements * @return the new stream */ Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator); /** * Returns a stream consisting of the elements of this stream, additionally * performing the provided action on each element as elements are consumed * from the resulting stream. * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate * operation&lt;/a&gt;. * * &lt;p&gt;For parallel stream pipelines, the action may be called at * whatever time and in whatever thread the element is made available by the * upstream operation. If the action modifies shared state, * it is responsible for providing the required synchronization. * * @apiNote This method exists mainly to support debugging, where you want * to see the elements as they flow past a certain point in a pipeline: * &lt;pre&gt;&#123;@code * Stream.of("one", "two", "three", "four") * .filter(e -&gt; e.length() &gt; 3) * .peek(e -&gt; System.out.println("Filtered value: " + e)) * .map(String::toUpperCase) * .peek(e -&gt; System.out.println("Mapped value: " + e)) * .collect(Collectors.toList()); * &#125;&lt;/pre&gt; * * @param action a &lt;a href="package-summary.html#NonInterference"&gt; * non-interfering&lt;/a&gt; action to perform on the elements as * they are consumed from the stream * @return the new stream */ Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action); /** * Returns a stream consisting of the elements of this stream, truncated * to be no longer than &#123;@code maxSize&#125; in length. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;short-circuiting * stateful intermediate operation&lt;/a&gt;. * * @apiNote * While &#123;@code limit()&#125; is generally a cheap operation on sequential * stream pipelines, it can be quite expensive on ordered parallel pipelines, * especially for large values of &#123;@code maxSize&#125;, since &#123;@code limit(n)&#125; * is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the * &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered * stream source (such as &#123;@link #generate(Supplier)&#125;) or removing the * ordering constraint with &#123;@link #unordered()&#125; may result in significant * speedups of &#123;@code limit()&#125; in parallel pipelines, if the semantics of * your situation permit. If consistency with encounter order is required, * and you are experiencing poor performance or memory utilization with * &#123;@code limit()&#125; in parallel pipelines, switching to sequential execution * with &#123;@link #sequential()&#125; may improve performance. * * @param maxSize the number of elements the stream should be limited to * @return the new stream * @throws IllegalArgumentException if &#123;@code maxSize&#125; is negative */ Stream&lt;T&gt; limit(long maxSize); /** * Returns a stream consisting of the remaining elements of this stream * after discarding the first &#123;@code n&#125; elements of the stream. * If this stream contains fewer than &#123;@code n&#125; elements then an * empty stream will be returned. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;stateful * intermediate operation&lt;/a&gt;. * * @apiNote * While &#123;@code skip()&#125; is generally a cheap operation on sequential * stream pipelines, it can be quite expensive on ordered parallel pipelines, * especially for large values of &#123;@code n&#125;, since &#123;@code skip(n)&#125; * is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the * &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered * stream source (such as &#123;@link #generate(Supplier)&#125;) or removing the * ordering constraint with &#123;@link #unordered()&#125; may result in significant * speedups of &#123;@code skip()&#125; in parallel pipelines, if the semantics of * your situation permit. If consistency with encounter order is required, * and you are experiencing poor performance or memory utilization with * &#123;@code skip()&#125; in parallel pipelines, switching to sequential execution * with &#123;@link #sequential()&#125; may improve performance. * * @param n the number of leading elements to skip * @return the new stream * @throws IllegalArgumentException if &#123;@code n&#125; is negative */ Stream&lt;T&gt; skip(long n); /** * Performs an action for each element of this stream. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * &lt;p&gt;The behavior of this operation is explicitly nondeterministic. * For parallel stream pipelines, this operation does &lt;em&gt;not&lt;/em&gt; * guarantee to respect the encounter order of the stream, as doing so * would sacrifice the benefit of parallelism. For any given element, the * action may be performed at whatever time and in whatever thread the * library chooses. If the action accesses shared state, it is * responsible for providing the required synchronization. * * @param action a &lt;a href="package-summary.html#NonInterference"&gt; * non-interfering&lt;/a&gt; action to perform on the elements */ void forEach(Consumer&lt;? super T&gt; action); /** * Performs an action for each element of this stream, in the encounter * order of the stream if the stream has a defined encounter order. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * &lt;p&gt;This operation processes the elements one at a time, in encounter * order if one exists. Performing the action for one element * &lt;a href="../concurrent/package-summary.html#MemoryVisibility"&gt;&lt;i&gt;happens-before&lt;/i&gt;&lt;/a&gt; * performing the action for subsequent elements, but for any given element, * the action may be performed in whatever thread the library chooses. * * @param action a &lt;a href="package-summary.html#NonInterference"&gt; * non-interfering&lt;/a&gt; action to perform on the elements * @see #forEach(Consumer) */ void forEachOrdered(Consumer&lt;? super T&gt; action); /** * Returns an array containing the elements of this stream. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * @return an array containing the elements of this stream */ Object[] toArray(); /** * Returns an array containing the elements of this stream, using the * provided &#123;@code generator&#125; function to allocate the returned array, as * well as any additional arrays that might be required for a partitioned * execution or for resizing. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * @apiNote * The generator function takes an integer, which is the size of the * desired array, and produces an array of the desired size. This can be * concisely expressed with an array constructor reference: * &lt;pre&gt;&#123;@code * Person[] men = people.stream() * .filter(p -&gt; p.getGender() == MALE) * .toArray(Person[]::new); * &#125;&lt;/pre&gt; * * @param &lt;A&gt; the element type of the resulting array * @param generator a function which produces a new array of the desired * type and the provided length * @return an array containing the elements in this stream * @throws ArrayStoreException if the runtime type of the array returned * from the array generator is not a supertype of the runtime type of every * element in this stream */ &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator); /** * Performs a &lt;a href="package-summary.html#Reduction"&gt;reduction&lt;/a&gt; on the * elements of this stream, using the provided identity value and an * &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt; * accumulation function, and returns the reduced value. This is equivalent * to: * &lt;pre&gt;&#123;@code * T result = identity; * for (T element : this stream) * result = accumulator.apply(result, element) * return result; * &#125;&lt;/pre&gt; * * but is not constrained to execute sequentially. * * &lt;p&gt;The &#123;@code identity&#125; value must be an identity for the accumulator * function. This means that for all &#123;@code t&#125;, * &#123;@code accumulator.apply(identity, t)&#125; is equal to &#123;@code t&#125;. * The &#123;@code accumulator&#125; function must be an * &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt; function. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * @apiNote Sum, min, max, average, and string concatenation are all special * cases of reduction. Summing a stream of numbers can be expressed as: * * &lt;pre&gt;&#123;@code * Integer sum = integers.reduce(0, (a, b) -&gt; a+b); * &#125;&lt;/pre&gt; * * or: * * &lt;pre&gt;&#123;@code * Integer sum = integers.reduce(0, Integer::sum); * &#125;&lt;/pre&gt; * * &lt;p&gt;While this may seem a more roundabout way to perform an aggregation * compared to simply mutating a running total in a loop, reduction * operations parallelize more gracefully, without needing additional * synchronization and with greatly reduced risk of data races. * * @param identity the identity value for the accumulating function * @param accumulator an &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt;, * &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function for combining two values * @return the result of the reduction */ T reduce(T identity, BinaryOperator&lt;T&gt; accumulator); /** * Performs a &lt;a href="package-summary.html#Reduction"&gt;reduction&lt;/a&gt; on the * elements of this stream, using an * &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt; accumulation * function, and returns an &#123;@code Optional&#125; describing the reduced value, * if any. This is equivalent to: * &lt;pre&gt;&#123;@code * boolean foundAny = false; * T result = null; * for (T element : this stream) &#123; * if (!foundAny) &#123; * foundAny = true; * result = element; * &#125; * else * result = accumulator.apply(result, element); * &#125; * return foundAny ? Optional.of(result) : Optional.empty(); * &#125;&lt;/pre&gt; * * but is not constrained to execute sequentially. * * &lt;p&gt;The &#123;@code accumulator&#125; function must be an * &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt; function. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * @param accumulator an &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt;, * &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function for combining two values * @return an &#123;@link Optional&#125; describing the result of the reduction * @throws NullPointerException if the result of the reduction is null * @see #reduce(Object, BinaryOperator) * @see #min(Comparator) * @see #max(Comparator) */ Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator); /** * Performs a &lt;a href="package-summary.html#Reduction"&gt;reduction&lt;/a&gt; on the * elements of this stream, using the provided identity, accumulation and * combining functions. This is equivalent to: * &lt;pre&gt;&#123;@code * U result = identity; * for (T element : this stream) * result = accumulator.apply(result, element) * return result; * &#125;&lt;/pre&gt; * * but is not constrained to execute sequentially. * * &lt;p&gt;The &#123;@code identity&#125; value must be an identity for the combiner * function. This means that for all &#123;@code u&#125;, &#123;@code combiner(identity, u)&#125; * is equal to &#123;@code u&#125;. Additionally, the &#123;@code combiner&#125; function * must be compatible with the &#123;@code accumulator&#125; function; for all * &#123;@code u&#125; and &#123;@code t&#125;, the following must hold: * &lt;pre&gt;&#123;@code * combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t) * &#125;&lt;/pre&gt; * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * @apiNote Many reductions using this form can be represented more simply * by an explicit combination of &#123;@code map&#125; and &#123;@code reduce&#125; operations. * The &#123;@code accumulator&#125; function acts as a fused mapper and accumulator, * which can sometimes be more efficient than separate mapping and reduction, * such as when knowing the previously reduced value allows you to avoid * some computation. * * @param &lt;U&gt; The type of the result * @param identity the identity value for the combiner function * @param accumulator an &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt;, * &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function for incorporating an additional element into a result * @param combiner an &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt;, * &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function for combining two values, which must be * compatible with the accumulator function * @return the result of the reduction * @see #reduce(BinaryOperator) * @see #reduce(Object, BinaryOperator) */ &lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner); /** * Performs a &lt;a href="package-summary.html#MutableReduction"&gt;mutable * reduction&lt;/a&gt; operation on the elements of this stream. A mutable * reduction is one in which the reduced value is a mutable result container, * such as an &#123;@code ArrayList&#125;, and elements are incorporated by updating * the state of the result rather than by replacing the result. This * produces a result equivalent to: * &lt;pre&gt;&#123;@code * R result = supplier.get(); * for (T element : this stream) * accumulator.accept(result, element); * return result; * &#125;&lt;/pre&gt; * * &lt;p&gt;Like &#123;@link #reduce(Object, BinaryOperator)&#125;, &#123;@code collect&#125; operations * can be parallelized without requiring additional synchronization. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * @apiNote There are many existing classes in the JDK whose signatures are * well-suited for use with method references as arguments to &#123;@code collect()&#125;. * For example, the following will accumulate strings into an &#123;@code ArrayList&#125;: * &lt;pre&gt;&#123;@code * List&lt;String&gt; asList = stringStream.collect(ArrayList::new, ArrayList::add, * ArrayList::addAll); * &#125;&lt;/pre&gt; * * &lt;p&gt;The following will take a stream of strings and concatenates them into a * single string: * &lt;pre&gt;&#123;@code * String concat = stringStream.collect(StringBuilder::new, StringBuilder::append, * StringBuilder::append) * .toString(); * &#125;&lt;/pre&gt; * * @param &lt;R&gt; type of the result * @param supplier a function that creates a new result container. For a * parallel execution, this function may be called * multiple times and must return a fresh value each time. * @param accumulator an &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt;, * &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function for incorporating an additional element into a result * @param combiner an &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt;, * &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function for combining two values, which must be * compatible with the accumulator function * @return the result of the reduction */ &lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner); /** * Performs a &lt;a href="package-summary.html#MutableReduction"&gt;mutable * reduction&lt;/a&gt; operation on the elements of this stream using a * &#123;@code Collector&#125;. A &#123;@code Collector&#125; * encapsulates the functions used as arguments to * &#123;@link #collect(Supplier, BiConsumer, BiConsumer)&#125;, allowing for reuse of * collection strategies and composition of collect operations such as * multiple-level grouping or partitioning. * * &lt;p&gt;If the stream is parallel, and the &#123;@code Collector&#125; * is &#123;@link Collector.Characteristics#CONCURRENT concurrent&#125;, and * either the stream is unordered or the collector is * &#123;@link Collector.Characteristics#UNORDERED unordered&#125;, * then a concurrent reduction will be performed (see &#123;@link Collector&#125; for * details on concurrent reduction.) * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * &lt;p&gt;When executed in parallel, multiple intermediate results may be * instantiated, populated, and merged so as to maintain isolation of * mutable data structures. Therefore, even when executed in parallel * with non-thread-safe data structures (such as &#123;@code ArrayList&#125;), no * additional synchronization is needed for a parallel reduction. * * @apiNote * The following will accumulate strings into an ArrayList: * &lt;pre&gt;&#123;@code * List&lt;String&gt; asList = stringStream.collect(Collectors.toList()); * &#125;&lt;/pre&gt; * * &lt;p&gt;The following will classify &#123;@code Person&#125; objects by city: * &lt;pre&gt;&#123;@code * Map&lt;String, List&lt;Person&gt;&gt; peopleByCity * = personStream.collect(Collectors.groupingBy(Person::getCity)); * &#125;&lt;/pre&gt; * * &lt;p&gt;The following will classify &#123;@code Person&#125; objects by state and city, * cascading two &#123;@code Collector&#125;s together: * &lt;pre&gt;&#123;@code * Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; peopleByStateAndCity * = personStream.collect(Collectors.groupingBy(Person::getState, * Collectors.groupingBy(Person::getCity))); * &#125;&lt;/pre&gt; * * @param &lt;R&gt; the type of the result * @param &lt;A&gt; the intermediate accumulation type of the &#123;@code Collector&#125; * @param collector the &#123;@code Collector&#125; describing the reduction * @return the result of the reduction * @see #collect(Supplier, BiConsumer, BiConsumer) * @see Collectors */ &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector); /** * Returns the minimum element of this stream according to the provided * &#123;@code Comparator&#125;. This is a special case of a * &lt;a href="package-summary.html#Reduction"&gt;reduction&lt;/a&gt;. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal operation&lt;/a&gt;. * * @param comparator a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * &#123;@code Comparator&#125; to compare elements of this stream * @return an &#123;@code Optional&#125; describing the minimum element of this stream, * or an empty &#123;@code Optional&#125; if the stream is empty * @throws NullPointerException if the minimum element is null */ Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator); /** * Returns the maximum element of this stream according to the provided * &#123;@code Comparator&#125;. This is a special case of a * &lt;a href="package-summary.html#Reduction"&gt;reduction&lt;/a&gt;. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * @param comparator a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * &#123;@code Comparator&#125; to compare elements of this stream * @return an &#123;@code Optional&#125; describing the maximum element of this stream, * or an empty &#123;@code Optional&#125; if the stream is empty * @throws NullPointerException if the maximum element is null */ Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator); /** * Returns the count of elements in this stream. This is a special case of * a &lt;a href="package-summary.html#Reduction"&gt;reduction&lt;/a&gt; and is * equivalent to: * &lt;pre&gt;&#123;@code * return mapToLong(e -&gt; 1L).sum(); * &#125;&lt;/pre&gt; * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal operation&lt;/a&gt;. * * @return the count of elements in this stream */ long count(); /** * Returns whether any elements of this stream match the provided * predicate. May not evaluate the predicate on all elements if not * necessary for determining the result. If the stream is empty then * &#123;@code false&#125; is returned and the predicate is not evaluated. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;short-circuiting * terminal operation&lt;/a&gt;. * * @apiNote * This method evaluates the &lt;em&gt;existential quantification&lt;/em&gt; of the * predicate over the elements of the stream (for some x P(x)). * * @param predicate a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * predicate to apply to elements of this stream * @return &#123;@code true&#125; if any elements of the stream match the provided * predicate, otherwise &#123;@code false&#125; */ boolean anyMatch(Predicate&lt;? super T&gt; predicate); /** * Returns whether all elements of this stream match the provided predicate. * May not evaluate the predicate on all elements if not necessary for * determining the result. If the stream is empty then &#123;@code true&#125; is * returned and the predicate is not evaluated. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;short-circuiting * terminal operation&lt;/a&gt;. * * @apiNote * This method evaluates the &lt;em&gt;universal quantification&lt;/em&gt; of the * predicate over the elements of the stream (for all x P(x)). If the * stream is empty, the quantification is said to be &lt;em&gt;vacuously * satisfied&lt;/em&gt; and is always &#123;@code true&#125; (regardless of P(x)). * * @param predicate a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * predicate to apply to elements of this stream * @return &#123;@code true&#125; if either all elements of the stream match the * provided predicate or the stream is empty, otherwise &#123;@code false&#125; */ boolean allMatch(Predicate&lt;? super T&gt; predicate); /** * Returns whether no elements of this stream match the provided predicate. * May not evaluate the predicate on all elements if not necessary for * determining the result. If the stream is empty then &#123;@code true&#125; is * returned and the predicate is not evaluated. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;short-circuiting * terminal operation&lt;/a&gt;. * * @apiNote * This method evaluates the &lt;em&gt;universal quantification&lt;/em&gt; of the * negated predicate over the elements of the stream (for all x ~P(x)). If * the stream is empty, the quantification is said to be vacuously satisfied * and is always &#123;@code true&#125;, regardless of P(x). * * @param predicate a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * predicate to apply to elements of this stream * @return &#123;@code true&#125; if either no elements of the stream match the * provided predicate or the stream is empty, otherwise &#123;@code false&#125; */ boolean noneMatch(Predicate&lt;? super T&gt; predicate); /** * Returns an &#123;@link Optional&#125; describing the first element of this stream, * or an empty &#123;@code Optional&#125; if the stream is empty. If the stream has * no encounter order, then any element may be returned. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;short-circuiting * terminal operation&lt;/a&gt;. * * @return an &#123;@code Optional&#125; describing the first element of this stream, * or an empty &#123;@code Optional&#125; if the stream is empty * @throws NullPointerException if the element selected is null */ Optional&lt;T&gt; findFirst(); /** * Returns an &#123;@link Optional&#125; describing some element of the stream, or an * empty &#123;@code Optional&#125; if the stream is empty. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;short-circuiting * terminal operation&lt;/a&gt;. * * &lt;p&gt;The behavior of this operation is explicitly nondeterministic; it is * free to select any element in the stream. This is to allow for maximal * performance in parallel operations; the cost is that multiple invocations * on the same source may not return the same result. (If a stable result * is desired, use &#123;@link #findFirst()&#125; instead.) * * @return an &#123;@code Optional&#125; describing some element of this stream, or an * empty &#123;@code Optional&#125; if the stream is empty * @throws NullPointerException if the element selected is null * @see #findFirst() */ Optional&lt;T&gt; findAny(); // Static factories /** * Returns a builder for a &#123;@code Stream&#125;. * * @param &lt;T&gt; type of elements * @return a stream builder */ public static&lt;T&gt; Builder&lt;T&gt; builder() &#123; return new Streams.StreamBuilderImpl&lt;&gt;(); &#125; /** * Returns an empty sequential &#123;@code Stream&#125;. * * @param &lt;T&gt; the type of stream elements * @return an empty sequential stream */ public static&lt;T&gt; Stream&lt;T&gt; empty() &#123; return StreamSupport.stream(Spliterators.&lt;T&gt;emptySpliterator(), false); &#125; /** * Returns a sequential &#123;@code Stream&#125; containing a single element. * * @param t the single element * @param &lt;T&gt; the type of stream elements * @return a singleton sequential stream */ public static&lt;T&gt; Stream&lt;T&gt; of(T t) &#123; return StreamSupport.stream(new Streams.StreamBuilderImpl&lt;&gt;(t), false); &#125; /** * Returns a sequential ordered stream whose elements are the specified values. * * @param &lt;T&gt; the type of stream elements * @param values the elements of the new stream * @return the new stream */ @SafeVarargs @SuppressWarnings("varargs") // Creating a stream from an array is safe public static&lt;T&gt; Stream&lt;T&gt; of(T... values) &#123; return Arrays.stream(values); &#125; /** * Returns an infinite sequential ordered &#123;@code Stream&#125; produced by iterative * application of a function &#123;@code f&#125; to an initial element &#123;@code seed&#125;, * producing a &#123;@code Stream&#125; consisting of &#123;@code seed&#125;, &#123;@code f(seed)&#125;, * &#123;@code f(f(seed))&#125;, etc. * * &lt;p&gt;The first element (position &#123;@code 0&#125;) in the &#123;@code Stream&#125; will be * the provided &#123;@code seed&#125;. For &#123;@code n &gt; 0&#125;, the element at position * &#123;@code n&#125;, will be the result of applying the function &#123;@code f&#125; to the * element at position &#123;@code n - 1&#125;. * * @param &lt;T&gt; the type of stream elements * @param seed the initial element * @param f a function to be applied to to the previous element to produce * a new element * @return a new sequential &#123;@code Stream&#125; */ public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) &#123; Objects.requireNonNull(f); final Iterator&lt;T&gt; iterator = new Iterator&lt;T&gt;() &#123; @SuppressWarnings("unchecked") T t = (T) Streams.NONE; @Override public boolean hasNext() &#123; return true; &#125; @Override public T next() &#123; return t = (t == Streams.NONE) ? seed : f.apply(t); &#125; &#125;; return StreamSupport.stream(Spliterators.spliteratorUnknownSize( iterator, Spliterator.ORDERED | Spliterator.IMMUTABLE), false); &#125; /** * Returns an infinite sequential unordered stream where each element is * generated by the provided &#123;@code Supplier&#125;. This is suitable for * generating constant streams, streams of random elements, etc. * * @param &lt;T&gt; the type of stream elements * @param s the &#123;@code Supplier&#125; of generated elements * @return a new infinite sequential unordered &#123;@code Stream&#125; */ public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) &#123; Objects.requireNonNull(s); return StreamSupport.stream( new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s), false); &#125; /** * Creates a lazily concatenated stream whose elements are all the * elements of the first stream followed by all the elements of the * second stream. The resulting stream is ordered if both * of the input streams are ordered, and parallel if either of the input * streams is parallel. When the resulting stream is closed, the close * handlers for both input streams are invoked. * * @implNote * Use caution when constructing streams from repeated concatenation. * Accessing an element of a deeply concatenated stream can result in deep * call chains, or even &#123;@code StackOverflowException&#125;. * * @param &lt;T&gt; The type of stream elements * @param a the first stream * @param b the second stream * @return the concatenation of the two input streams */ public static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) &#123; Objects.requireNonNull(a); Objects.requireNonNull(b); @SuppressWarnings("unchecked") Spliterator&lt;T&gt; split = new Streams.ConcatSpliterator.OfRef&lt;&gt;( (Spliterator&lt;T&gt;) a.spliterator(), (Spliterator&lt;T&gt;) b.spliterator()); Stream&lt;T&gt; stream = StreamSupport.stream(split, a.isParallel() || b.isParallel()); return stream.onClose(Streams.composedClose(a, b)); &#125; /** * A mutable builder for a &#123;@code Stream&#125;. This allows the creation of a * &#123;@code Stream&#125; by generating elements individually and adding them to the * &#123;@code Builder&#125; (without the copying overhead that comes from using * an &#123;@code ArrayList&#125; as a temporary buffer.) * * &lt;p&gt;A stream builder has a lifecycle, which starts in a building * phase, during which elements can be added, and then transitions to a built * phase, after which elements may not be added. The built phase begins * when the &#123;@link #build()&#125; method is called, which creates an ordered * &#123;@code Stream&#125; whose elements are the elements that were added to the stream * builder, in the order they were added. * * @param &lt;T&gt; the type of stream elements * @see Stream#builder() * @since 1.8 */ public interface Builder&lt;T&gt; extends Consumer&lt;T&gt; &#123; /** * Adds an element to the stream being built. * * @throws IllegalStateException if the builder has already transitioned to * the built state */ @Override void accept(T t); /** * Adds an element to the stream being built. * * @implSpec * The default implementation behaves as if: * &lt;pre&gt;&#123;@code * accept(t) * return this; * &#125;&lt;/pre&gt; * * @param t the element to add * @return &#123;@code this&#125; builder * @throws IllegalStateException if the builder has already transitioned to * the built state */ default Builder&lt;T&gt; add(T t) &#123; accept(t); return this; &#125; /** * Builds the stream, transitioning this builder to the built state. * An &#123;@code IllegalStateException&#125; is thrown if there are further attempts * to operate on the builder after it has entered the built state. * * @return the built stream * @throws IllegalStateException if the builder has already transitioned to * the built state */ Stream&lt;T&gt; build(); &#125;&#125; 串行流、并行流 Collection接口 123456789101112131415161718192021222324252627282930313233343536373839/** * Returns a sequential &#123;@code Stream&#125; with this collection as its source. * * &lt;p&gt;This method should be overridden when the &#123;@link #spliterator()&#125; * method cannot return a spliterator that is &#123;@code IMMUTABLE&#125;, * &#123;@code CONCURRENT&#125;, or &lt;em&gt;late-binding&lt;/em&gt;. (See &#123;@link #spliterator()&#125; * for details.) * * @implSpec * The default implementation creates a sequential &#123;@code Stream&#125; from the * collection's &#123;@code Spliterator&#125;. * * @return a sequential &#123;@code Stream&#125; over the elements in this collection * @since 1.8 */default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false);&#125;/** * Returns a possibly parallel &#123;@code Stream&#125; with this collection as its * source. It is allowable for this method to return a sequential stream. * * &lt;p&gt;This method should be overridden when the &#123;@link #spliterator()&#125; * method cannot return a spliterator that is &#123;@code IMMUTABLE&#125;, * &#123;@code CONCURRENT&#125;, or &lt;em&gt;late-binding&lt;/em&gt;. (See &#123;@link #spliterator()&#125; * for details.) * * @implSpec * The default implementation creates a parallel &#123;@code Stream&#125; from the * collection's &#123;@code Spliterator&#125;. * * @return a possibly parallel &#123;@code Stream&#125; over the elements in this * collection * @since 1.8 */default Stream&lt;E&gt; parallelStream() &#123; return StreamSupport.stream(spliterator(), true);&#125; Function接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * * */package java.util.function;import java.util.Objects;/** * Represents a function that accepts one argument and produces a result. * * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt; * whose functional method is &#123;@link #apply(Object)&#125;. * * @param &lt;T&gt; the type of the input to the function * @param &lt;R&gt; the type of the result of the function * * @since 1.8 */@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); /** * Returns a composed function that first applies the &#123;@code before&#125; * function to its input, and then applies this function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param &lt;V&gt; the type of input to the &#123;@code before&#125; function, and to the * composed function * @param before the function to apply before this function is applied * @return a composed function that first applies the &#123;@code before&#125; * function and then applies this function * @throws NullPointerException if before is null * * @see #andThen(Function) */ default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123; Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); &#125; /** * Returns a composed function that first applies this function to * its input, and then applies the &#123;@code after&#125; function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param &lt;V&gt; the type of output of the &#123;@code after&#125; function, and of the * composed function * @param after the function to apply after this function is applied * @return a composed function that first applies this function and then * applies the &#123;@code after&#125; function * @throws NullPointerException if after is null * * @see #compose(Function) */ default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); &#125; /** * Returns a function that always returns its input argument. * * @param &lt;T&gt; the type of the input and output objects to the function * @return a function that always returns its input argument */ static &lt;T&gt; Function&lt;T, T&gt; identity() &#123; return t -&gt; t; &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[索引库]]></title>
    <url>%2Fmyhexo%2F2019%2F05%2F02%2F%E7%B4%A2%E5%BC%95%E5%BA%93%2F</url>
    <content type="text"><![CDATA[work课程Coursera | Online Courses &amp; Credentials by Top Educators. Join for Free technologygitWorld Hello - WorldHello Pro Git（中文版） Git 完整教程–idea使用git进行项目管理 - it技术专业户 - 博客园 Git教程 - 廖雪峰的官方网站 Git 使用规范流程_慕课手记 Git - Book 使用webstorm操作git - 金广国 - 博客园 (9+条消息)Git/GitHub教程2-与本地和GitHub上删除repository和folder相关 - ljsnail的博客 - CSDN博客 如何撰写 Git 提交信息 - 囧克斯 Plugin ANZEclipse 安装 SVN 在线插件教程_java_脚本之家 Mysql5.7.14安装配置方法操作图文教程(密码问题解决办法)_Mysql_脚本之家 ideaIntelliJ_13书签 - 扯 - 博客园 Intellij IDEA 快捷键大全 - IntelliJ IDEA - 开发语言与工具 - 深度开源 介绍 - IntelliJ IDEA 使用教程 - 极客学院Wiki IDEA中对应eclipse ctrl + 2 + L的快捷键 是哪个 IDEA中对应eclipse ctrl + 2 + L的快捷键 是哪个？ - 知乎 IntelliJ IDEA 使用心得与常用快捷键 - 码农往事 - BlogJava IDEA 2018 激活 IDEA 2018.3激活教程 最新的（三种）—2018.11.26亲测 - HALEN的博客 - CSDN博客 IntelliJ IDEA 注册码 IDEA插件JRebel安装配置与破解激活详细教程 - Zephyrus007 - 博客园 Intellij IDEA 安装jrebel插件 - CSDN博客 Intellij IDEA神器居然还有这些小技巧 - CSDN博客 IDEA 主题样式 idea翻译插件Translation的安装与使用 - 简书 (9条消息)两分钟解决IntelliJ IDEA中文乱码问题 - 一生伏首拜阳明 - CSDN博客 IntelliJ IDEA 14.1 导入MyEclipse2015工程的过程及所遇问题整理 - 综合编程类其他综合 - 红黑联盟 (9条消息)idea项目全局去掉严格的语法校验 - 坚持积累坚持记录 - CSDN博客 Color Themes goole赛风 | 下载 Android 应用和 Windows 客户端 如何安装CRX格式？Chrome插件离线安装，CRX格式安装方法 - Chrome插件网 Chrome 浏览器 必知必会的小技巧 你不知道的Chrome DevTools（2）：那些debug的技巧 - civerzhu - SegmentFault 思否 Javascript调试命令——你只会Console.log() ? - 前端小记 - SegmentFault 思否 必备的JS调试技巧汇总_javascript技巧_脚本之家 Google Chrome 网络浏览器 chrome开发者工具各种骚技巧 - 掘金 自建ss服务器教程 · Alvin9999/new-pac Wiki · GitHub ss免费账号 · Alvin9999/new-pac Wiki · GitHub Vultr充值送50美元，2019年大促-Vultr VPS My Subscriptions - Vultr.com chrome://net-internals/#hsts chrome浏览器不安全提示NET::ERR_CERT_COMMON_NAME_INVALID解决方法 | 小冷博客 Google 的升级版 Google Drive 工具，让你备份电脑数据更轻松 - 少数派 gradleGradle - Help | IntelliJ IDEA 慕课网_《新一代构建工具gradle》学习总结 - study - SegmentFault 思否 Gradle用户指南官方文档中文版_Gradle 教程_Gradle_极客学院 Wiki (9+条消息)IDEA 及 Gradle 使用总结 - cluzax的专栏 - CSDN博客 TomcatTomcat源码分析(一)之源码下载与导入IDEA - 宸明 Apache Tomcat 9 (9.0.4) - JNDI Datasource HOW-TO cssCSS-Secrets/notes at master · cssmagic/CSS-Secrets CSS森林(CSS Forest) - 标签 学习CSS布局 关于css水平垂直居中的总结 · Issue #12 · hawx1993/tech-blog 个人总结（css3新特性） - 守候书阁 - SegmentFault 思否 关于「圣杯布局」 - 天道酬勤 - SegmentFault 思否 CSS3 动画 | 菜鸟教程 A Complete Guide to Flexbox | CSS-Tricks 浅谈display:flex - love星期六 - 博客园 Can I use… Support tables for HTML5, CSS3, etc 使用 CSS 渐变 - Web 开发者指南 | MDN jsVS Code - Debugger for Chrome调试JavaScript的两种方式 - SolidMango - 博客园 Understanding JavaScript’s async await 【JS实用技巧】优化动态创建元素的方式，让代码更加优雅且利于维护 - Web开发之路 - SegmentFault 思否 JavaScript如何一次性展示几万条数据 - 陈宏鸿 - 博客园 JavaScript 运行机制–Event Loop详解 - 掘金 跟着9张思维导图学习Javascript - ChokCoco - 博客园 JavaScript性能优化小窍门实例汇总 - 性能优化 - 开发语言与工具 - 深度开源 45个有用的JavaScript技巧，窍门和最佳实践 - 掘金 JavaScript深入系列15篇正式完结！ - 掘金 JavaScript性能优化小窍门实例汇总 - 性能优化 - 开发语言与工具 - 深度开源 pythonPython爬虫入门 | Linux运维部落 【超全整理】《Python自动化全能开发从入门到精通》python基础教程笔记全放送 | 马哥教育官网-专业linux培训|python培训 人生苦短，我用Python（目录） - 海燕。 - 博客园 pycharm项目上传到Github - Jacck - 博客园 数据提取之JSON与JsonPATH-博客-云栖社区-阿里云 MarkdownMastering Markdown · GitHub Guides hexohexo史上最全搭建教程 - Fangzh的技术博客 - CSDN博客 如何优雅地发布Hexo博客 - 简书 绝配：hexo+next主题及我走过的坑 - 简书 为NexT主题添加文章阅读量统计功能 | Doublemine 备份Hexo博客源文件 | Doublemine Interview questions从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！ - 前端 - 掘金 springjQueryjava深入理解Java：SimpleDateFormat安全的时间格式化 - peida - 博客园 java-生成任意格式的json数据 - web喵神 - 博客园 segmentfault-lessons/「一入 Java 深似海 」 at master · mercyblitz/segmentfault-lessons Java对象的序列化与反序列化-Json篇 - I am jison - ITeye博客 Java 动态代理机制分析及扩展，第 1 部分 面试中，我输在了简单的排序算法-博客-云栖社区-阿里云 ssmMAC下使用IDEA搭建SSM的Maven项目 - 后端 - 掘金 databasePL/SQL游标 - PL/SQL教程™ inner join 与 left join 之间的区别 - 十七年的夏天 - 博客园 oracle查询重复数据方法 - 小人物的奋斗 - 博客园 关于本书 - Oracle-RAC 体验 - 极客学院Wiki Using Oracle Real Application Clusters (RAC) for High Availability Oracle数据库18c - 教程 达梦数据库-国产数据库-掌握全部源代码-拥有完全自主知识产权-大数据-云平台-DCA认证培训-数据库培训-柔性替代方案 mybatismybatis – MyBatis 3 | Introduction mybatis-spring – MyBatis-Spring | 简介 mybaits入门（含实例教程和源码） - CSDN博客 MavenEclipse上Maven环境配置使用 (全) - java_2017_csdn的博客 - CSDN博客 (9+条消息)使用IntelliJ IDEA 配置Maven（入门） - 记事本 - CSDN博客 IntelliJ IDEA 15 创建maven项目 - Angelaboy - 博客园 svn(9+条消息)IntelliJ IDEA 下的svn配置及使用的非常详细的图文总结 - 请叫我大师兄 - CSDN博客 (9条消息)Idea SVN导出MyEclipse项目部署问题 - 小白笔记本 - CSDN博客 linuxLinux基础教程之vim编辑器使用入门 | 马哥教育官网-专业linux培训|python培训 《Linux就该这么学》 - 必读的Linux系统与红帽RHCE认证免费自学书籍 详解Ubuntu 16.04 几个国内更新源_Linux_脚本之家 Linux 中国◆开源社区|技术 Ubuntu 18.04 安装微信（Linux通用） - 毒逆天 - 博客园 如何在Ubuntu上使用微信客户端 | 《Linux就该这么学》 如何使用 U 盘安装 Ubuntu 操作系统？ - 知乎 liunx下查看日志最实用命令和方法 - 天下雨水 - 博客园 Linux查看日志命令 - 大道至简，知易行难 - CSDN博客 springbootIntroduction · spring-boot-book 「一入 Java 深似海 」系列 2019年第一季（第一、二、三期合集） - 思否编程 SpringBoot系列一：SpringBoot入门 - ImportNew iptvJava实现将文本内容、网址链接url,生成二维码与反解析（转） - frank1998819 - ITeye博客 Java利用Google Zxing实现在线生成二维码和二维码解码 - yoodb - 素文宅博客 Java Code Examples com.google.zxing.client.j2se.BufferedImageLuminanceSource EnglishCourse逆风学习网 - Powered by Discuz! GitHubmercyblitz (Mercy Ma) 开发环境Putty的安装和使用 - 阿亮的博客 - CSDN博客 8 Reasons Why Typora Might Be Your Favorite Markdown Editor Release pandoc 2.0.6 · jgm/pandoc eclipse Atom Download - Sublime Text 数据结构与算法如果天空不死的主页 - 博客园 windowsHow To Fix Kernel Data Inpage Error in Windows 10? 小米帮助中心-小米商城 springmvcspringmvc前台访问404，不能进入controller，后台不报错问题解决方案心得 - ITwelision的博客 - CSDN博客 WiresharkWireshark User’s Guide webserviceJAX-WS入门实例及wsimport的使用 webservice的框架—axis - New - ITeye论坛 Apache Axis – User’s Guide axis 自定义对象序列化 - Snowolf的意境空间！ - ITeye博客 HadoopApache Hadoop Releases Welcome to Apache™ Hadoop®! 压力测试工具Apache Haus Downloads bloghexo Jekyll jekyll博客搭建之艰辛之路 | Dailc的个人主页 技术人如何搭建自己的技术博客 - 纯洁的微笑博客 Jekyll搭建个人博客 - Freud’s Blog 开始使用 - NexT 使用文档+hexo 开始使用 - NexT 使用文档+jekyll Jekyll搭建个人博客 静觅 崔庆才的个人博客 Nikkkki’s Notes 奇舞周刊 Web前端导航 前端圈——打造专业的前端技术会议– 个人分享–web前端学习资源分享 - 掘金 小马哥的技术博客 - 小马哥的技术博客 徐靖峰|个人博客 梁桂钊的博客 导读 | 晓风轻技术小站 码酱博客 前端之旅 Java 技术驿站-一个专注于 Java 技术分享的精品博客网站 周立的博客 - 关注Spring Cloud、Docker ZhongFuCheng3y/3y: 3y文章导航 CyC2018 / Repositories https://yuzhouwan.com/ hijiangtao (Joe Jiang) Eloquent JavaScript Snailclimb (SnailClimb) 前端开发博客-前端开发,前端博客 41个网站每个Java开发人员都应该收藏 11个最值得Java开发者收藏的网站 - ImportNew IBM developerWorks 中国 : Java technology : 文档库 Tutorials on JavaScript, React, Vue, GraphQL, and more 过往记忆 芋道源码 —— 纯源码解析博客 V2EX CodingLabs - keep coding, keep foolish Tags - 王泽远的博客 | Crow’s Blog 首页 - Beifengtz Blog 原创技术博客大联盟 | techblog Archive | waylau.com 面试CS-Notes frank-lam/fullstack-tutorial: 🚀 fullstack tutorial 2019，后台技术栈/架构师之路/全栈开发社区，春招/秋招/校招/面试 aalansehaiyang/technology-talk: 汇总java生态圈常用技术框架、开源中间件，系统架构、数据库、大公司架构案例、常用三方类库、项目管理、线上问题排查、个人成长、思考等知识 GitHub - Advanced-Frontend/Daily-Interview-Question: 我是木易杨，公众号「高级前端进阶」作者，每天搞定一道前端大厂面试题，祝大家天天进步，一年后会看到不一样的自己。 doocs/advanced-java: 😮 互联网 Java 工程师进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务等领域知识，后端同学必看，前端同学也可学习 Snailclimb/JavaGuide: 【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。 aalansehaiyang/technology-talk: 汇总java生态圈常用技术框架、开源中间件，系统架构、数据库、大公司架构案例、常用三方类库、项目管理、线上问题排查、个人成长、思考等知识 azl397985856/leetcode: LeetCode Solutions: A Record of My Problem Solving Journey.( leetcode题解，记录自己的leetcode解题之路。) Blankj/awesome-java-leetcode: LeetCode of algorithms with java solution(updating). MisterBooo/LeetCodeAnimation: Demonstrate all the questions on LeetCode in the form of animation.（用动画的形式呈现解LeetCode题目的思路） interviews/README-zh-cn.md at master · kdn251/interviews biezhi/java-bible: 我的技术摘要 ZhongFuCheng3y/3y: 3y原创技术文章导航 程序员小吴 apiSpring Framework Documentation The Python Tutorial — Python 3.8.0a0 documentation The Python Standard Library — Python 3.7.1 documentation mybatis – MyBatis 3 | Introduction Spring Boot Reference Guide Spring Cloud jQuery API Documentation Cycle.js Cycle.js ECMAScript 2015 Language Specification – ECMA-262 6th Edition GitHub Developer | GitHub Developer Guide_测试接口 jQuery API 中文文档 | jQuery API 中文在线手册 | jquery api 下载 | jquery api chm ECharts nefe/You-Dont-Need-jQuery: Examples of how to do query, style, dom, ajax, event etc like jQuery with plain javascript. Guides | Node.js React Router: Declarative Routing for React.js 菜鸟教程 - 学的不仅是技术，更是梦想！ MySQL :: MySQL 5.7 Reference Manual Home - Wiki - 码云 Gitee.com Python Module Index — Python 3.8.0a3 documentation lyj8330328/leyou: 乐优商城项目后台 MDN Web 文档 Bootstrap中文网 Wikipedia Sublime Text - A sophisticated text editor for code, markup and prose devAtom IntelliJ IDEA: The Java IDE for Professional Developers by JetBrains Download PuTTY: latest release (0.70) 淘宝 NPM 镜像 Babel · The compiler for next generation JavaScript Index of /]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>index_catalogue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F03%2FSpringBoot%2F</url>
    <content type="text"><![CDATA[入门启动官网创建 第一个例子编辑pom.xml12345&lt;!-- springBoot的启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 编写controller1234567891011121314151617/** * SpringBoot HelloWorld * @author Administrator * */@Controllerpublic class HelloWorld &#123; @RequestMapping("/hello") @ResponseBody public Map&lt;String, Object&gt; showHelloWorld()&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("msg", "HelloWorld"); return map; &#125;&#125; 编写启动类1234567891011121314151617package com.bjsxt.app;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * SpringBoot 启动类 * @author Administrator * */@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 打包进入到项目目录下，终端运行 1mvn clean package -Dmaven.test.skip=true 运行1java -jar demo_springboot-0.0.1-SNAPSHOT.jar 整合Web开发整合Servlet注解扫描注册通过注解扫描完成Servlet组件的注册 编写Servlet12345678910111213141516171819202122232425/** *SpringBoot整合Servlet方式一 * *&lt;servlet&gt; * &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; * &lt;servlet-class&gt;com.bjsxt.servlet.FirstServlet&lt;/servlet-class&gt; *&lt;/servlet&gt; * *&lt;servlet-mapping&gt; * &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; * &lt;url-pattern&gt;/first&lt;/url-pattern&gt; *&lt;/servlet-mapping&gt; * */@WebServlet(name="FirstServlet",urlPatterns="/first")public class FirstServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("FirstServlet............"); &#125;&#125; 编写启动类1234567891011121314151617/** * SpringBoot整合Servlet方式一 * * */@SpringBootApplication//在springBoot启动时会扫描@WebServlet，并将该类实例化@ServletComponentScan public class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 方法注册通过方法完成Servlet组件的注册 编写Servlet1234567891011121314/** *SpringBoot整合Servlet方式二 * */public class SecondServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("SecondServlet.........."); &#125; &#125; 编写启动类123456789101112131415161718192021/** * SpringBoot整合Servlet方式二 * * */@SpringBootApplicationpublic class App2 &#123; public static void main(String[] args) &#123; SpringApplication.run(App2.class, args); &#125; @Bean public ServletRegistrationBean getServletRegistrationBean()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new SecondServlet()); bean.addUrlMappings("/second"); return bean; &#125;&#125; 整合Filter注解扫描注册编写Filter1234567891011121314151617181920212223242526272829303132333435/** *SpringBoot整合Filter 方式一 *&lt;filter&gt; * &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt; * &lt;filter-class&gt;com.bjsxt.filter.FirstFilter&lt;/filter-class&gt; *&lt;/filter&gt; *&lt;filter-mapping&gt; * &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt; * &lt;url-pattern&gt;/first&lt;/url-pattern&gt; *&lt;/filter-mapping&gt; *///@WebFilter(filterName="FirstFilter",urlPatterns=&#123;"*.do","*.jsp"&#125;)@WebFilter(filterName="FirstFilter",urlPatterns="/first")public class FirstFilter implements Filter &#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException &#123; System.out.println("进入Filter"); arg2.doFilter(arg0, arg1); System.out.println("离开Filter"); &#125; @Override public void init(FilterConfig arg0) throws ServletException &#123; // TODO Auto-generated method stub &#125;&#125; 编写启动类12345678910111213141516/** *SpringBoot整合Filter 方式一 * */@SpringBootApplication@ServletComponentScanpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 方法注册编写Filter123456789101112131415161718192021222324/** * *SpringBoot整合Filter 方式二 * */public class SecondFilter implements Filter &#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException &#123; System.out.println("进入SecondFilter"); arg2.doFilter(arg0, arg1); System.out.println("离开SecondFilter"); &#125; @Override public void init(FilterConfig arg0) throws ServletException &#123; // TODO Auto-generated method stub &#125;&#125; 编写启动类1234567891011121314151617181920212223242526/** * SpringBoot整合Filter方式二 * * */@SpringBootApplicationpublic class App2 &#123; public static void main(String[] args) &#123; SpringApplication.run(App2.class, args); &#125; /** * 注册Filter */ @Bean public FilterRegistrationBean getFilterRegistrationBean()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(new SecondFilter()); //bean.addUrlPatterns(new String[]&#123;"*.do","*.jsp"&#125;); bean.addUrlPatterns("/second"); return bean; &#125;&#125; 整合Listener注解扫描注册编写Listener12345678910111213141516171819202122232425262728package com.bjsxt.listener;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.annotation.WebListener;/** * springBoot整合Listener * *&lt;listener&gt; * &lt;listener-class&gt;com.bjsxt.listener.FirstListener&lt;/listener-class&gt; *&lt;/listener&gt; */@WebListenerpublic class FirstListener implements ServletContextListener &#123; @Override public void contextDestroyed(ServletContextEvent arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void contextInitialized(ServletContextEvent arg0) &#123; System.out.println("Listener...init......"); &#125;&#125; 编写启动类1234567891011121314151617181920package com.bjsxt;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.ServletComponentScan;/** * springBoot整合Listener方式一 * * */@SpringBootApplication@ServletComponentScanpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 方法注册编写Listener12345678910111213141516171819202122package com.bjsxt.listener;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;/** * springBoot整合Listener方式二。 * * */public class SecondListener implements ServletContextListener &#123; @Override public void contextDestroyed(ServletContextEvent arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void contextInitialized(ServletContextEvent arg0) &#123; System.out.println("SecondListener..init....."); &#125;&#125; 编写启动类12345678910111213141516171819202122/** * SpringBoot整合Listener方式二 * * */@SpringBootApplicationpublic class App2 &#123; public static void main(String[] args) &#123; SpringApplication.run(App2.class, args); &#125; /** * 注册listener */ @Bean public ServletListenerRegistrationBean&lt;SecondListener&gt; getServletListenerRegistrationBean()&#123; ServletListenerRegistrationBean&lt;SecondListener&gt; bean= new ServletListenerRegistrationBean&lt;SecondListener&gt;(new SecondListener()); return bean; &#125;&#125; 访问静态资源从classpath/static的目录下读取从ServletContext根目录下读取,即webapp目录文件上传编写Controller12345678910111213141516171819202122/** * SpringBoot文件上传 * * *///@Controller@RestController //表示该类下的方法的返回值会自动做json格式的转换public class FileUploadController &#123; /* * 处理文件上传 */ @RequestMapping("/fileUploadController") public Map&lt;String, Object&gt; fileUpload(MultipartFile filename)throws Exception&#123; System.out.println(filename.getOriginalFilename()); filename.transferTo(new File("e:/"+filename.getOriginalFilename())); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("msg", "ok"); return map; &#125;&#125; 编写启动类12345678910111213141516171819package com.bjsxt;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * SpringBoot文件上传 * * */@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 编写文件上传表单进入src/main/resources/static目录下,新增upload.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="fileUploadController" method="post" enctype="multipart/form-data"&gt; 上传文件：&lt;input type="file" name="filename"/&gt;&lt;br/&gt; &lt;input type="submit"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 设置上传文件大小的默认值进入/src/main/resources目录，编辑application.properties文件 12spring.http.multipart.maxFileSize=200MBspring.http.multipart.maxRequestSize=200MB 整合jsp编辑pom.xml1234567891011121314151617181920212223 &lt;!-- jdk1.7 --&gt; &lt;properties&gt; &lt;java.version&gt;1.7&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- springBoot的启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jasper --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建application.properties进入src/main/resources目录，新增编辑application.properties文件 12spring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.jsp 编写Controller123456789101112131415161718192021222324/** * SpringBoot整合jsp * * */@Controllerpublic class UserController &#123; /* * 处理请求，产生数据 */ @RequestMapping("/showUser") public String showUser(Model model)&#123; List&lt;Users&gt; list = new ArrayList&lt;&gt;(); list.add(new Users(1,"张三",20)); list.add(new Users(2,"李四",22)); list.add(new Users(3,"王五",24)); //需要一个Model对象 model.addAttribute("list", list); //跳转视图 return "userList"; &#125;&#125; 创建jsp进入src/main/webapp/WEB-INF/jsp目录,新增userList.jsp 1234567891011121314151617181920212223242526&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border="1" align="center" width="50%"&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;list &#125;" var="user"&gt; &lt;tr&gt; &lt;td&gt;$&#123;user.userid &#125;&lt;/td&gt; &lt;td&gt;$&#123;user.username &#125;&lt;/td&gt; &lt;td&gt;$&#123;user.userage &#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 创建启动类1234567891011121314151617package com.bjsxt;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * SpringBoot启动类 * * */@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 整合freemarker编辑pom.xml12345678910111213141516&lt;properties&gt; &lt;java.version&gt;1.7&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt;&lt;!-- springBoot的启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- freemarker启动器的坐标 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt;&lt;/dependencies&gt; 创建 Controller12345678910111213141516171819202122232425/** * SpringBoot整合jsp * * */@Controllerpublic class UserController &#123; /* * 处理请求，产生数据 */ @RequestMapping("/showUser") public String showUser(Model model)&#123; List&lt;Users&gt; list = new ArrayList&lt;&gt;(); list.add(new Users(1,"张三",20)); list.add(new Users(2,"李四",22)); list.add(new Users(3,"王五",24)); //需要一个Model对象 model.addAttribute("list", list); //跳转视图 return "userList"; &#125;&#125; 编写前端页面springBoot要求模板形式的视图层技术的文件必须要放到src/main/resources目录下必须要一个名称为templates 进入到src/main/resources/templates目录,新增userList.ftl文件 123456789101112131415161718192021222324252627&lt;html&gt; &lt;head&gt; &lt;title&gt;展示用户数据&lt;/title&gt; &lt;meta charset="utf-9"&gt;&lt;/meta&gt; &lt;/head&gt; &lt;body&gt; &lt;table border="1" align="center" width="50%"&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;/tr&gt; &lt;#list list as user &gt; &lt;tr&gt; &lt;td&gt;$&#123;user.userid&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.username&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.userage&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 创建启动类1234567891011121314151617package com.bjsxt;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * SpringBoot启动类 * * */@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 整合Thymeleaf编辑pom.xml123456789101112131415161718&lt;properties&gt;&lt;java.version&gt;1.7&lt;/java.version&gt;&lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt;&lt;thymeleaf-layout-dialect.version&gt;2.0.4&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- springBoot的启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- springBoot的启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;/dependencies&gt; 编辑前端页面进入src/main/resources/templates,templates目录是安全的。意味着该目录下的内容是不允许外界直接访问的。 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Thymeleaf入门&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;span th:text="Hello"&gt;&lt;/span&gt; &lt;hr/&gt; &lt;span th:text="$&#123;msg&#125;"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 编辑Controller12345678910111213141516171819package com.bjsxt.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;/** * Thymeleaf入门案例 * * */@Controllerpublic class DemoController &#123; @RequestMapping("/show") public String showInfo(Model model)&#123; model.addAttribute("msg", "Thymeleaf 第一个案例"); return "index"; &#125;&#125; 编辑启动类1234567891011121314151617package com.bjsxt;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * *Thymeleaf入门案例 * */@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 坑org.xml.sax.SAXParseException:元素类型 &quot;meta&quot; 必须由匹配的结束标记&quot;&lt;/meta&gt;&quot;终止解决 方式一 让html的标记按照严禁的语法编写 1&lt;meta charset="UTF-8"/&gt; 方式二 thymeleaf.jar更新为3.0以上的版本 thymeleaf-layout-dialect.jar更新为2.0以上的版本 12345&lt;properties&gt; &lt;java.version&gt;1.7&lt;/java.version&gt; &lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.0.4&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt; Thymeleaf语法变量输出与字符串操作调用内置对象一定要用# 大部分的内置对象都以s结尾strings、numbers、dates 后台数据1234567891011package com.bjsxt.controller;@Controllerpublic class DemoController &#123; @RequestMapping("/show") public String showInfo(HttpServletRequest request,Model model)&#123; model.addAttribute("msg", "Thymeleaf 第一个案例"); model.addAttribute("key", new Date()); return "index"; &#125;&#125; th:text1234&lt;span th:text="Hello"&gt;&lt;/span&gt;&lt;hr/&gt;&lt;span th:text="$&#123;msg&#125; "&gt;&lt;/span&gt;&lt;hr/&gt; th:value1&lt;span th:text="$&#123;msg&#125; "&gt;&lt;/span&gt; 判断字符串是否为空1&lt;span th:text="$&#123;#strings.isEmpty(msg)&#125;"&gt;&lt;/span&gt; 判断字符串是否包含指定的子串12&lt;span th:text="$&#123;#strings.contains(msg,'9')&#125;"&gt;&lt;/span&gt;&lt;span th:text="$&#123;#strings.contains(msg,'T')&#125;"&gt;&lt;/span&gt; 判断当前字符串是否以子串开头12&lt;span th:text="$&#123;#strings.startsWith(msg,'a')&#125;"&gt;&lt;/span&gt;&lt;span th:text="$&#123;#strings.startsWith(msg,'T')&#125;"&gt;&lt;/span&gt; 判断当前字符串是否以子串结尾12&lt;span th:text="$&#123;#strings.endsWith(msg,'a')&#125;"&gt;&lt;/span&gt;&lt;span th:text="$&#123;#strings.endsWith(msg,'案例')&#125;"&gt;&lt;/span&gt; 返回字符串的长度1&lt;span th:text="$&#123;#strings.length(msg)&#125;"&gt;&lt;/span&gt; 查找子串的位置返回该子串的下标，如果没找到则返回-1 1&lt;span th:text="$&#123;#strings.indexOf(msg,'h')&#125;"&gt;&lt;/span&gt; 截取子串12&lt;span th:text="$&#123;#strings.substring(msg,13)&#125;"&gt;&lt;/span&gt;&lt;span th:text="$&#123;#strings.substring(msg,13,14)&#125;"&gt;&lt;/span&gt; 字符串转大小写12&lt;span th:text="$&#123;#strings.toUpperCase(msg)&#125;"&gt;&lt;/span&gt;&lt;span th:text="$&#123;#strings.toLowerCase(msg)&#125;"&gt;&lt;/span&gt; 日期格式化处理后台数据1234567891011package com.bjsxt.controller;@Controllerpublic class DemoController &#123; @RequestMapping("/show") public String showInfo(HttpServletRequest request,Model model)&#123; model.addAttribute("key", new Date()); return "index"; &#125; &#125; 默认格式日期1&lt;span th:text="$&#123;#dates.format(key)&#125;"&gt;&lt;/span&gt; 按照自定义的格式做日期转换1&lt;span th:text="$&#123;#dates.format(key,'yyy/MM/dd')&#125;"&gt;&lt;/span&gt; 取年1&lt;span th:text="$&#123;#dates.year(key)&#125;"&gt;&lt;/span&gt; 取月1&lt;span th:text="$&#123;#dates.month(key)&#125;"&gt;&lt;/span&gt; 取日1&lt;span th:text="$&#123;#dates.day(key)&#125;"&gt;&lt;/span&gt; 条件判断后台数据1234567891011package com.bjsxt.controller;@Controllerpublic class DemoController &#123; @RequestMapping("/show2") public String showInfo2(Model model)&#123; model.addAttribute("sex", "女"); model.addAttribute("id","1"); return "index2"; &#125;&#125; th:if123456&lt;span th:if="$&#123;sex&#125; == '男'"&gt; 性别：男&lt;/span&gt;&lt;span th:if="$&#123;sex&#125; == '女'"&gt; 性别：女&lt;/span&gt; th:switch12345&lt;div th:switch="$&#123;id&#125;"&gt; &lt;span th:case="1"&gt;ID为1&lt;/span&gt; &lt;span th:case="2"&gt;ID为2&lt;/span&gt; &lt;span th:case="3"&gt;ID为3&lt;/span&gt;&lt;/div&gt; 迭代遍历后台数据1234567891011121314151617181920212223242526package com.bjsxt.controller;@Controllerpublic class DemoController &#123; @RequestMapping("/show3") public String showInfo3(Model model)&#123; List&lt;Users&gt; list = new ArrayList&lt;&gt;(); list.add(new Users(1,"张三",20)); list.add(new Users(2,"李四",22)); list.add(new Users(3,"王五",24)); model.addAttribute("list", list); return "index3"; &#125; @RequestMapping("/show4") public String showInfo4(Model model)&#123; Map&lt;String, Users&gt; map = new HashMap&lt;&gt;(); map.put("u1", new Users(1,"张三",20)); map.put("u2", new Users(2,"李四",22)); map.put("u3", new Users(3,"王五",24)); model.addAttribute("map", map); return "index4"; &#125; &#125; th:each迭代list12345&lt;tr th:each="u : $&#123;list&#125;"&gt; &lt;td th:text="$&#123;u.userid&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;u.username&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;u.userage&#125;"&gt;&lt;/td&gt;&lt;/tr&gt; th:each状态变量index当前迭代器的索引从0开始count当前迭代对象的计数从1开始size被迭代对象的长度even/odd布尔值,当前循环是否是偶数/奇数从0开始first布尔值，当前循环的是否是第一条,如果是返回true否则返回falselast布尔值，当前循环的是否是最后一条,如果是则返回true否则返回false 123456789101112&lt;tr th:each="u,var : $&#123;list&#125;"&gt; &lt;td th:text="$&#123;u.userid&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;u.username&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;u.userage&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;var.index&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;var.count&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;var.size&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;var.even&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;var.odd&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;var.first&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;var.last&#125;"&gt;&lt;/td&gt;&lt;/tr&gt; th:each迭代Map12345&lt;tr th:each="maps : $&#123;map&#125;"&gt; &lt;td th:each="entry:$&#123;maps&#125;" th:text="$&#123;entry.value.userid&#125;" &gt;&lt;/td&gt; &lt;td th:each="entry:$&#123;maps&#125;" th:text="$&#123;entry.value.username&#125;"&gt;&lt;/td&gt; &lt;td th:each="entry:$&#123;maps&#125;" th:text="$&#123;entry.value.userage&#125;"&gt;&lt;/td&gt;&lt;/tr&gt; 域对象操作后台数据1234567891011121314package com.bjsxt.controller;@Controllerpublic class DemoController &#123; @RequestMapping("/show5") public String showInfo5(HttpServletRequest request,Model model)&#123; request.setAttribute("req", "HttpServletRequest"); request.getSession().setAttribute("sess", "HttpSession"); request.getSession().getServletContext().setAttribute("app", "Application"); return "index5"; &#125; &#125; HttpServletRequest1Request:&lt;span th:text="$&#123;#httpServletRequest.getAttribute('req')&#125;"&gt;&lt;/span&gt;&lt;br/&gt; HttpSession1Session:&lt;span th:text="$&#123;session.sess&#125;"&gt;&lt;/span&gt;&lt;br/&gt; ServletContext1Application:&lt;span th:text="$&#123;application.app&#125;"&gt;&lt;/span&gt; URL表达式基本语法@{} 后台数据123456789101112package com.bjsxt.controller;@Controllerpublic class DemoController &#123; @RequestMapping("/&#123;page&#125;") public String showInfo(@PathVariable String page,Integer id,String name)&#123; System.out.println(id+"--"+name); return page; &#125; &#125; 绝对路径12&lt;a th:href="@&#123;http://www.baidu.com&#125;"&gt;绝对路径&lt;/a&gt;&lt;br/&gt;&lt;a href="http://www.baidu.com"&gt;绝对路径2&lt;/a&gt; 相对路径1234567&lt;a th:href="@&#123;/show&#125;"&gt;相对路径&lt;/a&gt;&lt;hr/&gt;&lt;a th:href="@&#123;~/project2/resourcename&#125;"&gt;相对于服务器的根&lt;/a&gt;&lt;hr/&gt;&lt;a th:href="@&#123;/show(id=1,name=zhagnsan)&#125;"&gt;相对路径-传参&lt;/a&gt;&lt;hr/&gt;&lt;a th:href="@&#123;/path/&#123;id&#125;/show(id=1,name=zhagnsan)&#125;"&gt;相对路径-传参-restful&lt;/a&gt; 整合MyBatis编辑pom.xml1234567891011121314151617&lt;!-- Mybatis启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql数据库驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- druid数据库连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt;&lt;/dependency&gt; 编辑application.properties进入src/main/resources目录,编辑application.properties 12345678spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/ssmspring.datasource.username=rootspring.datasource.password=rootspring.datasource.type=com.alibaba.druid.pool.DruidDataSourcemybatis.type-aliases-package=com.bjsxt.pojo 数据库表设计123456CREATE TABLE `users` ( `id` INT (11) NOT NULL AUTO_INCREMENT, `name` VARCHAR (255) DEFAULT NULL, `age` INT (11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE = INNODB DEFAULT CHARSET = utf8; 添加用户创建实体类1234567891011121314151617181920212223242526package com.bjsxt.pojo;public class Users &#123; private Integer id; private String name; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; &#125; 创建mapper接口以及映射配置文件12345678package com.bjsxt.mapper;import com.bjsxt.pojo.Users;public interface UsersMapper &#123; void insertUser(Users users);&#125; 123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.bjsxt.mapper.UsersMapper"&gt; &lt;insert id="insertUser" parameterType="users"&gt; insert into users(name,age) values(#&#123;name&#125;,#&#123;age&#125;) &lt;/insert&gt;&lt;/mapper&gt; 创建业务层所有方法开启事务@Transactional标注在类上 12345678910111213@Service@Transactionalpublic class UsersServiceImpl implements UsersService &#123; @Autowired private UsersMapper usersMapper; @Override public void addUser(Users users) &#123; this.usersMapper.insertUser(users); &#125;&#125; 创建Controller前端请求http://localhost:8080/users/input跳转到input.html页面 12345678910111213141516171819202122232425@Controller@RequestMapping("/users")public class UsersController &#123; @Autowired private UsersService usersService; /** * 页面跳转 */ @RequestMapping("/&#123;page&#125;") public String showPage(@PathVariable String page)&#123; return page; &#125; /** * 添加用户 */ @RequestMapping("/addUser") public String addUser(Users users)&#123; this.usersService.addUser(users); return "ok"; &#125;&#125; 编写页面使用thymeleaf模板,页面必须放在src/main/resources/templates目录下 添加用户页面input.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;添加用户&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form th:action="@&#123;/users/addUser&#125;" method="post"&gt; 用户姓名：&lt;input type="text" name="name"/&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="age"/&gt;&lt;br/&gt; &lt;input type="submit" value="确定"/&gt;&lt;br/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 添加成功页面ok.html 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;操作提示页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 操作成功！！！&lt;/body&gt;&lt;/html&gt; 创建启动类用户扫描MyBatis的Mapper接口,使用@MapperScan(&quot;com.bjsxt.mapper&quot;)注解 1234567891011121314package com.bjsxt;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan("com.bjsxt.mapper") //@MapperScan 用户扫描MyBatis的Mapper接口public class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 查询用户修改mapper接口中以及映射配置文件1List&lt;Users&gt; selectUsersAll(); 123&lt;select id="selectUsersAll" resultType="users"&gt; select id,name,age from users&lt;/select&gt; 修改业务层添加查询方法 1234@Overridepublic List&lt;Users&gt; findUserAll() &#123; return this.usersMapper.selectUsersAll();&#125; 修改Controller浏览器请求http://localhost:8080/findUserAll,跳转到showUsers.html 123456789/** * 查询全部用户 */@RequestMapping("/findUserAll")public String findUserAll(Model model)&#123; List&lt;Users&gt; list = this.usersService.findUserAll(); model.addAttribute("list", list); return "showUsers";&#125; 创建页面查询用户页面showUsers.html 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;展示用户数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border="1" style="width:300px;"&gt; &lt;tr&gt; &lt;th&gt;用户ID&lt;/th&gt; &lt;th&gt;用户姓名&lt;/th&gt; &lt;th&gt;用户年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="user : $&#123;list&#125;"&gt; &lt;td th:text="$&#123;user.id&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;user.age&#125;"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 更新用户数据回显更新用户之前的查询，将数据在页面中回显 修改mapper接口以及映射配置文件1Users selectUsersById(Integer id); 123&lt;select id="selectUsersById" resultType="users"&gt; select id,name,age from users where id = #&#123;value&#125;&lt;/select&gt; 修改业务层代码1234@Overridepublic Users findUserById(Integer id) &#123; return this.usersMapper.selectUsersById(id);&#125; 修改Controller浏览器请求http://localhost:8080/findUserById,跳转到updateUser.html页面，将数据用户数据回显 123456789/** * 根据用户id查询用户 */@RequestMapping("/findUserById")public String findUserById(Integer id,Model model)&#123; Users user = this.usersService.findUserById(id); model.addAttribute("user", user); return "updateUser";&#125; 编写页面更新用户页面updateUser.html进行数据回显,使用th:field取得controller中的模型数据 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form th:action="@&#123;/users/editUser&#125;" method="post"&gt; &lt;input type="hidden" name="id" th:field="$&#123;user.id&#125;"/&gt; 用户姓名：&lt;input type="text" name="name" th:field="$&#123;user.name&#125;"/&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="age" th:field="$&#123;user.age&#125;"/&gt;&lt;br/&gt; &lt;input type="submit" value="确定"/&gt;&lt;br/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 更新修改mapper接口以及映射配置文件1void updateUser(Users users); 123&lt;update id="updateUser" parameterType="users"&gt; update users set name=#&#123;name&#125; ,age=#&#123;age&#125; where id=#&#123;id&#125;&lt;/update&gt; 修改业务层代码1234@Overridepublic void updateUser(Users users) &#123; this.usersMapper.updateUser(users);&#125; 修改Controller更新用户页面updateUser.html点击提交，浏览器请求http://localhost:8080/editUser,跳转到修改成功页面ok.html 12345678/** * 更新用户 */@RequestMapping("/editUser")public String editUser(Users users)&#123; this.usersService.updateUser(users); return "ok";&#125; 删除用户修改mapper接口以及映射配置文件1void deleteUserById(Integer id); 123&lt;delete id="deleteUserById"&gt; delete from users where id = #&#123;value&#125;&lt;/delete&gt; 修改业务层1234@Overridepublic void deleteUserById(Integer id) &#123; this.usersMapper.deleteUserById(id);&#125; 修改Controller浏览器请求http://localhost:8080/delUser重定向请求/users/findUserAll，跳转到查询用户页面showUsers.html 12345678/** * 删除用户 */@RequestMapping("/delUser")public String delUser(Integer id)&#123; this.usersService.deleteUserById(id); return "redirect:/users/findUserAll";&#125; 修改页面修改查询用户页面showUsers.html,增加删除按钮链接 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;展示用户数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border="1" style="width:500px;"&gt; &lt;tr&gt; &lt;th&gt;用户ID&lt;/th&gt; &lt;th&gt;用户姓名&lt;/th&gt; &lt;th&gt;用户年龄&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="user : $&#123;list&#125;"&gt; &lt;td th:text="$&#123;user.id&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;user.age&#125;"&gt;&lt;/td&gt; &lt;td&gt; &lt;a th:href="@&#123;/users/findUserById(id=$&#123;user.id&#125;)&#125;"&gt;更新用户&lt;/a&gt; &lt;a th:href="@&#123;/users/delUser(id=$&#123;user.id&#125;)&#125;"&gt;删除用户&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 服务端表单数据校验表单做数据校验修改实体类非空校验使用@NotBlank注解标注在属性上 12345678910111213141516171819202122232425262728293031323334package com.bjsxt.pojo;import org.hibernate.validator.constraints.NotBlank;public class Users &#123; @NotBlank //非空校验 private String name; @NotBlank //密码非空校验 private String password; private Integer age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Users [name=" + name + ", password=" + password + ", age=" + age + "]"; &#125; &#125; 修改Controller浏览器请求http://localhost:8080/addUser,跳转到添加用户页面add.html,点击提交按钮浏览器请求http://localhost:8080/save,如果校验通过跳转到成功页面ok.html,校验不通过跳转到添加用户页面add.html 开启校验使用@Valid注解封装了校验的结果BindingResult 1234567891011121314151617181920212223242526272829/** * SpringBoot 表单数据校验 * * */@Controllerpublic class UsersController &#123; @RequestMapping("/addUser") public String showPage()&#123; return "add"; &#125; /** * 完成用户添加 *@Valid 开启对Users对象的数据校验 *BindingResult:封装了校验的结果 */ @RequestMapping("/save") public String saveUser(@Valid Users users,BindingResult result)&#123; if(result.hasErrors())&#123; return "add"; &#125; System.out.println(users); return "ok"; &#125;&#125; 修改页面添加用户页面add.html,使用th:errors取得校验信息 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;添加用户&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form th:action="@&#123;/save&#125;" method="post"&gt; 用户姓名：&lt;input type="text" name="name"/&gt;&lt;font color="red" th:errors="$&#123;users.name&#125;"&gt;&lt;/font&gt;&lt;br/&gt; 用户密码：&lt;input type="password" name="password" /&gt;&lt;font color="red" th:errors="$&#123;users.password&#125;"&gt;&lt;/font&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="age" /&gt;&lt;font color="red" th:errors="$&#123;users.age&#125;"&gt;&lt;/font&gt;&lt;br/&gt; &lt;input type="submit" value="OK"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 坑java.lang.IllegalStateException: Neither BindingResult nor plain target object for bean name ‘users’ available as request attribute描述浏览器请求http://localhost:8080/addUser方法，该方法并没有传递Users对象，跳转到添加用户页面add.html取不到数据所以报错 解决方式一跳转页面注入对象 可以在浏览器请求http://localhost:8080/addUser方法中注入一个Uesrs对象由于springmvc会将Uesrs对象放入到Model模型中传递,使用驼峰命名规则,参数的变量名需要与对象的名称相同,将首字母小写 修改Controller 1234567891011121314151617181920212223242526272829303132333435/** * SpringBoot 表单数据校验 * * */@Controllerpublic class UsersController &#123; /** * * 如果想为传递的对象更改名称，可以使用@ModelAttribute("aa")这表示当前传递的对象的key为aa。 * 那么我们在页面中获取该对象的key也需要修改为aa * @param users * @return */ @RequestMapping("/addUser") public String showPage(Users users)&#123; return "add"; &#125; /** * 完成用户添加 *@Valid 开启对Users对象的数据校验 *BindingResult:封装了校验的结果 */ @RequestMapping("/save") public String saveUser(@Valid Users users,BindingResult result)&#123; if(result.hasErrors())&#123; return "add"; &#125; System.out.println(users); return "ok"; &#125;&#125; 方式二设置参数名称可变 如果想为传递的对象更改名称,可以使用@ModelAttribute(&quot;aa&quot;)这表示当前传递的对象的key为aa那么我们在页面中获取该对象的key也需要修改为aa 修改Controller 1234567891011121314151617181920212223242526272829303132333435/** * SpringBoot 表单数据校验 * * */@Controllerpublic class UsersController &#123; /** * * 如果想为传递的对象更改名称，可以使用@ModelAttribute("aa")这表示当前传递的对象的key为aa。 * 那么我们在页面中获取该对象的key也需要修改为aa * @param users * @return */ @RequestMapping("/addUser") public String showPage(@ModelAttribute("aa") Users users)&#123; return "add"; &#125; /** * 完成用户添加 *@Valid 开启对Users对象的数据校验 *BindingResult:封装了校验的结果 */ @RequestMapping("/save") public String saveUser(@ModelAttribute("aa") @Valid Users users,BindingResult result)&#123; if(result.hasErrors())&#123; return "add"; &#125; System.out.println(users); return "ok"; &#125;&#125; 修改页面 添加用户页面add.html,${aa.name}需要和请求http://localhost:8080/addUser方法中设置的@ModelAttribute(&quot;aa&quot;)一样 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;添加用户&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form th:action="@&#123;/save&#125;" method="post"&gt; 用户姓名：&lt;input type="text" name="name"/&gt;&lt;font color="red" th:errors="$&#123;aa.name&#125;"&gt;&lt;/font&gt;&lt;br/&gt; 用户密码：&lt;input type="password" name="password" /&gt;&lt;font color="red" th:errors="$&#123;aa.password&#125;"&gt;&lt;/font&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="age" /&gt;&lt;font color="red" th:errors="$&#123;aa.age&#125;"&gt;&lt;/font&gt;&lt;br/&gt; 用户邮箱：&lt;input type="text" name="email" /&gt;&lt;font color="red" th:errors="$&#123;aa.email&#125;"&gt;&lt;/font&gt;&lt;br/&gt; &lt;input type="submit" value="OK"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 其他校验规则@NotBlank判断字符串是否为null或者是空串(去掉首尾空格)。@NotEmpty判断字符串是否null或者是空串。@Length判断字符的长度(最大或者最小)@Min判断数值最小值@Max判断数值最大值@Email判断邮箱是否合法 修改实体类123456789101112131415161718192021222324252627282930313233343536373839404142public class Users &#123; @NotBlank(message="用户名不能为空") //非空校验 @Length(min=2,max=6,message="最小长度为2位，最大长度为6位") private String name; @NotEmpty private String password; @Min(value=15) private Integer age; @Email private String email; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Users [name=" + name + ", password=" + password + ", age=" + age + "]"; &#125; &#125; 异常处理SpringBoot中对于异常处理提供了五种处理方式 自定义错误页面默认的处理异常的机制 一旦程序中出现了异常SpringBoot会向/error发送请求。在springBoot中提供了一个叫BasicExceptionController类来处理/error请求，然后跳转到默认显示异常的页面来展示异常信息 修改Controller浏览器请求http://localhost:8080/show和http://localhost:8080/show2发生了异常,并不会跳转到index.html页面，而是会有默认异常页面error.html来显示异常信息 12345678910111213141516171819202122232425262728package com.bjsxt.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * SpringBoot处理异常方式一：自定义错误页面 * * */@Controllerpublic class DemoController &#123; @RequestMapping("/show") public String showInfo()&#123; String str = null; str.length(); return "index"; &#125; @RequestMapping("/show2") public String showInfo2()&#123; int a = 10/0; return "index"; &#125; &#125; 效果 修改页面如果我们需要将所有的异常同一跳转到自定义的错误页面需要在src/main/resources/templates目录下创建error.html页面,名称必须叫error.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;错误提示页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 出错了，请与管理员联系。。。 &lt;span th:text="$&#123;exception&#125;"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 弊端对所有异常都显示到异常页面error.html,不能处理对不同的异常跳转到不同的异常显示页面 @ExceptionHandle修改Controller使用@ExceptionHandler注解标注在方法上分别对不同的异常进行处理 使用ModelAndView可以指定异常信息及异常视图页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * SpringBoot处理异常方式二：@ExceptionHandle注解处理异常 * * */@Controllerpublic class DemoController &#123; @RequestMapping("/show") public String showInfo()&#123; String str = null; str.length(); return "index"; &#125; @RequestMapping("/show2") public String showInfo2()&#123; int a = 10/0; return "index"; &#125; /** * java.lang.ArithmeticException * 该方法需要返回一个ModelAndView：目的是可以让我们封装异常信息以及视图的指定 * 参数Exception e:会将产生异常对象注入到方法中 */ @ExceptionHandler(value=&#123;java.lang.ArithmeticException.class&#125;) public ModelAndView arithmeticExceptionHandler(Exception e)&#123; ModelAndView mv = new ModelAndView(); mv.addObject("error", e.toString()); mv.setViewName("error1"); return mv; &#125; /** * java.lang.NullPointerException * 该方法需要返回一个ModelAndView：目的是可以让我们封装异常信息以及视图的指定 * 参数Exception e:会将产生异常对象注入到方法中 */ @ExceptionHandler(value=&#123;java.lang.NullPointerException.class&#125;) public ModelAndView nullPointerExceptionHandler(Exception e)&#123; ModelAndView mv = new ModelAndView(); mv.addObject("error", e.toString()); mv.setViewName("error2"); return mv; &#125; &#125; 修改页面进入src/main/resources/templates目录下，创建空指针和算术异常页面 算术异常页面error1.html1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;错误提示页面-ArithmeticException&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 出错了，请与管理员联系。。。 &lt;span th:text="$&#123;error&#125;"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 空指针异常页面error2.html1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;错误提示页面-NullPointerException&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 出错了，请与管理员联系。。。 &lt;span th:text="$&#123;error&#125;"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 效果 弊端只有标记了@ExceptionHandle注解的Controller类才能处理跳转到自定义异常页面，而其它的Controller类中的方法则还是跳转到springboot默认机制的异常处理 @ControllerAdvice+@ExceptionHandler修改Controller全局异常控制类GlobalException.java,浏览器请求Controller，如果发生了异常，则会走全局异常控制类GlobalException.java,该类可以对不同的异常进行不同的处理(指定异常信息、视图页面) 该方式优于@ExceptionHandle注解处理异常 1234567891011121314151617181920212223242526272829303132333435/** * 全局异常处理类 * * */@ControllerAdvicepublic class GlobalException &#123; /** * java.lang.ArithmeticException * 该方法需要返回一个ModelAndView：目的是可以让我们封装异常信息以及视图的指定 * 参数Exception e:会将产生异常对象注入到方法中 */ @ExceptionHandler(value=&#123;java.lang.ArithmeticException.class&#125;) public ModelAndView arithmeticExceptionHandler(Exception e)&#123; ModelAndView mv = new ModelAndView(); mv.addObject("error", e.toString()); mv.setViewName("error1"); return mv; &#125; /** * java.lang.NullPointerException * 该方法需要返回一个ModelAndView：目的是可以让我们封装异常信息以及视图的指定 * 参数Exception e:会将产生异常对象注入到方法中 */ @ExceptionHandler(value=&#123;java.lang.NullPointerException.class&#125;) public ModelAndView nullPointerExceptionHandler(Exception e)&#123; ModelAndView mv = new ModelAndView(); mv.addObject("error", e.toString()); mv.setViewName("error2"); return mv; &#125; &#125; 效果 SimpleMappingExceptionResolver比起@ControllerAdvice+@ExceptionHandler处理异常,通过SimpleMappingExceptionResolver做全局异常处理,方式更优雅,但是有个缺点即在异常页面不能输出异常信息 修改Controller1234567891011121314151617181920212223242526272829303132/** * 通过SimpleMappingExceptionResolver做全局异常处理 * * */@Configurationpublic class GlobalException &#123; /** * 该方法必须要有返回值。返回值类型必须是：SimpleMappingExceptionResolver */ @Bean public SimpleMappingExceptionResolver getSimpleMappingExceptionResolver()&#123; SimpleMappingExceptionResolver resolver = new SimpleMappingExceptionResolver(); Properties mappings = new Properties(); /** * 参数一：异常的类型，注意必须是异常类型的全名 * 参数二：视图名称 */ mappings.put("java.lang.ArithmeticException", "error1"); mappings.put("java.lang.NullPointerException","error2"); //设置异常与视图映射信息的 resolver.setExceptionMappings(mappings); return resolver; &#125; &#125; 效果不能输出异常信息 弊端不能在异常页面输出异常信息，SimpleMappingExceptionResolver类处理异常只能针对不同的异常映射不同的视图逻辑 自定义HandlerExceptionResolver修改Controller定义全局异常控制类必须要实现HandlerExceptionResolver接口,该种方式可以针对不同异常跳转不同的异常页面，并且在异常异页面可以输出异常信息，但是平常异常信息不会直接输出在异常页，避免异常数据被人窃取 推荐使用 1234567891011121314151617181920212223242526/** * 通过实现HandlerExceptionResolver接口做全局异常处理 * * */@Configurationpublic class GlobalException implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; ModelAndView mv = new ModelAndView(); //判断不同异常类型，做不同视图跳转 if(ex instanceof ArithmeticException)&#123; mv.setViewName("error1"); &#125; if(ex instanceof NullPointerException)&#123; mv.setViewName("error2"); &#125; mv.addObject("error", ex.toString()); return mv; &#125;&#125; 单元测试修改pom.xml12345&lt;!-- 添加junit环境的jar包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt; 创建dao1234567891011package com.bjsxt.dao;import org.springframework.stereotype.Repository;@Repositorypublic class UserDaoImpl &#123; public void saveUser()&#123; System.out.println("insert into users....."); &#125;&#125; 创建service1234567891011121314151617package com.bjsxt.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.bjsxt.dao.UserDaoImpl;@Servicepublic class UserServiceImpl &#123; @Autowired private UserDaoImpl userDaoImpl; public void addUser()&#123; this.userDaoImpl.saveUser(); &#125;&#125; 创建启动类12345678910111213package com.bjsxt;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 整合Junit做单元测试@RunWith启动器SpringJUnit4ClassRunner.class让junit与spring环境进行整合 @SpringBootTest(classes={App.class})说明当前类为springBoot的测试类加载SpringBoot启动类App.class 1234567891011121314151617181920212223242526272829303132package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.App;import com.bjsxt.service.UserServiceImpl;/** * SpringBoot测试类 *@RunWith:启动器 *SpringJUnit4ClassRunner.class：让junit与spring环境进行整合 * *@SpringBootTest(classes=&#123;App.class&#125;) 1,当前类为springBoot的测试类 *@SpringBootTest(classes=&#123;App.class&#125;) 2,加载SpringBoot启动类。启动springBoot * *junit与spring整合 @Contextconfiguartion("classpath:applicationContext.xml") */@RunWith(SpringJUnit4ClassRunner.class) @SpringBootTest(classes=&#123;App.class&#125;)public class UserServiceTest &#123; @Autowired private UserServiceImpl userServiceImpl; @Test public void testAddUser()&#123; this.userServiceImpl.addUser(); &#125;&#125; 热部署SpringLoader插件创建controller12345678910111213141516171819package com.bjsxt.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * SpringBoot----SpringLoader * * */@Controllerpublic class UsersController &#123; @RequestMapping("/show") public String showPage()&#123; System.out.println("ShowPage......"); return "index"; &#125;&#125; 创建页面进入/src/main/resources/templates目录下，创建热部署前端测试页面 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;span th:text="Hello...."&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 创建启动类1234567891011package com.bjsxt;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 运行方式一修改pom.xml12345678910111213141516&lt;!-- springloader插件 --&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;version&gt;1.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; maven命令启动 弊端这种方式的缺点是Springloader热部署程序是在系统后台以进程的形式来运行,需要手动关闭该进程对Java代码做部署处理,但是对页面无能为力 方式二在项目中直接使用jar包的方式 启动命令VM Options参数-javaagent:.\lib\springloaded-1.2.5.RELEASE.jar -noverify DevTools工具修改pom.xml123456&lt;!-- DevTools的坐标 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; SpringLoader与DevTools的区别SpringLoader在部署项目时使用的是热部署的方式 DevTools在部署项目时使用的是重新部署的方式 整合Ehcache修改pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;dependencies&gt; &lt;!-- springBoot的启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springBoot的启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springBoot的启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 测试工具的启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- druid连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Boot缓存支持启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Ehcache坐标 --&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建Ehcache的配置文件进入src/main/resources/目录下,创建ehcache.xml 123456789101112131415161718192021222324252627&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../config/ehcache.xsd"&gt; &lt;diskStore path="java.io.tmpdir"/&gt; &lt;!--defaultCache:echcache的默认缓存策略 --&gt; &lt;defaultCache maxElementsInMemory="10000" eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="120" maxElementsOnDisk="10000000" diskExpiryThreadIntervalSeconds="120" memoryStoreEvictionPolicy="LRU"&gt; &lt;persistence strategy="localTempSwap"/&gt; &lt;/defaultCache&gt; &lt;!-- 自定义缓存策略 --&gt; &lt;cache name="users" maxElementsInMemory="10000" eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="120" maxElementsOnDisk="10000000" diskExpiryThreadIntervalSeconds="120" memoryStoreEvictionPolicy="LRU"&gt; &lt;persistence strategy="localTempSwap"/&gt; &lt;/cache&gt;&lt;/ehcache&gt; 修改application.properties文件进入src/main/resources/目录下,修改application.properties 1234567891011spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/ssmspring.datasource.username=rootspring.datasource.password=rootspring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.jpa.hibernate.ddl-auto=updatespring.jpa.show-sql=truespring.cache.ehcache.cofnig=ehcache.xml 创建service使用缓存策略@Cacheable(value=&quot;users&quot;) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.bjsxt.service.impl;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.Cacheable;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.stereotype.Service;import com.bjsxt.dao.UsersRepository;import com.bjsxt.pojo.Users;import com.bjsxt.service.UsersService;/** * UsersService接口实现类 * * */@Servicepublic class UsersServiceImpl implements UsersService &#123; @Autowired private UsersRepository usersRepository; @Override public List&lt;Users&gt; findUserAll() &#123; return this.usersRepository.findAll(); &#125; @Override //@Cacheable:对当前查询的对象做缓存处理 @Cacheable(value="users") public Users findUserById(Integer id) &#123; return this.usersRepository.findOne(id); &#125; @Override public Page&lt;Users&gt; findUserByPage(Pageable pageable) &#123; return this.usersRepository.findAll(pageable); &#125; @Override public void saveUsers(Users users) &#123; this.usersRepository.save(users); &#125;&#125; 修改实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.bjsxt.pojo;import java.io.Serializable;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;@Entity@Table(name="t_users")public class Users implements Serializable &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name="id") private Integer id; @Column(name="name") private String name; @Column(name="age") private Integer age; @Column(name="address") private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "Users [id=" + id + ", name=" + name + ", age=" + age + ", address=" + address + "]"; &#125;&#125; 创建启动类开启缓存使用@EnableCaching注解 123456789101112131415package com.bjsxt;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cache.annotation.EnableCaching;@SpringBootApplication@EnableCachingpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 测试1234567891011121314151617181920212223242526272829303132package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.App;import com.bjsxt.service.UsersService;/** * UsersService测试 * * */@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes=App.class)public class UsersServiceTest &#123; @Autowired private UsersService usersService; @Test public void testFindUserById()&#123; //第一次查询 System.out.println(this.usersService.findUserById(1)); //第二次查询 System.out.println(this.usersService.findUserById(1)); &#125;&#125; 效果后台输出执行了一次sql查询，第二条结果是从缓存中取出来的 123456Hibernate: select users0_.id as id1_0_0_, users0_.address as address2_0_0_, users0_.age as age3_0_0_, users0_.name as name4_0_0_ from t_users users0_ where users0_.id=?Users [id=1, name=shenlibing, age=18, address=haikoou]Users [id=1, name=shenlibing, age=18, address=haikoou]2019-04-08 15:28:17.262 INFO 1320 --- [ Thread-4] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@5b94b04d: startup date [Mon Apr 08 15:28:11 CST 2019]; root of context hierarchy2019-04-08 15:28:17.265 INFO 1320 --- [ Thread-4] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit &apos;default&apos;2019-04-08 15:28:17.270 INFO 1320 --- [ Thread-4] com.alibaba.druid.pool.DruidDataSource : &#123;dataSource-1&#125; closed @Cacheable把方法的返回值添加到Ehcache中做缓存 Value属性：指定一个Ehcache配置文件中的缓存策略，如果么有给定value，则表示使用默认的缓存策略 Key属性：给存储的值起个名称。在查询时如果有名称相同的，那么则知己从缓存中将数据返回 修改service123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.bjsxt.service.impl;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.Cacheable;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.stereotype.Service;import com.bjsxt.dao.UsersRepository;import com.bjsxt.pojo.Users;import com.bjsxt.service.UsersService;/** * UsersService接口实现类 * * */@Servicepublic class UsersServiceImpl implements UsersService &#123; @Autowired private UsersRepository usersRepository; @Override public List&lt;Users&gt; findUserAll() &#123; return this.usersRepository.findAll(); &#125; @Override //@Cacheable:对当前查询的对象做缓存处理 @Cacheable(value="users") public Users findUserById(Integer id) &#123; return this.usersRepository.findOne(id); &#125; @Override @Cacheable(value="users",key="#pageable.pageSize") public Page&lt;Users&gt; findUserByPage(Pageable pageable) &#123; return this.usersRepository.findAll(pageable); &#125; @Override public void saveUsers(Users users) &#123; this.usersRepository.save(users); &#125;&#125; 修改测试123456789101112131415161718192021222324252627282930313233343536373839package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.App;import com.bjsxt.service.UsersService;/** * UsersService测试 * * */@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes=App.class)public class UsersServiceTest &#123; @Autowired private UsersService usersService; @Test public void testFindUserByPage()&#123; Pageable pageable = new PageRequest(0, 2); //第一次查询 System.out.println(this.usersService.findUserByPage(pageable).getTotalElements()); //第二次查询 System.out.println(this.usersService.findUserByPage(pageable).getTotalElements()); //第三次查询 pageable = new PageRequest(1, 2); System.out.println(this.usersService.findUserByPage(pageable).getTotalElements()); &#125;&#125; 效果后台输出执行了一次sql查询，后面两次是从缓存取出来的 因为service层使用了缓存策略@Cacheable(value=&quot;users&quot;,key=&quot;#pageable.pageSize&quot;)且指定了key为分页的每页条数在测试查询的时候虽然第三次查询重新new PageRequest(1, 2)，但是size还是为2，所以还是从缓存中取 12345678Hibernate: select users0_.id as id1_0_, users0_.address as address2_0_, users0_.age as age3_0_, users0_.name as name4_0_ from t_users users0_ limit ?Hibernate: select count(users0_.id) as col_0_0_ from t_users users0_5552019-04-08 15:45:08.451 INFO 20352 --- [ Thread-4] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@192c3f1e: startup date [Mon Apr 08 15:45:02 CST 2019]; root of context hierarchy2019-04-08 15:45:08.457 INFO 20352 --- [ Thread-4] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit &apos;default&apos;2019-04-08 15:45:08.464 INFO 20352 --- [ Thread-4] com.alibaba.druid.pool.DruidDataSource : &#123;dataSource-1&#125; closed @CacheEvict清除缓存,在对频繁查询的数据可以从缓存中取,然而一旦有新的数据写入数据库,必须重新刷新缓存,即清除缓存 修改service1234567@Override//@CacheEvict(value="users",allEntries=true) 清除缓存中以users缓存策略缓存的对象@CacheEvict(value="users",allEntries=true)public void saveUsers(Users users) &#123; this.usersRepository.save(users);&#125; 修改测试1234567891011121314151617181920212223242526272829303132333435363738394041package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.App;import com.bjsxt.pojo.Users;import com.bjsxt.service.UsersService;/** * UsersService测试 * * */@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes=App.class)public class UsersServiceTest &#123; @Autowired private UsersService usersService; @Test public void testFindAll()&#123; //第一次查询 System.out.println(this.usersService.findUserAll().size()); Users users = new Users(); users.setAddress("南京"); users.setAge(43); users.setName("朱七"); this.usersService.saveUsers(users); //第二次查询 System.out.println(this.usersService.findUserAll().size()); &#125;&#125; 效果 后台输出第一次查询和第二次查询之间插入了一条新数据，第一次查询结果是5条，在插入数据方法saveUsers上开启了清除缓存，所以插入数据之后再一次查询的数据也就同步过来更新为6条 12345678Hibernate: select users0_.id as id1_0_, users0_.address as address2_0_, users0_.age as age3_0_, users0_.name as name4_0_ from t_users users0_5Hibernate: insert into t_users (address, age, name) values (?, ?, ?)Hibernate: select users0_.id as id1_0_, users0_.address as address2_0_, users0_.age as age3_0_, users0_.name as name4_0_ from t_users users0_62019-04-08 15:54:13.046 INFO 19660 --- [ Thread-4] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@192c3f1e: startup date [Mon Apr 08 15:54:08 CST 2019]; root of context hierarchy2019-04-08 15:54:13.049 INFO 19660 --- [ Thread-4] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit &apos;default&apos;2019-04-08 15:54:13.053 INFO 19660 --- [ Thread-4] com.alibaba.druid.pool.DruidDataSource : &#123;dataSource-1&#125; closed 整合Redis修改pom.xml12345&lt;!-- Spring Data Redis的启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 创建Redis配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.bjsxt.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.StringRedisSerializer;import redis.clients.jedis.JedisPoolConfig;/** * 完成对Redis的整合的一些配置 * * */@Configurationpublic class RedisConfig &#123; /** * 1.创建JedisPoolConfig对象。在该对象中完成一些链接池配置 * */ @Bean public JedisPoolConfig jedisPoolConfig()&#123; JedisPoolConfig config = new JedisPoolConfig(); //最大空闲数 config.setMaxIdle(10); //最小空闲数 config.setMinIdle(5); //最大链接数 config.setMaxTotal(20); return config; &#125; /** * 2.创建JedisConnectionFactory：配置redis链接信息 */ @Bean public JedisConnectionFactory jedisConnectionFactory(JedisPoolConfig config)&#123; JedisConnectionFactory factory = new JedisConnectionFactory(); //关联链接池的配置对象 factory.setPoolConfig(config); //配置链接Redis的信息 //主机地址 factory.setHostName("192.168.1.104"); //端口 factory.setPort(6379); return factory; &#125; /** * 3.创建RedisTemplate:用于执行Redis操作的方法 */ @Bean public RedisTemplate&lt;String,Object&gt; redisTemplate(JedisConnectionFactory factory)&#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); //关联 template.setConnectionFactory(factory); //为key设置序列化器 template.setKeySerializer(new StringRedisSerializer()); //为value设置序列化器 template.setValueSerializer(new StringRedisSerializer()); return template; &#125;&#125; 创建测试修改pom.xml添加测试启动依赖坐标 12345&lt;!-- Test的启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt; 测试12345678910111213141516171819202122232425262728293031323334353637383940package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.App;/** * Spring Data Redis测试 * * */@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes=App.class)public class RedisTest &#123; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; /** * 添加一个字符串 */ @Test public void testSet()&#123; this.redisTemplate.opsForValue().set("key", "北京尚学堂"); &#125; /** * 获取一个字符串 */ @Test public void testGet()&#123; String value = (String)this.redisTemplate.opsForValue().get("key"); System.out.println(value); &#125;&#125; 提取redis的配置信息修改application.properties进入src/main/resource/目录,修改application.properties 123456spring.redis.pool.max-idle=10spring.redis.pool.min-idle=5spring.redis.pool.max-total=20spring.redis.hostName=192.168.1.104spring.redis.port=6379 修改redis配置类将前缀相同的内容创建一个实体使用@ConfigurationProperties注解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.bjsxt.config;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.StringRedisSerializer;import redis.clients.jedis.JedisPoolConfig;/** * 完成对Redis的整合的一些配置 * * */@Configurationpublic class RedisConfig &#123; /** * 1.创建JedisPoolConfig对象。在该对象中完成一些链接池配置 * @ConfigurationProperties:会将前缀相同的内容创建一个实体。 */ @Bean @ConfigurationProperties(prefix="spring.redis.pool") public JedisPoolConfig jedisPoolConfig()&#123; JedisPoolConfig config = new JedisPoolConfig(); /*//最大空闲数 config.setMaxIdle(10); //最小空闲数 config.setMinIdle(5); //最大链接数 config.setMaxTotal(20);*/ System.out.println("默认值："+config.getMaxIdle()); System.out.println("默认值："+config.getMinIdle()); System.out.println("默认值："+config.getMaxTotal()); return config; &#125; /** * 2.创建JedisConnectionFactory：配置redis链接信息 */ @Bean @ConfigurationProperties(prefix="spring.redis") public JedisConnectionFactory jedisConnectionFactory(JedisPoolConfig config)&#123; System.out.println("配置完毕："+config.getMaxIdle()); System.out.println("配置完毕："+config.getMinIdle()); System.out.println("配置完毕："+config.getMaxTotal()); JedisConnectionFactory factory = new JedisConnectionFactory(); //关联链接池的配置对象 factory.setPoolConfig(config); //配置链接Redis的信息 //主机地址 /*factory.setHostName("192.168.1.104"); //端口 factory.setPort(6379);*/ return factory; &#125; /** * 3.创建RedisTemplate:用于执行Redis操作的方法 */ @Bean public RedisTemplate&lt;String,Object&gt; redisTemplate(JedisConnectionFactory factory)&#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); //关联 template.setConnectionFactory(factory); //为key设置序列化器 template.setKeySerializer(new StringRedisSerializer()); //为value设置序列化器 template.setValueSerializer(new StringRedisSerializer()); return template; &#125;&#125; 效果12345678910111213141516172019-04-08 16:24:36.624 INFO 9340 --- [ main] .s.d.r.c.RepositoryConfigurationDelegate : Multiple Spring Data modules found, entering strict repository configuration mode!默认值：8默认值：0默认值：8配置完毕：10配置完毕：5配置完毕：202019-04-08 16:24:38.113 INFO 9340 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.web.context.support.GenericWebApplicationContext@79d8407f: startup date [Mon Apr 08 16:24:35 CST 2019]; root of context hierarchy2019-04-08 16:24:38.184 INFO 9340 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error]&#125;&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2019-04-08 16:24:38.185 INFO 9340 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error],produces=[text/html]&#125;&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2019-04-08 16:24:38.221 INFO 9340 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2019-04-08 16:24:38.221 INFO 9340 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2019-04-08 16:24:38.269 INFO 9340 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2019-04-08 16:24:38.317 WARN 9340 --- [ main] org.thymeleaf.templatemode.TemplateMode : [THYMELEAF][main] Template Mode &apos;HTML5&apos; is deprecated. Using Template Mode &apos;HTML&apos; instead.2019-04-08 16:24:38.931 INFO 9340 --- [ main] com.bjsxt.test.RedisTest : Started RedisTest in 4.089 seconds (JVM running for 5.112)北京尚学堂2019-04-08 16:24:39.039 INFO 9340 --- [ Thread-2] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@79d8407f: startup date [Mon Apr 08 16:24:35 CST 2019]; root of context hierarchy 存储实体对象创建实体实体必须实现序列化接口 123456789101112131415161718192021222324252627282930313233package com.bjsxt.pojo;import java.io.Serializable;public class Users implements Serializable &#123; private Integer id; private String name; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Users [id=" + id + ", name=" + name + ", age=" + age + "]"; &#125; &#125; 修改测试保存实体前时必须重新设置序列化器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.JdkSerializationRedisSerializer;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.App;import com.bjsxt.pojo.Users;/** * Spring Data Redis测试 * * */@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes=App.class)public class RedisTest &#123; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; /** * 添加Users对象 */ @Test public void testSetUesrs()&#123; Users users = new Users(); users.setAge(20); users.setName("张三丰"); users.setId(1); //重新设置序列化器 this.redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer()); this.redisTemplate.opsForValue().set("users", users); &#125; /** * 取Users对象 */ @Test public void testGetUsers()&#123; //重新设置序列化器 this.redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer()); Users users = (Users)this.redisTemplate.opsForValue().get("users"); System.out.println(users); &#125; &#125; 效果12345678910111213141516172019-04-08 16:29:32.045 INFO 12720 --- [ main] .s.d.r.c.RepositoryConfigurationDelegate : Multiple Spring Data modules found, entering strict repository configuration mode!默认值：8默认值：0默认值：8配置完毕：10配置完毕：5配置完毕：202019-04-08 16:29:33.400 INFO 12720 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.web.context.support.GenericWebApplicationContext@1e66f1f5: startup date [Mon Apr 08 16:29:31 CST 2019]; root of context hierarchy2019-04-08 16:29:33.477 INFO 12720 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error]&#125;&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2019-04-08 16:29:33.478 INFO 12720 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error],produces=[text/html]&#125;&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2019-04-08 16:29:33.518 INFO 12720 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2019-04-08 16:29:33.518 INFO 12720 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2019-04-08 16:29:33.564 INFO 12720 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2019-04-08 16:29:33.607 WARN 12720 --- [ main] org.thymeleaf.templatemode.TemplateMode : [THYMELEAF][main] Template Mode &apos;HTML5&apos; is deprecated. Using Template Mode &apos;HTML&apos; instead.2019-04-08 16:29:34.223 INFO 12720 --- [ main] com.bjsxt.test.RedisTest : Started RedisTest in 3.616 seconds (JVM running for 4.489)Users [id=1, name=张三丰, age=20]2019-04-08 16:29:34.352 INFO 12720 --- [ Thread-2] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@1e66f1f5: startup date [Mon Apr 08 16:29:31 CST 2019]; root of context hierarchy JdkSerializationRedisSerializer弊端实体对象通过JdkSerializationRedisSerializer序列化后存到Redis中占用空间大 JSON格式存储实体对象推荐使用 修改测试重置序列化Jackson2JsonRedisSerializer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.JdkSerializationRedisSerializer;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.App;import com.bjsxt.pojo.Users;/** * Spring Data Redis测试 * * */@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes=App.class)public class RedisTest &#123; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; /** * 基于JSON格式存Users对象 */ @Test public void testSetUsersUseJSON()&#123; Users users = new Users(); users.setAge(20); users.setName("李四丰"); users.setId(1); this.redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Users.class)); this.redisTemplate.opsForValue().set("users_json", users); &#125; /** * 基于JSON格式取Users对象 */ @Test public void testGetUseJSON()&#123; this.redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Users.class)); Users users = (Users)this.redisTemplate.opsForValue().get("users_json"); System.out.println(users); &#125;&#125; 效果12345678910111213141516172019-04-08 16:41:53.694 INFO 19280 --- [ main] .s.d.r.c.RepositoryConfigurationDelegate : Multiple Spring Data modules found, entering strict repository configuration mode!默认值：8默认值：0默认值：8配置完毕：10配置完毕：5配置完毕：202019-04-08 16:41:55.094 INFO 19280 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.web.context.support.GenericWebApplicationContext@1e66f1f5: startup date [Mon Apr 08 16:41:52 CST 2019]; root of context hierarchy2019-04-08 16:41:55.177 INFO 19280 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error]&#125;&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2019-04-08 16:41:55.178 INFO 19280 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error],produces=[text/html]&#125;&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2019-04-08 16:41:55.216 INFO 19280 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2019-04-08 16:41:55.216 INFO 19280 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2019-04-08 16:41:55.259 INFO 19280 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2019-04-08 16:41:55.311 WARN 19280 --- [ main] org.thymeleaf.templatemode.TemplateMode : [THYMELEAF][main] Template Mode &apos;HTML5&apos; is deprecated. Using Template Mode &apos;HTML&apos; instead.2019-04-08 16:41:55.957 INFO 19280 --- [ main] com.bjsxt.test.RedisTest : Started RedisTest in 3.767 seconds (JVM running for 4.678)Users [id=1, name=李四丰, age=20]2019-04-08 16:41:56.141 INFO 19280 --- [ Thread-2] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@1e66f1f5: startup date [Mon Apr 08 16:41:52 CST 2019]; root of context hierarchy]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat集群与Redis分布式]]></title>
    <url>%2Fmyhexo%2F2019%2F03%2F25%2FJava%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AFTomcat%E9%9B%86%E7%BE%A4%E4%B8%8ERedis%E5%88%86%E5%B8%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Lombok原理及使用下载官网 插件下载 IDEA安装Lombok插件Add the Lombok IntelliJ plugin to add lombok support for IntelliJ:Go to File &gt; Settings &gt; PluginsClick on Browse repositories…Search for Lombok PluginClick on Install pluginRestart IntelliJ IDEA Maven引入Lombok12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.4&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Java Decompiler官网 下载 Lombok验证通过Java Decompiler验证class文件 Lombok原理 Maven环境隔离项目环境本地开发环境(Local) 开发环境(Dev) 测试环境(Beta) 线上环境(Prod) 目录初始化 配置pom.xmlbuild节点中的resources中增加resource节点 1234567891011&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources.$&#123;deploy.type&#125;&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;*.jsp&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt;&lt;/resources&gt; project节点中增加profiles节点 1234567891011121314151617181920212223&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;deploy.type&gt;dev&lt;/deploy.type&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;beta&lt;/id&gt; &lt;properties&gt; &lt;deploy.type&gt;beta&lt;/deploy.type&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;deploy.type&gt;prod&lt;/deploy.type&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; IDEA中设置默认环境在IDEA右侧Maven Projects,选中本地开发环境对应的的环境，点击右下角出现import changes进行更新 这里设置的默认环境作用于IDEA中配置的Tomcat启动时发布部署的war包 编译打包命令开发环境手动打war包 1mvn clean package -Dmaven.test.skip=true -Pdev 线上环境1mvn clean package -Dmaven.test.skip=true -Pprod 验证 Tomcat集群搭建原理通过Nginx负载均衡进行请求转发 单机部署多应用单机部署多个Tomcat，第一个Tomcat不变,修改第二个Tomcat 配置环境变量修改/etc/profile增加Tomcat环境变量 123456789#tomcatexport CATALINA_BASE=/opt/module/tomcat1export CATALINA_HOME=/opt/module/tomcat1export TOMCAT_HOME=/opt/module/tomcat1export CATALINA_BASE_2=/opt/module/tomcat2export CATALINA_HOME_2=/opt/module/tomcat2export TOMCAT_HOME_2=/opt/module/tomcat2#export PATH=$PATH:$CATALINA_HOME/bin source /etc/profile使配置文件立即生效 编辑catalina.sh进入/opt/module/tomcat2/bin目录,编辑catalina.sh 123# OS specific support. $var _must_ be set to either true or false.export CATALINA_BASE=$CATALINA_BASE_2export CATALINA_HOME=$CATALINA_HOME_2 编辑server.xml进入/opt/module/tomcat2/conf目录，编辑server.xml，修改3个端口，为了方便，每个端口号加上1000 启动启动Tomcat2 123456789[root@192 bin]# pwd/opt/module/tomcat2/bin[root@192 bin]# ./startup.sh Using CATALINA_BASE: /opt/module/tomcat2Using CATALINA_HOME: /opt/module/tomcat2Using CATALINA_TMPDIR: /opt/module/tomcat2/tempUsing JRE_HOME: /usr/java/jdk1.7.0_80Using CLASSPATH: /opt/module/tomcat2/bin/bootstrap.jar:/opt/module/tomcat2/bin/tomcat-juli.jarTomcat started. 启动Tomcat1 123456789[root@192 bin]# pwd/opt/module/tomcat1/bin[root@192 bin]# ./startup.sh Using CATALINA_BASE: /opt/module/tomcat1Using CATALINA_HOME: /opt/module/tomcat1Using CATALINA_TMPDIR: /opt/module/tomcat1/tempUsing JRE_HOME: /usr/java/jdk1.7.0_80Using CLASSPATH: /opt/module/tomcat1/bin/bootstrap.jar:/opt/module/tomcat1/bin/tomcat-juli.jarTomcat started. 多机部署多应用多个服务器并且每个服务器只安装一个Tomcat，要保证它们之间的网络是互通的，方可集群，Nginx在任意一台服务器上即可，也可单独把Nginx服务独立出来一台。 Nginx负载均衡实现负载均衡常用策略轮询默认优点：实现简单缺点：不考虑每台服务器处理能力 权重优点：考虑了每台服务器处理能力的不同，weight默认是1 ip hash优点：能实现同一个用户访问同一个服务器,可以不改变现有技术架构，直接实现横向拓展缺点：导致服务器请求(负载)不平均(完全依赖ip hash的结果)在ip变化的环境下无法服务 url hash(第三方)优点：能实现同一个服务器访问同一个服务器缺点：根据url hash分配请求会不平均，请求频繁的url会请求到同一个服务器上的 fair(第三方)缺点：按后端服务器的响应时间来分配请求，响应时间短的优先分配 负载均衡策略权重配置编辑/usr/local/nginx/conf/nginx.conf文件，追加 12###########################vhost############################################## include vhost/*.conf; 在/usr/local/nginx/conf目录下，新建vhost文件夹 在/usr/local/nginx/conf/vhost目录下，编辑www.mytest.com.conf配置文件 1234567891011121314151617181920[root@192 sbin]# cat ../conf/vhost/www.mytest.com.confupstream 127.0.0.1&#123; server 127.0.0.1:8080 weight=1; server 127.0.0.1:9080 weight=2;&#125;#Start www.mytest.comserver &#123; listen 80; server_name www.mytest.com; access_log /usr/local/nginx/logs/access.log combined; index index.html index.htm index.php; # send request back to apach location / &#123; proxy_pass http://127.0.0.1; &#125;&#125; 验证替换/opt/module/tomcat2/webapps/ROOT目录下tomcat.png 访问www.mytest.com,请求分流一下打到Tomcat1，一下打到Tomcat2，Nginx负载均衡策略权重Tomcat2配置weight=2，Tomcat1配置weight=1，所以访问到Tomcat2的概率是Tomcat1的2倍 坑Session登录信息存储及读取的问题轮询登录的时候登录了A服务器，session信息存储到A服务器上了Nginx负载均衡策略使用轮询或者最小连接会导致，第一次访问A服务器，第二次可能访问到B服务器，这个时候存储在A服务器上的session信息在B服务器上读取不到。 ip hashNginx负载均衡策略使用ip hash，那么登录信息还可以从A服务器上访问，但是这个有可能造成某些服务器压力过大，某些服务器又没有什么压力，这个时候压力过大的机器(包括网卡带宽)有可能成为瓶颈，并且请求不够分散。 服务器定时任务并发的问题假设有定时关单的Job，单个Tomcat没有任何问题，但是在集群环境下，Spring Schedule定时执行的时候，会都一起执行，会导致数据错乱和资源浪费 Redis简介高性能的key-value数据库 内存数据库，支持数据持久化 安装linux下载redis-2.8.0.tar.gzwindows 解压 1[root@192 soft]# tar -zxvf redis-2.8.0.tar.gz -C /opt/module/ 服务端启动直接启动默认是6379端口 123456789101112131415161718192021222324[root@192 src]# pwd/opt/module/redis-2.8.0/src[root@192 src]# ./redis-server [6448] 26 Mar 18:30:37.044 # Warning: no config file specified, using the default config. In order to specify a config file use ./redis-server /path/to/redis.conf[6448] 26 Mar 18:30:37.045 * Max number of open files set to 10032 _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 2.8.0 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in stand alone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6379 | `-._ `._ / _.-&apos; | PID: 6448 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos; [6448] 26 Mar 18:30:37.046 # Server started, Redis version 2.8.0 指定端口启动123456789101112131415161718192021[root@192 src]# ./redis-server --port 6380[6457] 26 Mar 18:32:55.317 * Max number of open files set to 10032 _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 2.8.0 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in stand alone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6380 | `-._ `._ / _.-&apos; | PID: 6457 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos; [6457] 26 Mar 18:32:55.318 # Server started, Redis version 2.8.0 指定配置文件配置启动配置文件修改端口,登录密码 123[root@192 redis-2.8.0]# pwd/opt/module/redis-2.8.0[root@192 redis-2.8.0]# vim redis.conf 123456789101112131415161718192021[root@192 src]# ./redis-server ../redis.conf [6468] 26 Mar 18:37:12.957 * Max number of open files set to 10032 _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 2.8.0 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in stand alone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6380 | `-._ `._ / _.-&apos; | PID: 6468 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos; [6468] 26 Mar 18:37:12.959 # Server started, Redis version 2.8.0 关闭直接关闭1[root@192 src]# ./redis-cli shutdown 指定端口关闭启动如果指定了端口，关闭必须指定端口 1[root@192 src]# ./redis-cli -p 6379 shutdown 指定端口、ip地址、密码关闭启动指定配置文件启动，配置文件修改了端口、密码，关闭的时候必须指定端口、密码 123456[root@192 src]# ./redis-cli -p 6380 shutdown(error) NOAUTH Authentication required.[root@192 src]# ./redis-cli -p 6380 -h 127.0.0.1 -a 000000 shutdown[root@192 src]# ps -ef | grep redisroot 6526 6337 0 18:51 pts/6 00:00:00 grep redis[root@192 src]# 客户端连接服务端直接连接服务端默认启动，客户端可以直接默认连接 123456789101112[root@192 src]# ./redis-cli 127.0.0.1:6379&gt; keys *1) &quot;b&quot;2) &quot;hash&quot;3) &quot;a2&quot;4) &quot;a1&quot;5) &quot;1&quot;6) &quot;hash2&quot;7) &quot;word&quot;8) &quot;a&quot;9) &quot;a3&quot;127.0.0.1:6379&gt; quit 指定端口连接服务端指定端口启动，客户端启连接必须指定端口 1[root@192 src]# ./redis-cli -p 6379 指定端口、ip连接1[root@192 src]# ./redis-cli -p 6379 -h 127.0.0.1 指定端口、ip、密码连接服务端指定配置文件启动，配置文件修改了端口、密码，客户端连接必须指定端口、密码 123456789101112131415161718[root@192 src]# pwd/opt/module/redis-2.8.0/src[root@192 src]# ./redis-cli -p 6380127.0.0.1:6380&gt; keys *(error) NOAUTH Authentication required.127.0.0.1:6380&gt; quit[root@192 src]# ./redis-cli -p 6380 -h 127.0.0.1 -a 000000127.0.0.1:6380&gt; keys *1) &quot;1&quot;2) &quot;a&quot;3) &quot;a2&quot;4) &quot;hash2&quot;5) &quot;word&quot;6) &quot;b&quot;7) &quot;hash&quot;8) &quot;a3&quot;9) &quot;a1&quot;127.0.0.1:6380&gt; 关闭1127.0.0.1:6379&gt; quit 数据结构系统命令查看键1127.0.0.1:6379&gt; keys * 查看基本信息1127.0.0.1:6379&gt; info 退出1127.0.0.1:6379&gt; exit 1127.0.0.1:6379&gt; quit 切换库默认使用0库 1127.0.0.1:6379&gt; select 2 清除当前库数据1127.0.0.1:6379&gt; flushdb 清除所有库数据1127.0.0.1:6379&gt; flushall 查看键的数量1127.0.0.1:6379&gt; dbsize 查看键生命时间-1代表永久有效 12345127.0.0.1:6379[1]&gt; keys *1) &quot;a&quot;2) &quot;b&quot;127.0.0.1:6379[1]&gt; ttl a(integer) -1 查看类型12127.0.0.1:6379[1]&gt; type astring 日志监听12127.0.0.1:6379&gt; monitorOK String字符串设置设置单个12127.0.0.1:6379[1]&gt; set c cOK 设置指定生命时间(秒)123456127.0.0.1:6379[1]&gt; setex d 10 dOK127.0.0.1:6379[1]&gt; ttl d(integer) 7127.0.0.1:6379[1]&gt; ttl d(integer) 6 设置指定生命时间(毫秒秒)12345678127.0.0.1:6379[1]&gt; psetex e 10000 eOK127.0.0.1:6379[1]&gt; ttl e(integer) 8127.0.0.1:6379[1]&gt; ttl e(integer) 6127.0.0.1:6379[1]&gt; ttl e(integer) 5 重置单个123456127.0.0.1:6379[1]&gt; get a&quot;a&quot;127.0.0.1:6379[1]&gt; getset a aaa&quot;a&quot;127.0.0.1:6379[1]&gt; get a&quot;aaa&quot; 设置多个1234567891011127.0.0.1:6379[1]&gt; mset a1 a1_value a2 a2_value a3 a3_valueOK127.0.0.1:6379[1]&gt; keys *1) &quot;a&quot;2) &quot;b&quot;3) &quot;a1&quot;4) &quot;a3&quot;5) &quot;hello&quot;6) &quot;a2&quot;7) &quot;c&quot;127.0.0.1:6379[1]&gt; 设置前判断键是否存在setnx1234567891011121314127.0.0.1:6379[1]&gt; keys *1) &quot;a&quot;2) &quot;b&quot;3) &quot;a1&quot;4) &quot;a3&quot;5) &quot;hello&quot;6) &quot;a2&quot;7) &quot;c&quot;127.0.0.1:6379[1]&gt; get a&quot;aaa&quot;127.0.0.1:6379[1]&gt; setnx a a(integer) 0127.0.0.1:6379[1]&gt; get a&quot;aaa&quot; 设置多个，判断键是否存在，只要一个失败就失败12345678127.0.0.1:6379[1]&gt; keys *(empty list or set)127.0.0.1:6379[1]&gt; msetnx a a b b c c(integer) 1127.0.0.1:6379[1]&gt; keys *1) &quot;a&quot;2) &quot;b&quot;3) &quot;c&quot; 追加12345127.0.0.1:6379[1]&gt; append a aaa(integer) 4127.0.0.1:6379[1]&gt; get a&quot;aaaa&quot; 默认增长只能是数字增长，默认步长是1 12345678127.0.0.1:6379[1]&gt; set 1 1OK127.0.0.1:6379[1]&gt; incr 1 (integer) 2127.0.0.1:6379[1]&gt; incr 1 (integer) 3127.0.0.1:6379[1]&gt; get 1&quot;3&quot; 指定步长增长12345678127.0.0.1:6379[1]&gt; get 1&quot;3&quot;127.0.0.1:6379[1]&gt; incrby 1 100(integer) 103127.0.0.1:6379[1]&gt; incrby 1 100(integer) 203127.0.0.1:6379[1]&gt; get 1&quot;203&quot; 默认减值12345678910127.0.0.1:6379[1]&gt; get 1&quot;203&quot;127.0.0.1:6379[1]&gt; decr 1(integer) 202127.0.0.1:6379[1]&gt; decr 1(integer) 201127.0.0.1:6379[1]&gt; decr 1(integer) 200127.0.0.1:6379[1]&gt; get 1&quot;200&quot; 指定步长减值12345678910127.0.0.1:6379[1]&gt; get 1&quot;200&quot;127.0.0.1:6379[1]&gt; decrby 1 20(integer) 180127.0.0.1:6379[1]&gt; decrby 1 20(integer) 160127.0.0.1:6379[1]&gt; decrby 1 20(integer) 140127.0.0.1:6379[1]&gt; get 1&quot;140&quot; 获取获取单个1234127.0.0.1:6379[1]&gt; get a&quot;a&quot;127.0.0.1:6379[1]&gt; get b&quot;b&quot; 截取1234127.0.0.1:6379[1]&gt; set hello helloOK127.0.0.1:6379[1]&gt; getrange hello 0 2&quot;hel&quot; 获取多个12345127.0.0.1:6379[1]&gt; mget a1 a2 a3 1) &quot;a1_value&quot;2) &quot;a2_value&quot;3) &quot;a3_value&quot;127.0.0.1:6379[1]&gt; 长度1234127.0.0.1:6379[1]&gt; get hello&quot;hello&quot;127.0.0.1:6379[1]&gt; strlen hello(integer) 5 哈希hash设置设置单个12127.0.0.1:6379[1]&gt; hset hash username shenlibing(integer) 1 设置多个12345678910111213141516127.0.0.1:6379[1]&gt; hmset hash address haikou phone 15501892660OK127.0.0.1:6379[1]&gt; hgetall hash1) &quot;username&quot;2) &quot;shenlibing&quot;3) &quot;age&quot;4) &quot;18&quot;5) &quot;address&quot;6) &quot;haikou&quot;7) &quot;phone&quot;8) &quot;15501892660&quot;127.0.0.1:6379[1]&gt; hkeys hash1) &quot;username&quot;2) &quot;age&quot;3) &quot;address&quot;4) &quot;phone&quot; 删除多个12345678910127.0.0.1:6379[1]&gt; hkeys hash1) &quot;username&quot;2) &quot;age&quot;3) &quot;address&quot;4) &quot;phone&quot;127.0.0.1:6379[1]&gt; hdel hash address phone(integer) 2127.0.0.1:6379[1]&gt; hkeys hash1) &quot;username&quot;2) &quot;age&quot; 设置单个前判断键是否存在1234127.0.0.1:6379[1]&gt; hsetnx hash username xiaobingbing(integer) 0127.0.0.1:6379[1]&gt; hget hash username&quot;shenlibing&quot; 获取获取单个12127.0.0.1:6379[1]&gt; hget hash username&quot;shenlibing&quot; 判断键是否存在12127.0.0.1:6379[1]&gt; hexists hash username(integer) 1 获取整个12345127.0.0.1:6379[1]&gt; hgetall hash1) &quot;username&quot;2) &quot;shenlibing&quot;3) &quot;age&quot;4) &quot;18&quot; 获取键123127.0.0.1:6379[1]&gt; hkeys hash1) &quot;username&quot;2) &quot;age&quot; 获取值123127.0.0.1:6379[1]&gt; hvals hash1) &quot;shenlibing&quot;2) &quot;18&quot; 获取长度12127.0.0.1:6379[1]&gt; hlen hash(integer) 2 获取多个123127.0.0.1:6379[1]&gt; hmget hash username age1) &quot;shenlibing&quot;2) &quot;18&quot; 列表list设置从左往右进12127.0.0.1:6379&gt; lpush list 1 2 3 4 5 6 7 8 9 10(integer) 10 重置根据索引重置某个元素 12127.0.0.1:6379&gt; lset list 0 100OK 向左弹出12127.0.0.1:6379&gt; lpop list&quot;100&quot; 向右弹出12127.0.0.1:6379&gt; rpop list&quot;1&quot; 获取获取多个根据索引截取list元素，获取多个元素 1234127.0.0.1:6379&gt; lrange list 0 21) &quot;10&quot;2) &quot;9&quot;3) &quot;8&quot; 获取单个根据索引查找list中某个元素，获取单个元素 12127.0.0.1:6379&gt; lindex list 0&quot;100&quot; 长度12127.0.0.1:6379&gt; llen list(integer) 10 获取所有1234567891011127.0.0.1:6379&gt; llen list(integer) 8127.0.0.1:6379&gt; lrange list 0 71) &quot;9&quot;2) &quot;8&quot;3) &quot;7&quot;4) &quot;6&quot;5) &quot;5&quot;6) &quot;4&quot;7) &quot;3&quot;8) &quot;2&quot; 集合set无序，不允许重复 设置设置多个12127.0.0.1:6379&gt; sadd set a b c d(integer) 4 重命名12127.0.0.1:6379&gt; rename set set1OK 删除指定元素,一个或者多个1234127.0.0.1:6379&gt; srem set1 a b(integer) 2127.0.0.1:6379&gt; srem set1 c(integer) 1 随机删除一个元素12127.0.0.1:6379&gt; spop set2&quot;f&quot; 获取长度12127.0.0.1:6379&gt; scard set1(integer) 4 获取所有12345127.0.0.1:6379&gt; smembers set21) &quot;d&quot;2) &quot;e&quot;3) &quot;c&quot;4) &quot;f&quot; 差集12345678910111213127.0.0.1:6379&gt; smembers set1 1) &quot;d&quot;2) &quot;b&quot;3) &quot;c&quot;4) &quot;a&quot;127.0.0.1:6379&gt; smembers set21) &quot;d&quot;2) &quot;e&quot;3) &quot;c&quot;4) &quot;f&quot;127.0.0.1:6379&gt; sdiff set1 set21) &quot;b&quot;2) &quot;a&quot; 123127.0.0.1:6379&gt; sdiff set2 set11) &quot;e&quot;2) &quot;f&quot; 交集123127.0.0.1:6379&gt; sinter set1 set21) &quot;c&quot;2) &quot;d&quot; 并集1234567127.0.0.1:6379&gt; sunion set1 set21) &quot;c&quot;2) &quot;e&quot;3) &quot;f&quot;4) &quot;a&quot;5) &quot;b&quot;6) &quot;d&quot; 是否存在某个元素12127.0.0.1:6379&gt; sismember set1 a(integer) 1 有序集合sortedset设置根据分数设置12127.0.0.1:6379&gt; zadd sortedset1 100 a 200 b 300 c(integer) 3 重命名12127.0.0.1:6379&gt; rename sortedset1 sortedsetOK 加分数1234127.0.0.1:6379&gt; zincrby sortedset 1000 a&quot;1100&quot;127.0.0.1:6379&gt; zrank sortedset a(integer) 2 获取长度12127.0.0.1:6379&gt; zcard sortedset(integer) 3 获取分数获取元素的分数 12127.0.0.1:6379&gt; zscore sortedset a&quot;100&quot; 根据分数范围返回成员个数1234127.0.0.1:6379&gt; zcount sortedset 0 200(integer) 2127.0.0.1:6379&gt; zcount sortedset 0 300(integer) 3 获取元素索引1234127.0.0.1:6379&gt; zrank sortedset a(integer) 0127.0.0.1:6379&gt; zrank sortedset b(integer) 1 根据索引区间返回元素可以带分数显示 12345678910111213127.0.0.1:6379&gt; zcard sortedset(integer) 3127.0.0.1:6379&gt; zrange sortedset 0 21) &quot;b&quot;2) &quot;c&quot;3) &quot;a&quot;127.0.0.1:6379&gt; zrange sortedset 0 2 withscores1) &quot;b&quot;2) &quot;200&quot;3) &quot;c&quot;4) &quot;300&quot;5) &quot;a&quot;6) &quot;1100&quot; Redis_Desktop_Manager工具下载 下载2 Quick Start 原生单点登录原生Redis+Cookie+Jackson+Filter解决session共享问题实现单点登录 java使用Jedis客户端编辑pom.xml12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt;&lt;/dependency&gt; 获取连接从连接池获取连接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.mmall.common;import com.mmall.util.PropertiesUtil;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/** * Created by geely */public class RedisPool &#123; //jedis连接池 private static JedisPool pool; //最大连接数 private static Integer maxTotal = Integer.parseInt(PropertiesUtil.getProperty("redis.max.total", "20")); //在jedispool中最大的idle状态(空闲的)的jedis实例的个数 private static Integer maxIdle = Integer.parseInt(PropertiesUtil.getProperty("redis.max.idle", "20")); //在jedispool中最小的idle状态(空闲的)的jedis实例的个数 private static Integer minIdle = Integer.parseInt(PropertiesUtil.getProperty("redis.min.idle", "20")); //在borrow一个jedis实例的时候，是否要进行验证操作，如果赋值true。则得到的jedis实例肯定是可以用的。 private static Boolean testOnBorrow = Boolean.parseBoolean(PropertiesUtil.getProperty("redis.test.borrow", "true")); //在return一个jedis实例的时候，是否要进行验证操作，如果赋值true。则放回jedispool的jedis实例肯定是可以用的。 private static Boolean testOnReturn = Boolean.parseBoolean(PropertiesUtil.getProperty("redis.test.return", "true")); private static String redisIp = PropertiesUtil.getProperty("redis.ip"); private static Integer redisPort = Integer.parseInt(PropertiesUtil.getProperty("redis.port")); private static void initPool() &#123; JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(maxTotal); config.setMaxIdle(maxIdle); config.setMinIdle(minIdle); config.setTestOnBorrow(testOnBorrow); config.setTestOnReturn(testOnReturn); //连接耗尽的时候，是否阻塞，false会抛出异常，true阻塞直到超时。默认为true。 config.setBlockWhenExhausted(true); pool = new JedisPool(config, redisIp, redisPort, 1000 * 2); &#125; static &#123; initPool(); &#125; public static Jedis getJedis() &#123; return pool.getResource(); &#125; public static void returnBrokenResource(Jedis jedis) &#123; pool.returnBrokenResource(jedis); &#125; public static void returnResource(Jedis jedis) &#123; pool.returnResource(jedis); &#125; public static void main(String[] args) &#123; Jedis jedis = pool.getResource(); jedis.set("geelykey", "geelyvalue"); returnResource(jedis); //临时调用，销毁连接池中的所有连接 pool.destroy(); System.out.println("program is end"); &#125;&#125; Jedis API封装读写数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121package com.mmall.util;import com.mmall.common.RedisPool;import lombok.extern.slf4j.Slf4j;import redis.clients.jedis.Jedis;/** * Created by geely */@Slf4jpublic class RedisPoolUtil &#123; /** * 设置key的有效期，单位是秒 * @param key * @param exTime * @return */ public static Long expire(String key,int exTime)&#123; Jedis jedis = null; Long result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.expire(key,exTime); &#125; catch (Exception e) &#123; log.error("expire key:&#123;&#125; error",key,e); RedisPool.returnBrokenResource(jedis); return result; &#125; RedisPool.returnResource(jedis); return result; &#125; //exTime的单位是秒 public static String setEx(String key,String value,int exTime)&#123; Jedis jedis = null; String result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.setex(key,exTime,value); &#125; catch (Exception e) &#123; log.error("setex key:&#123;&#125; value:&#123;&#125; error",key,value,e); RedisPool.returnBrokenResource(jedis); return result; &#125; RedisPool.returnResource(jedis); return result; &#125; public static String set(String key,String value)&#123; Jedis jedis = null; String result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.set(key,value); &#125; catch (Exception e) &#123; log.error("set key:&#123;&#125; value:&#123;&#125; error",key,value,e); RedisPool.returnBrokenResource(jedis); return result; &#125; RedisPool.returnResource(jedis); return result; &#125; public static String get(String key)&#123; Jedis jedis = null; String result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.get(key); &#125; catch (Exception e) &#123; log.error("get key:&#123;&#125; error",key,e); RedisPool.returnBrokenResource(jedis); return result; &#125; RedisPool.returnResource(jedis); return result; &#125; public static Long del(String key)&#123; Jedis jedis = null; Long result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.del(key); &#125; catch (Exception e) &#123; log.error("del key:&#123;&#125; error",key,e); RedisPool.returnBrokenResource(jedis); return result; &#125; RedisPool.returnResource(jedis); return result; &#125; public static void main(String[] args) &#123; Jedis jedis = RedisPool.getJedis(); RedisPoolUtil.set("keyTest","value"); String value = RedisPoolUtil.get("keyTest"); RedisPoolUtil.setEx("keyex","valueex",60*10); RedisPoolUtil.expire("keyTest",60*20); RedisPoolUtil.del("keyTest"); String aaa = RedisPoolUtil.get(null); System.out.println(aaa); System.out.println("end"); &#125;&#125; Jackson封装JacksonUtil编辑pom.xml12345&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.12&lt;/version&gt;&lt;/dependency&gt; 多泛型序列化和反序列化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168package com.mmall.util;import com.google.common.collect.Lists;import com.mmall.pojo.Category;import com.mmall.pojo.TestPojo;import com.mmall.pojo.User;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang.StringUtils;import org.codehaus.jackson.map.DeserializationConfig;import org.codehaus.jackson.map.ObjectMapper;import org.codehaus.jackson.map.SerializationConfig;import org.codehaus.jackson.map.annotate.JsonSerialize.Inclusion;import org.codehaus.jackson.type.JavaType;import org.codehaus.jackson.type.TypeReference;import java.io.IOException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Created by geely */@Slf4jpublic class JsonUtil &#123; private static ObjectMapper objectMapper = new ObjectMapper(); static&#123; //对象的所有字段全部列入 objectMapper.setSerializationInclusion(Inclusion.ALWAYS); //取消默认转换timestamps形式 objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS,false); //忽略空Bean转json的错误 objectMapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS,false); //所有的日期格式都统一为以下的样式，即yyyy-MM-dd HH:mm:ss objectMapper.setDateFormat(new SimpleDateFormat(DateTimeUtil.STANDARD_FORMAT)); //忽略 在json字符串中存在，但是在java对象中不存在对应属性的情况。防止错误 objectMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES,false); &#125; public static &lt;T&gt; String obj2String(T obj)&#123; if(obj == null)&#123; return null; &#125; try &#123; return obj instanceof String ? (String)obj : objectMapper.writeValueAsString(obj); &#125; catch (Exception e) &#123; log.warn("Parse Object to String error",e); return null; &#125; &#125; public static &lt;T&gt; String obj2StringPretty(T obj)&#123; if(obj == null)&#123; return null; &#125; try &#123; return obj instanceof String ? (String)obj : objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj); &#125; catch (Exception e) &#123; log.warn("Parse Object to String error",e); return null; &#125; &#125; public static &lt;T&gt; T string2Obj(String str,Class&lt;T&gt; clazz)&#123; if(StringUtils.isEmpty(str) || clazz == null)&#123; return null; &#125; try &#123; return clazz.equals(String.class)? (T)str : objectMapper.readValue(str,clazz); &#125; catch (Exception e) &#123; log.warn("Parse String to Object error",e); return null; &#125; &#125; public static &lt;T&gt; T string2Obj(String str, TypeReference&lt;T&gt; typeReference)&#123; if(StringUtils.isEmpty(str) || typeReference == null)&#123; return null; &#125; try &#123; return (T)(typeReference.getType().equals(String.class)? str : objectMapper.readValue(str,typeReference)); &#125; catch (Exception e) &#123; log.warn("Parse String to Object error",e); return null; &#125; &#125; public static &lt;T&gt; T string2Obj(String str,Class&lt;?&gt; collectionClass,Class&lt;?&gt;... elementClasses)&#123; JavaType javaType = objectMapper.getTypeFactory().constructParametricType(collectionClass,elementClasses); try &#123; return objectMapper.readValue(str,javaType); &#125; catch (Exception e) &#123; log.warn("Parse String to Object error",e); return null; &#125; &#125; public static void main(String[] args) &#123; TestPojo testPojo = new TestPojo(); testPojo.setName("Geely"); testPojo.setId(666); //&#123;"name":"Geely","id":666&#125; String json = "&#123;\"name\":\"Geely\",\"color\":\"blue\",\"id\":666&#125;"; TestPojo testPojoObject = JsonUtil.string2Obj(json,TestPojo.class);// String testPojoJson = JsonUtil.obj2String(testPojo);// log.info("testPojoJson:&#123;&#125;",testPojoJson); log.info("end");// User user = new User();// user.setId(2);// user.setEmail("geely@happymmall.com");// user.setCreateTime(new Date());// String userJsonPretty = JsonUtil.obj2StringPretty(user);// log.info("userJson:&#123;&#125;",userJsonPretty);// User u2 = new User();// u2.setId(2);// u2.setEmail("geelyu2@happymmall.com");//////// String user1Json = JsonUtil.obj2String(u1);//// String user1JsonPretty = JsonUtil.obj2StringPretty(u1);//// log.info("user1Json:&#123;&#125;",user1Json);//// log.info("user1JsonPretty:&#123;&#125;",user1JsonPretty);////// User user = JsonUtil.string2Obj(user1Json,User.class);////// List&lt;User&gt; userList = Lists.newArrayList();// userList.add(u1);// userList.add(u2);//// String userListStr = JsonUtil.obj2StringPretty(userList);//// log.info("==================");//// log.info(userListStr);////// List&lt;User&gt; userListObj1 = JsonUtil.string2Obj(userListStr, new TypeReference&lt;List&lt;User&gt;&gt;() &#123;// &#125;);////// List&lt;User&gt; userListObj2 = JsonUtil.string2Obj(userListStr,List.class,User.class); System.out.println("end"); &#125;&#125; Cookie封装其中COOKIE_NAME和COOKIE_DOMAIN是根据实际项目，线上的域名来配置的，如果扩展开来讲，对于里面每个属性，在二级/三级域名下的读写问题是必须要细化的 Cookie的读、写、删 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.mmall.util;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang.StringUtils;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Created by geely */@Slf4jpublic class CookieUtil &#123; private final static String COOKIE_DOMAIN = ".happymmall.com"; private final static String COOKIE_NAME = "mmall_login_token"; public static String readLoginToken(HttpServletRequest request)&#123; Cookie[] cks = request.getCookies(); if(cks != null)&#123; for(Cookie ck : cks)&#123; log.info("read cookieName:&#123;&#125;,cookieValue:&#123;&#125;",ck.getName(),ck.getValue()); if(StringUtils.equals(ck.getName(),COOKIE_NAME))&#123; log.info("return cookieName:&#123;&#125;,cookieValue:&#123;&#125;",ck.getName(),ck.getValue()); return ck.getValue(); &#125; &#125; &#125; return null; &#125; //X:domain=".happymmall.com" //a:A.happymmall.com cookie:domain=A.happymmall.com;path="/" //b:B.happymmall.com cookie:domain=B.happymmall.com;path="/" //c:A.happymmall.com/test/cc cookie:domain=A.happymmall.com;path="/test/cc" //d:A.happymmall.com/test/dd cookie:domain=A.happymmall.com;path="/test/dd" //e:A.happymmall.com/test cookie:domain=A.happymmall.com;path="/test" public static void writeLoginToken(HttpServletResponse response,String token)&#123; Cookie ck = new Cookie(COOKIE_NAME,token); ck.setDomain(COOKIE_DOMAIN); ck.setPath("/");//代表设置在根目录 ck.setHttpOnly(true); //单位是秒。 //如果这个maxage不设置的话，cookie就不会写入硬盘，而是写在内存。只在当前页面有效。 ck.setMaxAge(60 * 60 * 24 * 365);//如果是-1，代表永久 log.info("write cookieName:&#123;&#125;,cookieValue:&#123;&#125;",ck.getName(),ck.getValue()); response.addCookie(ck); &#125; public static void delLoginToken(HttpServletRequest request,HttpServletResponse response)&#123; Cookie[] cks = request.getCookies(); if(cks != null)&#123; for(Cookie ck : cks)&#123; if(StringUtils.equals(ck.getName(),COOKIE_NAME))&#123; ck.setDomain(COOKIE_DOMAIN); ck.setPath("/"); ck.setMaxAge(0);//设置成0，代表删除此cookie。 log.info("del cookieName:&#123;&#125;,cookieValue:&#123;&#125;",ck.getName(),ck.getValue()); response.addCookie(ck); return; &#125; &#125; &#125; &#125;&#125; SessionExpireFilter构建Session时间重置过滤器编辑web.xml12345678&lt;filter&gt; &lt;filter-name&gt;sessionExpireFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.mmall.controller.common.SessionExpireFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;sessionExpireFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 时间重置过滤器类SessionExpireFilter.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.mmall.controller.common;import com.mmall.common.Const;import com.mmall.pojo.User;import com.mmall.util.CookieUtil;import com.mmall.util.JsonUtil;import com.mmall.util.RedisShardedPoolUtil;import org.apache.commons.lang.StringUtils;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import java.io.IOException;/** * Created by geely */public class SessionExpireFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest; String loginToken = CookieUtil.readLoginToken(httpServletRequest); if(StringUtils.isNotEmpty(loginToken))&#123; //判断logintoken是否为空或者""； //如果不为空的话，符合条件，继续拿user信息 String userJsonStr = RedisShardedPoolUtil.get(loginToken); User user = JsonUtil.string2Obj(userJsonStr,User.class); if(user != null)&#123; //如果user不为空，则重置session的时间，即调用expire命令 RedisShardedPoolUtil.expire(loginToken, Const.RedisCacheExtime.REDIS_SESSION_EXTIME); &#125; &#125; filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; Guava Cache迁移Redis分布式缓存描述：修改密码时需要验证token，token的生成是在校验忘记密码的问题答案是正确的时候生成，如果答案是正确的话，返回给前台。重置密码发起请求携带该token到后台校验是否一致。 集群后Guava Cache的不足Tomcat之前使用的guava cache存储token，它只存在于tomcat实例上，tomcat及tomcat之间并不共享，所以必须迁移。否则负载均衡就TomcatA存储了guava cache，TomcatB想拿就拿不到了 Guava Cache迁移Redis缓存修改前guava cache存储token 12345678910111213141516171819202122232425262728293031323334353637public ServerResponse&lt;String&gt; checkAnswer(String username,String question,String answer)&#123; int resultCount = userMapper.checkAnswer(username,question,answer); if(resultCount&gt;0)&#123; //说明问题及问题答案是这个用户的,并且是正确的 String forgetToken = UUID.randomUUID().toString(); TokenCache.setKey(TokenCache.TOKEN_PREFIX+username,forgetToken); return ServerResponse.createBySuccess(forgetToken); &#125; return ServerResponse.createByErrorMessage("问题的答案错误");&#125;public ServerResponse&lt;String&gt; forgetResetPassword(String username,String passwordNew,String forgetToken)&#123; if(org.apache.commons.lang3.StringUtils.isBlank(forgetToken))&#123; return ServerResponse.createByErrorMessage("参数错误,token需要传递"); &#125; ServerResponse validResponse = this.checkValid(username,Const.USERNAME); if(validResponse.isSuccess())&#123; //用户不存在 return ServerResponse.createByErrorMessage("用户不存在"); &#125; String token = TokenCache.getKey(TokenCache.TOKEN_PREFIX+username); if(org.apache.commons.lang3.StringUtils.isBlank(token))&#123; return ServerResponse.createByErrorMessage("token无效或者过期"); &#125; if(org.apache.commons.lang3.StringUtils.equals(forgetToken,token))&#123; String md5Password = MD5Util.MD5EncodeUtf8(passwordNew); int rowCount = userMapper.updatePasswordByUsername(username,md5Password); if(rowCount &gt; 0)&#123; return ServerResponse.createBySuccessMessage("修改密码成功"); &#125; &#125;else&#123; return ServerResponse.createByErrorMessage("token错误,请重新获取重置密码的token"); &#125; return ServerResponse.createByErrorMessage("修改密码失败");&#125; 修改后后台token保存在Redis上 12345678910111213141516171819202122232425262728293031323334353637public ServerResponse&lt;String&gt; checkAnswer(String username,String question,String answer)&#123; int resultCount = userMapper.checkAnswer(username,question,answer); if(resultCount&gt;0)&#123; //说明问题及问题答案是这个用户的,并且是正确的 String forgetToken = UUID.randomUUID().toString(); RedisShardedPoolUtil.setEx(Const.TOKEN_PREFIX+username,forgetToken,60*60*12); return ServerResponse.createBySuccess(forgetToken); &#125; return ServerResponse.createByErrorMessage("问题的答案错误");&#125;public ServerResponse&lt;String&gt; forgetResetPassword(String username,String passwordNew,String forgetToken)&#123; if(org.apache.commons.lang3.StringUtils.isBlank(forgetToken))&#123; return ServerResponse.createByErrorMessage("参数错误,token需要传递"); &#125; ServerResponse validResponse = this.checkValid(username,Const.USERNAME); if(validResponse.isSuccess())&#123; //用户不存在 return ServerResponse.createByErrorMessage("用户不存在"); &#125; String token = RedisShardedPoolUtil.get(Const.TOKEN_PREFIX+username); if(org.apache.commons.lang3.StringUtils.isBlank(token))&#123; return ServerResponse.createByErrorMessage("token无效或者过期"); &#125; if(org.apache.commons.lang3.StringUtils.equals(forgetToken,token))&#123; String md5Password = MD5Util.MD5EncodeUtf8(passwordNew); int rowCount = userMapper.updatePasswordByUsername(username,md5Password); if(rowCount &gt; 0)&#123; return ServerResponse.createBySuccessMessage("修改密码成功"); &#125; &#125;else&#123; return ServerResponse.createByErrorMessage("token错误,请重新获取重置密码的token"); &#125; return ServerResponse.createByErrorMessage("修改密码失败");&#125; Redis分布式环境搭建第一个Redis不变，修改第二个Redis 编辑redis.conf 启动第一个默认启动,默认端口6379 1[root@192 src]# ./redis-server &amp; 第二个指定配置文件启动，修改后的端口6380 1[root@192 src]# ./redis-server ../redis.conf &amp; java代码连接Redis分布式缓存一致性算法 获取连接1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.mmall.common;import com.mmall.util.PropertiesUtil;import redis.clients.jedis.JedisPoolConfig;import redis.clients.jedis.JedisShardInfo;import redis.clients.jedis.ShardedJedis;import redis.clients.jedis.ShardedJedisPool;import redis.clients.util.Hashing;import redis.clients.util.Sharded;import java.util.ArrayList;import java.util.List;/** * Created by geely */public class RedisShardedPool &#123; private static ShardedJedisPool pool;//sharded jedis连接池 private static Integer maxTotal = Integer.parseInt(PropertiesUtil.getProperty("redis.max.total","20")); //最大连接数 private static Integer maxIdle = Integer.parseInt(PropertiesUtil.getProperty("redis.max.idle","20"));//在jedispool中最大的idle状态(空闲的)的jedis实例的个数 private static Integer minIdle = Integer.parseInt(PropertiesUtil.getProperty("redis.min.idle","20"));//在jedispool中最小的idle状态(空闲的)的jedis实例的个数 private static Boolean testOnBorrow = Boolean.parseBoolean(PropertiesUtil.getProperty("redis.test.borrow","true"));//在borrow一个jedis实例的时候，是否要进行验证操作，如果赋值true。则得到的jedis实例肯定是可以用的。 private static Boolean testOnReturn = Boolean.parseBoolean(PropertiesUtil.getProperty("redis.test.return","true"));//在return一个jedis实例的时候，是否要进行验证操作，如果赋值true。则放回jedispool的jedis实例肯定是可以用的。 private static String redis1Ip = PropertiesUtil.getProperty("redis1.ip"); private static Integer redis1Port = Integer.parseInt(PropertiesUtil.getProperty("redis1.port")); private static String redis2Ip = PropertiesUtil.getProperty("redis2.ip"); private static Integer redis2Port = Integer.parseInt(PropertiesUtil.getProperty("redis2.port")); private static void initPool()&#123; JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(maxTotal); config.setMaxIdle(maxIdle); config.setMinIdle(minIdle); config.setTestOnBorrow(testOnBorrow); config.setTestOnReturn(testOnReturn); //连接耗尽的时候，是否阻塞，false会抛出异常，true阻塞直到超时。默认为true。 config.setBlockWhenExhausted(true); JedisShardInfo info1 = new JedisShardInfo(redis1Ip,redis1Port,1000*2); JedisShardInfo info2 = new JedisShardInfo(redis2Ip,redis2Port,1000*2); List&lt;JedisShardInfo&gt; jedisShardInfoList = new ArrayList&lt;JedisShardInfo&gt;(2); jedisShardInfoList.add(info1); jedisShardInfoList.add(info2); pool = new ShardedJedisPool(config,jedisShardInfoList, Hashing.MURMUR_HASH, Sharded.DEFAULT_KEY_TAG_PATTERN); &#125; static&#123; initPool(); &#125; public static ShardedJedis getJedis()&#123; return pool.getResource(); &#125; public static void returnBrokenResource(ShardedJedis jedis)&#123; pool.returnBrokenResource(jedis); &#125; public static void returnResource(ShardedJedis jedis)&#123; pool.returnResource(jedis); &#125; public static void main(String[] args) &#123; ShardedJedis jedis = pool.getResource(); for(int i =0;i&lt;10;i++)&#123; jedis.set("key"+i,"value"+i); &#125; returnResource(jedis);// pool.destroy();//临时调用，销毁连接池中的所有连接 System.out.println("program is end"); &#125;&#125; 读写数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151package com.mmall.util;import com.mmall.common.RedisShardedPool;import lombok.extern.slf4j.Slf4j;import redis.clients.jedis.ShardedJedis;/** * Created by geely */@Slf4jpublic class RedisShardedPoolUtil &#123; /** * 设置key的有效期，单位是秒 * @param key * @param exTime * @return */ public static Long expire(String key,int exTime)&#123; ShardedJedis jedis = null; Long result = null; try &#123; jedis = RedisShardedPool.getJedis(); result = jedis.expire(key,exTime); &#125; catch (Exception e) &#123; log.error("expire key:&#123;&#125; error",key,e); RedisShardedPool.returnBrokenResource(jedis); return result; &#125; RedisShardedPool.returnResource(jedis); return result; &#125; //exTime的单位是秒 public static String setEx(String key,String value,int exTime)&#123; ShardedJedis jedis = null; String result = null; try &#123; jedis = RedisShardedPool.getJedis(); result = jedis.setex(key,exTime,value); &#125; catch (Exception e) &#123; log.error("setex key:&#123;&#125; value:&#123;&#125; error",key,value,e); RedisShardedPool.returnBrokenResource(jedis); return result; &#125; RedisShardedPool.returnResource(jedis); return result; &#125; public static String set(String key,String value)&#123; ShardedJedis jedis = null; String result = null; try &#123; jedis = RedisShardedPool.getJedis(); result = jedis.set(key,value); &#125; catch (Exception e) &#123; log.error("set key:&#123;&#125; value:&#123;&#125; error",key,value,e); RedisShardedPool.returnBrokenResource(jedis); return result; &#125; RedisShardedPool.returnResource(jedis); return result; &#125; public static String getSet(String key,String value)&#123; ShardedJedis jedis = null; String result = null; try &#123; jedis = RedisShardedPool.getJedis(); result = jedis.getSet(key,value); &#125; catch (Exception e) &#123; log.error("getset key:&#123;&#125; value:&#123;&#125; error",key,value,e); RedisShardedPool.returnBrokenResource(jedis); return result; &#125; RedisShardedPool.returnResource(jedis); return result; &#125; public static String get(String key)&#123; ShardedJedis jedis = null; String result = null; try &#123; jedis = RedisShardedPool.getJedis(); result = jedis.get(key); &#125; catch (Exception e) &#123; log.error("get key:&#123;&#125; error",key,e); RedisShardedPool.returnBrokenResource(jedis); return result; &#125; RedisShardedPool.returnResource(jedis); return result; &#125; public static Long del(String key)&#123; ShardedJedis jedis = null; Long result = null; try &#123; jedis = RedisShardedPool.getJedis(); result = jedis.del(key); &#125; catch (Exception e) &#123; log.error("del key:&#123;&#125; error",key,e); RedisShardedPool.returnBrokenResource(jedis); return result; &#125; RedisShardedPool.returnResource(jedis); return result; &#125; public static Long setnx(String key,String value)&#123; ShardedJedis jedis = null; Long result = null; try &#123; jedis = RedisShardedPool.getJedis(); result = jedis.setnx(key,value); &#125; catch (Exception e) &#123; log.error("setnx key:&#123;&#125; value:&#123;&#125; error",key,value,e); RedisShardedPool.returnBrokenResource(jedis); return result; &#125; RedisShardedPool.returnResource(jedis); return result; &#125; public static void main(String[] args) &#123; ShardedJedis jedis = RedisShardedPool.getJedis(); RedisPoolUtil.set("keyTest","value"); String value = RedisPoolUtil.get("keyTest"); RedisPoolUtil.setEx("keyex","valueex",60*10); RedisPoolUtil.expire("keyTest",60*20); RedisPoolUtil.del("keyTest"); String aaa = RedisPoolUtil.get(null); System.out.println(aaa); System.out.println("end"); &#125;&#125; Spring Session单点登录参考官网 官方文档 GitHub地址 Quick Start 引入依赖123456&lt;!-- spring session 单点登录 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;1.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring Session整合RedisapplicationContext.xml引入整合配置文件 1&lt;import resource="applicationContext-spring-session.xml"/&gt; 新建applicationContext-spring-session.xml资源文件 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;bean id="redisHttpSessionConfiguration" class="org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"&gt; &lt;property name="maxInactiveIntervalInSeconds" value="1800" /&gt; &lt;/bean&gt; &lt;bean id="defaultCookieSerializer" class="org.springframework.session.web.http.DefaultCookieSerializer"&gt; &lt;property name="domainName" value="localhost" /&gt; &lt;property name="useHttpOnlyCookie" value="true" /&gt; &lt;property name="cookiePath" value="/" /&gt; &lt;property name="cookieMaxAge" value="31536000" /&gt; &lt;/bean&gt; &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;property name="maxTotal" value="20"/&gt; &lt;/bean&gt; &lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt; &lt;property name="hostName" value="192.168.1.104" /&gt; &lt;property name="port" value="6379" /&gt; &lt;property name="poolConfig" ref="jedisPoolConfig" /&gt; &lt;/bean&gt;&lt;/beans&gt; 配置web.xml12345678&lt;filter&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 使用这里的session是经过包装过的代理类 123session.setAttribute(Const.CURRENT_USER,response.getData());session.removeAttribute(Const.CURRENT_USER);User user = (User)session.getAttribute(Const.CURRENT_USER); 坑Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [org.springframework.session.SessionRepository] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {}描述： 启动报错 解决：修改&lt;org.springframework.version&gt;4.0.0.RELEASE&lt;/org.springframework.version&gt;为 &lt;org.springframework.version&gt;4.0.3.RELEASE&lt;/org.springframework.version&gt; No bean named ‘springSessionRepositoryFilter’ is defined描述：启动报错，容器找不到该bean 12345678&lt;filter&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 解决： spring配置文件没有引入spring-session整合配置文件 1&lt;import resource="applicationContext-spring-session.xml"/&gt; SpringMVC全局异常控制Spring及SpringMVC包扫描隔离Spring扫描排除controller扫描注解 123&lt;context:component-scan base-package="com.mmall" annotation-config="true"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt;&lt;/context:component-scan&gt; SpringMVC扫描123456&lt;!--springmvc扫描包指定到controller，防止重复扫描 use-default-filters="false" 关闭默认扫描 --&gt;&lt;context:component-scan base-package="com.mmall.controller" annotation-config="true" use-default-filters="false"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;&lt;/context:component-scan&gt; @Component注解异常包装类ExceptionResolver.java,必须要加上@Component注解，使其成为容器中的bean，@Component类似于@Controller、@Service、@Repository dao层用@Repositoryservice层用@Servicecontroller层用@Controller其它的用@Component 123456789101112131415161718192021222324252627282930313233package com.mmall.common;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component;import org.springframework.stereotype.Repository;import org.springframework.stereotype.Service;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.view.json.MappingJacksonJsonView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Created by geely */@Slf4j@Componentpublic class ExceptionResolver implements HandlerExceptionResolver&#123; @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123; log.error("&#123;&#125; Exception",httpServletRequest.getRequestURI(),e); ModelAndView modelAndView = new ModelAndView(new MappingJacksonJsonView()); //当使用是jackson2.x的时候使用MappingJackson2JsonView，本项目使用的是1.9。 modelAndView.addObject("status",ResponseCode.ERROR.getCode()); modelAndView.addObject("msg","接口异常,详情请查看服务端日志的异常信息"); modelAndView.addObject("data",e.toString()); return modelAndView; &#125;&#125; SpringMVC拦截器springmvc配置拦截器&lt;mvc:mapping path=&quot;/manage/**&quot;/&gt;代表请求经过/manage目录下的子目录下的controller也会被拦截 &lt;mvc:mapping path=&quot;/manage/*&quot;/&gt;代表请求经过/manage目录下的controller会被拦截，而子目录下的controller不会被拦截 &lt;mvc:exclude-mapping path=&quot;/manage/user/login.do&quot;/&gt;配置不拦截某些请求 12345678910111213&lt;mvc:interceptors&gt; &lt;!-- 定义在这里的，所有的都会拦截--&gt; &lt;mvc:interceptor&gt; &lt;!--manage/a.do /manage/*--&gt; &lt;!--manage/b.do /manage/*--&gt; &lt;!--manage/product/save.do /manage/**--&gt; &lt;!--manage/order/detail.do /manage/**--&gt; &lt;mvc:mapping path="/manage/**"/&gt; &lt;!--&lt;mvc:exclude-mapping path="/manage/user/login.do"/&gt;--&gt; &lt;bean class="com.mmall.controller.common.interceptor.AuthorityInterceptor" /&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 定义拦截器处理类preHandle请求到达controll之前会调用该方法 postHandle请求到达controller处理后会调用该方法 afterCompletion请求到达controller处理后返回ModelAndView后会调用该方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package com.mmall.controller.common.interceptor;import com.google.common.collect.Maps;import com.mmall.common.Const;import com.mmall.common.ServerResponse;import com.mmall.pojo.User;import com.mmall.util.CookieUtil;import com.mmall.util.JsonUtil;import com.mmall.util.RedisShardedPoolUtil;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang.StringUtils;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.PrintWriter;import java.util.Arrays;import java.util.Iterator;import java.util.Map;/** * Created by geely */@Slf4jpublic class AuthorityInterceptor implements HandlerInterceptor&#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; log.info("preHandle"); //请求中Controller中的方法名 HandlerMethod handlerMethod = (HandlerMethod)handler; //解析HandlerMethod String methodName = handlerMethod.getMethod().getName(); String className = handlerMethod.getBean().getClass().getSimpleName(); //解析参数,具体的参数key以及value是什么，我们打印日志 StringBuffer requestParamBuffer = new StringBuffer(); Map paramMap = request.getParameterMap(); Iterator it = paramMap.entrySet().iterator(); while (it.hasNext())&#123; Map.Entry entry = (Map.Entry)it.next(); String mapKey = (String)entry.getKey(); String mapValue = StringUtils.EMPTY; //request这个参数的map，里面的value返回的是一个String[] Object obj = entry.getValue(); if(obj instanceof String[])&#123; String[] strs = (String[])obj; mapValue = Arrays.toString(strs); &#125; requestParamBuffer.append(mapKey).append("=").append(mapValue); &#125; if(StringUtils.equals(className,"UserManageController") &amp;&amp; StringUtils.equals(methodName,"login"))&#123; log.info("权限拦截器拦截到请求,className:&#123;&#125;,methodName:&#123;&#125;",className,methodName); //如果是拦截到登录请求，不打印参数，因为参数里面有密码，全部会打印到日志中，防止日志泄露 return true; &#125; log.info("权限拦截器拦截到请求,className:&#123;&#125;,methodName:&#123;&#125;,param:&#123;&#125;",className,methodName,requestParamBuffer.toString()); User user = null; String loginToken = CookieUtil.readLoginToken(request); if(StringUtils.isNotEmpty(loginToken))&#123; String userJsonStr = RedisShardedPoolUtil.get(loginToken); user = JsonUtil.string2Obj(userJsonStr,User.class); &#125; if(user == null || (user.getRole().intValue() != Const.Role.ROLE_ADMIN))&#123; //返回false.即不会调用controller里的方法 response.reset();//geelynote 这里要添加reset，否则报异常 getWriter() has already been called for this response. response.setCharacterEncoding("UTF-8");//geelynote 这里要设置编码，否则会乱码 response.setContentType("application/json;charset=UTF-8");//geelynote 这里要设置返回值的类型，因为全部是json接口。 PrintWriter out = response.getWriter(); //上传由于富文本的控件要求，要特殊处理返回值，这里面区分是否登录以及是否有权限 if(user == null)&#123; if(StringUtils.equals(className,"ProductManageController") &amp;&amp; StringUtils.equals(methodName,"richtextImgUpload"))&#123; Map resultMap = Maps.newHashMap(); resultMap.put("success",false); resultMap.put("msg","请登录管理员"); out.print(JsonUtil.obj2String(resultMap)); &#125;else&#123; out.print(JsonUtil.obj2String(ServerResponse.createByErrorMessage("拦截器拦截,用户未登录"))); &#125; &#125;else&#123; if(StringUtils.equals(className,"ProductManageController") &amp;&amp; StringUtils.equals(methodName,"richtextImgUpload"))&#123; Map resultMap = Maps.newHashMap(); resultMap.put("success",false); resultMap.put("msg","无权限操作"); out.print(JsonUtil.obj2String(resultMap)); &#125;else&#123; out.print(JsonUtil.obj2String(ServerResponse.createByErrorMessage("拦截器拦截,用户无权限操作"))); &#125; &#125; out.flush(); out.close();//geelynote 这里要关闭 return false; &#125; return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; log.info("postHandle"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; log.info("afterCompletion"); &#125;&#125; 登录死循环描述：springmvc配置拦截器，如果登录请求也拦截的话，会导致一直登录不上，陷入死循环当中 解决：方式一：可以在配置拦截器的时候过滤掉登录请求&lt;mvc:exclude-mapping path=&quot;/manage/user/login.do&quot;/&gt; 方式二：拦截器处理类的preHandle方法会在到达controller调用该方法,因此可以在该方法中过滤掉登录请求不拦截 12345if(StringUtils.equals(className,"UserManageController") &amp;&amp; StringUtils.equals(methodName,"login"))&#123; log.info("权限拦截器拦截到请求,className:&#123;&#125;,methodName:&#123;&#125;",className,methodName); //如果是拦截到登录请求，不打印参数，因为参数里面有密码，全部会打印到日志中，防止日志泄露 return true;&#125; 重置响应对象描述：拦截器处理类的三个方法都是返回布尔值，而controller都是返回json数据，请求如果被拦截到没有到达controller，那么在拦截器处理类的preHandle方法中必须重置响应对象 解决： 12345678910111213141516171819202122232425262728293031323334if(user == null || (user.getRole().intValue() != Const.Role.ROLE_ADMIN))&#123; //返回false.即不会调用controller里的方法 response.reset();//geelynote 这里要添加reset，否则报异常 getWriter() has already been called for this response. response.setCharacterEncoding("UTF-8");//geelynote 这里要设置编码，否则会乱码 response.setContentType("application/json;charset=UTF-8");//geelynote 这里要设置返回值的类型，因为全部是json接口。 PrintWriter out = response.getWriter(); //上传由于富文本的控件要求，要特殊处理返回值，这里面区分是否登录以及是否有权限 if(user == null)&#123; if(StringUtils.equals(className,"ProductManageController") &amp;&amp; StringUtils.equals(methodName,"richtextImgUpload"))&#123; Map resultMap = Maps.newHashMap(); resultMap.put("success",false); resultMap.put("msg","请登录管理员"); out.print(JsonUtil.obj2String(resultMap)); &#125;else&#123; out.print(JsonUtil.obj2String(ServerResponse.createByErrorMessage("拦截器拦截,用户未登录"))); &#125; &#125;else&#123; if(StringUtils.equals(className,"ProductManageController") &amp;&amp; StringUtils.equals(methodName,"richtextImgUpload"))&#123; Map resultMap = Maps.newHashMap(); resultMap.put("success",false); resultMap.put("msg","无权限操作"); out.print(JsonUtil.obj2String(resultMap)); &#125;else&#123; out.print(JsonUtil.obj2String(ServerResponse.createByErrorMessage("拦截器拦截,用户无权限操作"))); &#125; &#125; out.flush(); out.close();//geelynote 这里要关闭 return false;&#125; SpringMVC RESTful改造编辑web.xml修改前 12345678910&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 修改后 12345678910&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; controller使用RESTful风格根据id查询产品修改前 12345@RequestMapping("detail.do")@ResponseBodypublic ServerResponse&lt;ProductDetailVo&gt; detail(Integer productId)&#123; return iProductService.getProductDetail(productId);&#125; 修改后 12345@RequestMapping(value = "/&#123;productId&#125;", method = RequestMethod.GET)@ResponseBodypublic ServerResponse&lt;ProductDetailVo&gt; detailRESTful(@PathVariable Integer productId)&#123; return iProductService.getProductDetail(productId);&#125; 搜索产品keyword、categoryId不为空修改前 123456789@RequestMapping("list.do")@ResponseBodypublic ServerResponse&lt;PageInfo&gt; list(@RequestParam(value = "keyword",required = false)String keyword, @RequestParam(value = "categoryId",required = false)Integer categoryId, @RequestParam(value = "pageNum",defaultValue = "1") int pageNum, @RequestParam(value = "pageSize",defaultValue = "10") int pageSize, @RequestParam(value = "orderBy",defaultValue = "") String orderBy)&#123; return iProductService.getProductByKeywordCategory(keyword,categoryId,pageNum,pageSize,orderBy);&#125; 修改后 1234567891011121314151617181920//http://www.happymmall.com/product/手机/100012/1/10/price_asc@RequestMapping(value = "/&#123;keyword&#125;/&#123;categoryId&#125;/&#123;pageNum&#125;/&#123;pageSize&#125;/&#123;orderBy&#125;",method = RequestMethod.GET)@ResponseBodypublic ServerResponse&lt;PageInfo&gt; listRESTful(@PathVariable(value = "keyword")String keyword, @PathVariable(value = "categoryId")Integer categoryId, @PathVariable(value = "pageNum") Integer pageNum, @PathVariable(value = "pageSize") Integer pageSize, @PathVariable(value = "orderBy") String orderBy)&#123; if(pageNum == null)&#123; pageNum = 1; &#125; if(pageSize == null)&#123; pageSize = 10; &#125; if(StringUtils.isBlank(orderBy))&#123; orderBy = "price_asc"; &#125; return iProductService.getProductByKeywordCategory(keyword,categoryId,pageNum,pageSize,orderBy);&#125; keyword、categoryId有一个为空修改后版本一keyword为空 12345678910111213141516171819// http://www.happymmall.com/product/100012/1/10/price_asc@RequestMapping(value = "/&#123;categoryId&#125;/&#123;pageNum&#125;/&#123;pageSize&#125;/&#123;orderBy&#125;",method = RequestMethod.GET)@ResponseBodypublic ServerResponse&lt;PageInfo&gt; listRESTfulBadcase(@PathVariable(value = "categoryId")Integer categoryId, @PathVariable(value = "pageNum") Integer pageNum, @PathVariable(value = "pageSize") Integer pageSize, @PathVariable(value = "orderBy") String orderBy)&#123; if(pageNum == null)&#123; pageNum = 1; &#125; if(pageSize == null)&#123; pageSize = 10; &#125; if(StringUtils.isBlank(orderBy))&#123; orderBy = "price_asc"; &#125; return iProductService.getProductByKeywordCategory("",categoryId,pageNum,pageSize,orderBy);&#125; categoryId为空 123456789101112131415161718@RequestMapping(value = "/&#123;keyword&#125;/&#123;pageNum&#125;/&#123;pageSize&#125;/&#123;orderBy&#125;",method = RequestMethod.GET)@ResponseBodypublic ServerResponse&lt;PageInfo&gt; listRESTfulBadcase(@PathVariable(value = "keyword")String keyword, @PathVariable(value = "pageNum") Integer pageNum, @PathVariable(value = "pageSize") Integer pageSize, @PathVariable(value = "orderBy") String orderBy)&#123; if(pageNum == null)&#123; pageNum = 1; &#125; if(pageSize == null)&#123; pageSize = 10; &#125; if(StringUtils.isBlank(orderBy))&#123; orderBy = "price_asc"; &#125; return iProductService.getProductByKeywordCategory(keyword,null,pageNum,pageSize,orderBy);&#125; 浏览器请求http://localhost:8088/mmall_war_exploded/product/100012/1/10/price_asc 发生了歧义，不知道要走哪一个方法，所以报错了 修改后版本二categoryId为空 12345678910111213141516171819//http://www.happymmall.com/product/keyword/手机/1/10/price_asc@RequestMapping(value = "/keyword/&#123;keyword&#125;/&#123;pageNum&#125;/&#123;pageSize&#125;/&#123;orderBy&#125;",method = RequestMethod.GET)@ResponseBodypublic ServerResponse&lt;PageInfo&gt; listRESTful(@PathVariable(value = "keyword")String keyword, @PathVariable(value = "pageNum") Integer pageNum, @PathVariable(value = "pageSize") Integer pageSize, @PathVariable(value = "orderBy") String orderBy)&#123; if(pageNum == null)&#123; pageNum = 1; &#125; if(pageSize == null)&#123; pageSize = 10; &#125; if(StringUtils.isBlank(orderBy))&#123; orderBy = "price_asc"; &#125; return iProductService.getProductByKeywordCategory(keyword,null,pageNum,pageSize,orderBy);&#125; keyword为空 12345678910111213141516171819//http://www.happymmall.com/product/category/100012/1/10/price_asc@RequestMapping(value = "/category/&#123;categoryId&#125;/&#123;pageNum&#125;/&#123;pageSize&#125;/&#123;orderBy&#125;",method = RequestMethod.GET)@ResponseBodypublic ServerResponse&lt;PageInfo&gt; listRESTful(@PathVariable(value = "categoryId")Integer categoryId, @PathVariable(value = "pageNum") Integer pageNum, @PathVariable(value = "pageSize") Integer pageSize, @PathVariable(value = "orderBy") String orderBy)&#123; if(pageNum == null)&#123; pageNum = 1; &#125; if(pageSize == null)&#123; pageSize = 10; &#125; if(StringUtils.isBlank(orderBy))&#123; orderBy = "price_asc"; &#125; return iProductService.getProductByKeywordCategory("",categoryId,pageNum,pageSize,orderBy);&#125; 浏览器访问http://localhost:8088/mmall_war_exploded/product/keyword/手机/1/10/price_asc和http://localhost:8088/mmall_war_exploded/product/category/100002/1/10/price_asc 这样子就可以避免歧义 Spring Schedul定时任务Cron生成器在线Cron表达式生成器 定时任务配置注解方式配置定时任务 编辑spring配置文件12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beansxmlns:task="http://www.springframework.org/schema/task"xsi:schemaLocation="http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd"&lt;task:annotation-driven/&gt;&lt;/beans&gt; 创建定时任务类12345678910111213141516171819202122232425262728package com.mmall.task;import com.mmall.service.IOrderService;import com.mmall.util.PropertiesUtil;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;/** * Created by geely */@Component@Slf4jpublic class CloseOrderTask &#123; @Autowired private IOrderService iOrderService; //每隔5秒执行一次 @Scheduled(cron="*/5 * * * * ?") public void closeOrderTaskV1()&#123; log.info("关闭订单定时任务启动"); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour","2"));// iOrderService.closeOrder(hour); log.info("关闭订单定时任务结束"); &#125;&#125; MySQL行锁、表锁行锁明确的主键明确指定主键id，并且有结果集,产生行锁123456SELECT *FROM mmall_productWHERE id = '26' FOR UPDATE; 明确指定主键id，并且无结果集,无锁123456SELECT *FROM mmall_productWHERE id = '66' FOR UPDATE; 表锁无明确的主键无主键,产生表锁123456SELECT *FROM mmall_productWHERE NAME = 'Apple iPhone 7 Plus (A1661) 128G 玫瑰金色 移动联通电信4G手机' FOR UPDATE; 主键不明确产生表锁123456SELECT *FROM mmall_productWHERE id &lt;&gt; '66' FOR UPDATE; 123456SELECT *FROM mmall_productWHERE id LIKE '66' FOR UPDATE; 使用关单:查询订单的时候，订单包含了子订单，根据子订单号查询产品 1234567&lt;select id="selectStockByProductId" resultType="int" parameterType="java.lang.Integer"&gt;selectstockfrom mmall_productwhere id = #&#123;id&#125;for update&lt;/select&gt; xml转义用&amp;lt![CDATA[]]&gt;&amp;gt包裹住有转义的字符即可 12345678910&lt;select id="selectOrderStatusByCreateTime" resultMap="BaseResultMap" parameterType="map"&gt;SELECT&lt;include refid="Base_Column_List"/&gt;from mmall_orderwhere status = #&#123;status&#125;&amp;lt![CDATA[and create_time &lt;= #&#123;date&#125;]]&amp;gtorder by create_time desc&lt;/select&gt; 原生分布式锁Spring Schedule+Redis分布式锁构建分布式任务调度 简单版获取到锁，锁住时间5秒，如果此期间发生中断，会导致死锁 12345678910111213141516171819202122232425// @Scheduled(cron="0 */1 * * * ?") public void closeOrderTaskV2()&#123; log.info("关闭订单定时任务启动"); long lockTimeout = Long.parseLong(PropertiesUtil.getProperty("lock.timeout","5000")); Long setnxResult = RedisShardedPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+lockTimeout)); if(setnxResult != null &amp;&amp; setnxResult.intValue() == 1)&#123; //如果返回值是1，代表设置成功，获取锁 closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125;else&#123; log.info("没有获得分布式锁:&#123;&#125;",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125; log.info("关闭订单定时任务结束"); &#125; private void closeOrder(String lockName)&#123; //有效期50秒，防止死锁 RedisShardedPoolUtil.expire(lockName,5); log.info("获取&#123;&#125;,ThreadName:&#123;&#125;",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName()); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour","2")); iOrderService.closeOrder(hour); RedisShardedPoolUtil.del(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); log.info("释放&#123;&#125;,ThreadName:&#123;&#125;",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName()); log.info("==============================="); &#125; 安全版双重防死锁 未获取到锁，继续判断，判断时间戳，看是否可以重置并获取到锁 123456789101112131415161718192021222324252627282930313233343536373839@Scheduled(cron="0 */1 * * * ?")public void closeOrderTaskV3()&#123; log.info("关闭订单定时任务启动"); long lockTimeout = Long.parseLong(PropertiesUtil.getProperty("lock.timeout","5000")); Long setnxResult = RedisShardedPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+lockTimeout)); if(setnxResult != null &amp;&amp; setnxResult.intValue() == 1)&#123; closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125;else&#123; //未获取到锁，继续判断，判断时间戳，看是否可以重置并获取到锁 String lockValueStr = RedisShardedPoolUtil.get(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); if(lockValueStr != null &amp;&amp; System.currentTimeMillis() &gt; Long.parseLong(lockValueStr))&#123; String getSetResult = RedisShardedPoolUtil.getSet(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+lockTimeout)); //再次用当前时间戳getset。 //返回给定的key的旧值，-&gt;旧值判断，是否可以获取锁 //当key没有旧值时，即key不存在时，返回nil -&gt;获取锁 //这里我们set了一个新的value值，获取旧的值。 if(getSetResult == null || (getSetResult != null &amp;&amp; StringUtils.equals(lockValueStr,getSetResult)))&#123; //真正获取到锁 closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125;else&#123; log.info("没有获取到分布式锁:&#123;&#125;",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125; &#125;else&#123; log.info("没有获取到分布式锁:&#123;&#125;",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125; &#125; log.info("关闭订单定时任务结束");&#125;private void closeOrder(String lockName)&#123; //有效期50秒，防止死锁 RedisShardedPoolUtil.expire(lockName,5); log.info("获取&#123;&#125;,ThreadName:&#123;&#125;",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName()); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour","2")); iOrderService.closeOrder(hour); RedisShardedPoolUtil.del(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); log.info("释放&#123;&#125;,ThreadName:&#123;&#125;",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName()); log.info("===============================");&#125; Redisson分布式锁编辑pom.xml12345678910&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-avro&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 使用Redisson分布式锁12345678910111213141516171819202122// @Scheduled(cron="0 */1 * * * ?") public void closeOrderTaskV4()&#123; RLock lock = redissonManager.getRedisson().getLock(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); boolean getLock = false; try &#123; if(getLock = lock.tryLock(0,50, TimeUnit.SECONDS))&#123; log.info("Redisson获取到分布式锁:&#123;&#125;,ThreadName:&#123;&#125;",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName()); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour","2"));// iOrderService.closeOrder(hour); &#125;else&#123; log.info("Redisson没有获取到分布式锁:&#123;&#125;,ThreadName:&#123;&#125;",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName()); &#125; &#125; catch (InterruptedException e) &#123; log.error("Redisson分布式锁获取异常",e); &#125; finally &#123; if(!getLock)&#123; return; &#125; lock.unlock(); log.info("Redisson分布式锁释放锁"); &#125; &#125;]]></content>
      <categories>
        <category>集群</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>Redis</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS]]></title>
    <url>%2Fmyhexo%2F2019%2F03%2F20%2FNodeJS%2F</url>
    <content type="text"><![CDATA[NodeJS入门 NodeJS模块 http模块 server.js 123456789101112131415161718const http=require('http');let server=http.createServer((req, res)=&gt;&#123; switch(req.url)&#123; case '/aaa': res.write('abc'); break; case '/bbb': res.write('dddd'); break; case '/1.html': res.write('&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;sdfasfasf&lt;/body&gt;&lt;/html&gt;'); break; &#125; res.end();&#125;);server.listen(8080); server2.js 1234567891011121314const http=require('http');const fs=require('fs');let server=http.createServer((req, res)=&gt;&#123; fs.readFile(`www$&#123;req.url&#125;`, (err, data)=&gt;&#123; if(err)&#123; res.write('404'); //? &#125;else&#123; res.write(data); &#125; res.end(); &#125;);&#125;);server.listen(8080); 断言——assert 1234567891011const assert=require('assert');function sum(a, b)&#123; assert(arguments.length==2, '必须传2个参数'); assert(typeof a=='number', '第一个参数必须是数字'); assert(typeof b=='number', '第二个参数必须是数字'); return a+b;&#125;console.log(sum(12, 5)); File System 读写文件 fs.js 123456789101112131415161718const fs=require('fs');fs.readFile('1.txt', (err, data)=&gt;&#123; if(err)&#123; console.log('有错'); &#125;else&#123; //'ads'.charCodeAt(0) console.log(data.toString()); &#125;&#125;);/*fs.writeFile('3.txt', 'erqwreqwere', err=&gt;&#123; if(err)&#123; console.log(err); &#125;else&#123; console.log('成功'); &#125;&#125;);*/ fs2.js 1234567891011const fs=require('fs');fs.readFile('ofo.png', (err, data)=&gt;&#123; fs.writeFile('ofo2.png', data, (err)=&gt;&#123; if(err)&#123; console.log(err); &#125;else&#123; console.log('成功'); &#125; &#125;);&#125;); 多进程 进程和线程的区别： 进程拥有独立的执行空间、存储同一个进程内的所有线程共享一套空间、代码 多进程(PHP、Node) 成本高(慢)；安全(进程间隔离)；进程间通信麻烦；写代码简单多线程(Java、C) 成本低(快)；不安全(线程要死一块死)；线程间通信容易；写代码复杂 进程间通信的几种方式管道共享内存socket Crypto——签名 MD5是单向散列生成hash值，不可逆破解 md5.js 1234567891011const crypto=require('crypto');let obj=crypto.createHash('md5');obj.update('123456');// obj.update('123');// obj.update('4');// obj.update('56');console.log(obj.digest('hex')); 双重加密 md5_2.js 12345678910const crypto=require('crypto');function md5(str)&#123; let obj=crypto.createHash('md5'); obj.update(str); return obj.digest('hex');&#125;console.log(md5(md5('123456')+'se32ssdfsd43')); OS 获取系统信息 123const os=require('os');console.log(os.cpus()); Path 123456789const path=require('path');let str='/var/local/www/aaa/1.png';//dirname//basename//extnameconsole.log(path.extname(str)); Events事件队列 和普通js函数的定义调用区别：解耦 12345678910111213141516171819const Event=require('events').EventEmitter;let ev=new Event();//1.监听(接收)ev.on('msg', function (a, b, c)&#123; console.log('收到了msg事件：', a, b, c);&#125;);//2.派发(发送)ev.emit('msg', 12, 5, 88);/*function msg(a, b, c)&#123; console.log('收到了msg事件：', a, b, c);&#125;msg(12, 5, 88);*/ Query Strings、URL 地址解析 querystring.js 12345const querystring=require('querystring');let obj=querystring.parse('ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=aa&amp;rsv_pq=f80d982000063ffb&amp;rsv_t=6498LAZdRZjq9v4v0hs88kZItnCjDpT6UNBKr%2FF83%2F%2Bg4eiPURW2eQl9Iwc&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug2=0&amp;inputT=10&amp;rsv_sug4=10');console.log(obj); url.js 12345const url=require('url');let obj=url.parse('https://www.baidu.com:8080/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=aa&amp;rsv_pq=f80d982000063ffb&amp;rsv_t=6498LAZdRZjq9v4v0hs88kZItnCjDpT6UNBKr%2FF83%2F%2Bg4eiPURW2eQl9Iwc&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug2=0&amp;inputT=10&amp;rsv_sug4=10',true);console.log(obj); 域名解析 DNS、Domain 123456789const dns=require('dns');dns.resolve('www.goole.com', (err, res)=&gt;&#123; if(err)&#123; console.log('解析失败'); &#125;else&#123; console.log(res); &#125;&#125;); 流操作——Stream 连续数据都是流——视频流、网络流、文件流、语音流 TLS/SSL 加密、安全 ZLIB——gz 压缩 NodeJS数据交互 设置响应头 get请求 数据放在url地址上，存放的数量小(32k) post请求 在body里面,存放的数据量大(1G),一个大数据包切成一堆小包传输,容错性强 安全性 一切来自前台的数据都不可信前后台都得进行数据校验 前台校验：提高用户体验 后台校验：提高安全性 数据库 关系型数据库——MySQL、Oracle 特点 最常见、最常用,数据之间是有关系的MySQL使用占比80%，免费，绝大多数普通应用，性能很高、安全性很高，容灾略差Oracle收费，应用在金融、医疗，容灾特别强 SQL 增 INSERT INTO 表 (字段列表) VALUES(值列表) 1INSERT INTO user_table (ID, name, gender, chinese, math, english) VALUES(0, 'blue', '男', 35, 18, 29); 删 DELETE FROM 表 WHERE 条件 12DELETE FROM user_table WHERE ID=3; 改 UPDATE 表 SET 字段=值, 字段2=值2, … WHERE 条件 1UPDATE user_table SET chinese=100 WHERE ID=2; 查 SELECT 字段列表 FROM 表 WHERE 条件 1SELECT name, gender FROM user_table WHERE ID=2; 文件型数据库——sqlite 使用简单、存储数据量小 文档型数据库——MongoDB 直接存储异构数据，使用方便 NoSQL 没有复杂的关系、对性能有极高的要求常见的有redis、memcached、hypertable、bigtable NodeJS进阶上 文件数据解析 表单的三种POST text/plain,用的很少，纯文字application/x-www-form-urlencoded,默认,以url编码方式,xxx=xxx&amp;xxx=xx...multipart/form-data上传文件内容 file上传，是post请求方式 普通纯文本表单文件上传 普通纯文本文件上传可以用字符串拼接接收，有弊端，如果是图片文件上传，用字符串接收会出现数据错乱 描述：可以看到纯文本文件上传请求了2个资源 浏览器 后台结果输出 包含了前台表单用户名、密码和纯文本文件的描述和内容 1234567891011121314151617/upload------WebKitFormBoundaryNIoabcKEXajTUMAIContent-Disposition: form-data; name=&quot;user&quot;shenlibing------WebKitFormBoundaryNIoabcKEXajTUMAIContent-Disposition: form-data; name=&quot;pass&quot;000000------WebKitFormBoundaryNIoabcKEXajTUMAIContent-Disposition: form-data; name=&quot;f1&quot;; filename=&quot;1.txt&quot;Content-Type: text/plainabc------WebKitFormBoundaryNIoabcKEXajTUMAI--/favicon.ico Buffer接收文件上传的原始二进制数据 1234/upload&lt;Buffer 2d 2d 2d 2d 2d 2d 57 65 62 4b 69 74 46 6f 72 6d 42 6f 75 6e 64 61 72 79 75 42 6d 6b 78 4a 65 51 6d 35 6b 4a 4f 68 59 65 0d 0a 43 6f 6e 74 65 6e 74 2d ... &gt;/favicon.ico&lt;Buffer &gt; Buffer数据进行查找、截取、切分 如果是非纯文本文件上传，用字符串接收会破坏数据的完整性，需要用Buffer接收二进制数据 Buffer数据查找 123let b=new Buffer('abccc-=-dddder-=-qwerqwer');console.log(b.indexOf('-=-')); Buffer数据截取 123let b=new Buffer('abccc-=-dddder-=-qwerqwer');console.log(b.slice(17).toString()); Buffer数据切分 Buffer本身不具有split方法 123456789101112131415161718192021let b=new Buffer('abccc-=-dddder-=-qwerqwer');Buffer.prototype.split=Buffer.prototype.split||function (b)&#123; let arr=[]; let cur=0; let n=0; while((n=this.indexOf(b, cur))!=-1)&#123; arr.push(this.slice(cur, n)); cur=n+b.length; &#125; arr.push(this.slice(cur)); return arr;&#125;;let arr=b.split('-=-');console.log(arr);console.log(arr.map(buffer=&gt;buffer.toString())); 解析数据 数据化简 先对纯文本文件上传用字符串拼接的结果进行分析化简版本一 1234567891011121314分隔符Content-Disposition: form-data; name=&quot;user&quot;shenlibing分隔符Content-Disposition: form-data; name=&quot;pass&quot;000000分隔符Content-Disposition: form-data; name=&quot;f1&quot;; filename=&quot;1.txt&quot;Content-Type: text/plainabc分隔符-- 化简版本二：每一行末尾会自动加上\r\n 1234567891011121314分隔符\r\nContent-Disposition: form-data; name=&quot;user&quot;\r\n\r\nshenlibing\r\n分隔符\r\nContent-Disposition: form-data; name=&quot;pass&quot;\r\n\r\n000000\r\n分隔符\r\nContent-Disposition: form-data; name=&quot;f1&quot;; filename=&quot;1.txt&quot;\r\nContent-Type: text/plain\r\n\r\nabc\r\n分隔符--\r\n 化简版本三 1234分隔符\r\n数据描述\r\n\r\n数据值\r\n分隔符\r\n数据描述\r\n\r\n数据值\r\n分隔符\r\n数据描述1\r\n数据描述2\r\n\r\n文件内容\r\n分隔符--\r\n 化简到版本三的时候，就可以开始解析数据了 用分隔符切开数据 1234567[ 空, \r\n数据描述\r\n\r\n数据值\r\n, \r\n数据描述\r\n\r\n数据值\r\n, \r\n数据描述1\r\n数据描述2\r\n\r\n&lt;文件内容&gt;\r\n, --\r\n] 丢弃头尾元素 12345[ \r\n数据描述\r\n\r\n数据值\r\n, \r\n数据描述\r\n\r\n数据值\r\n, \r\n数据描述1\r\n数据描述2\r\n\r\n&lt;文件内容&gt;\r\n,] 丢弃每一项的头尾\r\n 12345[ 数据描述\r\n\r\n数据值, 数据描述\r\n\r\n数据值, 数据描述1\r\n数据描述2\r\n\r\n&lt;文件内容&gt;,] 用第一次出现的\r\n\r\n切分 普通数据：[数据描述, 数据值] 文件数据：[数据描述1\r\n数据描述2, &lt;文件内容&gt;] 判断描述的里面有没有\r\n 有的话就是文件数据：[数据描述1\r\n数据描述2, &lt;文件内容&gt;]没有的话就是普通数据：[数据描述, 数据值] 分析数据描述 文件上传代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687const http=require('http');const common=require('./libs/common');const fs=require('fs');const uuid=require('uuid/v4');let server=http.createServer((req, res)=&gt;&#123; let arr=[]; req.on('data', data=&gt;&#123; arr.push(data); &#125;); req.on('end', ()=&gt;&#123; let data=Buffer.concat(arr); //data //解析二进制文件上传数据 let post=&#123;&#125;; let files=&#123;&#125;; if(req.headers['content-type'])&#123; let str=req.headers['content-type'].split('; ')[1]; if(str)&#123; let boundary='--'+str.split('=')[1]; //1.用"分隔符切分整个数据" let arr=data.split(boundary); //2.丢弃头尾两个数据 arr.shift(); arr.pop(); //3.丢弃掉每个数据头尾的"\r\n" arr=arr.map(buffer=&gt;buffer.slice(2,buffer.length-2)); //4.每个数据在第一个"\r\n\r\n"处切成两半 arr.forEach(buffer=&gt;&#123; let n=buffer.indexOf('\r\n\r\n'); let disposition=buffer.slice(0, n); let content=buffer.slice(n+4); disposition=disposition.toString(); if(disposition.indexOf('\r\n')==-1)&#123; //普通数据 //Content-Disposition: form-data; name="user" content=content.toString(); let name=disposition.split('; ')[1].split('=')[1]; name=name.substring(1, name.length-1); post[name]=content; &#125;else&#123; //文件数据 /*Content-Disposition: form-data; name="f1"; filename="a.txt"\r\n Content-Type: text/plain*/ let [line1, line2]=disposition.split('\r\n'); let [,name,filename]=line1.split('; '); let type=line2.split(': ')[1]; name=name.split('=')[1]; name=name.substring(1,name.length-1); filename=filename.split('=')[1]; filename=filename.substring(1,filename.length-1); let path=`upload/$&#123;uuid().replace(/\-/g, '')&#125;`; fs.writeFile(path, content, err=&gt;&#123; if(err)&#123; console.log('文件写入失败', err); &#125;else&#123; files[name]=&#123;filename, path, type&#125;; console.log(files); &#125; &#125;); &#125; &#125;); //5.完成 console.log(post); &#125; &#125; res.end(); &#125;);&#125;);server.listen(8080); 流操作 fs.readFile和fs.writeFile的弊端 描述：以上文件上传的一个瑕疵就是会等到所有数据都到达了才开始处理，然后通过fs.writeFile上传文件 12345http.createServer((req, res)=&gt;&#123; fs.readFile(`www$&#123;req.url&#125;`, (err, data)=&gt;&#123; res.write(data); &#125;);&#125;); fs.readFile先把所有数据全读到内存中，然后回调,这种方式极其占用内存且资源利用极其不充分，读取文件的过程中网络传输一直空闲，等到文件IO读取完毕，IO一直空闲，网络传输变得繁忙 解决：收到一部分就解析一部分，极大节约内存,使用流读取文件，读一点、发一点 分类 读取流fs.createReadStream写入流fs.createWriteStream 12345678910111213141516const http=require('http');const fs=require('fs');let server=http.createServer((req, res)=&gt;&#123; let rs=fs.createReadStream(`www$&#123;req.url&#125;`); rs.pipe(res); rs.on('error', err=&gt;&#123; res.writeHeader(404); res.write('Not Found'); res.end(); &#125;);&#125;);server.listen(8080); gz压缩 无gz压缩传输 没有通过gz压缩传输,请求资源1.html文件大小321B，jquery.js文件大小262KB 12345678910111213141516171819202122const http=require('http');const fs=require('fs');const zlib=require('zlib');let server=http.createServer((req, res)=&gt;&#123; let rs=fs.createReadStream(`www$&#123;req.url&#125;`); rs.pipe(res); /*res.setHeader('content-encoding', 'gzip'); let gz=zlib.createGzip(); rs.pipe(gz).pipe(res);*/ rs.on('error', err=&gt;&#123; res.writeHeader(404); res.write('Not Found'); res.end(); &#125;);&#125;);server.listen(8080); gz压缩传输 读写流,通过gz压缩传输,请求资源1.html文件大小292B，jquery.js文件大小77.8KB 创建读取流读取www${req.url}文件，通过gz压缩、加密该文件然后返回给浏览器，需要设置响应头res.setHeader(&#39;content-encoding&#39;, &#39;gzip&#39;),让浏览器识别该资源是通过gz压缩的文件 12345678910111213141516171819202122const http=require('http');const fs=require('fs');const zlib=require('zlib');let server=http.createServer((req, res)=&gt;&#123; let rs=fs.createReadStream(`www$&#123;req.url&#125;`); //rs.pipe(res); res.setHeader('content-encoding', 'gzip'); let gz=zlib.createGzip(); rs.pipe(gz).pipe(res); rs.on('error', err=&gt;&#123; res.writeHeader(404); res.write('Not Found'); res.end(); &#125;);&#125;);server.listen(8080); NodeJS进阶下 缓存 标记文件修改时间实现缓存 获得文件修改时间 123456789const fs=require('fs');fs.stat('./www/1.html', (err, stat)=&gt;&#123; if(err)&#123; console.log('获取文件信息失败'); &#125;else&#123; console.log(stat.mtime.toGMTString()); &#125;&#125;); 服务器设置响应头Last-Modified 标记文件最后一次修改时间 缓存实现过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const http=require('http');const fs=require('fs');const url=require('url');http.createServer((req, res)=&gt;&#123; let &#123;pathname&#125;=url.parse(req.url); //获取文件日期 fs.stat(`www$&#123;pathname&#125;`, (err, stat)=&gt;&#123; if(err)&#123; res.writeHeader(404); res.write('Not Found'); res.end(); &#125;else&#123; // console.log(req) if(req.headers['if-modified-since'])&#123; let oDate=new Date(req.headers['if-modified-since']); let time_client=Math.floor(oDate.getTime()/1000); let time_server=Math.floor(stat.mtime.getTime()/1000); if(time_server&gt;time_client)&#123; //服务器的文件时间&gt;客户端手里的版本 sendFileToClient(); &#125;else&#123; res.writeHeader(304); res.write('Not Modified'); res.end(); &#125; &#125;else&#123; sendFileToClient(); &#125; function sendFileToClient()&#123; //发送 let rs=fs.createReadStream(`www$&#123;pathname&#125;`); res.setHeader('Last-Modified', stat.mtime.toGMTString()); //输出 rs.pipe(res); rs.on('error', err=&gt;&#123; res.writeHeader(404); res.write('Not Found'); res.end(); &#125;); &#125; &#125; &#125;);&#125;).listen(8080); 第一次请求,响应状态码200,浏览器没有缓存 服务器响应头带了Last-Modified标记该资源文件最后一次修改时间 第二次请求,响应状态码304，浏览器有缓存 请求头带了if-modified-since标记该资源文件的最后一次修改时间,通过该标记去告诉服务器我本地有这个文件及这个文件最后一次修改时间，服务器收到请求通过if-modified-since标记的时间和服务器上该文件的时间进行比较，如果服务器的文件等于if-modified-since的时间，说明该资源文件没有被修改过，浏览器决定从不从缓存中取出 缓存策略 服务器设置响应头cache-control和expires 多进程 主进程负责派生子进程，子进程负责干活 特点 普通程序不能“创建”进程，只有系统进程才能创建进程；只有主进程能分裂进程是分裂出来分裂出来的两个进程执行的是同一套代码父子进程之间可以共享”句柄”(如：8080端口) 进程分裂实现 通过cluster.isMaster判断是否是主进程，如果是主进程则cluster.fork()分裂子进程 12345678910111213141516171819202122232425const http=require('http');const cluster=require('cluster');const os=require('os');const process=require('process');if(cluster.isMaster)&#123; for(let i=0;i&lt;os.cpus().length;i++)&#123; cluster.fork(); &#125; console.log('主进程');&#125;else&#123; console.log('子进程'); let server=http.createServer((req, res)=&gt;&#123; //进程id console.log('子进程id',process.pid); res.write('aaaa'); res.end(); &#125;); server.listen(8080); console.log('服务器开好了，在8080上');&#125; 123456789101112131415161718主进程子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程 26956 进程调度 主进程通过系统的CPU核数分裂了8个子进程，浏览器发起请求的时候只有一个子进程 26956干活 多个进程同时存在时，进程的调度原则是第一个进程满了才开启第二个进程，前面两个进程满了才开启第三个进程，这样做的原因是因为进程调度即进程切换是需要花费开销的 坑 主进程能否分裂100个进程，有必要么 可以分裂100个进程，但是没有必要，进程调度需要花费开销，况且进程的实际工作计算能力需要根据计算机本身硬件的限制 NodeJS使用MySQL 连接 一条连接 1let db=mysql.createConnection(&#123;host: 'localhost', user: 'root', password: '', port: 3309, database: '20180127'&#125;); 连接池获取连接 12//连接池let db=mysql.createPool(&#123;host: 'localhost', user: 'root', password: '', port: 3309, database: '20180127'&#125;); 查询 1234567891011const mysql=require('mysql');let db=mysql.createConnection(&#123;host: 'localhost', user: 'root', password: '', port: 3309, database: '20180127'&#125;);db.query(`INSERT INTO user_table (ID, name, gender, chinese, math, english) VALUES(0, '小明', '男', 98, 5, 3);`, (err, data)=&gt;&#123; if(err)&#123; console.log('错了', err); &#125;else&#123; console.log(data); &#125;&#125;); 用户登录注册 数据库结构(数据字典) 接口格式(接口文档) 123注册： /reg?user=xxx&amp;pass=xxx =&gt;&#123;err: 0, msg: &apos;原因&apos;&#125; 123登陆： /login?user=xxx&amp;pass=xxx =&gt;&#123;err: 0, msg: &apos;原因&apos;&#125; 代码实现 前台 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; $(function ()&#123; //注册 $('#btn_reg').click(function ()&#123; $.ajax(&#123; url: '/reg', data: &#123;user: $('#user').val(),pass: $('#pass').val()&#125;, dataType: 'json', success(json)&#123; if(json.err)&#123; alert('注册失败'+json.msg); &#125;else&#123; alert('注册成功'); &#125; &#125;, error(err)&#123; alert('失败'); &#125; &#125;); &#125;); //登陆 $('#btn_login').click(function ()&#123; $.ajax(&#123; url: '/login', data: &#123;user: $('#user').val(),pass: $('#pass').val()&#125;, dataType: 'json', success(json)&#123; if(json.err)&#123; alert('登陆失败'+json.msg); &#125;else&#123; alert('登陆成功'); &#125; &#125;, error(err)&#123; alert('失败'); &#125; &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 用户：&lt;input type="text" id="user" /&gt;&lt;br&gt; 密码：&lt;input type="password" id="pass" /&gt;&lt;br&gt; &lt;input type="button" value="注册" id="btn_reg"&gt; &lt;input type="button" value="登陆" id="btn_login"&gt; &lt;/body&gt;&lt;/html&gt; 后台 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119const http=require('http');const mysql=require('mysql');const fs=require('fs');const url=require('url');const zlib=require('zlib');const crypto=require('crypto');//盐值const _key='sadfslekrtuew5iutoselgdtjiypoydse4ufhs.edtyo;s8te4arfeliawkfhtsie5tlfia;sefdshroiupeoutwyeli5gurse;ihf';//MD5加密function md5(str)&#123; let obj=crypto.createHash('md5'); obj.update(str); return obj.digest('hex');&#125;//MD5盐值加密function md5_2(str)&#123; return md5(md5(str)+_key);&#125;//从连接池获取连接let db=mysql.createPool(&#123;host: 'localhost', port: 3306, user: 'root', password: '000000', database: 'mytest'&#125;);let server=http.createServer((req, res)=&gt;&#123; let &#123;pathname, query&#125;=url.parse(req.url, true); let &#123;user, pass&#125;=query; switch(pathname)&#123; //接口 case '/reg': //校验 if(!user)&#123; res.write('&#123;"err": 1, "msg": "username can\'t be null"&#125;'); res.end(); &#125;else if(!pass)&#123; res.write('&#123;"err": 1, "msg": "password can\'t be null"&#125;'); res.end(); &#125;else if(!/^\w&#123;4,16&#125;$/.test(user))&#123; res.write('&#123;"err": 1, "msg": "username is invaild"&#125;'); res.end(); &#125;else if(/['|"]/.test(pass))&#123; res.write('&#123;"err": 1, "msg": "password is invaild"&#125;'); res.end(); &#125;else&#123; db.query(`SELECT * FROM user_table WHERE username='$&#123;user&#125;'`, (err, data)=&gt;&#123; if(err)&#123; res.write('&#123;"err": 1, "msg": "database error"&#125;'); res.end(); &#125;else if(data.length&gt;0)&#123; res.write('&#123;"err": 1, "msg": "this username exsits"&#125;'); res.end(); &#125;else&#123; db.query(`INSERT INTO user_table (ID,username,password) VALUES(0,'$&#123;user&#125;','$&#123;md5_2(pass)&#125;')`, (err, data)=&gt;&#123; if(err)&#123; res.write('&#123;"err": 1, "msg": "database error"&#125;'); res.end(); &#125;else&#123; res.write('&#123;"err": 0, "msg": "success"&#125;'); res.end(); &#125; &#125;); &#125; &#125;); &#125; break; case '/login': //校验 if(!user)&#123; res.write('&#123;"err": 1, "msg": "username can\'t be null"&#125;'); res.end(); &#125;else if(!pass)&#123; res.write('&#123;"err": 1, "msg": "password can\'t be null"&#125;'); res.end(); &#125;else if(!/^\w&#123;4,16&#125;$/.test(user))&#123; res.write('&#123;"err": 1, "msg": "username is invaild"&#125;'); res.end(); &#125;else if(/['|"]/.test(pass))&#123; res.write('&#123;"err": 1, "msg": "password is invaild"&#125;'); res.end(); &#125;else&#123; db.query(`SELECT * FROM user_table WHERE username='$&#123;user&#125;'`, (err, data)=&gt;&#123; if(err)&#123; res.write('&#123;"err": 1, "msg": "database error"&#125;'); res.end(); &#125;else if(data.length==0)&#123; res.write('&#123;"err": 1, "msg": "no this user"&#125;'); res.end(); &#125;else if(data[0].password!=md5_2(pass))&#123; res.write('&#123;"err": 1, "msg": "username or password is incorrect"&#125;'); res.end(); &#125;else&#123; res.write('&#123;"err": 0, "msg": "success"&#125;'); res.end(); &#125; &#125;); &#125; break; default: //缓存 TODO //静态文件 let rs=fs.createReadStream(`www$&#123;pathname&#125;`); let gz=zlib.createGzip(); res.setHeader('content-encoding', 'gzip'); rs.pipe(gz).pipe(res); rs.on('error', err=&gt;&#123; res.writeHeader(404); res.write('Not Found'); res.end(); &#125;); &#125;&#125;);server.listen(8080);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0开始独立完成企业级Java电商网站开发（服务端）]]></title>
    <url>%2Fmyhexo%2F2019%2F03%2F13%2F%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%8B%AC%E7%AB%8B%E5%AE%8C%E6%88%90%E4%BC%81%E4%B8%9A%E7%BA%A7Java%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据表结构设计唯一索引unique，保证数据唯一性1234567891011121314CREATE TABLE `mmall_user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户表id', `username` varchar(50) NOT NULL COMMENT '用户名', `password` varchar(50) NOT NULL COMMENT '用户密码，MD5加密', `email` varchar(50) DEFAULT NULL, `phone` varchar(20) DEFAULT NULL, `question` varchar(100) DEFAULT NULL COMMENT '找回密码问题', `answer` varchar(100) DEFAULT NULL COMMENT '找回密码答案', `role` int(4) NOT NULL COMMENT '角色0-管理员,1-普通用户', `create_time` datetime NOT NULL COMMENT '创建时间', `update_time` datetime NOT NULL COMMENT '最后一次更新时间', PRIMARY KEY (`id`), UNIQUE KEY `user_name_unique` (`username`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8; 单索引及组合索引12345678910111213141516CREATE TABLE `mmall_order_item` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '订单子表id', `user_id` int(11) DEFAULT NULL, `order_no` bigint(20) DEFAULT NULL, `product_id` int(11) DEFAULT NULL COMMENT '商品id', `product_name` varchar(100) DEFAULT NULL COMMENT '商品名称', `product_image` varchar(500) DEFAULT NULL COMMENT '商品图片地址', `current_unit_price` decimal(20,2) DEFAULT NULL COMMENT '生成订单时的商品单价，单位是元,保留两位小数', `quantity` int(10) DEFAULT NULL COMMENT '商品数量', `total_price` decimal(20,2) DEFAULT NULL COMMENT '商品总价,单位是元,保留两位小数', `create_time` datetime DEFAULT NULL, `update_time` datetime DEFAULT NULL, PRIMARY KEY (`id`), KEY `order_no_index` (`order_no`) USING BTREE, KEY `order_no_user_id_index` (`user_id`,`order_no`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=135 DEFAULT CHARSET=utf8; 查业务问题的后悔药create_time 数据创建时间update_time 数据更新时间 mybatis三剑客mybatis-generator自动化生成数据库交互代码配置pom.xml 12345678910111213&lt;build&gt; &lt;finalName&gt;mmall&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/build&gt; datasource.properties 12345678910111213141516db.driverLocation=/Users/imooc/mysql-connector-java-5.1.6-bin.jardb.driverClassName=com.mysql.jdbc.Driver#db.url=jdbc:mysql://192.1.1.1:3306/mmall?characterEncoding=utf-8db.url=jdbc:mysql://你的数据库IP:你的数据库Port/你的database?characterEncoding=utf-8db.username=mmalldb.password=dbpassworddb.initialSize = 20db.maxActive = 50db.maxIdle = 20db.minIdle = 10db.maxWait = 10db.defaultAutoCommit = truedb.minEvictableIdleTimeMillis = 3600000 generatorConfig.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!--导入属性配置--&gt; &lt;properties resource="datasource.properties"&gt;&lt;/properties&gt; &lt;!--指定特定数据库的jdbc驱动jar包的位置--&gt; &lt;classPathEntry location="$&#123;db.driverLocation&#125;"/&gt; &lt;context id="default" targetRuntime="MyBatis3"&gt; &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--jdbc的数据库连接 --&gt; &lt;jdbcConnection driverClass="$&#123;db.driverClassName&#125;" connectionURL="$&#123;db.url&#125;" userId="$&#123;db.username&#125;" password="$&#123;db.password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类 targetPackage 指定生成的model生成所在的包名 targetProject 指定在该项目下所在的路径 --&gt; &lt;!--&lt;javaModelGenerator targetPackage="com.mmall.pojo" targetProject=".\src\main\java"&gt;--&gt; &lt;javaModelGenerator targetPackage="com.mmall.pojo" targetProject="./src/main/java"&gt; &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;!-- 是否对model添加 构造函数 --&gt; &lt;property name="constructorBased" value="true"/&gt; &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;!-- 建立的Model对象是否 不可改变 即生成的Model对象不会有 setter方法，只有构造方法 --&gt; &lt;property name="immutable" value="false"/&gt; &lt;/javaModelGenerator&gt; &lt;!--mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt; &lt;!--&lt;sqlMapGenerator targetPackage="mappers" targetProject=".\src\main\resources"&gt;--&gt; &lt;sqlMapGenerator targetPackage="mappers" targetProject="./src/main/resources"&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码 type="ANNOTATEDMAPPER",生成Java Model 和基于注解的Mapper对象 type="MIXEDMAPPER",生成基于注解的Java Model 和相应的Mapper对象 type="XMLMAPPER",生成SQLMap XML文件和独立的Mapper接口 --&gt; &lt;!-- targetPackage：mapper接口dao生成的位置 --&gt; &lt;!--&lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.mmall.dao" targetProject=".\src\main\java"&gt;--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.mmall.dao" targetProject="./src/main/java"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/javaClientGenerator&gt; &lt;table tableName="mmall_shipping" domainObjectName="Shipping" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_cart" domainObjectName="Cart" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_cart_item" domainObjectName="CartItem" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_category" domainObjectName="Category" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_order" domainObjectName="Order" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_order_item" domainObjectName="OrderItem" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_pay_info" domainObjectName="PayInfo" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_product" domainObjectName="Product" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt; &lt;columnOverride column="detail" jdbcType="VARCHAR" /&gt; &lt;columnOverride column="sub_images" jdbcType="VARCHAR" /&gt; &lt;/table&gt; &lt;table tableName="mmall_user" domainObjectName="User" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;!-- geelynote mybatis插件的搭建 --&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 运行 mybatis-plugin idea插件，实现mybatis的接口文件和xml自动跳转下载 mybatis-pagehelper mybatis分页组件配置pom.xml 12345678910111213141516171819&lt;!-- mybatis pager --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.miemiedev&lt;/groupId&gt; &lt;artifactId&gt;mybatis-paginator&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.4&lt;/version&gt; &lt;/dependency&gt; Tomcat加载spring、springmvc方式一：配置web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 启动我们自己的listener --&gt; &lt;listener&gt; &lt;listener-class&gt;com.atguigu.scw.manager.listener.MyAppListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 启动spring容器 --&gt; &lt;!-- needed for ContextLoaderListener --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Bootstraps the root web application context before servlet initialization --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- The front controller of this Spring Web application, responsible for handling all application requests --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- Map all requests to the DispatcherServlet for handling --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 加上字符编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 只是指定了编码格式 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 进行请求乱码解决 --&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 方式二：配置web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 测试插件FeHelper Restlet Client 用户模块横向越权入参需要指定当前用户id 纵向越权MD5明文加密盐值加密 MD5Util.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.mmall.util;import org.springframework.util.StringUtils;import java.security.MessageDigest;/** * Created by geely */public class MD5Util &#123; private static String byteArrayToHexString(byte b[]) &#123; StringBuffer resultSb = new StringBuffer(); for (int i = 0; i &lt; b.length; i++) resultSb.append(byteToHexString(b[i])); return resultSb.toString(); &#125; private static String byteToHexString(byte b) &#123; int n = b; if (n &lt; 0) n += 256; int d1 = n / 16; int d2 = n % 16; return hexDigits[d1] + hexDigits[d2]; &#125; /** * 返回大写MD5 * * @param origin * @param charsetname * @return */ private static String MD5Encode(String origin, String charsetname) &#123; String resultString = null; try &#123; resultString = new String(origin); MessageDigest md = MessageDigest.getInstance("MD5"); if (charsetname == null || "".equals(charsetname)) resultString = byteArrayToHexString(md.digest(resultString.getBytes())); else resultString = byteArrayToHexString(md.digest(resultString.getBytes(charsetname))); &#125; catch (Exception exception) &#123; &#125; return resultString.toUpperCase(); &#125; public static String MD5EncodeUtf8(String origin) &#123; origin = origin + PropertiesUtil.getProperty("password.salt", ""); return MD5Encode(origin, "utf-8"); &#125; private static final String hexDigits[] = &#123;"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"&#125;;&#125; PropertiesUtil.java 读取src/main/resources目录下的配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.mmall.util;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.io.InputStreamReader;import java.util.Properties;/** * Created by geely */public class PropertiesUtil &#123; private static Logger logger = LoggerFactory.getLogger(PropertiesUtil.class); private static Properties props; static &#123; String fileName = "mmall.properties"; props = new Properties(); try &#123; props.load(new InputStreamReader(PropertiesUtil.class.getClassLoader().getResourceAsStream(fileName),"UTF-8")); &#125; catch (IOException e) &#123; logger.error("配置文件读取异常",e); &#125; &#125; public static String getProperty(String key)&#123; String value = props.getProperty(key.trim()); if(StringUtils.isBlank(value))&#123; return null; &#125; return value.trim(); &#125; public static String getProperty(String key,String defaultValue)&#123; String value = props.getProperty(key.trim()); if(StringUtils.isBlank(value))&#123; value = defaultValue; &#125; return value.trim(); &#125;&#125; mmall.properties 123456789ftp.server.ip=你的FTP服务器ip地址ftp.user=mmallftpftp.pass=ftppasswordftp.server.http.prefix=http://img.happymmall.com/alipay.callback.url=http://www.happymmall.com/order/alipay_callback.dopassword.salt = geelysdafaqj23ou89ZXcj@#$@#$#@KJdjklj;D../dSF., 应用：明文加密 guava缓存设置token并传给前台用户 验证token TokenCache.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.mmall.common;import com.google.common.cache.CacheBuilder;import com.google.common.cache.CacheLoader;import com.google.common.cache.LoadingCache;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.concurrent.TimeUnit;/** * Created by geely */public class TokenCache &#123; private static Logger logger = LoggerFactory.getLogger(TokenCache.class); public static final String TOKEN_PREFIX = "token_"; //LRU算法 private static LoadingCache&lt;String,String&gt; localCache = CacheBuilder.newBuilder().initialCapacity(1000).maximumSize(10000).expireAfterAccess(12, TimeUnit.HOURS) .build(new CacheLoader&lt;String, String&gt;() &#123; //默认的数据加载实现,当调用get取值的时候,如果key没有对应的值,就调用这个方法进行加载. @Override public String load(String s) throws Exception &#123; return "null"; &#125; &#125;); public static void setKey(String key,String value)&#123; localCache.put(key,value); &#125; public static String getKey(String key)&#123; String value = null; try &#123; value = localCache.get(key); if("null".equals(value))&#123; return null; &#125; return value; &#125;catch (Exception e)&#123; logger.error("localCache get error",e); &#125; return null; &#125;&#125; UserServiceImpl.java 12345678910111213141516171819202122232425262728293031323334353637383940public ServerResponse&lt;String&gt; checkAnswer(String username,String question,String answer)&#123; int resultCount = userMapper.checkAnswer(username,question,answer); if(resultCount&gt;0)&#123; //说明问题及问题答案是这个用户的,并且是正确的 String forgetToken = UUID.randomUUID().toString(); TokenCache.setKey(TokenCache.TOKEN_PREFIX+username,forgetToken); return ServerResponse.createBySuccess(forgetToken); &#125; return ServerResponse.createByErrorMessage("问题的答案错误"); &#125; public ServerResponse&lt;String&gt; forgetResetPassword(String username,String passwordNew,String forgetToken)&#123; if(org.apache.commons.lang3.StringUtils.isBlank(forgetToken))&#123; return ServerResponse.createByErrorMessage("参数错误,token需要传递"); &#125; ServerResponse validResponse = this.checkValid(username,Const.USERNAME); if(validResponse.isSuccess())&#123; //用户不存在 return ServerResponse.createByErrorMessage("用户不存在"); &#125; String token = TokenCache.getKey(TokenCache.TOKEN_PREFIX+username); if(org.apache.commons.lang3.StringUtils.isBlank(token))&#123; return ServerResponse.createByErrorMessage("token无效或者过期"); &#125; if(org.apache.commons.lang3.StringUtils.equals(forgetToken,token))&#123; String md5Password = MD5Util.MD5EncodeUtf8(passwordNew); int rowCount = userMapper.updatePasswordByUsername(username,md5Password); if(rowCount &gt; 0)&#123; return ServerResponse.createBySuccessMessage("修改密码成功"); &#125; &#125;else&#123; return ServerResponse.createByErrorMessage("token错误,请重新获取重置密码的token"); &#125; return ServerResponse.createByErrorMessage("修改密码失败"); &#125; 高复用服务响应对象的设计思想和封装ServerResponse.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.mmall.common;import org.codehaus.jackson.annotate.JsonIgnore;import org.codehaus.jackson.map.annotate.JsonSerialize;import java.io.Serializable;/** * Created by geely */@JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL)//保证序列化json的时候,如果是null的对象,key也会消失public class ServerResponse&lt;T&gt; implements Serializable &#123; private int status; private String msg; private T data; private ServerResponse(int status)&#123; this.status = status; &#125; private ServerResponse(int status,T data)&#123; this.status = status; this.data = data; &#125; private ServerResponse(int status,String msg,T data)&#123; this.status = status; this.msg = msg; this.data = data; &#125; private ServerResponse(int status,String msg)&#123; this.status = status; this.msg = msg; &#125; @JsonIgnore //使之不在json序列化结果当中 public boolean isSuccess()&#123; return this.status == ResponseCode.SUCCESS.getCode(); &#125; public int getStatus()&#123; return status; &#125; public T getData()&#123; return data; &#125; public String getMsg()&#123; return msg; &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess()&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode()); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccessMessage(String msg)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),msg); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess(T data)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),data); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess(String msg,T data)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),msg,data); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByError()&#123; return new ServerResponse&lt;T&gt;(ResponseCode.ERROR.getCode(),ResponseCode.ERROR.getDesc()); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByErrorMessage(String errorMessage)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.ERROR.getCode(),errorMessage); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByErrorCodeMessage(int errorCode,String errorMessage)&#123; return new ServerResponse&lt;T&gt;(errorCode,errorMessage); &#125;&#125; ResponseCode.java 1234567891011121314151617181920212223242526272829package com.mmall.common;/** * Created by geely */public enum ResponseCode &#123; SUCCESS(0,"SUCCESS"), ERROR(1,"ERROR"), NEED_LOGIN(10,"NEED_LOGIN"), ILLEGAL_ARGUMENT(2,"ILLEGAL_ARGUMENT"); private final int code; private final String desc; ResponseCode(int code,String desc)&#123; this.code = code; this.desc = desc; &#125; public int getCode()&#123; return code; &#125; public String getDesc()&#123; return desc; &#125;&#125; 分类模块递归算法12345678910111213141516171819202122232425262728293031323334/** * 递归查询本节点的id及孩子节点的id * @param categoryId * @return */public ServerResponse&lt;List&lt;Integer&gt;&gt; selectCategoryAndChildrenById(Integer categoryId)&#123; Set&lt;Category&gt; categorySet = Sets.newHashSet(); findChildCategory(categorySet,categoryId); List&lt;Integer&gt; categoryIdList = Lists.newArrayList(); if(categoryId != null)&#123; for(Category categoryItem : categorySet)&#123; categoryIdList.add(categoryItem.getId()); &#125; &#125; return ServerResponse.createBySuccess(categoryIdList);&#125;//递归算法,算出子节点private Set&lt;Category&gt; findChildCategory(Set&lt;Category&gt; categorySet ,Integer categoryId)&#123; Category category = categoryMapper.selectByPrimaryKey(categoryId); if(category != null)&#123; categorySet.add(category); &#125; //查找子节点,递归算法一定要有一个退出的条件 List&lt;Category&gt; categoryList = categoryMapper.selectCategoryChildrenByParentId(categoryId); for(Category categoryItem : categoryList)&#123; findChildCategory(categorySet,categoryItem.getId()); &#125; return categorySet;&#125; 复杂对象排重Set集合 重写自定义对象Category的equals和hashCode方法 无限层级树结构设计 商品模块POJO、BO、VO抽象模型 Product.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package com.mmall.pojo;import java.math.BigDecimal;import java.util.Date;public class Product &#123; private Integer id; private Integer categoryId; private String name; private String subtitle; private String mainImage; private String subImages; private String detail; private BigDecimal price; private Integer stock; private Integer status; private Date createTime; private Date updateTime; public Product(Integer id, Integer categoryId, String name, String subtitle, String mainImage, String subImages, String detail, BigDecimal price, Integer stock, Integer status, Date createTime, Date updateTime) &#123; this.id = id; this.categoryId = categoryId; this.name = name; this.subtitle = subtitle; this.mainImage = mainImage; this.subImages = subImages; this.detail = detail; this.price = price; this.stock = stock; this.status = status; this.createTime = createTime; this.updateTime = updateTime; &#125; public Product() &#123; super(); &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getCategoryId() &#123; return categoryId; &#125; public void setCategoryId(Integer categoryId) &#123; this.categoryId = categoryId; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name == null ? null : name.trim(); &#125; public String getSubtitle() &#123; return subtitle; &#125; public void setSubtitle(String subtitle) &#123; this.subtitle = subtitle == null ? null : subtitle.trim(); &#125; public String getMainImage() &#123; return mainImage; &#125; public void setMainImage(String mainImage) &#123; this.mainImage = mainImage == null ? null : mainImage.trim(); &#125; public String getSubImages() &#123; return subImages; &#125; public void setSubImages(String subImages) &#123; this.subImages = subImages == null ? null : subImages.trim(); &#125; public String getDetail() &#123; return detail; &#125; public void setDetail(String detail) &#123; this.detail = detail == null ? null : detail.trim(); &#125; public BigDecimal getPrice() &#123; return price; &#125; public void setPrice(BigDecimal price) &#123; this.price = price; &#125; public Integer getStock() &#123; return stock; &#125; public void setStock(Integer stock) &#123; this.stock = stock; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; public Date getCreateTime() &#123; return createTime; &#125; public void setCreateTime(Date createTime) &#123; this.createTime = createTime; &#125; public Date getUpdateTime() &#123; return updateTime; &#125; public void setUpdateTime(Date updateTime) &#123; this.updateTime = updateTime; &#125;&#125; ProductDetailVo.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package com.mmall.vo;import java.math.BigDecimal;/** * Created by geely */public class ProductDetailVo &#123; private Integer id; private Integer categoryId; private String name; private String subtitle; private String mainImage; private String subImages; private String detail; private BigDecimal price; private Integer stock; private Integer status; private String createTime; private String updateTime; private String imageHost; private Integer parentCategoryId; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getCategoryId() &#123; return categoryId; &#125; public void setCategoryId(Integer categoryId) &#123; this.categoryId = categoryId; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSubtitle() &#123; return subtitle; &#125; public void setSubtitle(String subtitle) &#123; this.subtitle = subtitle; &#125; public String getMainImage() &#123; return mainImage; &#125; public void setMainImage(String mainImage) &#123; this.mainImage = mainImage; &#125; public String getSubImages() &#123; return subImages; &#125; public void setSubImages(String subImages) &#123; this.subImages = subImages; &#125; public String getDetail() &#123; return detail; &#125; public void setDetail(String detail) &#123; this.detail = detail; &#125; public BigDecimal getPrice() &#123; return price; &#125; public void setPrice(BigDecimal price) &#123; this.price = price; &#125; public Integer getStock() &#123; return stock; &#125; public void setStock(Integer stock) &#123; this.stock = stock; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; public String getCreateTime() &#123; return createTime; &#125; public void setCreateTime(String createTime) &#123; this.createTime = createTime; &#125; public String getUpdateTime() &#123; return updateTime; &#125; public void setUpdateTime(String updateTime) &#123; this.updateTime = updateTime; &#125; public String getImageHost() &#123; return imageHost; &#125; public void setImageHost(String imageHost) &#123; this.imageHost = imageHost; &#125; public Integer getParentCategoryId() &#123; return parentCategoryId; &#125; public void setParentCategoryId(Integer parentCategoryId) &#123; this.parentCategoryId = parentCategoryId; &#125;&#125; 静态代码块&gt;普通代码块&gt;构造代码块Tomcat启动加载静态代码块 时间转换工具类DateTimeUtil.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.mmall.util;import org.apache.commons.lang3.StringUtils;import org.joda.time.DateTime;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;import java.util.Date;/** * Created by geely */public class DateTimeUtil &#123; //joda-time //str-&gt;Date //Date-&gt;str public static final String STANDARD_FORMAT = "yyyy-MM-dd HH:mm:ss"; public static Date strToDate(String dateTimeStr,String formatStr)&#123; DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(formatStr); DateTime dateTime = dateTimeFormatter.parseDateTime(dateTimeStr); return dateTime.toDate(); &#125; public static String dateToStr(Date date,String formatStr)&#123; if(date == null)&#123; return StringUtils.EMPTY; &#125; DateTime dateTime = new DateTime(date); return dateTime.toString(formatStr); &#125; public static Date strToDate(String dateTimeStr)&#123; DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(STANDARD_FORMAT); DateTime dateTime = dateTimeFormatter.parseDateTime(dateTimeStr); return dateTime.toDate(); &#125; public static String dateToStr(Date date)&#123; if(date == null)&#123; return StringUtils.EMPTY; &#125; DateTime dateTime = new DateTime(date); return dateTime.toString(STANDARD_FORMAT); &#125; public static void main(String[] args) &#123; System.out.println(DateTimeUtil.dateToStr(new Date(),"yyyy-MM-dd HH:mm:ss")); System.out.println(DateTimeUtil.strToDate("2010-01-01 11:11:11","yyyy-MM-dd HH:mm:ss")); &#125;&#125; mybatis-pagehelper高效分页配置pom.xml 实现 mybatis-pagehelper动态排序 mybatis对List遍历的实现方法 mybatis对where语句动态拼装 FTP服务对接先将文件上传到本地======&gt;上传到远程ftp====&gt;删除本地文件 配置pom.xml 12345678910111213&lt;!-- file upload --&gt; &lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; 配置dispatcher-servlet.xml 123456&lt;!-- 文件上传 --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="10485760"/&gt; &lt;!-- 10m --&gt; &lt;property name="maxInMemorySize" value="4096" /&gt; &lt;property name="defaultEncoding" value="UTF-8"&gt;&lt;/property&gt;&lt;/bean&gt; FileServiceImpl.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.mmall.service.impl;import com.google.common.collect.Lists;import com.mmall.service.IFileService;import com.mmall.util.FTPUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Service;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;import java.util.UUID;/** * Created by geely */@Service("iFileService")public class FileServiceImpl implements IFileService &#123; private Logger logger = LoggerFactory.getLogger(FileServiceImpl.class); public String upload(MultipartFile file,String path)&#123; String fileName = file.getOriginalFilename(); //扩展名 //abc.jpg String fileExtensionName = fileName.substring(fileName.lastIndexOf(".")+1); String uploadFileName = UUID.randomUUID().toString()+"."+fileExtensionName; logger.info("开始上传文件,上传文件的文件名:&#123;&#125;,上传的路径:&#123;&#125;,新文件名:&#123;&#125;",fileName,path,uploadFileName); File fileDir = new File(path); if(!fileDir.exists())&#123; fileDir.setWritable(true); fileDir.mkdirs(); &#125; File targetFile = new File(path,uploadFileName); try &#123; file.transferTo(targetFile); //文件已经上传成功了 FTPUtil.uploadFile(Lists.newArrayList(targetFile)); //已经上传到ftp服务器上 targetFile.delete(); &#125; catch (IOException e) &#123; logger.error("上传文件异常",e); return null; &#125; //A:abc.jpg //B:abc.jpg return targetFile.getName(); &#125;&#125; 连接远程ftp，上传文件 FTPUtil.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.mmall.util;import org.apache.commons.net.ftp.FTPClient;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.util.List;/** * Created by geely */public class FTPUtil &#123; private static final Logger logger = LoggerFactory.getLogger(FTPUtil.class); private static String ftpIp = PropertiesUtil.getProperty("ftp.server.ip"); private static String ftpUser = PropertiesUtil.getProperty("ftp.user"); private static String ftpPass = PropertiesUtil.getProperty("ftp.pass"); public FTPUtil(String ip,int port,String user,String pwd)&#123; this.ip = ip; this.port = port; this.user = user; this.pwd = pwd; &#125; public static boolean uploadFile(List&lt;File&gt; fileList) throws IOException &#123; FTPUtil ftpUtil = new FTPUtil(ftpIp,21,ftpUser,ftpPass); logger.info("开始连接ftp服务器"); boolean result = ftpUtil.uploadFile("img",fileList); logger.info("开始连接ftp服务器,结束上传,上传结果:&#123;&#125;"); return result; &#125; private boolean uploadFile(String remotePath,List&lt;File&gt; fileList) throws IOException &#123; boolean uploaded = true; FileInputStream fis = null; //连接FTP服务器 if(connectServer(this.ip,this.port,this.user,this.pwd))&#123; try &#123; ftpClient.changeWorkingDirectory(remotePath); ftpClient.setBufferSize(1024); ftpClient.setControlEncoding("UTF-8"); ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); ftpClient.enterLocalPassiveMode(); for(File fileItem : fileList)&#123; fis = new FileInputStream(fileItem); ftpClient.storeFile(fileItem.getName(),fis); &#125; &#125; catch (IOException e) &#123; logger.error("上传文件异常",e); uploaded = false; e.printStackTrace(); &#125; finally &#123; fis.close(); ftpClient.disconnect(); &#125; &#125; return uploaded; &#125; private boolean connectServer(String ip,int port,String user,String pwd)&#123; boolean isSuccess = false; ftpClient = new FTPClient(); try &#123; ftpClient.connect(ip); isSuccess = ftpClient.login(user,pwd); &#125; catch (IOException e) &#123; logger.error("连接FTP服务器异常",e); &#125; return isSuccess; &#125; private String ip; private int port; private String user; private String pwd; private FTPClient ftpClient; public String getIp() &#123; return ip; &#125; public void setIp(String ip) &#123; this.ip = ip; &#125; public int getPort() &#123; return port; &#125; public void setPort(int port) &#123; this.port = port; &#125; public String getUser() &#123; return user; &#125; public void setUser(String user) &#123; this.user = user; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; public FTPClient getFtpClient() &#123; return ftpClient; &#125; public void setFtpClient(FTPClient ftpClient) &#123; this.ftpClient = ftpClient; &#125;&#125; 富文本上传和ftp文件上传类似，只是对返回值有特殊要求 购物车模块商品总价计算复用封装123456789101112131415161718192021222324252627282930313233343536373839404142package com.mmall.util;import java.math.BigDecimal;/** * Created by geely */public class BigDecimalUtil &#123; private BigDecimalUtil()&#123; &#125; public static BigDecimal add(double v1,double v2)&#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.add(b2); &#125; public static BigDecimal sub(double v1,double v2)&#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.subtract(b2); &#125; public static BigDecimal mul(double v1,double v2)&#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.multiply(b2); &#125; public static BigDecimal div(double v1,double v2)&#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.divide(b2,2,BigDecimal.ROUND_HALF_UP);//四舍五入,保留2位小数 //除不尽的情况 &#125;&#125; 高复用的逻辑方法封装思想 解决商业运算丢失精度的坑一定要用BigDecimal的String构造函数 123456789101112131415161718192021222324252627public class BigDecimalTest &#123; @Test public void test1()&#123; System.out.println(0.05+0.01); System.out.println(1.0-0.42); System.out.println(4.015*100); System.out.println(123.3/100); &#125; @Test public void test2()&#123; BigDecimal b1 = new BigDecimal(0.05); BigDecimal b2 = new BigDecimal(0.01); System.out.println(b1.add(b2)); &#125; @Test public void test3()&#123; BigDecimal b1 = new BigDecimal("0.05"); BigDecimal b2 = new BigDecimal("0.01"); System.out.println(b1.add(b2)); &#125;&#125; 订单模块安全漏洞解决方案订单号生成规则 强大的常量、枚举设计Const.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package com.mmall.common;import com.google.common.collect.Sets;import java.util.Set;/** * Created by geely */public class Const &#123; public static final String CURRENT_USER = "currentUser"; public static final String EMAIL = "email"; public static final String USERNAME = "username"; public interface ProductListOrderBy&#123; Set&lt;String&gt; PRICE_ASC_DESC = Sets.newHashSet("price_desc","price_asc"); &#125; public interface Cart&#123; int CHECKED = 1;//即购物车选中状态 int UN_CHECKED = 0;//购物车中未选中状态 String LIMIT_NUM_FAIL = "LIMIT_NUM_FAIL"; String LIMIT_NUM_SUCCESS = "LIMIT_NUM_SUCCESS"; &#125; public interface Role&#123; int ROLE_CUSTOMER = 0; //普通用户 int ROLE_ADMIN = 1;//管理员 &#125; public enum ProductStatusEnum&#123; ON_SALE(1,"在线"); private String value; private int code; ProductStatusEnum(int code,String value)&#123; this.code = code; this.value = value; &#125; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; &#125; public enum OrderStatusEnum&#123; CANCELED(0,"已取消"), NO_PAY(10,"未支付"), PAID(20,"已付款"), SHIPPED(40,"已发货"), ORDER_SUCCESS(50,"订单完成"), ORDER_CLOSE(60,"订单关闭"); OrderStatusEnum(int code,String value)&#123; this.code = code; this.value = value; &#125; private String value; private int code; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; public static OrderStatusEnum codeOf(int code)&#123; for(OrderStatusEnum orderStatusEnum : values())&#123; if(orderStatusEnum.getCode() == code)&#123; return orderStatusEnum; &#125; &#125; throw new RuntimeException("么有找到对应的枚举"); &#125; &#125; public interface AlipayCallback&#123; String TRADE_STATUS_WAIT_BUYER_PAY = "WAIT_BUYER_PAY"; String TRADE_STATUS_TRADE_SUCCESS = "TRADE_SUCCESS"; String RESPONSE_SUCCESS = "success"; String RESPONSE_FAILED = "failed"; &#125; public enum PayPlatformEnum&#123; ALIPAY(1,"支付宝"); PayPlatformEnum(int code,String value)&#123; this.code = code; this.value = value; &#125; private String value; private int code; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; &#125; public enum PaymentTypeEnum&#123; ONLINE_PAY(1,"在线支付"); PaymentTypeEnum(int code,String value)&#123; this.code = code; this.value = value; &#125; private String value; private int code; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; public static PaymentTypeEnum codeOf(int code)&#123; for(PaymentTypeEnum paymentTypeEnum : values())&#123; if(paymentTypeEnum.getCode() == code)&#123; return paymentTypeEnum; &#125; &#125; throw new RuntimeException("么有找到对应的枚举"); &#125; &#125;&#125; 使用 mybatis批量插入 收货地址同步获取自增主键 数据绑定的对象绑定 收货地址对象必须要有get和set方法 越权问题升级巩固支付模块支付宝SDK源码解析当面付 当面付Demo 服务端SDK下载和使用教程 沙箱环境使用 生成RSA密钥 支付宝支付流程与集成导入依赖 配置maven插件,除了pom.xml配置的依赖，lib包中的依赖也会一起打包部署 配置沙箱环境zfbinfo.properties 1234567891011121314151617181920212223242526272829303132333435# 支付宝网关名、partnerId和appIdopen_api_domain = https://openapi.alipaydev.com/gateway.domcloud_api_domain = http://mcloudmonitor.com/gateway.dopid = 2088102180444972appid = 2016102100728313# RSA私钥、公钥和支付宝公钥private_key = MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCKQ2pEIzXM4IoN1cMzOFXdlk8yVX2cKXWITZ92EGAQQcRytaV07yQOaz3UE9KTeT9Nu628G+HZMsJUxQjEUETagmY5nLtbeL35M2UcibYpM3e2gVTtUW86CA65GCdLzUhdIug8yf2F9zWayzG4sHZ9DcTezG6ZjFu+EtDpFgg+CtqY7n/ihjTIqeE1lX0C2ZIKpIYs7QjR8AztB/qRcpOJKRfMKGDgmT9GALN8LeFEYCbQ+W/GJHN8bQ0Bk1Ll6EKQ4cHXZ1Yko+aXaRfbXfUZYgD9hwAVlxtwZndgeFX8KapOCw0J25pzV4WkutIjMlt7I2Q1jaWNoKLuxtz4M2mzAgMBAAECggEAAhnsL4TpeGehMXyiLtEYXPm/0mACPLFUm/GyDrVJAHY/ag7gqNpJjf6LPgHfHWamU6Qai9VQpWBkG62y6Gjf4wJAU3fSUR2QpYzmaHyfTBkAJMHqbIDkU9lzf9SiJEDGbMPvC512QOb05ZlY9Bmac2QWLdylgafkbQsUKbawAWFa/BAOMIp0tgYLW8/yY2aG6jeLqhOgTo8MWIW5d1qHtX5m/x7g97dYYMdX3kTo2i1dFLUVfEOvZe4US6VBvLg71dMxwadVF5YMaY9jq/ShPD0Gkf29wdThwsjcH6u9Tq/KArQTK+z02DAGkdWOcue3pHql+gvoIA8U5uFDdIeYwQKBgQDri3jPkDKi48efdKQk38rn+CJYeNFNRAhlly3h2AHaFEY92XRlBsho/vGFg43BvHu+cMz0Run4SS8Vo09vcTIY6p2xNMffjR0w2gQqx6PUdGHBFtw7FavxN4uVtVhL6uTAqfBv97mqQO0bq+DhOGwSRNIWqvnzfXywqwmXhKYECwKBgQCWRTl6tNv8scxPq4fpRL/uw71TU6XqSS/nME7KT4uyQPAXPk0mXVVwdmyST9Crlr6O6WJopPe9nMIFUYdjdkLfGKLCR96AH3U7frr4jf60eDYEhfHGIzln/ptrTJLvvbXTaPctAaZd6TIv63QVz3yim4MMl3VSdRlrE+O9R5ZR+QKBgQDjEP8TyUSnNsJX+4/JZFwsp04kz8OlorIdjVHT5/JREz5rnVfRlGpanXqjZSCg5Vy9R+ysiDhA+/wB9f87xXmv/2ypSeJspZLAZ0uhGffbdZ5PEASaiNfKn+tWFQ3bkcOX37tDlSJM+G4bQOR2+XdlXSbSZ1yx2AT+IsQKZvvL5QKBgQCPZEUiEz0sV1kX2R2a+XCQ3RVnUxWqh+X/HPjCUr+B/DdeZqPl7QAfjdGymBkN842o/4lZQ7nnpJL70j14KpxLGM4Ox9fIuLv8ZsTxc0XOXjtle48nO+uGkc0qyWoY/RVpQ+tBdiaTzHeIhIxEV7adz/lwZYKdiYIUzGjv8ES/uQKBgCgeWysXjahCQItxx5fTrS8SQFP7Dx5vDW+UkqQ2pbL0AlHyUS7pWJj3AAe3pn4AJZZp4SZPoQP+Z8JPqDA6MrQWHYMi0XkMuMYwLWbGCkmf1MnjUxgOaLXoItjxS/y3jQfeOmHhmOAVkjnEvAh+BWlZxFMv2kiuHRU72bNa0rDIpublic_key = MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAikNqRCM1zOCKDdXDMzhV3ZZPMlV9nCl1iE2fdhBgEEHEcrWldO8kDms91BPSk3k/TbutvBvh2TLCVMUIxFBE2oJmOZy7W3i9+TNlHIm2KTN3toFU7VFvOggOuRgnS81IXSLoPMn9hfc1mssxuLB2fQ3E3sxumYxbvhLQ6RYIPgramO5/4oY0yKnhNZV9AtmSCqSGLO0I0fAM7Qf6kXKTiSkXzChg4Jk/RgCzfC3hRGAm0PlvxiRzfG0NAZNS5ehCkOHB12dWJKPml2kX2131GWIA/YcAFZcbcGZ3YHhV/CmqTgsNCduac1eFpLrSIzJbeyNkNY2ljaCi7sbc+DNpswIDAQAB#SHA1withRsa对应支付宝公钥#alipay_public_key = MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDI6d306Q8fIfCOaTXyiUeJHkrIvYISRcc73s3vF1ZT7XN8RNPwJxo8pWaJMmvyTn9N4HQ632qJBVHf8sxHi/fEsraprwCtzvzQETrNRwVxLO5jVmRGi60j8Ue1efIlzPXV9je9mkjzOmdssymZkh2QhUrCmZYI/FCEa3/cNMW0QIDAQAB#SHA256withRsa对应支付宝公钥alipay_public_key = MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqzWgVL/NWrJAeyEImwtaK3IDwj0dKkqUDIfqqWn5SiLaWMYi9RmKhn+jY9VM7JXEIkYYeVlqIL6Xn7OvYFRTi4buTCXGKvFLn95aDcaur77/S/0ibcdN1K2wIoHzaqQhXAb1ezKxTnFP7OLJsAL22b0NzrQDj2OH9SA06gJb8nHBfR+7Sx7DfwcqE0OtTcDHjbbcB24Qgg/dfItxoEnKuSyRVrf6BtpUnJxSzG/Ge7FfF+VBq8re1t4ZTSxaDEjto071I5VFBxr7I4SyqZsc7WpAmZL8AqUgEbQ1XYBWx2LnpJXM5GQW/thUvcDDqzea7LJNWJOQPM5DaZQgu7QuuwIDAQAB# 签名类型: RSA-&gt;SHA1withRsa,RSA2-&gt;SHA256withRsasign_type = RSA2# 当面付最大查询次数和查询间隔（毫秒）max_query_retry = 5query_duration = 5000# 当面付最大撤销次数和撤销间隔（毫秒）max_cancel_retry = 3cancel_duration = 2000# 交易保障线程第一次调度延迟和调度间隔（秒）heartbeat_delay = 5heartbeat_duration = 900 二维码生成，扫码支付配置回调url 两次回调，扫码进行一次回调，扫码付款成功进行一次回调 生成二维码，上传到ftp服务器 OrderServiceImpl.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216package com.mmall.service.impl;/** * Created by geely */@Service("iOrderService")public class OrderServiceImpl implements IOrderService &#123; private static AlipayTradeService tradeService; static &#123; /** 一定要在创建AlipayTradeService之前调用Configs.init()设置默认参数 * Configs会读取classpath下的zfbinfo.properties文件配置信息，如果找不到该文件则确认该文件是否在classpath目录 */ Configs.init("zfbinfo.properties"); /** 使用Configs提供的默认参数 * AlipayTradeService可以使用单例或者为静态成员对象，不需要反复new */ tradeService = new AlipayTradeServiceImpl.ClientBuilder().build(); &#125; private static final Logger logger = LoggerFactory.getLogger(OrderServiceImpl.class); @Autowired private OrderMapper orderMapper; @Autowired private OrderItemMapper orderItemMapper; @Autowired private PayInfoMapper payInfoMapper; @Autowired private CartMapper cartMapper; @Autowired private ProductMapper productMapper; @Autowired private ShippingMapper shippingMapper; public ServerResponse pay(Long orderNo,Integer userId,String path)&#123; Map&lt;String ,String&gt; resultMap = Maps.newHashMap(); Order order = orderMapper.selectByUserIdAndOrderNo(userId,orderNo); if(order == null)&#123; return ServerResponse.createByErrorMessage("用户没有该订单"); &#125; resultMap.put("orderNo",String.valueOf(order.getOrderNo())); // (必填) 商户网站订单系统中唯一订单号，64个字符以内，只能包含字母、数字、下划线， // 需保证商户系统端不能重复，建议通过数据库sequence生成， String outTradeNo = order.getOrderNo().toString(); // (必填) 订单标题，粗略描述用户的支付目的。如“xxx品牌xxx门店当面付扫码消费” String subject = new StringBuilder().append("happymmall扫码支付,订单号:").append(outTradeNo).toString(); // (必填) 订单总金额，单位为元，不能超过1亿元 // 如果同时传入了【打折金额】,【不可打折金额】,【订单总金额】三者,则必须满足如下条件:【订单总金额】=【打折金额】+【不可打折金额】 String totalAmount = order.getPayment().toString(); // (可选) 订单不可打折金额，可以配合商家平台配置折扣活动，如果酒水不参与打折，则将对应金额填写至此字段 // 如果该值未传入,但传入了【订单总金额】,【打折金额】,则该值默认为【订单总金额】-【打折金额】 String undiscountableAmount = "0"; // 卖家支付宝账号ID，用于支持一个签约账号下支持打款到不同的收款账号，(打款到sellerId对应的支付宝账号) // 如果该字段为空，则默认为与支付宝签约的商户的PID，也就是appid对应的PID String sellerId = ""; // 订单描述，可以对交易或商品进行一个详细地描述，比如填写"购买商品2件共15.00元" String body = new StringBuilder().append("订单").append(outTradeNo).append("购买商品共").append(totalAmount).append("元").toString(); // 商户操作员编号，添加此参数可以为商户操作员做销售统计 String operatorId = "test_operator_id"; // (必填) 商户门店编号，通过门店号和商家后台可以配置精准到门店的折扣信息，详询支付宝技术支持 String storeId = "test_store_id"; // 业务扩展参数，目前可添加由支付宝分配的系统商编号(通过setSysServiceProviderId方法)，详情请咨询支付宝技术支持 ExtendParams extendParams = new ExtendParams(); extendParams.setSysServiceProviderId("2088100200300400500"); // 支付超时，定义为120分钟 String timeoutExpress = "120m"; // 商品明细列表，需填写购买商品详细信息， List&lt;GoodsDetail&gt; goodsDetailList = new ArrayList&lt;GoodsDetail&gt;(); List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNoUserId(orderNo,userId); for(OrderItem orderItem : orderItemList)&#123; GoodsDetail goods = GoodsDetail.newInstance(orderItem.getProductId().toString(), orderItem.getProductName(), BigDecimalUtil.mul(orderItem.getCurrentUnitPrice().doubleValue(),new Double(100).doubleValue()).longValue(), orderItem.getQuantity()); goodsDetailList.add(goods); &#125; // 创建扫码支付请求builder，设置请求参数 AlipayTradePrecreateRequestBuilder builder = new AlipayTradePrecreateRequestBuilder() .setSubject(subject).setTotalAmount(totalAmount).setOutTradeNo(outTradeNo) .setUndiscountableAmount(undiscountableAmount).setSellerId(sellerId).setBody(body) .setOperatorId(operatorId).setStoreId(storeId).setExtendParams(extendParams) .setTimeoutExpress(timeoutExpress) .setNotifyUrl(PropertiesUtil.getProperty("alipay.callback.url"))//支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置 .setGoodsDetailList(goodsDetailList); AlipayF2FPrecreateResult result = tradeService.tradePrecreate(builder); switch (result.getTradeStatus()) &#123; case SUCCESS: logger.info("支付宝预下单成功: )"); AlipayTradePrecreateResponse response = result.getResponse(); dumpResponse(response); File folder = new File(path); if(!folder.exists())&#123; folder.setWritable(true); folder.mkdirs(); &#125; // 需要修改为运行机器上的路径 //细节细节细节 String qrPath = String.format(path+"/qr-%s.png",response.getOutTradeNo()); String qrFileName = String.format("qr-%s.png",response.getOutTradeNo()); ZxingUtils.getQRCodeImge(response.getQrCode(), 256, qrPath); File targetFile = new File(path,qrFileName); try &#123; FTPUtil.uploadFile(Lists.newArrayList(targetFile)); &#125; catch (IOException e) &#123; logger.error("上传二维码异常",e); &#125; logger.info("qrPath:" + qrPath); String qrUrl = PropertiesUtil.getProperty("ftp.server.http.prefix")+targetFile.getName(); resultMap.put("qrUrl",qrUrl); return ServerResponse.createBySuccess(resultMap); case FAILED: logger.error("支付宝预下单失败!!!"); return ServerResponse.createByErrorMessage("支付宝预下单失败!!!"); case UNKNOWN: logger.error("系统异常，预下单状态未知!!!"); return ServerResponse.createByErrorMessage("系统异常，预下单状态未知!!!"); default: logger.error("不支持的交易状态，交易返回异常!!!"); return ServerResponse.createByErrorMessage("不支持的交易状态，交易返回异常!!!"); &#125; &#125; // 简单打印应答 private void dumpResponse(AlipayResponse response) &#123; if (response != null) &#123; logger.info(String.format("code:%s, msg:%s", response.getCode(), response.getMsg())); if (StringUtils.isNotEmpty(response.getSubCode())) &#123; logger.info(String.format("subCode:%s, subMsg:%s", response.getSubCode(), response.getSubMsg())); &#125; logger.info("body:" + response.getBody()); &#125; &#125; public ServerResponse aliCallback(Map&lt;String,String&gt; params)&#123; Long orderNo = Long.parseLong(params.get("out_trade_no")); String tradeNo = params.get("trade_no"); String tradeStatus = params.get("trade_status"); Order order = orderMapper.selectByOrderNo(orderNo); if(order == null)&#123; return ServerResponse.createByErrorMessage("非快乐慕商城的订单,回调忽略"); &#125; if(order.getStatus() &gt;= Const.OrderStatusEnum.PAID.getCode())&#123; return ServerResponse.createBySuccess("支付宝重复调用"); &#125; if(Const.AlipayCallback.TRADE_STATUS_TRADE_SUCCESS.equals(tradeStatus))&#123; order.setPaymentTime(DateTimeUtil.strToDate(params.get("gmt_payment"))); order.setStatus(Const.OrderStatusEnum.PAID.getCode()); orderMapper.updateByPrimaryKeySelective(order); &#125; PayInfo payInfo = new PayInfo(); payInfo.setUserId(order.getUserId()); payInfo.setOrderNo(order.getOrderNo()); payInfo.setPayPlatform(Const.PayPlatformEnum.ALIPAY.getCode()); payInfo.setPlatformNumber(tradeNo); payInfo.setPlatformStatus(tradeStatus); payInfoMapper.insert(payInfo); return ServerResponse.createBySuccess(); &#125; public ServerResponse queryOrderPayStatus(Integer userId,Long orderNo)&#123; Order order = orderMapper.selectByUserIdAndOrderNo(userId,orderNo); if(order == null)&#123; return ServerResponse.createByErrorMessage("用户没有该订单"); &#125; if(order.getStatus() &gt;= Const.OrderStatusEnum.PAID.getCode())&#123; return ServerResponse.createBySuccess(); &#125; return ServerResponse.createByError(); &#125;&#125; 内网穿透NATAPP1分钟快速新手图文教程 线上部署云服务器vsftpd、nginx等配置云服务器的配置与域名解析发布上线注意事项]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Mysql</tag>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux系统下开发环境安装与配置]]></title>
    <url>%2Fmyhexo%2F2019%2F03%2F07%2Flinux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装系统环境 CentOS 6.8 64位 jdk版本 7u80 64位 Tomcat版本 Tomcat7 maven版本 Apache Maven 3.6.0 vsftpd版本 vsftpd-2.2.2-24.el6.x86_64 Nginx版本 nginx-1.14.2 mysql版本 mysql-server-5.1.73-8.el6_8.x86_64 git版本 git version 2.18.0 阿里源配置 123456#备份[root@192 yum.repos.d]# mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup#下载新的CentOS-Base.repo 到/etc/yum.repos.d/[root@192 yum.repos.d]# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo#生成缓存[root@192 yum.repos.d]# yum makecache 设置开机时关闭防火墙 1[root@192 vsftpd]# chkconfig iptables off jdk安装 下载 清理系统默认自带jdk 12345[root@192 yum.repos.d]# rpm -qa | grep jdkjava-1.6.0-openjdk-1.6.0.38-1.13.10.4.el6.x86_64java-1.7.0-openjdk-1.7.0.99-2.6.5.1.el6.x86_64[root@192 yum.repos.d]# yum remove java-1.6.0-openjdk-1.6.0.38-1.13.10.4.el6.x86_64[root@192 yum.repos.d]# yum remove java-1.7.0-openjdk-1.7.0.99-2.6.5.1.el6.x86_64 授权 1[root@192 soft]# chmod 777 jdk-7u80-linux-x64.rpm 安装 1[root@192 soft]# rpm -ivh jdk-7u80-linux-x64.rpm 默认安装路径/user/java jdk配置环境变量,编辑/etc/profile文件，末尾追加 1234#jdkexport JAVA_HOME=/usr/java/jdk1.7.0_80export PATH=$PATH:$JAVA_HOME/binexport CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 使得/etc/profile文件立即生效 1[root@192 apache-maven-3.6.0]# source /etc/profile Tomcat安装 下载 解压 12[root@192 soft]# tar -zxvf apache-tomcat-7.0.93.tar.gz -C /opt/module/ Tomcat配置环境变量,编辑/etc/profile文件，末尾追加 123#tomcatexport CATALINA_HOME=/opt/module/apache-tomcat-7.0.93export PATH=$PATH:$CATALINA_HOME/bin 使得/etc/profile文件立即生效 1[root@192 apache-maven-3.6.0]# source /etc/profile 配置UTF-8字符集，进入Tomcat安装的conf文件夹，编辑server.xml文件，找到配置8080默认端口的位置，在xml节点末尾增加URIEncoding=&quot;UTF-8&quot; 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; /&gt; 启动Tomcat，进入/opt/module/apache-tomcat-7.0.93/bin目录，执行./startup.sh 访问http://192.168.1.104:8080/ Maven安装 下载 解压 1[root@192 soft]# tar -zxvf apache-maven-3.6.0-bin.tar.gz -C /opt/module/ Maven配置环境变量,编辑/etc/profile文件，末尾追加 123#mavenexport MAVEN_HOME=/opt/module/apache-maven-3.6.0export PATH=$PATH:$MAVEN_HOME/bin 使得/etc/profile文件立即生效 1[root@192 apache-maven-3.6.0]# source /etc/profile 验证 1[root@192 apache-maven-3.6.0]# mvn -version vsftpd安装 安装 1[root@192 apache-maven-3.6.0]# yum -y install vsftpd 查看是否已安装 12[root@192 apache-maven-3.6.0]# rpm -qa | grep vsftpdvsftpd-2.2.2-24.el6.x86_64 默认配置文件/etc/vsftpd/vsftpd.conf 创建虚拟用户 根目录下创建ftp文件夹 12[root@192 vsftpd]# cd /[root@192 /]# mkdir ftpfile 添加匿名用户 1[root@192 /]# useradd ftpuser -d /ftpfile/ -s /sbin/nologin 修改ftpfile权限 1[root@192 /]# chown -R ftpuser.ftpuser /ftpfile/ 重设ftpuser密码 1[root@192 /]# passwd ftpuser 将刚刚新增的虚拟用户添加到此配置文件中 1234[root@192 ~]# cd /etc/vsftpd/[root@192 vsftpd]# vim chroo_list [root@192 bin]# cat /etc/vsftpd/chroo_list ftpuser 编辑配置文件/etc/vsftpd/vsftpd.conf，末尾追加 1234local_root=/ftpfileanon_root=/ftpfileuse_localtime=YESanonymous_enable=no 登录验证的时候出现500提示,编辑/etc/selinux/config文件，设置SELINUX=disabled 1[root@192 vsftpd]# vim /etc/selinux/config 如果还报500，执行 1[root@192 vsftpd]# setsebool -P ftp_home_dir 1 设置开启启动vsftpd服务 1[root@192 vsftpd]# chkconfig vsftpd on 访问ftp://192.168.1.104/ 安装Nginx 下载 安装依赖gcc、pcre、zlib、openssl 1[root@192 vsftpd]# yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 解压 1[root@192 soft]# tar -zxvf nginx-1.14.2.tar.gz -C /opt/module/ 编译安装 12345[root@192 nginx-1.14.2]# pwd/opt/module/nginx-1.14.2[root@192 nginx-1.14.2]# ./configure[root@192 nginx-1.14.2]# make[root@192 nginx-1.14.2]# make install 查看Nginx安装目录、版本 1234[root@192 nginx-1.14.2]# whereis nginxnginx: /usr/local/nginx[root@192 nginx-1.14.2]# /usr/local/nginx/sbin/nginx -vnginx version: nginx/1.14.2 测试配置文件nginx.conf的正确性 1[root@192 nginx-1.14.2]# /usr/local/nginx/sbin/nginx -t 启动Nginx 12345[root@192 nginx-1.14.2]# /usr/local/nginx/sbin/nginx[root@192 nginx-1.14.2]# ps -ef | grep nginxroot 5606 1 0 01:02 ? 00:00:00 nginx: master process /usr/local/nginx/sbin/nginxnobody 5607 5606 0 01:02 ? 00:00:00 nginx: worker process root 5626 2868 0 01:09 pts/0 00:00:00 grep nginx 停止Nginx 1[root@192 nginx-1.14.2]# /usr/local/nginx/sbin/nginx -s stop 访问http://192.168.1.104/ Nginx配置虚拟域名 配置虚拟域名映射 12345678[root@192 vhost]# cat /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6#centos#192.168.1.104 www.imooc.com127.0.0.1 www.imooc.com 测试 1234[root@192 sbin]# ping www.imooc.comPING www.imooc.com (127.0.0.1) 56(84) bytes of data.64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.013 ms64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.032 ms 编辑/usr/local/nginx/conf/nginx.conf文件，追加 12###########################vhost############################################## include vhost/*.conf; 在/usr/local/nginx/conf目录下，新建vhost文件夹 在/usr/local/nginx/conf/vhost目录下，新建域名转发www.mytest.com.conf配置文件 123456789101112131415161718[root@192 vhost]# cat /usr/local/nginx/conf/vhost/www.mytest.com.conf #Start www.mytest.comserver &#123; listen 80; server_name www.mytest.com; access_log /usr/local/nginx/logs/access.log combined; index index.html index.htm index.php; if ( $query_string ~* &quot;.*[\;&apos;\&lt;\&gt;].*&quot; )&#123; return 404; &#125; # send request back to apach location / &#123; proxy_pass http://127.0.0.1:8080/; &#125;&#125; 访问www.mytest.com Nginx配置静态资源转发 编辑/usr/local/nginx/conf/nginx.conf文件，追加 12###########################vhost############################################## include vhost/*.conf; 在/usr/local/nginx/conf目录下，新建vhost文件夹 在/usr/local/nginx/conf/vhost目录下，新建域名转发www.mytest.com.conf配置文件 123456789101112131415161718[root@192 vhost]# cat /usr/local/nginx/conf/vhost/www.mytest.com.conf #Start www.mytest.comserver &#123; listen 80; server_name www.mytest.com; access_log /usr/local/nginx/logs/access.log combined; index index.html index.htm index.php; if ( $query_string ~* &quot;.*[\;&apos;\&lt;\&gt;].*&quot; )&#123; return 404; &#125; # send request back to apach location / &#123; root /ftpfile/; &#125;&#125; mysql安装 安装 1[root@192 ~]# yum -y install mysql-server 配置字符集,编辑/etc/my.cnf文件，追加 12#utf8default-character-set=utf8 设置mysql服务随系统自动启动 123[root@192 ~]# chkconfig mysqld on[root@192 ~]# chkconfig --list mysqldmysqld 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭 启动mysql服务 12[root@192 ~]# service mysqld start正在启动 mysqld： [确定] 登录，使用非密码登录 1234567891011121314[root@192 mysql]# mysql -uroot Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 5Server version: 5.1.73 Source distributionCopyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; 查看mysql的用户 1234567891011mysql&gt; select user,host,password from mysql.user;+------+---------------+----------+| user | host | password |+------+---------------+----------+| root | localhost | || root | 192.168.1.104 | || root | 127.0.0.1 | || | localhost | || | 192.168.1.104 | |+------+---------------+----------+5 rows in set (0.00 sec) 删除匿名用户 12mysql&gt; delete from mysql.user where user=&apos;&apos;;Query OK, 2 rows affected (0.00 sec) 刷新，立即生效 12mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec) 修改root密码 12mysql&gt; set password for root@localhost=password(&quot;000000&quot;);Query OK, 0 rows affected (0.00 sec) 插入mysql新用户 12mysql&gt; insert into mysql.user(Host,User,Password) values(&quot;localhost&quot;,&quot;admin&quot;,password(&quot;000000&quot;));Query OK, 1 row affected, 3 warnings (0.01 sec) 查看用户权限 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162mysql&gt; select * from mysql.user \G*************************** 1. row *************************** Host: localhost User: root Password: *032197AE5731D4664921A6CCAC7CFCE6A0698693 Select_priv: Y Insert_priv: Y Update_priv: Y Delete_priv: Y Create_priv: Y Drop_priv: Y Reload_priv: Y Shutdown_priv: Y Process_priv: Y File_priv: Y Grant_priv: Y References_priv: Y Index_priv: Y Alter_priv: Y Show_db_priv: Y Super_priv: YCreate_tmp_table_priv: Y Lock_tables_priv: Y Execute_priv: Y Repl_slave_priv: Y Repl_client_priv: Y Create_view_priv: Y Show_view_priv: Y Create_routine_priv: Y Alter_routine_priv: Y Create_user_priv: Y Event_priv: Y Trigger_priv: Y ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0*************************** 2. row *************************** Host: 192.168.1.104 User: root Password: Select_priv: Y Insert_priv: Y Update_priv: Y Delete_priv: Y Create_priv: Y Drop_priv: Y Reload_priv: Y Shutdown_priv: Y Process_priv: Y File_priv: Y Grant_priv: Y References_priv: Y Index_priv: Y Alter_priv: Y Show_db_priv: Y Super_priv: YCreate_tmp_table_priv: Y Lock_tables_priv: Y Execute_priv: Y Repl_slave_priv: Y Repl_client_priv: Y Create_view_priv: Y Show_view_priv: Y Create_routine_priv: Y Alter_routine_priv: Y Create_user_priv: Y Event_priv: Y Trigger_priv: Y ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0*************************** 3. row *************************** Host: 127.0.0.1 User: root Password: Select_priv: Y Insert_priv: Y Update_priv: Y Delete_priv: Y Create_priv: Y Drop_priv: Y Reload_priv: Y Shutdown_priv: Y Process_priv: Y File_priv: Y Grant_priv: Y References_priv: Y Index_priv: Y Alter_priv: Y Show_db_priv: Y Super_priv: YCreate_tmp_table_priv: Y Lock_tables_priv: Y Execute_priv: Y Repl_slave_priv: Y Repl_client_priv: Y Create_view_priv: Y Show_view_priv: Y Create_routine_priv: Y Alter_routine_priv: Y Create_user_priv: Y Event_priv: Y Trigger_priv: Y ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0*************************** 4. row *************************** Host: localhost User: admin Password: *032197AE5731D4664921A6CCAC7CFCE6A0698693 Select_priv: N Insert_priv: N Update_priv: N Delete_priv: N Create_priv: N Drop_priv: N Reload_priv: N Shutdown_priv: N Process_priv: N File_priv: N Grant_priv: N References_priv: N Index_priv: N Alter_priv: N Show_db_priv: N Super_priv: NCreate_tmp_table_priv: N Lock_tables_priv: N Execute_priv: N Repl_slave_priv: N Repl_client_priv: N Create_view_priv: N Show_view_priv: N Create_routine_priv: N Alter_routine_priv: N Create_user_priv: N Event_priv: N Trigger_priv: N ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 04 rows in set (0.00 sec) 查库，新建database数据库 123456789101112131415161718192021mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || test |+--------------------+3 rows in set (0.01 sec)mysql&gt; create database mytest default character set utf8 collate utf8_general_ci;Query OK, 1 row affected (0.00 sec)mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || mytest || test |+--------------------+4 rows in set (0.00 sec) 本地用户赋予所有权限、给账号开通外网所有权限 1234mysql&gt; grant all privileges on mytest.* to admin@&apos;%&apos; identified by &apos;000000&apos; with grant option;Query OK, 0 rows affected (0.00 sec)mysql&gt; grant select,delete,create on mytest.* to admin@&apos;192.168.1.104&apos; identified by &apos;000000&apos; with grant option;Query OK, 0 rows affected (0.00 sec) 导入sql文件 1mysql&gt; source /opt/module/mmall.sql git安装 下载 解压 1[root@192 ~]# tar -zxvf git-2.18.0.tar.gz -C /opt/module/ 安装依赖 1[root@192 ~]# yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker cpio 编译安装 1[root@192 git-2.18.0]# make prefix=/usr/local/ install 验证 12[root@192 ~]# git --versiongit version 2.18.0 生成公私密钥对 123456789101112131415161718192021[root@192 ~]# ssh-keygen -t rsa -C &quot;782125244@qq.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:85:1e:ef:5a:33:ab:e7:79:a4:46:f6:8e:8f:7f:af:cd 782125244@qq.comThe key&apos;s randomart image is:+--[ RSA 2048]----+| || . || o . || . + || S . || .o . || o=+ || o+Bo .o || o=*=+..oE|+-----------------+ 复制公钥粘贴到码云或者GitHub上SSH公钥上 12[root@192 .ssh]# cat id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA1sZvTnjQyVn7r2C7G9Q/WyVTTmJYqWhQdVfh3tBCUX8kJHaAcThwR4sl8ROz6xXl/22wbzlsKtfsiyr5zrV0Ifnq7KuCeNVNUYjOQCTn+ODaRzdj7DYC4Mz9BvxZAr0MDfSbgpLp6ZLAvZlkP3DioOPda7VnfJSAHGEYztOVPITj31pVnP1nXkPZRQlsTwImXEGJpuU+zOaurMShpaukrY/ONxWHR6xlG5M1FgOLdBvEnlbhOFoME1HHziI4/08Xw/NrHIUhvjZZgkAzWUo5NvYZLEwrUjOPtlVxHbYwBEtgBWRgWLFMfTlxQnEJVKzbwUDPLvZWac9WSpGLx5xiww== 782125244@qq.com 配置用户名、邮箱，提交时会引用 12345[root@192 mytest]# git config --global user.name &quot;shenlibng&quot;[root@192 mytest]# git config --global user.email &quot;782125244@qq.com&quot;[root@192 mytest]# git config --global core.autocrlf false[root@192 mytest]# git config --global core.quotepath off[root@192 mytest]# git config --global gui.encoding utf-8 开启防火墙配置 查看防火墙初始化配置 1234567891011121314[root@192 ~]# cat /etc/sysconfig/iptables# Firewall configuration written by system-config-firewall# Manual customization of this file is not recommended.*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibitedCOMMIT 开放Tomcat端口 重启生效防火墙 12345[root@192 ~]# service iptables restartiptables：将链设置为政策 ACCEPT：filter [确定]iptables：清除防火墙规则： [确定]iptables：正在卸载模块： [确定]iptables：应用防火墙规则： [确定] 查看防火墙状态 1234567891011121314151617[root@192 ~]# service iptables status表格：filterChain INPUT (policy ACCEPT)num target prot opt source destination 1 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 2 ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 3 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 4 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22 5 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8080 6 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain FORWARD (policy ACCEPT)num target prot opt source destination 1 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain OUTPUT (policy ACCEPT)num target prot opt source destination]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>vsftpd</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh无密登录_集群分发脚本xsync]]></title>
    <url>%2Fmyhexo%2F2019%2F02%2F18%2Fssh%E6%97%A0%E5%AF%86%E7%99%BB%E5%BD%95-%E9%9B%86%E7%BE%A4%E5%88%86%E5%8F%91%E8%84%9A%E6%9C%ACxsync%2F</url>
    <content type="text"><![CDATA[1、ssh免密登录 ssh ip地址 123[root@192 ~]# ssh 192.168.1.102root@192.168.1.102&apos;s password: Last login: Mon Feb 18 20:40:28 2019 from 192.168.1.101 免密登录配置 生成公钥和私钥 1234567891011121314151617181920212223[root@192 ~]# ssh-keygen -t rsa Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:d4:95:6c:a8:21:9b:27:62:79:43:76:e8:4b:32:6c:fe root@192.168.1.101The key&apos;s randomart image is:+--[ RSA 2048]----+| . o.. || = o...+ || . = =.o.. || O O.o || + * =S || . . || . || E || |+-----------------+[root@192 ~]# ls /root/.ssh/id_rsa id_rsa.pub 将公钥拷贝到要免密登录的目标机器上 .ssh文件夹下（~/.ssh）的文件功能解释（1）known_hosts ：记录ssh访问过计算机的公钥(public key)（2）id_rsa ：生成的私钥（3）id_rsa.pub ：生成的公钥（4）authorized_keys ：存放授权过得无密登录服务器公钥 123456789101112131415161718192021[root@192 ~]# hostname 192.168.1.101[root@192 ~]# ssh-copy-id 192.168.1.102The authenticity of host &apos;192.168.1.102 (192.168.1.102)&apos; can&apos;t be established.RSA key fingerprint is 56:57:4c:81:94:e0:47:fe:1e:aa:8c:9c:2a:87:a6:dc.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;192.168.1.102&apos; (RSA) to the list of known hosts.root@192.168.1.102&apos;s password: Now try logging into the machine, with &quot;ssh &apos;192.168.1.102&apos;&quot;, and check in: .ssh/authorized_keysto make sure we haven&apos;t added extra keys that you weren&apos;t expecting.[root@192 ~]# ls /root/.ssh/id_rsa id_rsa.pub known_hosts[root@192 ~]# ssh 192.168.1.102Last login: Mon Feb 18 22:50:53 2019 from 192.168.1.101[root@192 ~]# ls /root/.ssh/authorized_keys 2、集群分发脚本xsync 服务器与服务器数据拷贝 rsync和scp区别：用rsync做文件的复制要比scp的速度快，rsync只对差异文件做更新。scp是把所有文件都复制过去。 scp 12[root@192 ~]# scp -r /tmp/1.txt root@192.168.1.102:/tmp/1.txt rsync 选项 功能-r 递归-v 显示复制过程-l 拷贝符号连接 123456[root@192 ~]# rsync -rvl /tmp/2.txt root@192.168.1.102:/tmp/sending incremental file list2.txtsent 84 bytes received 31 bytes 76.67 bytes/sectotal size is 13 speedup is 0.11 集群分发脚本xsync 12345[root@192 ~]# mkdir bin[root@192 ~]# cd bin/[root@192 bin]# touch xsync[root@192 bin]# vim xsync[root@192 bin]# chmod 777 xsync 12345678910111213141516171819202122232425262728#!/bin/bash#1 获取输入参数个数，如果没有参数，直接退出pcount=$#if((pcount==0)); thenecho no args;exit;fi#2 获取文件名称p1=$1fname=`basename $p1`echo fname=$fname#3 获取上级目录到绝对路径pdir=`cd -P $(dirname $p1); pwd`echo pdir=$pdir#4 获取当前用户名称user=`whoami`#5 循环for((host=102; host&lt;104; host++)); do echo --------------------- 192.168.1.$host ---------------- rsync -rvl $pdir/$fname $user@192.168.1.$host:$pdir #echo ------"rsync -rvl $pdir/$fname $user@192.168.1.$host:$pdir complete"------------done xsync调用 1234567891011121314151617181920[root@192 bin]# xsync /tmp/1.txt /tmp/fname=1.txtpdir=/tmp--------------------- 192.168.1.102 ----------------sending incremental file list1.txtsent 516 bytes received 31 bytes 364.67 bytes/sectotal size is 445 speedup is 0.81--------------------- 192.168.1.103 ----------------The authenticity of host &apos;192.168.1.103 (192.168.1.103)&apos; can&apos;t be established.RSA key fingerprint is 56:57:4c:81:94:e0:47:fe:1e:aa:8c:9c:2a:87:a6:dc.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;192.168.1.103&apos; (RSA) to the list of known hosts.root@192.168.1.103&apos;s password: sending incremental file list1.txtsent 71 bytes received 37 bytes 5.84 bytes/sectotal size is 445 speedup is 4.12]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ssh</tag>
        <tag>scp</tag>
        <tag>rsync</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机配置静态ip]]></title>
    <url>%2Fmyhexo%2F2019%2F02%2F15%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81ip%2F</url>
    <content type="text"><![CDATA[镜像下载链接 https://wiki.centos.org/Download 环境：CentOS-6.8-x86_64-bin-DVD1.iso 1、克隆虚拟机 修改主机名 [root@192 桌面]# vim /etc/sysconfig/network12NETWORKING=yesHOSTNAME=192.168.1.104 修改网卡信息 [root@192 桌面]# vim /etc/udev/rules.d/70-persistent-net.rules删除或者注释eth0该行；将eth1修改为eth0，同时复制物理ip地址00:0c:29:ac:81:e4 123456789101112# This file was automatically generated by the /lib/udev/write_net_rules# program, run by the persistent-net-generator.rules rules file.## You can modify it, as long as you keep each rule on a single# line, and change only the value of the NAME= key.# PCI device 0x8086:0x100f (e1000)#SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;00:0c:29:00:88:b3&quot;, ATTR&#123;type&#125;==&quot;1&quot;, KERNEL==&quot;eth*&quot;, NAME=&quot;eth0&quot;# PCI device 0x8086:0x100f (e1000)SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;00:0c:29:ac:81:e4&quot;, ATTR&#123;type&#125;==&quot;1&quot;, KERNEL==&quot;eth*&quot;, NAME=&quot;eth0&quot;[root@192 桌面]# 更新物理ip地址HWADDR=00:0c:29:ac:81:e4 [root@192 桌面]# vim /etc/sysconfig/network-scripts/ifcfg-eth0 1234567DEVICE=eth0HWADDR=00:0c:29:ac:81:e4TYPE=EthernetUUID=55735d7f-16c6-46fe-9db8-f7d484b3e7c0ONBOOT=noneNM_CONTROLLED=yesBOOTPROTO=dhcp 2、NAT模式配置 编辑–虚拟网络编辑器 配置静态ip网段和子网掩码 NAT设置 网关ip不能和vmnet8的ip地址冲突 宿主机上的vmnet8网卡会自动分配ip 3、配置静态ip ONBOOT=yes系统启动时激活网卡BOOTPROTO=static通过指定方式的办法来获得地址，设置为静态手动配置IPADDR=192.168.1.104主机ip地址GATEWAY=192.168.1.2网关NETMASK=255.255.255.0子网掩码DNS1=8.8.8.8配置DNS域名解析访问互联网DNS2=8.8.4.4 123456789101112DEVICE=eth0HWADDR=00:0c:29:ac:81:e4TYPE=EthernetUUID=55735d7f-16c6-46fe-9db8-f7d484b3e7c0ONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.1.104GATEWAY=192.168.1.2NETMASK=255.255.255.0DNS1=8.8.8.8DNS2=8.8.4.4]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring定时任务_文件上传进度条]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F30%2Fspring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[spring定时任务 导依赖 123456&lt;!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz --&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt;&lt;/dependency&gt; 配置定时任务类 123456789101112package com.atguigu.scw.portal.service;import org.springframework.stereotype.Service;@Servicepublic class ExampleJob &#123; public void hello() &#123; System.out.println("定时任务触发===========&gt;"); &#125;&#125; 配置定时任务 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd"&gt; &lt;!-- &lt;bean id="exampleJob" class="com.atguigu.scw.portal.service.ExampleJob"&gt;&lt;/bean&gt; --&gt; &lt;!--配置定时任务触发类和方法 --&gt; &lt;bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;property name="targetObject" ref="exampleJob" /&gt; &lt;property name="targetMethod" value="hello" /&gt; &lt;/bean&gt; &lt;!--配置触发器，指定何时触发 --&gt; &lt;bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="jobDetail" /&gt; &lt;!-- run every morning at 6 AM --&gt; &lt;property name="cronExpression" value="*/5 * * * * ?" /&gt; &lt;/bean&gt; &lt;!--配置定时任务调用哪一个触发器 --&gt; &lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt; &lt;property name="triggers"&gt; &lt;list&gt; &lt;ref bean="cronTrigger" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; cron表达式使用 123456789每隔5秒执行一次：*/5 * * * * ?每隔1分钟执行一次：0 */1 * * * ?每天23点执行一次：0 0 23 * * ?每天凌晨1点执行一次：0 0 1 * * ?每月1号凌晨1点执行一次：0 0 1 1 * ?每月最后一天23点执行一次：0 0 23 L * ?每周星期天凌晨1点实行一次：0 0 1 ? * L在26分、29分、33分执行一次：0 26,29,33 * * * ?每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ? 参考 https://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#scheduling-quartz 文件上传进度条 ajax异步提交表单$(&quot;#subBtn&quot;).on(&#39;click&#39;, function() { return false}是js对象的机制 &lt;button type=&quot;submit&quot; id=&#39;subBtn&#39; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;点击按钮直接提交是浏览器的机制 文件上传 表单直接提交action=&#39;${ctp}/member/upload&#39; method=&#39;post&#39; enctype=&quot;multipart/form-data&quot; 1234567891011&lt;form action='$&#123;ctp&#125;/member/upload' method='post' enctype="multipart/form-data"&gt; &lt;div class="form-group"&gt; &lt;input type="file" class="form-control" id="file" name='file'&gt; &lt;/div&gt; &lt;div class="progress"&gt; &lt;div class="progress-bar" role="progressbar" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100" style="width: 60%;"&gt; 60%&lt;/div&gt; &lt;/div&gt; &lt;button type="submit" id='subBtn' class="btn btn-default"&gt;Submit&lt;/button&gt;&lt;/form&gt; ajax提交type : &quot;post&quot;,contentType : false,processData : false 进度条:获取myXhr = $.ajaxSettings.xhr()对象并返回 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;form id='submitForm'&gt; &lt;div class="form-group"&gt; &lt;input type="file" class="form-control" id="file" name='file'&gt; &lt;/div&gt; &lt;div class="progress" style='display: none;'&gt; &lt;div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%;"&gt;0%&lt;/div&gt; &lt;/div&gt; &lt;button type="submit" id='subBtn' class="btn btn-default"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script type="text/javascript"&gt; $("#subBtn").on('click', function() &#123; var fd = new FormData($("#submitForm")[0]); $.ajax(&#123; url : "$&#123;ctp&#125;/member/upload", data : fd, type : "post", contentType : false, processData : false, //获取ajaxSettings中的xhr对象，为它的upload属性绑定progress事件的处理函数 xhr : function() &#123; myXhr = $.ajaxSettings.xhr() //检查upload属性是否存在 if (myXhr.upload) &#123; //绑定progress事件的回调函数 myXhr.upload.addEventListener('progress', progressHandlingFunction, false) &#125; //xhr对象返回给jQuery使用 return myXhr; &#125;, success : function(result) &#123; console.log("result==========&gt;", result) &#125;, error : function(e) &#123; console.log('e=========&gt;', e) &#125; &#125;) return false &#125;) var progressHandlingFunction = function(e) &#123; var curr = e.loaded var total = e.total process = curr / total * 100 console.log('上传进度============&gt;', process) $('.progress').attr('style', 'display:show;') $('.progress-bar').html(process + '%') $('.progress-bar').attr('style', 'width:' + process + '%;') &#125;&lt;/script&gt; 图片预览 123456789101112131415161718$("#ad_file_input").on('change', function(event) &#123; $(this).empty() $(this).parent('.form-group').next('.form-group').find('.imgdiv').empty() fileList = event.currentTarget.files log('fileList==============&gt;', fileList) var URL = window.URL || window.webkitURL var imgURL //遍历上传的文件进行显示 $.each(fileList, function (index, item) &#123; //创建一个临时的url地址 imgURL = URL.createObjectURL(item) log('this=========&gt;',this) log('item==========&gt;',item) $('#ad_file_input').parent(".form-group").next(".form-group").find(".imgdiv").append("&lt;img src='"+imgURL+"' style='width:200px;height:220px;'/&gt;").append('&lt;p&gt;'+item.name+'&lt;p&gt;') &#125;)&#125;)]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多表连接查询]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F29%2F%E5%A4%9A%E8%A1%A8%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[1、查询用户拥有的权限 子查询和连接查询2种，比较推荐连接查询，子查询比较影响性能，子查询看起来比较容易理解，而连接查询需要比较熟悉各个表之间的关系 123456789101112131415161718SELECT DISTINCT p.* FROM t_permission p LEFT JOIN t_role_permission trp ON trp.`permissionid`=p.`id` LEFT JOIN t_role tr ON tr.`id`=trp.`roleid` WHERE tr.id IN( SELECT t_r.id FROM t_role t_r LEFT JOIN t_user_role t_u_r ON t_u_r.`roleid`=t_r.`id` WHERE t_u_r.`userid`=31 );子查询不太推荐，比较影响性能推荐连接查询SELECT DISTINCT p.* FROM t_permission p LEFT JOIN t_role_permission trp ON trp.`permissionid`=p.`id` LEFT JOIN t_role tr ON tr.`id`=trp.`roleid` LEFT JOIN t_user_role tur ON tur.`roleid`=tr.`id` LEFT JOIN t_user tu ON tu.`id`=tur.`userid` WHERE tu.`id`=31;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HttpClient远程接口调用_实名认证]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F28%2FHttpClient%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8-%E5%AE%9E%E5%90%8D%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[1、HttpClient远程接口调用 1)用户注册 注册按钮button提交表单时，要return false form表单 12345&lt;!-- action="http://localhost:8082/scw-restapi/member/regist" --&gt;&lt;form class="form-signin" role="form" action="$&#123;ctp&#125;/member/regist" method="post" id="regForm"&gt;...&lt;/form&gt; js提交表单 1234567891011121314$("#submitBtn").click(function() &#123; var loginType = $("select.form-control").val(); log("注册类型==============&gt;", loginType) /* if (loginType == "管理") &#123; $("#regForm").submit(); &#125; else &#123; alert("此功能尚未开通"); &#125; */ $("#regForm").submit(); return false&#125;) 2)加载外部资源文件 app.properties 123restapi.server.ip=127.0.0.1restapi.server.port=8082restapi.server.apppath=scw-restapi 编辑springmvc.xml 123&lt;!-- 引入外部配置文件 --&gt;&lt;context:property-placeholder location="classpath:other/app.properties" /&gt; RestApiServerInfo.java 123456789101112131415161718@Controllerpublic class RestApiServerInfo &#123; // MemberService memberService; @Value("$&#123;restapi.server.ip&#125;") private String restapiserver; @Value("$&#123;restapi.server.port&#125;") private String restapiport; @Value("$&#123;restapi.server.apppath&#125;") private String appPath; public String getRestApiURL() &#123; System.out.println("http://" + restapiserver + ":" + restapiport); return "http://" + restapiserver + ":" + restapiport + "/" + appPath; &#125;&#125; 3)HTTPClient工具远程调用接口 导入依赖 123456&lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.3&lt;/version&gt;&lt;/dependency&gt; 发送post请求 1public static String httpPostRequest(String url, Map&lt;String, Object&gt; params) 工具类HttpClientUtil.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152package com.atguigu.project;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.URISyntaxException;import java.util.ArrayList;import java.util.Map;import org.apache.http.HttpEntity;import org.apache.http.NameValuePair;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.client.methods.HttpRequestBase;import org.apache.http.client.utils.URIBuilder;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;/** * @author Nan 2015-11 */public class HttpClientUtil &#123; private static PoolingHttpClientConnectionManager cm; private static String EMPTY_STR = ""; private static String UTF_8 = "UTF-8"; private static void init() &#123; if (cm == null) &#123; cm = new PoolingHttpClientConnectionManager(); cm.setMaxTotal(50);// 整个连接池最大连接数 cm.setDefaultMaxPerRoute(5);// 每路由最大连接数，默认值是2 &#125; &#125; /** * 通过连接池获取HttpClient * * @return */ private static CloseableHttpClient getHttpClient() &#123; init(); return HttpClients.custom().setConnectionManager(cm).build(); &#125; /** * @param url * @return */ public static String httpGetRequest(String url) &#123; HttpGet httpGet = new HttpGet(url); return getResult(httpGet); &#125; public static String httpGetRequest(String url, Map&lt;String, Object&gt; params) throws URISyntaxException &#123; URIBuilder ub = new URIBuilder(); ub.setPath(url); ArrayList&lt;NameValuePair&gt; pairs = covertParams2NVPS(params); ub.setParameters(pairs); HttpGet httpGet = new HttpGet(ub.build()); return getResult(httpGet); &#125; public static String httpGetRequest(String url, Map&lt;String, Object&gt; headers, Map&lt;String, Object&gt; params) throws URISyntaxException &#123; URIBuilder ub = new URIBuilder(); ub.setPath(url); ArrayList&lt;NameValuePair&gt; pairs = covertParams2NVPS(params); ub.setParameters(pairs); HttpGet httpGet = new HttpGet(ub.build()); for (Map.Entry&lt;String, Object&gt; param : headers.entrySet()) &#123; httpGet.addHeader(param.getKey(), String.valueOf(param.getValue())); &#125; return getResult(httpGet); &#125; public static String httpPostRequest(String url) &#123; HttpPost httpPost = new HttpPost(url); return getResult(httpPost); &#125; public static String httpPostRequest(String url, Map&lt;String, Object&gt; params) throws UnsupportedEncodingException &#123; HttpPost httpPost = new HttpPost(url); ArrayList&lt;NameValuePair&gt; pairs = covertParams2NVPS(params); httpPost.setEntity(new UrlEncodedFormEntity(pairs, UTF_8)); return getResult(httpPost); &#125; public static String httpPostRequest(String url, Map&lt;String, Object&gt; headers, Map&lt;String, Object&gt; params) throws UnsupportedEncodingException &#123; HttpPost httpPost = new HttpPost(url); for (Map.Entry&lt;String, Object&gt; param : headers.entrySet()) &#123; httpPost.addHeader(param.getKey(), String.valueOf(param.getValue())); &#125; ArrayList&lt;NameValuePair&gt; pairs = covertParams2NVPS(params); httpPost.setEntity(new UrlEncodedFormEntity(pairs, UTF_8)); return getResult(httpPost); &#125; private static ArrayList&lt;NameValuePair&gt; covertParams2NVPS(Map&lt;String, Object&gt; params) &#123; ArrayList&lt;NameValuePair&gt; pairs = new ArrayList&lt;NameValuePair&gt;(); for (Map.Entry&lt;String, Object&gt; param : params.entrySet()) &#123; pairs.add(new BasicNameValuePair(param.getKey(), String.valueOf(param.getValue()))); &#125; return pairs; &#125; /** * 处理Http请求 * * @param request * @return */ private static String getResult(HttpRequestBase request) &#123; // CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpClient httpClient = getHttpClient(); try &#123; CloseableHttpResponse response = httpClient.execute(request); // response.getStatusLine().getStatusCode(); HttpEntity entity = response.getEntity(); if (entity != null) &#123; // long len = entity.getContentLength();// -1 表示长度未知 String result = EntityUtils.toString(entity); response.close(); // httpClient.close(); return result; &#125; &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; &#125; return EMPTY_STR; &#125;&#125; 远程接口返回ScwReturn&lt;T&gt;封装对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.atguigu.scw.restapi.bean;import java.util.Map;public class ScwReturn&lt;T&gt; &#123; private int code;// 状态码 1：表示成功 0:表示失败 private String msg;// 要给的提示信息 private T content;// 响应的内容； private Map&lt;String, Object&gt; ext;// 额外的数据 public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public T getContent() &#123; return content; &#125; public void setContent(T content) &#123; this.content = content; &#125; public Map&lt;String, Object&gt; getExt() &#123; return ext; &#125; public void setExt(Map&lt;String, Object&gt; ext) &#123; this.ext = ext; &#125; // 两个快速的成功失败方法 public static &lt;T&gt; ScwReturn&lt;T&gt; success(String msg, T content, Map&lt;String, Object&gt; ext) &#123; ScwReturn&lt;T&gt; t = new ScwReturn&lt;T&gt;(); t.setCode(1); t.setMsg(msg); t.setContent(content); t.setExt(ext); return t; &#125; public static &lt;T&gt; ScwReturn&lt;T&gt; fail(String msg, T content, Map&lt;String, Object&gt; ext) &#123; ScwReturn&lt;T&gt; t = new ScwReturn&lt;T&gt;(); t.setCode(0); t.setMsg(msg); t.setContent(content); t.setExt(ext); return t; &#125;&#125; 注册调用远程接口 发送请求 1String response = HttpClientUtil.httpPostRequest(url, params); 远程接口返回的响应字符串转java对象 12readValue = new ObjectMapper().readValue(response.getBytes(), new TypeReference&lt;ScwReturn&lt;TMemeber&gt;&gt;() &#123; &#125;); 1234567891011121314151617181920212223242526272829303132333435363738394041@RequestMapping("/regist")public String regist(TMemeber memeber, Model model) throws Exception &#123; // 需要利用http工具去模拟发调用接口的请求 // http://localhost:8082/scw-restapi/member/regist // &lt;httpclient.version&gt;4.5.3&lt;/httpclient.version&gt; // httpclient使用java代码来模拟发送请求 // 能收到api调用后产生的json数据； // 1、可以将产生的json逆向成对象ScwReturn&lt;TMemeber&gt; // 2、可以直接将json写给页面 System.out.println("memeber===========&gt;" + memeber); // 注册成功以后可以来到一个页面； // 1、应该去发送请求来进行注册；java代码发请求 String url = serverInfo.getRestApiURL() + "/member/regist"; System.out.println("url===========&gt;" + url); // 2、构建请求参数 Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;(); params.put("loginacct", memeber.getLoginacct()); // 密码是业务逻辑加密的，我们不用管 params.put("userpswd", memeber.getUserpswd()); params.put("email", memeber.getEmail()); // 响应内容； String response = HttpClientUtil.httpPostRequest(url, params); // 封装响应为对象 ScwReturn&lt;TMemeber&gt; readValue = null; readValue = new ObjectMapper().readValue(response.getBytes(), new TypeReference&lt;ScwReturn&lt;TMemeber&gt;&gt;() &#123; &#125;); // 判断，注册成功！来到登陆页面 if (readValue.getCode() == 1) &#123; return "redirect:/login.jsp"; &#125; else &#123; // 注册失败！来到注册页面进行回显 model.addAttribute("msg", "用户名和邮箱已经被注册了！"); return "forward:/reg.jsp"; &#125;&#125; 远程接口注册方法 控制层 123456789101112131415161718192021222324252627/** * ScwReturn&lt;List&lt;TMemeber&gt;&gt;:泛型是content内容的对象的类型 * * @Description (TODO这里用一句话描述这个方法的作用) * @param memeber * @return */ @RequestMapping("/regist") public ScwReturn&lt;TMemeber&gt; regist(TMemeber memeber) &#123; // 创建一个空的对象 TMemeber regist = new TMemeber(); Map&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;(); try &#123; regist = memberService.regist(memeber); &#125; catch (Exception e) &#123; // 判断异常类型来放错误 // e.printStackTrace(); hashMap.put("error", "触犯唯一约束，请保证用户名和邮箱唯一"); &#125; regist.setUserpswd(""); if (regist.getId() != null) &#123; return ScwReturn.success("用户注册成功！", regist, null); &#125; else &#123; return ScwReturn.fail("用户注册失败!", null, hashMap); &#125; &#125; 业务层 带条件插入 1int i = memeberMapper.insertSelective(tMemeber); 12345678910111213141516171819202122@Override public TMemeber regist(TMemeber tMemeber) &#123; // TODO Auto-generated method stub String digest = MD5Util.digest(tMemeber.getUserpswd()); // 加密密码保存 tMemeber.setUserpswd(digest); // 初始化用户名和账号 tMemeber.setUsername(tMemeber.getLoginacct()); // 实名认证状态 0:未实名认证 1::实名认证 tMemeber.setAuthstatus("0"); // 真实姓名；实名认证是保存的 tMemeber.setRealname("未实名"); // 0：普通会员 1：月费会员 2：年费会员 3： tMemeber.setUsertype("0"); // 身份证号，账户类型；（实名认证是做的） // 账户类型：直接保存账户的全名 int i = memeberMapper.insertSelective(tMemeber); // 刚才就是按照这个对象给数据库插入值，希望获取到数据库分配的自增主键 return tMemeber; &#125; 2、实名认证文件上传 1)上传用户资质证件 导入依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt; 编辑springmvc.xml文件 1234&lt;!-- 1、文件上传需要一个文件上传解析器 --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="defaultEncoding" value="utf-8"&gt;&lt;/property&gt;&lt;/bean&gt; 前台ajax提交 带有文件表单，一次提交所有项 1var fd = new FormData($(&quot;#certForm&quot;)[0]) 带有文件表单,提交部分内容 123456//使用formData（js对象来包装form表单）var fd = new FormData();log($(&quot;#ad_name_input&quot;).val())log($(&quot;#ad_file_input&quot;)[0].files[0])fd.append(&quot;name&quot;, $(&quot;#ad_name_input&quot;).val());fd.append(&quot;ad&quot;, $(&quot;#ad_file_input&quot;)[0].files[0]) processData(默认: true) 默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 “application/x-www-form-urlencoded”。 contentType 不使用默认的内容类型；(默认: “application/x-www-form-urlencoded”) 发送信息至服务器时内容编码类型。 123456789101112131415161718//这是一个资质文件上传的页面//发送文件上传资质文件请求；var fd = new FormData($("#certForm")[0]);$.ajax(&#123; url:"http://localhost:8082/scw-restapi/auth/upload", data:fd, type:"post", contentType:false, dataType:"json", processData:false, success:function(result)&#123; //来到邮箱填写页面 location.href="$&#123;ctp&#125;/auth/apply-2.html" &#125;, error:function(e)&#123; layer.msg("上传失败:"+e); &#125;&#125;); 控制层 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//文件上传 private String uploadfile(String webPath,MultipartFile file,HttpSession session)&#123; ServletContext context = session.getServletContext(); String realPath = context.getRealPath(webPath); String name = UUID.randomUUID().toString().replace("-", "").substring(0, 10) +"_file_"+ file.getOriginalFilename(); try &#123; //webPath不存在的情况下必须创建 File file2 = new File(realPath); if(!file2.exists())&#123; //创建目录 file2.mkdirs(); &#125; file.transferTo(new File(realPath+"/"+name)); //返回这个图片在服务器下的路径 return webPath+"/"+name; &#125;catch (Exception e) &#123; return null; &#125; &#125; @RequestMapping("/upload") public ScwReturn&lt;Object&gt; upload(HttpSession session, @RequestParam("file")MultipartFile[] file, @RequestParam("certid")Integer[] certid,@RequestParam("memberid")Integer memberid)&#123; try &#123; System.out.println("资质的id"+certid); List&lt;TMemberCert&gt; certsList= new ArrayList&lt;TMemberCert&gt;(); for (int i=0;i&lt;certid.length;i++) &#123; TMemberCert cert = new TMemberCert(); MultipartFile multipartFile = file[i]; String uploadfile = uploadfile("/certsimg", multipartFile, session); cert.setCertid(certid[i]); cert.setMemberid(memberid); cert.setIconpath(uploadfile); certsList.add(cert); &#125; //调用业务逻辑进行保存;/删除原有资质，保存新的资质 certService.insertCerts(certsList); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block System.out.println(e); return ScwReturn.fail("资质保存失败！", null, null); &#125; return ScwReturn.success("保存成功！", null, null); &#125; 2)批量插入用户资质证件描述信息 业务层 CertService.java 1public void insertCerts(List&lt;TMemberCert&gt; certsList); CertServiceImpl.java 1234567891011@Override public void insertCerts(List&lt;TMemberCert&gt; certsList) &#123; // TODO Auto-generated method stub TMemberCertExample example = new TMemberCertExample(); Criteria criteria = example.createCriteria(); criteria.andMemberidEqualTo(certsList.get(0).getMemberid()); //先删除 memberCertMapper.deleteByExample(example); //后保存 certMapper.insertBatch(certsList); &#125; dao层 TCertMapper.java 1void insertBatch(@Param("certs")List&lt;TMemberCert&gt; certsList); TCertMapper.xml 12345678&lt;!-- void insertBatch(@Param("certs")List&lt;TMemberCert&gt; certsList); --&gt;&lt;insert id="insertBatch"&gt; INSERT INTO t_member_cert(memberid,certid,iconpath) VALUES&lt;foreach collection="certs" item="c" separator=","&gt; (#&#123;c.memberid&#125;,#&#123;c.certid&#125;,#&#123;c.iconpath&#125;)&lt;/foreach&gt;&lt;/insert&gt;]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>HTTPClient</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术分享]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F26%2F%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[1、快速深入地学习一个新技术、知识点步骤 1）我们有一个需求 项目开发时，我们需要解决某个问题—页面局部刷新问题 跳槽，学习新技术 2）先看看使用现有的技术能否解决这个问题 可以解决，使用传统的方法iframe 发现使用传统的方法可以解决，但是不够好，使用新技术ajax 3）学习新技术或者知识点 原理 基本语法 4）快速入门案例 特点是简单 了解新技术或者知识点的基本使用，这里不需要涉及技术细节 5）讨论这个新技术或者知识点的细节 怎么使用更规范 使用该技术有没有什么陷阱 需要使用时，注意些什么 2、学习方法的介绍 1）高效而愉快地学习 2）先建立一个整体框架，然后细节 3）在实际工作中，要培养用到什么，能够快速学习什么的能力 4）先know how，再know why 5）软件编程是一门’做中学‘的学科，不是会了再做，而是做了才会 6）适当的囫囵吞枣 7）学习软件编程是在在琢磨别人怎么做，而不是我认为应该怎么做的过程 123for i:=0;i&lt;10;i++ &#123; fmt.Println(&quot;hello,world&quot;)&#125;]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>方法论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6异步]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F25%2Fes6%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[1、promise-解决异步操作 同步——串行 简单、方便 异步——并发 性能高、体验好 jQuery异步问题：回到地狱 123456789101112131415161718192021222324252627282930313233$.ajax(&#123; url: '/banner_data', success(banners)&#123; $.ajax(&#123; url: '/user_data', success(user)&#123; $.ajax(&#123; url: '/item_data', success(items)&#123; $.ajax(&#123; url: '/news_data', success(news)&#123; &#125;, error()&#123; alert('数据获取失败'); &#125; &#125;) &#125;, error()&#123; alert('数据获取失败'); &#125; &#125;) &#125;, error()&#123; alert('数据获取失败'); &#125; &#125;) &#125;, error()&#123; alert('数据获取失败'); &#125;&#125;) 使用Promise Promise.all() 与：所有的都成功 Promise.race() 或：只要有一个完成 123456789//PromisePromise.all([ $.ajax('/banner_data'), $.ajax('/item_data'), $.ajax('/user_data'), $.ajax('/news_data'),]).then(arr=&gt;&#123; let [banners, items, user, news]=arr;&#125;, ()=&gt;&#123;&#125;) 1.txt 1&#123;&quot;a&quot;: 3, &quot;b&quot;: 5&#125; 2.txt 1[12,5,8,3] 3.txt 1&#123;&quot;name&quot;: &quot;blue&quot;, &quot;age&quot;: 18&#125; promise怎么用.html 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; let p = new Promise((resolve, reject) =&gt; &#123; //resolve 解决-&gt;成功 //reject 拒绝-&gt;失败 $.ajax(&#123; url: '1.txt', dataType: 'json', success(json) &#123; resolve(json) &#125;, error(err) &#123; reject(err) &#125; &#125;) &#125;) debugger p.then(json =&gt; &#123; alert('成功') console.log(json) &#125;, err =&gt; &#123; alert('失败') &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; promise怎么用2.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; let p = new Promise((resolve, reject) =&gt; &#123; //resolve 解决-&gt;成功 //reject 拒绝-&gt;失败 $.ajax(&#123; url: '1.txt', dataType: 'json', success(json) &#123; resolve(json) &#125;, error(err) &#123; reject(err) &#125; &#125;) &#125;) let p2 = new Promise((resolve, reject) =&gt; &#123; //resolve 解决-&gt;成功 //reject 拒绝-&gt;失败 $.ajax(&#123; url: '2.txt', dataType: 'json', success(json) &#123; resolve(json) &#125;, error(err) &#123; reject(err) &#125; &#125;); &#125;); let p3 = new Promise((resolve, reject) =&gt; &#123; //resolve 解决-&gt;成功 //reject 拒绝-&gt;失败 $.ajax(&#123; url: '3.txt', dataType: 'json', success(json) &#123; resolve(json) &#125;, error(err) &#123; reject(err) &#125; &#125;) &#125;) Promise.all([p, p2, p3]).then(arr =&gt; &#123; let [j1, a, j2] = arr; alert('成功') console.log(j1, a, j2) &#125;, err =&gt; &#123; alert('失败') &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; promise怎么用3.html 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; $.ajax(&#123; url: '1.txt', dataType: 'json' &#125;).then(json=&gt;&#123; alert('成了'); &#125;, err=&gt;&#123; alert('错了'); &#125;); debugger /* Promise.all([p, p2, p3]).then(arr=&gt;&#123; let [j1, a, j2]=arr; alert('成功'); console.log(j1, a, j2); &#125;, err=&gt;&#123; alert('失败'); &#125;); */ &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; promise怎么用4.html 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; Promise.all([ $.ajax(&#123;url: '1.txt', dataType: 'json'&#125;), $.ajax(&#123;url: '2.txt', dataType: 'json'&#125;), $.ajax(&#123;url: '3.txt', dataType: 'json'&#125;), ]).then(arr=&gt;&#123; let [j1, a, j2]=arr; console.log(j1, a, j2); &#125;, err=&gt;&#123; alert('失败'); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 结论 Proimse有用——解除异步操作 Promise有局限——带逻辑的异步操作麻烦 2、generator-生成器（过渡） 可以暂停 generator函数.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function* show() &#123; alert('aaa') yield alert('bbb') &#125; let gen = show() gen.next() //aaa setTimeout(function() &#123; gen.next() //bbb &#125;, 5000) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; generator函数3.html 传参 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function *show()&#123; alert('aaa'); let a=yield; alert('bbb'+a); &#125; let gen=show(); gen.next(); gen.next(12); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; generator函数4.html 返回值 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function* show() &#123; alert('aaa') yield 55 alert('bbb') return 89 &#125; let gen = show() let res1 = gen.next() // debugger console.log(res1) //&#123;value: 55, done: false&#125; let res2 = gen.next() console.log(res2) //&#123;value: 89, done: true&#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 3、async/await（推荐，es7） 可以暂停且可以处理带业务逻辑、异常 async和await.html 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function sleep(sec) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; resolve() &#125;, sec * 1000) &#125;) &#125; async function show() &#123; alert('a') await sleep(1) alert('b') await sleep(2) alert('c') &#125; show() &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 处理带业务逻辑 async和await2.html 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; (async () =&gt; &#123; let data1 = await $.ajax(&#123; url: '1.txt', dataType: 'json' &#125;) console.log('data1=========&gt;', data1) if (data1.a + data1.b &lt; 10) &#123; let data2 = await $.ajax(&#123; url: '2.txt', dataType: 'json' &#125;) alert(data2[0]) &#125; else &#123; let data3 = await $.ajax(&#123; url: '3.txt', dataType: 'json' &#125;) alert(data3.name) &#125; &#125;)() &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 处理异常 async和await3.html 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; async function show() &#123; try &#123; let data1 = await $.ajax(&#123; url: '1.txt', dataType: 'json' &#125;) let data2 = await $.ajax(&#123; url: '33.txt', dataType: 'json' &#125;) let data3 = await $.ajax(&#123; url: '3.txt', dataType: 'json' &#125;) console.log(data1, data2, data3) &#125; catch (e) &#123; alert('有问题') throw new Error('我错了....') &#125; &#125; show() &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F23%2Fhexo%2F</url>
    <content type="text"><![CDATA[安装Node.jshttps://nodejs.org/en/ 安装Githttps://git-scm.com/ 安装Hexo12//全局安装$ npm install -g hexo-cli 存放位置 1C:\Users\libingshen\AppData\Roaming\npm\node_modules 验证安装是否成功 1234567891011121314151617181920212223242526C:\Users\libingshen&gt;node --versionv10.15.0C:\Users\libingshen&gt;npm --version6.4.1C:\Users\libingshen&gt;git --versiongit version 2.16.2.windows.1C:\Users\libingshen&gt;hexo --versionhexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64http_parser: 2.8.0node: 10.15.0v8: 6.8.275.32-node.45uv: 1.23.2zlib: 1.2.11ares: 1.15.0modules: 64nghttp2: 1.34.0napi: 3openssl: 1.1.0jicu: 62.1unicode: 11.0cldr: 33.1tz: 2018e Hexo博客初始化1234567891011$ cd D:\mytest\myhexo$ hexo init//安装依赖$ npm install//或者hexo generate生成静态页$ hexo g //或者hexo server，启动服务器，可以在http://localhost:4000/ 查看$ hexo s Hexo博客部署到GitHub本地客户端与GitHub建立授权连接生成公私钥1ssh-keygen -t rsa -C &quot;782125244@qq.com&quot; 公私钥存放位置 1C:\Users\libingshen\.ssh 将公钥内容上传到GitHub GitHub创建仓库作为hexo博客的站点hexo配置GitHub连接安装 hexo-deployer-git 1$ npm install hexo-deployer-git --save 修改配置D:\mytest\myhexo_config.yml 12345678910111213141516#配置GitHub博客站址访问路径# URL这里要是没有配置，GitHub样式显示不出来## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://shenlibing.github.io/myhexo/root: /myhexopermalink: :year/:month/:day/:title/permalink_defaults:#博客推送到GitHub地址配置# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/shenlibing/myhexo.git branch: [master] 配置GitHub Pages![](http://images.bingbing.tech/配置GitHub page.png) 备份博客源文件hexo部署到GitHub只上传.deploy_git文件夹的内容，并不会上传_posts文件夹下的博客源文件 123D:\mytest\myhexo\.deploy_gitD:\mytest\myhexo\source\_posts 解决： 将_posts文件夹作为git仓库，上传到GitHub，使得其作为另一个分支 创建并切换到新分支 123libingshen@DESKTOP-7V287SK MINGW64 /d/mytest/myhexo/source/_posts (master)$ git checkout -b srcSwitched to a new branch &apos;src&apos; 将新分支推送到GitHub 123git add .git commit -m &apos;add_v1:-新增hello-world笔记初始化&apos;git push origin src 将博客源文件分支设为推送的默认分支，git push推送直接推送到src分支 补充： 删除本地分支 1$ git branch -d src 删除远程分支 1$ git push origin -d src 切换分支 1$ git checkout master 查看提交日志 1$ git log --oneline 拓展更换hexo主题下载 https://github.com/theme-next/hexo-theme-next 解压放到D:\mytest\myhexo\themes 修改D:\mytest\myhexo\_config.yml配置文件 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-next-master 修改站点语言编辑D:\mytest\myhexo\_config.yml文件 12345678# Sitetitle: 小兵兵subtitle:description:keywords:author: shenlibinglanguage: zh-CNtimezone: 开启搜索、字数统计和阅读时长统计安装依赖hexo-symbols-count-time、hexo-generator-searchdb，安装依赖不成功时先删除D:\mytest\myhexo\node_modules文件夹，重新安装依赖 1234npm install hexo-symbols-count-time --savenpm install hexo-generator-searchdb --save 配置主题样式文件 进入D:\mytest\myhexo\themes\hexo-theme-next-master\文件夹，编辑_config.yml文件 123456789101112# Local search# Dependencies: https://github.com/theme-next/hexo-generator-searchdblocal_search: enable: true# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 4 wpm: 275 配置站点文件 编辑D:\mytest\myhexo\_config.yml文件 12345678910111213#阅读时长和本文字数symbols_count_time: symbols: true time: true total_symbols: true total_time: true#搜索功能search: path: search.xml field: post format: html limit: 10000 添加分类和标签123$ hexo new page categories$ hexo new page tags 编辑D:\mytest\myhexo\source\categories\index.md 123456---title: categoriesdate: 2019-01-22 16:37:58type: &quot;categories&quot; #这部分是新添加的--- 编辑D:\mytest\myhexo\source\tags\index.md 123456---title: tagsdate: 2019-01-22 16:38:40type: &quot;tags&quot; #新添加的内容--- 修改菜单，添加categories和tags到menu中 123456789menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 新增文章，添加categories、tags 123456789101112---title: hexo博客搭建date: 2019-01-23 09:07:30categories: 日常记录tags: - hexo - git - github - node - markdown--- 更换页面菜单布局位置12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 配置文章浏览量注册 https://leancloud.cn/ 创建应用 创建Class 配置web安全域名 获取app_id、app_key 编辑D:\mytest\myhexo\themes\hexo-theme-next-master\_config.yml配置文件，填app_id、 app_key;security设置为false 123456789101112# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: BedsOkBLOBR4nM4W52xTcBhb-gzGzoHsz #&lt;app_id&gt; app_key: EEaRfb6dCMaS38laDCkSYhM9 #&lt;app_key&gt; # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don&apos;t care about security in leancloud counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set `security` to `false`. security: false betterPerformance: false 插入本地图片安装依赖 1npm install hexo-asset-image --save 编辑D:\mytest\myhexo\_config.yml配置文件 1post_asset_folder: true 命令hexo new post test来生成博文时，/source/_post文件夹中除了test.md外，还有一个同名test文件夹 typora插入本地图片typora设置文件–偏好设置–图片插入 编辑–图片工具–设置图片根目录 1typora-root-url: hexo/ 设置动态背景进入D:\mytest\myhexo\themes\hexo-theme-next-master\layout\文件夹，编辑_layout.swig文件，在&lt;/body&gt;之前添加 1&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt; 添加Fork me on GitHub进入D:\mytest\myhexo\themes\hexo-theme-next-master\layout\文件夹，编辑_layout.swig文件，在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面添加选择的图标样式代码 1&lt;a href=&quot;https://github.com/shenlibing/&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 添加友情链接方式一进入D:\mytest\myhexo\themes\hexo-theme-next-master\layout\_partials文件夹，在footer.swig文件末尾追加 123456&lt;div&gt;友情链接： &lt;a class=&quot;theme-link&quot; href=&quot;http://collect.w3ctrain.com/&quot;&gt; 前端收藏夹 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;a class=&quot;theme-link&quot; href=&quot;http://www.alloyteam.com/nav/&quot;&gt; Web前端导航 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;a class=&quot;theme-link&quot; href=&quot;http://www.runoob.com/&quot;&gt; 菜鸟教程 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;a class=&quot;theme-link&quot; href=&quot;https://mccxj.github.io/&quot;&gt; 小毛的胡思乱想 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/div&gt; 方式二进入D:\mytest\myhexo\themes\hexo-theme-next-master文件夹，编辑_config.yml文件 1234567891011# Blog rollslinks_icon: linklinks_title: Linkslinks_layout: block#links_layout: inline#links: #Title: http://example.comlinks: 美团技术团队: https://tech.meituan.com/ 百度FEX: http://fex.baidu.com/ 淘宝FED: http://taobaofed.org/ 设置阅读全文进入D:\mytest\myhexo\themes\hexo-theme-next-master文件夹，编辑_config.yml文件 12345# Automatically Excerpt. Not recommend.# Use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150 添加评论选择gitalk 需要 GitHub Application，如果没有 点击这里申请，Authorization callback URL 填写当前使用插件页面的域名。 获取client_id和client_secret 进入D:\mytest\myhexo文件夹，编辑_config.yml文件 clientID String Required. GitHub Application Client ID. clientSecret String Required. GitHub Application Client Secret. repo String Required. GitHub repository. owner String Required. GitHub repository owner. Can be personal user or organization. admin Array Required. GitHub repository owner and collaborators. (Users who having write access to this repository) 1234567891011# Gitalk# Demo: https://gitalk.github.io# Reference: https://asdfv1929.github.io/2018/01/20/gitalk/, https://liujunzhou.top/2018/8/10/gitalk-error/gitalk: enable: true github_id: shenlibing # Github repo owner repo: myhexo # Repository name to store issues. client_id: # Github Application Client ID client_secret: # Github Application Client Secret admin_user: shenlibing # GitHub repo owner and collaborators, only these guys can initialize github issues distraction_free_mode: true # Facebook-like distraction free mode 开启打赏进入D:\mytest\myhexo文件夹，编辑_config.yml文件 123456789# Reward# If true, reward would be displayed in every article by default.# And you can show or hide one article specially through add page variable `reward: true/false`.reward: enable: true #comment: Donate comment here wechatpay: /images/wechat.jpg alipay: /images/alipay.jpg #bitcoin: /images/bitcoin.jpg 部署到云服务器拷贝本机的公钥id_rsa.pub内容到云服务器authorized_keys上 进入D:\mytest\myhexo文件夹，编辑_config.yml文件 12345678910111213141516171819# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'# url: https://shenlibing.github.io/url: http://bingbing.tech/root: /permalink: :year/:month/:day/:title/permalink_defaults:# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git # repo: https://github.com/shenlibing/shenlibing.github.io.git #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io repo: root@192.168.1.101:/root/project/hexo.git#https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io# repo: ssh://root@192.168.1.101:22/root/project/hexo.git branch: [master] #published 服务器创建裸仓库 1[root@izm5eac6bnsz8uq175jkvez project]# git init --bare hexo.git 配置钩子 12345678910111213141516171819202122232425262728293031[root@izm5eac6bnsz8uq175jkvez hooks]# pwd/root/project/hexo.git/hooks[root@izm5eac6bnsz8uq175jkvez hooks]# chmod 744 post-receive[root@izm5eac6bnsz8uq175jkvez hooks]# lltotal 44-rwxr-xr-x 1 root root 452 Aug 13 16:59 applypatch-msg.sample-rwxr-xr-x 1 root root 896 Aug 13 16:59 commit-msg.sample-rwxr--r-- 1 root root 357 Aug 14 17:50 post-receive-rwxr-xr-x 1 root root 189 Aug 13 16:59 post-update.sample-rwxr-xr-x 1 root root 398 Aug 13 16:59 pre-applypatch.sample-rwxr-xr-x 1 root root 1704 Aug 13 16:59 pre-commit.sample-rwxr-xr-x 1 root root 1239 Aug 13 16:59 prepare-commit-msg.sample-rw-r--r-- 1 root root 1348 Aug 13 16:59 pre-push.sample-rwxr-xr-x 1 root root 4951 Aug 13 16:59 pre-rebase.sample-rwxr-xr-x 1 root root 3611 Aug 13 16:59 update.sample[root@izm5eac6bnsz8uq175jkvez hooks]# cat post-receive #!/bin/bash -l#GIT_REPO=&lt;到hexo.git的目录&gt;#TMP_GIT_CLONE=&lt;到临时blog的目录&gt;#PUBLIC_WWW=&lt;到blog服务的目录/public/blog&gt;GIT_REPO=/root/project/hexo.gitTMP_GIT_CLONE=/tmp/blogPUBLIC_WWW=/opt/module/website/blogrm -rf $&#123;TMP_GIT_CLONE&#125;git clone $&#123;GIT_REPO&#125; $&#123;TMP_GIT_CLONE&#125;rm -rf $&#123;PUBLIC_WWW&#125;/*cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125;[root@izm5eac6bnsz8uq175jkvez hooks]# 修改Nginx配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128[root@izm5eac6bnsz8uq175jkvez blog]# whereis nginxnginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz /usr/share/man/man3/nginx.3pm.gz[root@izm5eac6bnsz8uq175jkvez blog]# cd /etc/nginx/[root@izm5eac6bnsz8uq175jkvez nginx]# lltotal 72drwxr-xr-x 2 root root 4096 May 10 16:14 conf.ddrwxr-xr-x 2 root root 4096 May 10 16:14 default.d-rw-r--r-- 1 root root 1077 May 10 16:10 fastcgi.conf-rw-r--r-- 1 root root 1077 May 10 16:10 fastcgi.conf.default-rw-r--r-- 1 root root 1007 May 10 16:10 fastcgi_params-rw-r--r-- 1 root root 1007 May 10 16:10 fastcgi_params.default-rw-r--r-- 1 root root 2837 May 10 16:10 koi-utf-rw-r--r-- 1 root root 2223 May 10 16:10 koi-win-rw-r--r-- 1 root root 3957 May 10 16:10 mime.types-rw-r--r-- 1 root root 3957 May 10 16:10 mime.types.default-rw-r--r-- 1 root root 3051 Aug 15 20:29 nginx.conf-rw-r--r-- 1 root root 2467 Aug 13 11:05 nginx.conf.bak-rw-r--r-- 1 root root 2656 May 10 16:10 nginx.conf.default-rw-r--r-- 1 root root 636 May 10 16:10 scgi_params-rw-r--r-- 1 root root 636 May 10 16:10 scgi_params.default-rw-r--r-- 1 root root 664 May 10 16:10 uwsgi_params-rw-r--r-- 1 root root 664 May 10 16:10 uwsgi_params.default-rw-r--r-- 1 root root 3610 May 10 16:10 win-utf[root@izm5eac6bnsz8uq175jkvez nginx]# cat nginx.conf# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;# Load dynamic modules. See /usr/share/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024;&#125;http &#123; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server &#123; listen 8000 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; server &#123; listen 80; #端口# server_name bingbing.tech; #域名或IP root /opt/module/website/blog; #站点根目录 charset utf-8; #文件编码 index index.html index.htm; #首页 error_page 404 /404.html; #404页面 error_page 500 502 503 504 /50x.html; #服务端错误页面 #url访问匹配路径，可以添加多个 location / &#123; index index.html index.htm; root /opt/module/website/blog; #这里可以是绝对路径或者相对路径，基于站点根目录 &#125; &#125; # Settings for a TLS enabled server.## server &#123;# listen 443 ssl http2 default_server;# listen [::]:443 ssl http2 default_server;# server_name _;# root /usr/share/nginx/html;## ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;# ssl_certificate_key &quot;/etc/pki/nginx/private/server.key&quot;;# ssl_session_cache shared:SSL:1m;# ssl_session_timeout 10m;# ssl_ciphers HIGH:!aNULL:!MD5;# ssl_prefer_server_ciphers on;## # Load configuration files for the default server block.# include /etc/nginx/default.d/*.conf;## location / &#123;# &#125;## error_page 404 /404.html;# location = /40x.html &#123;# &#125;## error_page 500 502 503 504 /50x.html;# location = /50x.html &#123;# &#125;# &#125;&#125; 使用GitHub图床创建个存放图片的仓库blogphoto 替换typora生成的图片路径 替换脚本 使用七牛云图床如何配置域名的 CNAME 新建存储空间 绑定域名 域名添加CANME记录 上传图片、外链访问 替换脚本 优化URL安装依赖 1npm install hexo-abbrlink --save 编辑D:\mytest\myhexo\_config.yml配置文件 123456789101112131415# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'# url: https://shenlibing.github.io/url: http://bingbing.tech/root: /# permalink: :year/:month/:day/:title/# permalink_defaults:#插件hexo-abbrlink# permalink: :title/permalink: archives/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 常见错误错误一： 故障现象：xml转移错误，导致搜索不出结果 故障原因： 解决： 参考：【持续更新】Github Pages + Hexo 博客搭建，Next主题个性化修改 Hexo+NexT 打造一个炫酷博客 hexo史上最全搭建教程 用 Typora 写 Hexo 博客 | zhangnew 使用Typora+Hexo+Google Drive打造自己的云笔记 | 情起·而深 我的云端硬盘 - Google 云端硬盘]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化点击事件绑定]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F15%2F%E4%BC%98%E5%8C%96%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[1、优化点击事件绑定 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button data-action="id1"&gt;新增按钮1&lt;/button&gt;&lt;button data-action="id2"&gt;删除按钮2&lt;/button&gt;&lt;button data-action="id3"&gt;按钮3&lt;/button&gt;&lt;button data-action="id4"&gt;按钮4&lt;/button&gt;&lt;script&gt; var log = function () &#123; console.log.apply(console, arguments) &#125; var actionList = &#123; 'id1': function () &#123; alert('id1=============&gt;') &#125;, 'id2': function () &#123; alert('id2===============&gt;') &#125;, 'id3': function () &#123; alert('id3===============&gt;') &#125;, 'id4': function () &#123; alert('id4===============&gt;') &#125; &#125; let $body = $('body') $body.on('click', '[data-action]', function () &#123; //jQuery获取html标签自定义属性值或data值 let action_name = $(this).data('action') let action = actionList[action_name] // log(action) // log($.isFunction(action)) if ($.isFunction(action)) &#123; action() &#125; &#125;) //页面需要新增一个按钮，做扩展 $body.append('&lt;button data-action="id5"&gt;按钮5&lt;/button&gt;') $.extend(actionList, &#123; 'id5': function () &#123; alert('id5============&gt;') &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考 https://github.com/cssmagic/blog/issues/48]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户分配角色_角色维护权限树]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F14%2F%E7%94%A8%E6%88%B7%E5%88%86%E9%85%8D%E8%A7%92%E8%89%B2_%E8%A7%92%E8%89%B2%E7%BB%B4%E6%8A%A4%E6%9D%83%E9%99%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1、用户分配角色 效果图： 实现思路： 1）先静态实现页面 2）从数据库查询用户未分配角色和已分配角色，前端初始化该列表 3）添加、移除用户拥有的角色 前端： 1)左移、右移：append和appendTo的使用 12$(&quot;.unroles :selected&quot;).appendTo(&quot;.roles_select&quot;) 2）遍历选中的角色 123456//遍历选中的元素,拼接用户角色id$(&apos;.unroles :selected&apos;).each(function() &#123; log(this) rids += $(this).val() + &apos;,&apos;&#125;) 3)ajax发送异步请求（参数拼接：用户id,角色rids） 1234567uid = &apos;$&#123;param.uid&#125;&apos;url = &apos;$&#123;ctp&#125;/permission/user/assignrole?opt=remove&amp;uid=&apos; + uid + &apos;&amp;rids=&apos; + rids + &apos;&apos;//发送请求移除$.get(url, fnf) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;div class="panel panel-default"&gt; &lt;div class="panel-body"&gt; &lt;form role="form" class="form-inline"&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputPassword1"&gt;未分配角色列表&lt;/label&gt;&lt;br&gt; &lt;select class="form-control unroles" multiple size="10" style="width: 100px; overflow-y: auto;"&gt; &lt;c:forEach items="$&#123;list_user_unrole&#125;" var="user_unrole"&gt; &lt;option value="$&#123;user_unrole.id&#125;"&gt;$&#123;user_unrole.name&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;ul&gt; &lt;li class="btn btn-default glyphicon glyphicon-chevron-right"&gt;&lt;/li&gt; &lt;br&gt; &lt;li class="btn btn-default glyphicon glyphicon-chevron-left" style="margin-top: 20px;"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="form-group" style="margin-left: 40px;"&gt; &lt;label for="exampleInputPassword1"&gt;已分配角色列表&lt;/label&gt;&lt;br&gt; &lt;select class="form-control roles_select" multiple size="10" style="width: 100px; overflow-y: auto;"&gt; &lt;c:forEach items="$&#123;list_user_role&#125;" var="user_role"&gt; &lt;option value="$&#123;user_role.id&#125;"&gt;$&#123;user_role.name&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;script type="text/javascript"&gt; $(function() &#123; $(".list-group-item").click(function() &#123; if ($(this).find("ul")) &#123; $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) &#123; $("ul", this).hide("fast"); &#125; else &#123; $("ul", this).show("fast"); &#125; &#125; &#125;); &#125;); //页面加载完成执行 $(function() &#123; addUserRoleEvent() removeUserRoleEvent() &#125;) //用户添加角色事件 var addUserRoleEvent = function() &#123; $('.glyphicon-chevron-right').click( function() &#123; log('向右移动=============&gt;') var uid = '' var rids = '' //遍历选中的元素,拼接用户角色id $('.unroles :selected').each(function() &#123; log(this) rids += $(this).val() + ',' &#125;) rids = rids.substring(0, rids.length - 1) log('用户角色ids==========&gt;', rids) uid = '$&#123;param.uid&#125;' url = '$&#123;ctp&#125;/permission/user/assignrole?opt=add&amp;uid=' + uid + '&amp;rids=' + rids + '' //选中的得进行处理添加到用户角色表中 //发送请求给当前用户添加这几个角色，必须带上权限id的拼串和userid $.get(url, fns) &#125;) &#125; //用户删除角色事件 var removeUserRoleEvent = function() &#123; $('.glyphicon-chevron-left') .click( function() &#123; log('向左移动=============&gt;') var rids = '' $('.roles_select :selected').each(function() &#123; rids += $(this).val() + ',' &#125;) rids = rids.substring(0, rids.length - 1) log('用户角色ids==========&gt;', rids) uid = '$&#123;param.uid&#125;' url = '$&#123;ctp&#125;/permission/user/assignrole?opt=remove&amp;uid=' + uid + '&amp;rids=' + rids + '' //发送请求移除 $.get(url, fnf) &#125;) &#125; //异步请求成功的回调函数 var fns = function(data) &#123; log('异步请求成功的回调函数===============&gt;') log('data===========&gt;', data) //$('.roles_select').append($('.unroles :selected')) $(".unroles :selected").appendTo(".roles_select") &#125; //异步请求失败的回调函数 var fnf = function(data) &#123; log('异步请求失败的回调函数===============&gt;') log('data===========&gt;', data) $('.roles_select :selected').appendTo('.unroles') &#125;&lt;/script&gt; 控制层: 1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 添加移除用户角色 @RequestMapping("/assignrole") @ResponseBody public String userRole(@RequestParam("uid") Integer uid, @RequestParam("rids") String rids, @RequestParam("opt") String opt) &#123; System.out.println("添加移除用户角色==================&gt;"); System.out.println("用户id-----角色ids------类型：添加、移除"); System.out.println(uid); System.out.println(rids); System.out.println(opt); if ("add".equals(opt)) &#123; // 为某个用户添加角色 int i = userRoleService.add(uid, rids); &#125; else if ("remove".equals(opt)) &#123; // 为某个用户删除角色 int i = userRoleService.remove(uid, rids); &#125; return "success"; &#125; @RequestMapping("/toAssignRolePage") public String toAssignRolePage(@RequestParam(value = "uid") Integer uid, Model model) &#123; System.out.println("UserController.toAssignRolePage去分配角色页面=============&gt;"); // 1、查出所有角色 List&lt;TRole&gt; list_role = roleService.getAllRole(); System.out.println("所有角色===========&gt;"); System.out.println(list_role); // 2、查出当前用户拥有的角色 List&lt;TRole&gt; list_user_role = roleService.getUserRole(uid); System.out.println("当前用户的角色==========&gt;"); System.out.println(list_user_role); HashMap&lt;Integer, TRole&gt; map_user_role = new HashMap&lt;&gt;(); for (TRole tRole : list_user_role) &#123; map_user_role.put(tRole.getId(), tRole); &#125; // 3、用户未分配的角色 ArrayList&lt;TRole&gt; list_user_unrole = new ArrayList&lt;&gt;(); for (TRole tRole : list_role) &#123; if (!map_user_role.containsKey(tRole.getId())) &#123; list_user_unrole.add(tRole); &#125; &#125; System.out.println("用户未分配的角色=============&gt;"); System.out.println(list_user_unrole); model.addAttribute("list_user_role", list_user_role); model.addAttribute("list_user_unrole", list_user_unrole); // model.addAttribute("uid", uid); return "manager/permission/assignRole"; &#125; sql: 1)用户表、用户_角色表、角色表3个表多表查询 12345678910111213141516171819&lt;resultMap id="BaseResultMap" type="com.atguigu.scw.manager.bean.TRole"&gt; &lt;id column="id" jdbcType="INTEGER" property="id" /&gt; &lt;result column="name" jdbcType="VARCHAR" property="name" /&gt;&lt;/resultMap&gt;&lt;!-- List&lt;TRole&gt; getUserRole(Integer uid); --&gt;&lt;select id="getUserRole" resultMap="BaseResultMap"&gt; SELECT a.* FROM t_role a LEFT JOIN t_user_role b ON a.`id` = b.`roleid` LEFT JOIN t_user c ON b.`userid` = c.`id` WHERE c.`id` = #&#123;uid&#125;&lt;/select&gt; 2、角色维护权限树 效果图： 实现思路： 1）zTree展示权限树，初始化含有复选框的权限树，异步请求控制层（参数：角色rid）查询出角色拥有的权限 2）点击分配权限携带角色rid和权限permission_ids到控制层，先删除角色所拥有的权限，再更加permission_ids更新角色拥有的权限，同步到前端 3）bootstrap模态框–分配权限按钮绑定参数 前端： 1）zTree权限树复选框初始化的时候刚开始使用2次异步请求（一次请求所有权限，一次请求角色拥有的权限），展示数据有点混乱，后来改为一次异步请求同时查询出（所有权限、角色拥有的权限）。 2）bootstrap自定义图标显示不出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201&lt;!-- Modal模态框 --&gt;&lt;div class="modal fade" id="permissModel" tabindex="-1" role="dialog" aria-labelledby="myModalLabel"&gt; &lt;div class="modal-dialog" role="document"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"&gt; &lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;h4 class="modal-title" id="myModalLabel"&gt;Modal title&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;!--展示权限树 --&gt; &lt;ul id="permissionTree" class="ztree"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;关闭&lt;/button&gt; &lt;button type="button" class="btn btn-primary" id='addPermissionBtn'&gt;分配权限&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; $(function() &#123; $(".list-group-item").click(function() &#123; if ($(this).find("ul")) &#123; $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) &#123; $("ul", this).hide("fast"); &#125; else &#123; $("ul", this).show("fast"); &#125; &#125; &#125;); &#125;); /* $("tbody .btn-success").click(function() &#123; window.location.href = "assignPermission.html"; &#125;); */ var zTree //设置ajax同步 //$.ajaxSettings.async = false var assignPermissionEvent = function() &#123; $(".assignPermissionModelBtn").click(function() &#123; log('assignPermissionEvent==============&gt;') //获取当前角色id log('当前角色id==========&gt;', $(this).attr('rid')) var rid = $(this).attr('rid') loadModalAndTree(rid) &#125;) &#125; var loadModalAndTree = function(rid) &#123; //模态框设置 var options = &#123; backdrop : 'static', show : true &#125; //手动打开模态框 $('#permissModel').modal(options) //从数据库查出的所有权限节点数据 //发送ajax请求获取到所有权限的json数据 var url = '$&#123;ctp&#125;/permission/role/json/' + rid $.getJSON(url, fns) //将角色id保存到模态框的哪个属性中； //打开模态框将角色id传递给model里面的权限分配按钮 log('角色id===========&gt;', rid) $('#addPermissionBtn').attr("rid", rid) &#125; //成功回调函数，刷新权限树 var fns = function(data) &#123; log('成功返回数据', data) log('event==========&gt;', event) var ids = [] $.each(data.listCurrentPermission, function() &#123; ids.push(this.id) &#125;) log('ids===========&gt;', ids) //遍历每一条权限 $.each(data.listPermission, function() &#123; //给每一个节点修改或者添加一些属性 if (this.pid == 0) &#123; this.open = true &#125; if (ids.includes(this.id)) &#123; this.checked = true &#125; &#125;) var setting = &#123; data : &#123; simpleData : &#123; enable : true, idKey : "id", pIdKey : "pid", &#125;, key : &#123; url : "haha" &#125; &#125;, /* view : &#123; addDiyDom : showIcon &#125;, */ check : &#123; enable : true &#125; &#125; zTree = $.fn.zTree.init($("#permissionTree"), setting, data.listPermission) log('zTree赋值完成==========&gt;', zTree) &#125; //用于在节点上固定显示用户自定义控件 //?图标无法正常显示可能是字体样式没有引入进来 var showIcon = function(treeId, treeNode) &#123; log('自定义显示图标==============&gt;') log('treeId===============&gt;', treeId) log('treeNode===============&gt;', treeNode) //#permissionTree_10_ico $("#" + treeNode.tId + "_ico").removeClass() .addClass(treeNode.icon) &#125; //默认勾选当前角色的权限 var checkcurPermisson = function(rid) &#123; var url = '$&#123;ctp&#125;/permission/role/curPermission/' + rid $.getJSON(url, fns2) &#125; //获取当前角色权限成功回调函数 var fns2 = function(data) &#123; log('fns2===============&gt;') log('fns2_data================', data) //遍历当前角色拥有的权限 $.each(data, function() &#123; //$(this).attr('id') var node = zTree.getNodesByParam('id', this.id, null) log('使用zTree===========&gt;', zTree) log('当前角色拥有的权限=============&gt;', node) zTree.checkNode(node, true, false) log('是否选中=========&gt;', node.checked) node.nocheck = true //表示显示checkbox &#125;) &#125; //更新权限树 var updateTree = function() &#123; log('更新权限树===========&gt;') var rid = $('#addPermissionBtn').attr("rid") log('角色rid==========&gt;', rid) var permission_ids = '' //1、获取当前我们已经选中的权限 var nodes = zTree.getCheckedNodes(true) log('nodes=============&gt;', nodes) $.each(nodes, function() &#123; permission_ids += this.id + ',' &#125;) var url = '$&#123;ctp&#125;/permission/role/update?rid=' + rid + '&amp;permission_ids=' + permission_ids $.get(url, updateTreeFn) &#125; //更新权限树回调函数 var updateTreeFn = function(data) &#123; alert(data) log("权限分配成功===========&gt;"); $('#permissModel').modal("hide"); &#125; var addPermissionBtnEvent = function() &#123; $('#addPermissionBtn').click(function() &#123; log('点击分配权限按钮=============&gt;') updateTree() &#125;) &#125; var __main = function() &#123; assignPermissionEvent() addPermissionBtnEvent() &#125; $(function() &#123; __main() &#125;)&lt;/script&gt; 控制层： 123456789101112131415161718192021222324252627282930313233343536//分配权限@RequestMapping("/update") @ResponseBody public String updateRolePermission(@RequestParam("rid") Integer rid, @RequestParam("permission_ids") String permission_ids) &#123; System.out.println("更新权限==========&gt;"); System.out.println(rid); System.out.println(permission_ids); // 先删除该角色所有权限，在为该用户分配权限 boolean flag = rolePermissionService.updatePermission(rid, permission_ids); return flag ? "success" : "fail"; &#125; @RequestMapping("/curPermission/&#123;id&#125;") @ResponseBody public List&lt;TPermission&gt; getCurrentPermission(@PathVariable("id") Integer rid) &#123; System.out.println("当前角色拥有的权限==============&gt;"); List&lt;TPermission&gt; listPermission = permissionService.getPermissionsById(rid); System.out.println(listPermission); return listPermission; &#125;//查出角色拥有的权限、所有权限 @RequestMapping("/json/&#123;id&#125;") @ResponseBody public HashMap&lt;String, List&lt;TPermission&gt;&gt; getAllPermission(@PathVariable("id") Integer rid) &#123; List&lt;TPermission&gt; listPermission = permissionService.getPermissions(); List&lt;TPermission&gt; listCurrentPermission = permissionService.getPermissionsById(rid); HashMap&lt;String, List&lt;TPermission&gt;&gt; map = new HashMap&lt;&gt;(); map.put("listPermission", listPermission); map.put("listCurrentPermission", listCurrentPermission); return map; &#125; 业务层： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 更新权限树 @Override public boolean updatePermission(Integer rid, String permission_ids) &#123; // 删除角色权限 TRolePermissionExample tRolePermissionExample = new TRolePermissionExample(); Criteria criteria = tRolePermissionExample.createCriteria(); criteria.andRoleidEqualTo(rid); int count = mapper.deleteByExample(tRolePermissionExample); // 更新权限 if (permission_ids.contains(",")) &#123; String[] split = permission_ids.split(","); for (String permission_id : split) &#123; int i = Integer.parseInt(permission_id); TRolePermission rolePermission = new TRolePermission(); // 设置权限id rolePermission.setPermissionid(i); // 设置角色id rolePermission.setRoleid(rid); // 保存角色权限关系 mapper.insertSelective(rolePermission); &#125; &#125; else &#123; int i = Integer.parseInt(permission_ids); TRolePermission rolePermission = new TRolePermission(); // 设置权限id rolePermission.setPermissionid(i); // 设置角色id rolePermission.setRoleid(rid); // 保存角色权限关系 mapper.insertSelective(rolePermission); &#125; return true; &#125; // 为角色分配权限，查询所有权限 @Override public List&lt;TPermission&gt; getPermissions() &#123; List&lt;TPermission&gt; list_permission = mapper.selectByExample(null); return list_permission; &#125; @Override public List&lt;TPermission&gt; getPermissionsById(Integer rid) &#123; List&lt;TPermission&gt; list_permission = mapper.getRolePermission(rid); return list_permission; &#125;]]></content>
      <categories>
        <category>权限</category>
      </categories>
      <tags>
        <tag>ztree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易邮箱服务器发送电子邮件_搭建James邮件服务器发送电子邮件]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F13%2F%E7%BD%91%E6%98%93%E9%82%AE%E7%AE%B1%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6_%E6%90%AD%E5%BB%BAJames%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1、网易邮箱发送电子邮件 为了安全，网易邮箱开启pop3授权码验证，该授权码可以让客户端进行登录 qq开启授权码 https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;no=1001256&amp;&amp;id=28 实现：JavaMailAPI使用比较麻烦，这里采用的是Apache Commons Email 导入依赖 1234567&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-email --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-email&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 测试：A simple text email 1234567891011121314151617181920212223@Test public void test01() throws Exception &#123; SimpleEmail email = new SimpleEmail(); // 设置主机名，远程服务器的主机名 email.setHostName(&quot;smtp.163.com&quot;); email.setSmtpPort(25); // 设置登陆远程服务器的账号和pop3授权码 email.setAuthentication(&quot;15501892660@163.com&quot;, &quot;xxxxxxx&quot;); // 编写一个邮件 // 设置发送给谁 email.addTo(&quot;782125244@qq.com&quot;); // 设置这个邮件来源于哪里 email.setFrom(&quot;15501892660@163.com&quot;); // 设置邮件主题 email.setSubject(&quot;163发给qq的测试邮件 &quot;); // 设置邮件内容 email.setMsg(&quot;测试邮件&quot;); // 邮件发送 email.send(); &#125; 参考： http://commons.apache.org/proper/commons-email/userguide.html 2、搭建James邮件服务器 下载 https://archive.apache.org/dist/james/server/ quick-start http://james.apache.org/server/quick-start.html 解压 D:\devsoft\apache-james-3.0-beta4 建库 配置数据源 启动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101D:\devsoft\apache-james-3.0-beta4\bin&gt;run.batINFO 09:28:46,331 | org.apache.james.container.spring.context.JamesServerApplicationContext | Refreshing org.apache.james.container.spring.context.JamesServerApplicationContext@153f5a29: startup date [Thu Jan 03 09:28:46 CST 2019]; root of context hierarchyException in thread &quot;main&quot; org.springframework.beans.factory.BeanDefinitionStoreException: Failed to create the JAXB binder; nested exception is javax.xml.bind.JAXBException: Provider com.sun.xml.internal.bind.v2.ContextFactory could not be instantiated: com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition - with linked exception:[com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition] at org.apache.camel.spring.handler.CamelNamespaceHandler$CamelContextBeanDefinitionParser.doParse(CamelNamespaceHandler.java:258) at org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser.parseInternal(AbstractSingleBeanDefinitionParser.java:85) at org.springframework.beans.factory.xml.AbstractBeanDefinitionParser.parse(AbstractBeanDefinitionParser.java:59) at org.springframework.beans.factory.xml.NamespaceHandlerSupport.parse(NamespaceHandlerSupport.java:73) at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1419) at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1409) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:184) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:140) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:111) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.registerBeanDefinitions(XmlBeanDefinitionReader.java:493) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:390) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:334) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:302) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:174) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:209) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:180) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:243) at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:127) at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:93) at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:131) at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:522) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:436) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:139) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:93) at org.apache.james.container.spring.context.JamesServerApplicationContext.&lt;init&gt;(JamesServerApplicationContext.java:39) at org.apache.james.app.spring.JamesAppSpringMain.init(JamesAppSpringMain.java:61) at org.apache.james.app.spring.JamesAppSpringMain.main(JamesAppSpringMain.java:42)Caused by: javax.xml.bind.JAXBException: Provider com.sun.xml.internal.bind.v2.ContextFactory could not be instantiated: com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition - with linked exception:[com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition] at javax.xml.bind.ContextFinder.newInstance(ContextFinder.java:146) at javax.xml.bind.ContextFinder.find(ContextFinder.java:356) at javax.xml.bind.JAXBContext.newInstance(JAXBContext.java:431) at javax.xml.bind.JAXBContext.newInstance(JAXBContext.java:394) at org.apache.camel.spring.handler.CamelNamespaceHandler.createJaxbContext(CamelNamespaceHandler.java:187) at org.apache.camel.spring.handler.CamelNamespaceHandler.getJaxbContext(CamelNamespaceHandler.java:174) at org.apache.camel.spring.handler.CamelNamespaceHandler$CamelContextBeanDefinitionParser.doParse(CamelNamespaceHandler.java:256) ... 26 moreCaused by: com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition at com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException$Builder.check(IllegalAnnotationsException.java:91) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl.getTypeInfoSet(JAXBContextImpl.java:445) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl.&lt;init&gt;(JAXBContextImpl.java:277) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl.&lt;init&gt;(JAXBContextImpl.java:124) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl$JAXBContextBuilder.build(JAXBContextImpl.java:1123) at com.sun.xml.internal.bind.v2.ContextFactory.createContext(ContextFactory.java:147) at com.sun.xml.internal.bind.v2.ContextFactory.createContext(ContextFactory.java:271) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at javax.xml.bind.ContextFinder.newInstance(ContextFinder.java:171) at javax.xml.bind.ContextFinder.newInstance(ContextFinder.java:131) ... 32 moreD:\devsoft\apache-james-3.0-beta4\bin&gt; 123456789101112131415161718192021222324252627282930313233D:\devsoft\apache-james-3.0-beta4\bin&gt;run.batINFO 09:37:44,247 | org.apache.james.container.spring.context.JamesServerApplicationContext | Refreshing org.apache.james.container.spring.context.JamesServerApplicationContext@7ca48474: startup date [Thu Jan 03 09:37:44 CST 2019]; root of context hierarchylog4j:WARN No appenders could be found for logger (org.apache.commons.configuration.ConfigurationUtils).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.INFO 09:37:45,153 | org.apache.james.container.spring.context.JamesServerApplicationContext | Bean &apos;logprovider&apos; of type [class org.apache.james.container.spring.lifecycle.LogProviderImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)INFO 09:37:45,544 | james.mailrepositorystore | JamesMailStore init...INFO 09:37:45,550 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.file.FileMailRepository to handle file protocol requests for repositories with key fileINFO 09:37:45,550 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.jdbc.JDBCMailRepository to handle db protocol requests for repositories with key dbINFO 09:37:45,550 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.jdbc.JDBCMailRepository to handle dbfile protocol requests for repositories with key dbfileINFO 09:37:45,551 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.file.MBoxMailRepository to handle mbox protocol requests for repositories with key mboxINFO 09:37:45,936 | james.dnsservice | Autodiscovery is enabled - trying to discover your system&apos;s DNS ServersINFO 09:37:45,942 | james.dnsservice | Adding autodiscovered server 202.100.192.68INFO 09:37:45,942 | james.dnsservice | Adding autodiscovered server 202.100.199.8INFO 09:37:45,943 | james.dnsservice | DNS Server is: 202.100.192.68INFO 09:37:45,943 | james.dnsservice | DNS Server is: 202.100.199.8INFO 09:37:45,949 | james.dnsservice | Registered cache, resolver and search paths as DNSJava defaults12 James WARN [main] openjpa.Runtime - An error occurred while registering a ClassTransformer with PersistenceUnitInfo: name &apos;James&apos;, root URL [file:/D:/devsoft/apache-james-3.0-beta4/conf/]. The error has been consumed. To see it, set your openjpa.Runtime log level to TRACE. Load-time class transformation will not be available.INFO 09:37:55,187 | james.domainlist | Set autodetect to: trueINFO 09:37:55,187 | james.domainlist | Set autodetectIP to: true28 James INFO [main] openjpa.Runtime - Starting OpenJPA 2.1.052 James INFO [main] openjpa.jdbc.JDBC - Using dictionary class &quot;org.apache.openjpa.jdbc.sql.MySQLDictionary&quot;.Cannot load JDBC driver class &apos;com.mysql.jdbc.Driver&apos;java.lang.ClassNotFoundException: com.mysql.jdbc.Driver at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at org.apache.commons.dbcp.BasicDataSource.createConnectionFactory(BasicDataSource.java:1420) at org.apache.commons.dbcp.BasicDataSource.createDataSource(BasicDataSource.java:1371) at org.apache.commons.dbcp.BasicDataSource.getConnection(BasicDataSource.java:1044) 解决办法 D:\devsoft\apache-james-3.0-beta4\conf\lib：存放自己导入的jar D:\devsoft\apache-james-3.0-beta4\lib：存放James默认jar 复制jaxb-impl-2.1.3.jar，mysql驱动jar包到conf/lib下 设置服务器域名、建立账户 1234567D:\devsoft\apache-james-3.0-beta4\bin&gt; james-cli.bat -h localhost -p 9999 adddomain atguigu.comadddomain command executed sucessfully in 106 ms.D:\devsoft\apache-james-3.0-beta4\bin&gt; james-cli.bat -h localhost -p 9999 adduser test@atguigu.com testadduser command executed sucessfully in 94 ms. 配置Foxmail客户端连接James邮件服务器 测试： 123456789101112131415161718192021222324252627282930/** * 测试james发送邮件 * @Description (TODO这里用一句话描述这个方法的作用) * @throws Exception */ @Test public void test02() throws Exception&#123; SimpleEmail email = new SimpleEmail(); //设置主机名，远程服务器的主机名 email.setHostName("127.0.0.1"); //自定义的ip，一定要手动设置好端口号 email.setSmtpPort(25); //设置登陆远程服务器的密码 email.setAuthentication("test@atguigu.com", "000000"); //编写一个邮件 //设置发送给谁 email.addTo("17512080612@163.com"); //设置这个邮件来源于哪里 email.setFrom("admin@atguigu.com"); //设置邮件主题 email.setSubject("哈哈，给你测试 "); //设置邮件内容 email.setMsg("我能给您发邮件&lt;a href='http://www.atguigu.com'&gt;尚硅谷&lt;/a&gt;"); //邮件发送 email.send(); &#125;]]></content>
      <categories>
        <category>邮件服务器</category>
      </categories>
      <tags>
        <tag>email</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维矩阵显示账户类型和资质_ajax异步传参_插入mysql中文乱码]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F11%2F%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E6%98%BE%E7%A4%BA%E8%B4%A6%E6%88%B7%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%B5%84%E8%B4%A8_ajax%E5%BC%82%E6%AD%A5%E4%BC%A0%E5%8F%82_%E6%8F%92%E5%85%A5mysql%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1、二维矩阵显示账号类型和资质 效果： 表结构： 账号类型和资质中间表 资质表 思路： 业务层查出账户和资质中间表、资质表、账户表数据，前端展示图横轴根据账户数据填充，纵轴根据资质数据填充，选择框的确定–根据账户资质中间表数据和选择框上自定义属性绑定的账户名、资质id进行相等比较确定。 前端： 1）单选框勾选关系初始化 2）异步传参(封装成实体) 实体对象必须有get和set方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120 &lt;body&gt; &lt;% //设置导航条上的显示 pageContext.setAttribute("navinfo", "分类管理"); //设置点击高亮效果 pageContext.setAttribute("curUrl", "servicectrl/type/ctrl"); %&gt; &lt;!--引入导航条 --&gt; &lt;%@include file="/WEB-INF/includes/nav-bar.jsp"%&gt; &lt;div class="container-fluid"&gt; &lt;div class="row"&gt; &lt;!--引入树形菜单 --&gt; &lt;%@include file="/WEB-INF/includes/user_menu.jsp"%&gt; &lt;div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main"&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt; &lt;i class="glyphicon glyphicon-th"&gt;&lt;/i&gt; 数据矩阵 &lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;div class="table-responsive"&gt; &lt;table class="table table-bordered"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;名称&lt;/th&gt; &lt;c:forEach items="$&#123;types&#125;" var="type"&gt; &lt;th&gt;$&#123;type&#125;&lt;/th&gt; &lt;/c:forEach&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items="$&#123;certs&#125;" var="cert"&gt; &lt;tr&gt; &lt;td&gt;$&#123;cert.name&#125;&lt;/td&gt; &lt;c:forEach items="$&#123;types&#125;" var="type"&gt; &lt;td&gt;&lt;input class='checkSimple' type="checkbox" type_name='$&#123;type&#125;' cid='$&#123;cert.id&#125;'&gt;&lt;/td&gt; &lt;/c:forEach&gt; &lt;/c:forEach&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%@include file="/WEB-INF/includes/js-file.jsp"%&gt; &lt;!-- 引入树形菜单结构点击时动态显示页面高亮效果的js --&gt; &lt;%@include file="/WEB-INF/includes/common-js.jsp"%&gt; &lt;script type="text/javascript"&gt; $(function() &#123; $(".list-group-item").click(function() &#123; if ($(this).find("ul")) &#123; $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) &#123; $("ul", this).hide("fast"); &#125; else &#123; $("ul", this).show("fast"); &#125; &#125; &#125;) &#125;) $(function() &#123; //页面加载完成获取账户类型和资质的关系 var list_type_cert = '$&#123;list_type_cert_json&#125;' log('list_type_cert', list_type_cert) //string log('list_type_cert type=======&gt;', typeof (list_type_cert)) //JSON.parse(list_type_cert) 字符串转成json对象 $.each(JSON.parse(list_type_cert),function(index, content) &#123; log(index, content, content.accttype,content.certid) $('.checkSimple').each(function() &#123; //attr获取自定义属性值 if ($(this).attr('type_name') == (content.accttype)&amp;&amp; $(this).attr('cid') == (content.certid)) &#123; //设置原生属性值 $(this).prop('checked',true) &#125; &#125;) &#125;) //执行事件 __main() &#125;) //更新 var update_type_cert_event = function() &#123; var tAccountTypeCert = &#123;&#125; log('update_type_cert_event=============&gt;') $('body').on('click', 'input', function() &#123; log('update==========&gt;', this) var flag = $(this).prop('checked') log('flag==========&gt;', flag) accttype = $(this).attr('type_name') certid = $(this).attr('cid') log(accttype, certid) tAccountTypeCert.accttype = accttype tAccountTypeCert.certid = certid tAccountTypeCert.flag = flag var url = '$&#123;ctp&#125;/servicectrl/type/update_type_cert' var data = tAccountTypeCert $.getJSON(url, data, function(result) &#123; log(result) &#125;) &#125;) &#125; var __main = function() &#123; update_type_cert_event() &#125; &lt;/script&gt;&lt;/body&gt; 控制层： 1)接收异步传参实体返回json 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.atguigu.scw.manager.controller.manager;import java.util.Arrays;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import com.atguigu.scw.manager.bean.TAccountTypeCert;import com.atguigu.scw.manager.bean.TCert;import com.atguigu.scw.manager.service.CertService;import com.atguigu.scw.manager.service.CertTypeService;import com.fasterxml.jackson.databind.ObjectMapper;@Controller@RequestMapping("/servicectrl/type")public class TypeController &#123; @Autowired CertService certService; @Autowired CertTypeService cTypeService; private static ObjectMapper MAPPER = new ObjectMapper(); @RequestMapping("/ctrl") public String list(Model model) throws Exception &#123; System.out.println("分类管理界面============&gt;"); // 1、先去数据库查出表格横向的显示数据 List&lt;String&gt; types = Arrays.asList("商业公司", "个体工商户", "个人经营", "政府及非营利组织"); // 2、在查出纵向要显示的标题 List&lt;TCert&gt; certs = certService.getAllCert(); System.out.println("资质===========&gt;"); System.out.println(certs); // 3、查询经营类型与资质关系中间表 // List&lt;TAccountTypeCert&gt; cTypeService.getAllCertType(); List&lt;TAccountTypeCert&gt; list_type_cert = cTypeService.getAllCertType(); System.out.println("经营类型===============&gt;"); System.out.println(list_type_cert); // 4、将数据放到模型域当中 model.addAttribute("types", types); model.addAttribute("certs", certs); // list转json字符串 String list_type_cert_json = MAPPER.writeValueAsString(list_type_cert); System.out.println("经营类型--资质----"); System.out.println(list_type_cert_json); model.addAttribute("list_type_cert_json", list_type_cert_json); return "manager/servicemanager/type"; &#125; @RequestMapping("/update_type_cert") @ResponseBody public String update_type_cert(TAccountTypeCert tAccountTypeCert) &#123; System.out.println("更新经营类型---资质==========&gt;"); System.out.println(tAccountTypeCert); boolean flag = tAccountTypeCert.isFlag(); System.out.println("flag============&gt;"); System.out.println(flag); if (flag) &#123; System.out.println("增加一条记录========&gt;"); int count = cTypeService.updateTypeCert(tAccountTypeCert); &#125; else &#123; System.out.println("移除一条记录========&gt;"); cTypeService.removeTypeCert(tAccountTypeCert); &#125; return "success"; &#125;&#125; 业务层： 1）单表的写读操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.atguigu.scw.manager.service.impl;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.atguigu.scw.manager.bean.TAccountTypeCert;import com.atguigu.scw.manager.bean.TAccountTypeCertExample;import com.atguigu.scw.manager.bean.TAccountTypeCertExample.Criteria;import com.atguigu.scw.manager.dao.TAccountTypeCertMapper;import com.atguigu.scw.manager.service.CertTypeService;@Servicepublic class CertTypeServiceImpl implements CertTypeService &#123; @Autowired TAccountTypeCertMapper mapper; //查询资质和账户中间表 @Override public List&lt;TAccountTypeCert&gt; getAllCertType() &#123; List&lt;TAccountTypeCert&gt; list_type_cert = mapper.selectByExample(null); return list_type_cert; &#125; // 增加经营类型--资质 @Override public int updateTypeCert(TAccountTypeCert tAccountTypeCert) &#123; int count = mapper.insertSelective(tAccountTypeCert); return count; &#125; // 删除经营类型--资质 @Override public int removeTypeCert(TAccountTypeCert tAccountTypeCert) &#123; TAccountTypeCertExample example = new TAccountTypeCertExample(); Criteria criteria = example.createCriteria(); criteria.andAccttypeEqualTo(tAccountTypeCert.getAccttype()); criteria.andCertidEqualTo(tAccountTypeCert.getCertid()); int count = mapper.deleteByExample(example); return count; &#125;&#125; 2、mysql插入中文乱码 1）数据库编码和web.xml配置均为utf-8，Controller读取到的是正确的中文，但是保存到数据库后变成”??” 解决 12&lt;property name="url" value="jdbc:mysql://localhost:3306/scw_0325?useUnicode=true&amp;amp;characterEncoding=UTF-8" &gt;&lt;/property&gt;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>ajax -	ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ztree树形结构菜单_mybatis分页查询]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F10%2Fztree%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E8%8F%9C%E5%8D%95_mybatis%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[1、二级树形菜单 效果图 表结构 业务层： 二级菜单实现思路： 1）查出父菜单（pid=0），通过遍历父菜单获得父菜单(id)，根据父菜单id值作为条件查出子菜单（子菜单pid=父菜单id），接着整理父子菜单关系；这种不推荐，假如所有菜单为18个，查出父菜单3个封装到集合时需要遍历18次，根据父菜单id作为查询子菜单的条件需要遍历3*18次。 2）一次性查出所有菜单18个，使用程序进行组合，这种推荐，以空间换时间。 封装菜单实体 业务层： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public List&lt;TPermission&gt; getAllMenus() &#123; // 保存父菜单 List&lt;TPermission&gt; menus = new ArrayList&lt;TPermission&gt;(); Map&lt;Integer, TPermission&gt; map = new HashMap&lt;Integer, TPermission&gt;(); // 查询所有菜单 // 参数为null，表示不带条件查询菜单 List&lt;TPermission&gt; list = mapper.selectByExample(null); System.out.println("所有菜单=========&gt;"); System.out.println(list); // 1、将所有菜单都放在map中 // 都是引用，如果从map中拿到这个数据改变以后，map中页面变化 for (TPermission tPermission : list) &#123; map.put(tPermission.getId(), tPermission); &#125; // 2、先封装父菜单，再将子菜单放入到父菜单中 for (TPermission tPermission : list) &#123; if (tPermission.getPid() == 0) &#123; menus.add(tPermission); &#125; else &#123; // tPermission（子菜单），拿到父菜单 Integer pid = tPermission.getPid(); // 拿到父菜单；以pid的值作为map中的菜单id，就是父菜单 TPermission p_menu = map.get(pid); // 拿到当前父菜单的子菜单；子菜单会有一些额外的问题 // 这个list第一次获取是没有的，如果添加上一次以后。这个list是有的 List&lt;TPermission&gt; childs = p_menu.getChilds(); if (childs != null) &#123; // 当前有子菜单 childs.add(tPermission); &#125; else &#123; // 当前没有子菜单 childs = new ArrayList&lt;&gt;(); // 添加当前子菜单 childs.add(tPermission); // 将当前整理好的childs设置进去 p_menu.setChilds(childs); &#125; &#125; &#125; System.out.println("父菜单===========&gt;"); System.out.println(menus); return menus;&#125; 控制层 1）将整理好的父子菜单数据放入到session域中，当前用户的这次会话一直使用，只需要去数据库查询一次 12345678910111213141516171819202122232425@RequestMapping(value = "/main.html")public String toMainPage(HttpSession session) &#123; // 校验 // 判断session中是否有这个用户，如果没有去登陆页面 Object object = session.getAttribute(Constants.LOGIN_USER); if (object == null) &#123; // 用户没登陆 return "redirect:/login.jsp"; &#125; else &#123; // 用户登陆才来到主页，session中没有菜单，或者菜单被我们从session中清除了 if (session.getAttribute(Constants.USER_MENUS) == null) &#123; // 1、查出所有菜单，在页面进行显示 List&lt;TPermission&gt; menus = ps.getAllMenus(); // 2、将查到的菜单放在session域中 // 菜单这些数据没必要每次来到主页，都调用service方法进行查询；放在session用户， // 当前用户的这次会话一直使用，只需要去数据库查一次 session.setAttribute(Constants.USER_MENUS, menus); &#125; return "manager/main"; &#125;&#125; 前台： 1）引入：&lt;%@ taglib prefix=”fn” uri=”http://java.sun.com/jsp/jstl/functions&quot;%&gt;计算后台传过来的list集合的长度：${fn:length(p_menu.childs)} 123456789101112131415161718192021222324252627&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions"%&gt;&lt;div class="col-sm-3 col-md-2 sidebar"&gt; &lt;div class="tree"&gt; &lt;ul style="padding-left: 0px;" class="list-group"&gt; &lt;li class="list-group-item tree-closed"&gt;&lt;a href="main.html"&gt;&lt;i class="glyphicon glyphicon-dashboard"&gt;&lt;/i&gt; 控制面板&lt;/a&gt;&lt;/li&gt; &lt;!-- 遍历父菜单 --&gt; &lt;c:forEach items="$&#123;sessionScope.userMenus&#125;" var="p_menu"&gt; &lt;li class="list-group-item tree-closed"&gt;&lt;span&gt;&lt;i class="$&#123;p_menu.icon&#125;"&gt;&lt;/i&gt;$&#123;p_menu.name&#125; &lt;span class="badge" style="float: right"&gt;$&#123;fn:length(p_menu.childs)&#125;&lt;/span&gt;&lt;/span&gt; &lt;ul style="margin-top: 10px; display: none;"&gt; &lt;!-- 遍历子菜单 --&gt; &lt;c:forEach items="$&#123;p_menu.childs&#125;" var="c_menu"&gt; &lt;li style="height: 30px;"&gt;&lt;a href="$&#123;ctp&#125;/$&#123;c_menu.url&#125;" data-action="$&#123;c_menu.id&#125;"&gt;&lt;i class="$&#123;c_menu.icon&#125;"&gt;&lt;/i&gt;$&#123;c_menu.name&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:forEach&gt; &lt;/ul&gt;&lt;/li&gt; &lt;/c:forEach&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 2、mybatis分页查询 根据用户名或者账号进行查询 效果图： 引入依赖： 123456&lt;!-- 分页 插件 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;&lt;/dependency&gt; 业务层： 1）带条件查询 123456789101112131415161718@Overridepublic List&lt;TUser&gt; getAllUsersByCondition(String str) &#123; System.out.println("UserServiceImpl.getAllUsersByCondition 带条件查询员工============&gt;"); // 查询条件拼接 // 第一次创建的条件，默认使用and连接的 TUserExample tUserExample = new TUserExample(); Criteria criteria = tUserExample.createCriteria(); Criteria criteria2 = tUserExample.createCriteria(); if (!str.trim().equals("")) &#123; criteria.andLoginacctLike("%" + str + "%"); criteria.andUsernameLike("%" + str + "%"); &#125; tUserExample.or(criteria2); List&lt;TUser&gt; list_users_example = userMapper.selectByExample(tUserExample); return list_users_example;&#125; 控制层： 1）mybatis分页插件会对结果集进行包装，必须在查询前设置： PageHelper.startPage(pn, ps); 2）查询后输入框数据回显：model.addAttribute(“sp”, search);（转发） 1234567891011121314151617181920212223242526@RequestMapping("/list")public String users(@RequestParam(value = "pn", defaultValue = "1") Integer pn, @RequestParam(value = "ps", defaultValue = "5") Integer ps, @RequestParam(value = "sp", defaultValue = "") String search, Model model) &#123; System.out.println("UserController.users 用户列表显示页===========&gt;"); System.out.println("前台请求参数[第xxx页，每页显示xxx条数]==========&gt;"); System.out.println(pn); System.out.println(ps); // 分页显示数据,这里设置必须放到查询数据之前，否则前台会有问题 PageHelper.startPage(pn, ps); List&lt;TUser&gt; list_users = userService.getAllUsersByCondition(search); System.out.println("查询到的所有用户列表========&gt;"); System.out.println(list_users); PageInfo&lt;TUser&gt; users = new PageInfo&lt;&gt;(list_users, 5); System.out.println("分页后的数据处理"); System.out.println(users); // 将查询用户列表数据放在请求域中，表单查询参数回显到页面 model.addAttribute("users", users); model.addAttribute("sp", search); return "manager/permission/user";&#125; 前台： 1）为所有分页连接绑定单击事件，让其动态的带上分页的查询参数 123var href = $(this).attr("href") + "&amp;sp="+ $("input[name='sp']").val()&lt;br/&gt;$(this).attr("href", href) 2)全选和全不选函数 1234567891011121314//全选/全不选函数function checkall_reverse(check_all_btn, check_btn) &#123; check_all_btn.click(function() &#123; //如果是原生的属性，使用prop获取比较好 check_btn.prop("checked", $(this).prop("checked")) &#125;) check_btn.click(function() &#123; //当check_btn点满以后check_all_btn勾上，否则不选中 //获取被选中的checkbtn个数 var flag = check_btn.filter(":checked").length == check_btn.length check_all_btn.prop("checked", flag); &#125;)&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html lang="UTF-8"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;&lt;meta name="description" content=""&gt;&lt;meta name="author" content=""&gt;&lt;%@include file="/WEB-INF/includes/css-file.jsp"%&gt;&lt;link rel="stylesheet" href="$&#123;ctp&#125;/css/main.css"&gt;&lt;style&gt;.tree li &#123; list-style-type: none; cursor: pointer;&#125;table tbody tr:nth-child(odd) &#123; background: #F4F4F4;&#125;table tbody td:nth-child(even) &#123; color: #C00;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;% //设置导航条上的显示 pageContext.setAttribute("navinfo", "用户维护"); //设置点击高亮效果 pageContext.setAttribute("curUrl", "permission/user/list"); %&gt; &lt;!-- 引入navbar--&gt; &lt;%@include file="/WEB-INF/includes/nav-bar.jsp"%&gt;&lt;/nav&gt; &lt;div class="container-fluid"&gt; &lt;div class="row"&gt; &lt;!-- 引入树形菜单 --&gt; &lt;%@include file="/WEB-INF/includes/user_menu.jsp"%&gt; &lt;div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main"&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt; &lt;i class="glyphicon glyphicon-th"&gt;&lt;/i&gt; 数据列表 &lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;form class="form-inline" role="form" style="float: left;" action="$&#123;ctp &#125;/permission/user/list" method="post"&gt; &lt;div class="form-group has-feedback"&gt; &lt;div class="input-group"&gt; &lt;div class="input-group-addon"&gt;查询条件&lt;/div&gt; &lt;input class="form-control has-success" type="text" name="sp" placeholder="用户名/账号查询" value="$&#123;sp&#125;"&gt; &lt;/div&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-warning"&gt; &lt;i class="glyphicon glyphicon-search"&gt;&lt;/i&gt; 查询 &lt;/button&gt; &lt;/form&gt; &lt;button type="button" class="btn btn-danger" style="float: right; margin-left: 10px;"&gt; &lt;i class=" glyphicon glyphicon-remove"&gt;&lt;/i&gt; 删除 &lt;/button&gt; &lt;button type="button" class="btn btn-primary" style="float: right;" onclick="window.location.href='add.html'"&gt; &lt;i class="glyphicon glyphicon-plus"&gt;&lt;/i&gt; 新增 &lt;/button&gt; &lt;br&gt; &lt;hr style="clear: both;"&gt; &lt;div class="table-responsive"&gt; &lt;table class="table table-bordered"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th width="30"&gt;#&lt;/th&gt; &lt;th width="30"&gt;&lt;input type="checkbox" id="checkall_btn"&gt;&lt;/th&gt; &lt;th&gt;账号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;邮箱地址&lt;/th&gt; &lt;th width="100"&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items="$&#123;users.list&#125;" var="user"&gt; &lt;tr&gt; &lt;td&gt;$&#123;user.id&#125;&lt;/td&gt; &lt;td&gt;&lt;input type="checkbox" class="single_check"&gt;&lt;/td&gt; &lt;td&gt;$&#123;user.loginacct &#125;&lt;/td&gt; &lt;td&gt;$&#123;user.username &#125;&lt;/td&gt; &lt;td&gt;$&#123;user.email &#125;&lt;/td&gt; &lt;td&gt; &lt;button type="button" class="btn btn-success btn-xs"&gt; &lt;i class=" glyphicon glyphicon-check"&gt;&lt;/i&gt; &lt;/button&gt; &lt;button type="button" class="btn btn-primary btn-xs"&gt; &lt;i class=" glyphicon glyphicon-pencil"&gt;&lt;/i&gt; &lt;/button&gt; &lt;button type="button" class="btn btn-danger btn-xs"&gt; &lt;i class=" glyphicon glyphicon-remove"&gt;&lt;/i&gt; &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td colspan="6" align="center"&gt; &lt;ul class="pagination"&gt; &lt;!-- 即使点击分页连接也应该带上查询条件的值 --&gt; &lt;!-- 给分页超链接绑定单击事件； --&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=1"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;!-- 是否还有前一页 --&gt; &lt;c:if test="$&#123;users.hasPreviousPage&#125;"&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;users.prePage&#125;"&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;!-- 遍历页数 --&gt; &lt;c:forEach items="$&#123;users.navigatepageNums&#125;" var="pn"&gt; &lt;!-- 当前页 --&gt; &lt;c:if test="$&#123;pn==users.pageNum &#125;"&gt; &lt;li class="active"&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;pn&#125;"&gt;$&#123;pn&#125;&lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;c:if test="$&#123;pn != users.pageNum &#125;"&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;pn&#125;"&gt;$&#123;pn &#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;!--是否还有下一页 --&gt; &lt;c:if test="$&#123;users.hasNextPage&#125;"&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;users.nextPage&#125;"&gt;下一页&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;users.pages&#125;"&gt;末页&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%@include file="/WEB-INF/includes/js-file.jsp"%&gt; &lt;!-- 引入树形菜单结构点击时动态显示页面高亮效果的js --&gt; &lt;%@include file="/WEB-INF/includes/common-js.jsp"%&gt; &lt;script type="text/javascript"&gt; $(function() &#123; $(".list-group-item").click(function() &#123; if ($(this).find("ul")) &#123; $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) &#123; $("ul", this).hide("fast"); &#125; else &#123; $("ul", this).show("fast"); &#125; &#125; &#125;); &#125;); $("tbody .btn-success").click(function() &#123; window.location.href = "assignRole.html"; &#125;); $("tbody .btn-primary").click(function() &#123; window.location.href = "edit.html"; &#125;); //当前页面所在的哪个超链接是color:red //他的父list-group-item. tree-closed是没有的 //找到当前页面的a连接 //使用css为某个元素加样式 list-group-item //为所有分页连接绑定单击事件，让其动态的带上分页的查询参数 $(".pagination").find("a").click( function() &#123; //1、获取到查询表单的查询参数 //不禁用默认行为，而是为超链接多拼装上查询条件 //为超链接动态拼装查询条件 var href = $(this).attr("href") + "&amp;sp=" + $("input[name='sp']").val() $(this).attr("href", href) &#125;) //这是调用了抽取过来的方法； checkall_reverse($("#checkall_btn"), $(".single_check")) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>权限</category>
      </categories>
      <tags>
        <tag>ztree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svn版本控制]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F09%2Fsvn%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1、svn下载 https://sourceforge.net/projects/win32svn/ 2、验证是否安装成功 12C:\Users\libingshen&gt;svn --version 3、创建版本库 12D:\mytest\mysvn\OA&gt;svnadmin create D:\mytest\mysvn\OA 4、启动svn服务 5、验证svn服务是否启动 svn服务监听3690端口 6、svn注册为Windows服务 tip:等号左边没有空格，等号右边有一个空格。 12C:\WINDOWS\system32&gt;sc create MySVNService binpath= &quot;C:\Pmyprogram\svn\bin\svnserve.exe --service -r D:\mytest\mysvn&quot; start= auto depend= Tcpip 原因：每次启动svn服务时必须启动一个cmd窗口，cmd窗口一关闭，svn服务就关闭。 非管理员运行时会失败。 管理员运行 启动、停止、删除svn服务（管理员身份运行cmd） 123456789//启动svn服务C:\WINDOWS\system32&gt;sc start MySVNService//停止服务C:\WINDOWS\system32&gt;sc stop MySVNService//删除服务C:\WINDOWS\system32&gt;sc delete MySVNService 7、检出项目 12D:\mytest\mycheckout&gt;svn checkout svn://localhost/OA MyOA 8、提交文件 –开启匿名权限访问 –先将文件加入版本库，然后提交（需添加提交日志信息，不然报错） svn commit 命令最后可以不指定具体文件，此时表示提交当前工作副本中的所有修改 9、更新 另一个客户端检出项目、更新并提交文件 1234//远程版本库具体位置 svn://localhost/OA//将OA检出到本地的目录 MyOA2D:\mytest\mycheckout&gt;svn checkout svn://localhost/OA MyOA2 10、授权访问版本库 –单版本库开启授权访问 –多版本库开启授权访问 123456在版本库根目录 D:\mytest\mysvn 下创建 commConf 目录将未修改的 authz 和 passwd 文件拷贝到 commConf 目录下修改需要设置权限的版本库的 svnserve.conf 文件①password-db = ../../commConf/passwd②authz-db = ../../commConf/authz passwd：设置访问版本库的用户信息 authz：设置用户访问版本库的权限]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc配置]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F07%2Fspringmvc%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1、springmvc路径跳转配置 目录结构 控制层 123456789101112131415161718192021&lt;!-- 使用注解开发，不用配置controller，需要配置一个组件扫描器 --&gt;&lt;context:component-scan base-package="com.*" /&gt;&lt;!-- 视图解析器 --&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置从项目根目录到指定目录一端路径 ,建议指定浅一点的目录 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"&gt;&lt;/property&gt; &lt;!-- 文件的后缀名 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--将index2.jsp放在/WEB-INF/jsp/目录下，请求index2时不经过controller处理;配置了mvc:view-controller后需要配置mvc:annotation-driven,不然走controller的请求会失效 --&gt;&lt;mvc:view-controller path="/index2" view-name="index2" /&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;!--处理静态资源 --&gt;&lt;mvc:default-servlet-handler/&gt; index.jsp 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page language="java" contentType="text/html; charset=ISO-8859-1" pageEncoding="ISO-8859-1"%&gt;&lt;%@ taglib uri="http://java.sun.com/jstl/core_rt" prefix="c"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="ISO-8859-1"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;% request.setAttribute("path", request.getContextPath());%&gt;&lt;/head&gt;&lt;body&gt; //走controller跳转 &lt;a href="hello"&gt;go controller&lt;/a&gt; &lt;br&gt; //不走controller跳转，在springmvc配置文件中配置了mvc-view;index2.jsp页面需放在/WEB-INF/jsp/目录下 &lt;a href="index2"&gt;not go controller&lt;/a&gt; &lt;br/&gt; //加载静态资源 &lt;a href="$&#123;path&#125;/static/index3.jsp"&gt;load static resource index3.jsp&lt;/a&gt; //加载静态资源，需在springmvc配置文件中配置mvc:default-servlet-handler &lt;script type="text/javascript" src="$&#123;path&#125;/ui/jquery/jquery-1.8.3.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function() &#123; console.log("$&#123;path&#125;") &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、springmvc获取请求参数，封装数据到请求域 前台 123456&lt;form action='testParam' method='get'&gt; 用户名：&lt;input type='text' name='username'&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; 控制层 处理方式一：方法参数为Map或者ModelMap类型，数据封装到Map或者Modelmap类型中，其实就是将数据放入到请求域当中 123456789101112@RequestMapping("/testParam")public String testParam(ModelMap modelMap,HttpServletRequest request) &#123; String username = request.getParameter("username"); System.out.println("接收前台发送过来的请求参数=========&gt;用户名："+username); //modelmap会将数据放到请求域当中 modelMap.put("address", "haikou"); //返回视图 return "hello";&#125; 处理方式二：用ModelAndView作为返回值，可以将数据放到请求域中且指定返回的视图 1234567891011@RequestMapping("/testParam")public ModelAndView testParam(HttpServletRequest request) &#123; String username = request.getParameter("username"); System.out.println("接收前台发送过来的请求参数=========&gt;用户名："+username); //参数为返回的视图 ModelAndView hello =new ModelAndView("hello"); hello.addObject("address", "haikou"); return hello;&#125; 前台获取 1234&lt;!-- 获取后台封装在请求域中的数据 --&gt;地址：$&#123;requestScope.address&#125;&lt;br/&gt;&lt;%=request.getAttribute(&quot;address&quot;)%&gt; 3、springmvc处理文件上传 springmvc.xml增加如下配置 1234567&lt;!--文件上传 --&gt;&lt;bean name="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="defaultEncoding" value="UTF-8"&gt;&lt;/property&gt; &lt;property name="maxUploadSize" value="10240000"&gt;&lt;/property&gt;&lt;/bean&gt; 前台表单提交 123456//必须是post请求，且enctype='multipart/form-data'&lt;form action='testFileUpload' method='post' enctype='multipart/form-data'&gt; 文件：&lt;input type='file' name='file' &gt;&lt;br/&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; 控制层 12345678910@RequestMapping("/testFileUpload")public String testFileUpload(@RequestParam("file")MultipartFile file) throws IOException &#123; //获取文件名 String fileName=file.getOriginalFilename(); //获取流，即可取得内容 InputStream in=file.getInputStream(); System.out.println("文件名===========&gt;"+fileName); return "hello";&#125; 4、springmvc返回json数据 pom.xml加入依赖 12345678910111213141516171819&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; 控制层 12345678910//需要加@ResponseBody注解@RequestMapping("/testJson")@ResponseBodypublic Map testFileUpload() &#123; Map&lt;String, Object&gt; map=new HashMap&lt;&gt;(); map.put("username", "沈利兵"); map.put("sex", "男"); return map;&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my_en]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F06%2Fmy_en%2F</url>
    <content type="text"><![CDATA[english2018121412345678910111213141516171819202122232425262728293031323334353637383940414243eviction --赶出thorough --彻底fixed --固定notifications --通知traverse graphs --遍历图covers --覆盖block --阻塞Redis Releases --Redis 发布Benchmarks --基准Latency monitoring --延迟监控tune --调整High Availability --高可用性Signals Handling --信号处理Administration --管理troubleshoot --解决Troubleshooting --故障排除command line interface --命令行界面durability --持久力Credits --积分Sponsors --赞助商Trademark --商标Lexicographical order --字典顺序populated --填充reply --答复、回复indicating --指示、说明penultimate --倒数第二treat --对待、视其为abstractions --抽象separately --单独、分别地retrieve --检索、取出bitmaps --位图probabilistic --概率estimate --估计cardinality --基数scared --害怕trivial --不重要的、微不足道的crash course --速成班specification --规范Prerequisites --先决条件clause --条款、子句omit --忽略semantics --语义 20181215 参考https://tylermcginnis.com/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/ 123456789101112131415161718192021222324252627opinion --观点properly --正确地strategy --策略interpret --解释authoring --创作form --形式consist of --包括responsibilities --责任spot --点、发现key --关键phases --阶段deserve --值得cement --巩固Hoisting --提升exactly identical --完全相同fairly comfortable --相当熟悉adapt --调整、适应Set up memory space --设置内存空间Execution Stack --执行堆栈Call Stack --调用堆栈intuition --直觉scenario --脚本misunderstood --误解Implicit Binding --隐式绑定Explicit Binding --显示绑定Lexical Binding --词法绑定 20181217参考 https://dev.to/siwalik/async-programming-basics-every-js-developer-should-know-in-2018-a9c 123hence --于是imensely --非常 20190117参考： https://docs.python.org/3/library/stdtypes.html#comparisons 123456Comparisons --比较Comparisons can be chained arbitrarily --比较可以任意连接negated --否定notion --概念、主张raise --养、引发 https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range 12345678ascending --升序restrictions --限制imposed --加强lexicographically --字典顺序multidimensional list --多维列表Immutable Sequence Types --不可变序列类型slice --切片 20190523来源： Jekyll • Simple, blog-aware, static sites | Transform your plain text into static websites and blogs 1234567891011121314151617181920212223Sick 厌倦custom domain name 自定义域名pesky 讨厌omment moderation 评论审核Permalinks 永久链接Migrate your blog 迁移你的博客site scaffold 站点脚手架metadata file 元数据文件Front Matter 前方问题Assets 资产SITE STRUCTURE 现场结构Liquid 液体Pagination 分页extendable 扩展static site generator 静态站点生成器churns 搅动tweak 拧tweaks 调整unearthed 发现regarding 关于nstallation wizard 安装向导Command Prompt instance 命令提示符实例code snippets 代码片段 201906031234the related materials used in this book 本书中使用的相关资料Protocol Analysis Institute 方案分析研究所warranty 担保Dedication 奉献]]></content>
      <categories>
        <category>词汇</category>
      </categories>
      <tags>
        <tag>english</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven配置]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F05%2Fmaven%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1、下载： https://maven.apache.org/download.cgi 2、配置path环境变量 3、验证安装是否成功 4、配置本地仓库、阿里镜像、jdk编译版本 配置本地仓库位置 12&lt;localRepository&gt;C:\greensoft\apache-maven-3.5.2\repository&lt;/localRepository&gt; 配置jar包下载阿里远程镜像 1234567&lt;mirror&gt; &lt;id&gt;aliyun-maven&lt;/id&gt; &lt;name&gt;aliyun-maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 配置jdk编译版本 12345678910111213&lt;profile&gt; &lt;id&gt;jdk-1.7&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.7&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 5、eclipse整合maven 使用自己的maven安装包 6、IDEA整合maven]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js面向对象_箭头函数this_数组常用方法]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F04%2Fjs%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this_%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、js面向对象 1)传统的面向对象 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function Person(name, age)&#123; this.name=name; this.age=age; &#125; Person.prototype.showName=function ()&#123; alert('我叫'+this.name); &#125;; Person.prototype.showAge=function ()&#123; alert('我'+this.age+'岁'); &#125;; let p=new Person('blue', 18); p.showName(); p.showAge(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function Person(name, age)&#123; this.name=name; this.age=age; &#125; Person.prototype.showName=function ()&#123; alert('我叫'+this.name); &#125;; Person.prototype.showAge=function ()&#123; alert('我'+this.age+'岁'); &#125;; //------------------------------------------------ function Worker(name, age, job)&#123; //通过call调用父类构造函数 Person.call(this, name, age); this.job=job; &#125; //使得子类实例对象共享父类原型对象上的方法 Worker.prototype=new Person(); //重写子类原型对象的构造，特别恶心 Worker.prototype.constructor=Worker; Worker.prototype.showJob=function ()&#123; alert('我是做：'+this.job); &#125;; let w=new Worker('blue', 18, '打杂的'); w.showName(); w.showAge(); w.showJob(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2）js标准的面向对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /*function Person(name, age)&#123; this.name=name; this.age=age; &#125; Person.prototype.showName=function ()&#123; alert('我叫'+this.name); &#125;; Person.prototype.showAge=function ()&#123; alert('我'+this.age+'岁'); &#125;;*/ //标准面向对象书写方式 class Person&#123; constructor(name, age)&#123; this.name=name; this.age=age; &#125; showName()&#123; alert('我叫'+this.name); &#125; showAge()&#123; alert('我'+this.age+'岁'); &#125; &#125; let p=new Person('blue', 18); p.showName(); p.showAge(); //------------------------------------------------ function Worker(name, age, job)&#123; Person.call(this, name, age); this.job=job; &#125; Worker.prototype=new Person(); Worker.prototype.constructor=Worker; Worker.prototype.showJob=function ()&#123; alert('我是做：'+this.job); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 标准的继承方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /*function Person(name, age)&#123; this.name=name; this.age=age; &#125; Person.prototype.showName=function ()&#123; alert('我叫'+this.name); &#125;; Person.prototype.showAge=function ()&#123; alert('我'+this.age+'岁'); &#125;;*/ //标准面向对象书写方式 class Person&#123; constructor(name, age)&#123; this.name=name; this.age=age; &#125; showName()&#123; alert('我叫'+this.name); &#125; showAge()&#123; alert('我'+this.age+'岁'); &#125; &#125; /*let p=new Person('blue', 18); p.showName(); p.showAge();*/ //------------------------------------------------ /*function Worker(name, age, job)&#123; Person.call(this, name, age); this.job=job; &#125; Worker.prototype=new Person(); Worker.prototype.constructor=Worker; Worker.prototype.showJob=function ()&#123; alert('我是做：'+this.job); &#125;;*/ //标准继承方式，子类通过extends实例化的子类可以访问到父类原型对象的方法 class Worker extends Person&#123; constructor(name, age, job)&#123; //super-超类(父类)，可以访问到构造方法，不需要通过call的方式调用 super(name, age); this.job=job; &#125; showJob()&#123; alert('我是做：'+this.job); &#125; &#125; let w=new Worker('blue', 18, '打杂的'); w.showName(); w.showAge(); w.showJob(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2、箭头函数this 普通函数：根据调用我的人 this老变 箭头函数：根据所在的环境 this恒定 bind——给函数定死一个this 例1： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr = [1, 2, 3]; //箭头函数所处的环境是window arr.a = () =&gt; &#123; console.log(this); &#125;; arr.a(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 输出 例2： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; document.onclick=function ()&#123; let arr=[1,2,3]; //箭头函数所处的环境是document arr.a=()=&gt;&#123; console.log(this); &#125;; arr.a(); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 输出 ![](https://raw.githubusercontent.com/shenlibing/blogphoto/master/source/箭头函数this (2).png) 例3： 箭头函数所处的环境是document，尽管通过bind绑定死了12，但还是输出document，说明箭头函数的this优先级高于bind方式绑定的this 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; document.onclick=function ()&#123; let a=()=&gt;&#123; console.log(this); &#125;; let oBtn=document.getElementById('btn1'); oBtn.onclick=a.bind(12); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="button" value="aaa" id="btn1"&gt; &lt;/body&gt;&lt;/html&gt; 输出 ![](https://raw.githubusercontent.com/shenlibing/blogphoto/master/source/箭头函数this (3).png) 3、数组常用方法 1）map 映射 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[62, 55, 82, 37, 26]; let arr2=arr.map(function (item)&#123; if(item&gt;=60)&#123; return true; &#125;else&#123; return false; &#125; &#125;); //true,false,true,false,false alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 改进1 map参数：回调函数使用箭头函数书写方式 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[62, 55, 82, 37, 26]; let arr2=arr.map((item)=&gt;&#123; if(item&gt;=60)&#123; return true; &#125;else&#123; return false; &#125; &#125;); alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 改进2 如果有且仅有1个参数，()可以省 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[62, 55, 82, 37, 26]; let arr2=arr.map(item=&gt;&#123; if(item&gt;=60)&#123; return true; &#125;else&#123; return false; &#125; &#125;); alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 改进3 如果函数体只有一句话，而且是return，{}可以省 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[62, 55, 82, 37, 26]; let arr2=arr.map(item=&gt;item&gt;=60); alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2）filter过滤 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[12,5,88,37,21,91,17,24]; let arr2=arr.filter(item=&gt;item%2); //5,37,21,91,17 alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 3）forEach 遍历 求和 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[12,5,88,37,21,91,17,24]; let sum=0; arr.forEach(item=&gt;&#123; sum+=item; &#125;); //结果295 alert(sum); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 4）reduce 汇总 参数 tmp:中间结果 item：元素项 index：元素索引 求和 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[12,5,88,37,21,91,17,24]; let sum=arr.reduce((tmp,item,index)=&gt;&#123; console.log(tmp, item, index); return tmp+item; &#125;); console.log(sum); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 输出 求平均 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[12,5,88,37,21,91,17,24]; let sum=arr.reduce((tmp,item,index)=&gt;&#123; return tmp+item; &#125;); //结果36.875 console.log(sum/arr.length); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 5）from 将类数组转换成数组 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; div &#123;width:200px; height:200px; background:#CCC; float:left; margin:10px;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; //DOM对象 let aDiv=document.getElementsByTagName('div'); console.log(aDiv); //数组 let aDiv2=Array.from(aDiv); console.log(aDiv2); Array.from(aDiv).forEach(div=&gt;&#123; div.style.background='yellow'; &#125;); Array.prototype.slice.call(aDiv).forEach(div=&gt;&#123; div.style.background='blue'; &#125;); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 输出]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js开发者经常忽略的基础知识点]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F03%2Fjs%E5%BC%80%E5%8F%91%E8%80%85%E7%BB%8F%E5%B8%B8%E5%BF%BD%E7%95%A5%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1、字符串匹配 匹配所有 1234567891011// Mistake// 踩到坑了var str = "David is an Arsenal fan, which means David is great";str.replace("David", "Darren");// "Darren is an Arsenal fan, which means David is great"// Desired// 符合预期str.replace(/David/g, "Darren");// "Darren is an Arsenal fan, which means Darren is great" 忽略大小写 123str.replace(/david/gi, "Darren");// "Darren will always be an Arsenal fan, which means Darren will always be great" 2、将“类数组”元素（比如 arguments 参数列表、节点列表和属性列表）转换成真正的数组 12345678var nodesArr = Array.prototype.slice.call(document.querySelectorAll("div"));// "true" array of DIVs// 得到一个由 div 元素组成的“真正的”数组var argsArr = Array.prototype.slice.call(arguments);// changes arguments to "true" array// 把 arguments 转换成一个“真正的”数组 克隆数组 1234var clone = myArray.slice(0);// naive clone// 浅克隆 3、数组的sort方法 简单排序 1234[1, 3, 9, 2].sort();// Returns: [1, 2, 3, 9]// 返回 [1, 2, 3, 9] 复杂排序 12345678910111213141516[ &#123; name: "Robin Van PurseStrings", age: 30 &#125;, &#123; name: "Theo Walcott", age: 24 &#125;, &#123; name: "Bacary Sagna", age: 28 &#125;].sort(function(obj1, obj2) &#123; // Ascending: first age less than the previous // 实现增序排列：前者的 age 小于后者 return obj1.age - obj2.age;&#125;); // Returns: // [ // &#123; name: "Theo Walcott", age: 24 &#125;, // &#123; name: "Bacary Sagna", age: 28 &#125;, // &#123; name: "Robin Van PurseStrings", age: 30 &#125; // ] 4、push合并数组 1234567var mergeTo = [4,5,6];var mergeFrom = [7,8,9];Array.prototype.push.apply(mergeTo, mergeFrom);mergeTo; // is: [4, 5, 6, 7, 8, 9] 5、join拼接字符串 1234567var str = [ '&lt;div&gt;', '&lt;button id="lucky-draw"&gt;Lucky Draw&lt;/button&gt;', '&lt;/div&gt;'].join('')log(str) 参考 https://github.com/cssmagic/blog/issues/21]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Inheritance and the Prototype Chain]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F02%2FJavaScript%20Inheritance%20and%20the%20Prototype%20Chain%2F</url>
    <content type="text"><![CDATA[参考： https://tylermcginnis.com/javascript-inheritance-and-the-prototype-chain/ ##JavaScript Inheritance and the Prototype Chain Post This post is designed to be read after you read JavaScript Private and Public Class Fields. Previously we learned how to create an Animal class both in ES5 as well as in ES6. We also learned how to share methods across those classes using JavaScript’s prototype. To review, here’s the code we saw in an earlier post. 12345678910111213141516171819202122function Animal (name, energy) &#123; this.name = name this.energy = energy&#125;Animal.prototype.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Animal.prototype.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Animal.prototype.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125;const leo = new Animal(&apos;Leo&apos;, 7) 123456789101112131415161718192021class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep() &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play() &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;const leo = new Animal(&apos;Leo&apos;, 7) Now let’s say we wanted to start making individual classes for specific animals. For example, what if we wanted to start making a bunch of dog instances. What properties and methods will these dogs have? Well, similar to our Animal class, we could give each dog a name, an energy level, and the ability to eat, sleep, and play. Unique to our Dog class, we could also give them a breed property as well as the ability to bark. In ES5, our Dog class could look something like this 12345678910111213141516171819202122232425262728function Dog (name, energy, breed) &#123; this.name = name this.energy = energy this.breed = breed&#125;Dog.prototype.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Dog.prototype.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Dog.prototype.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125;Dog.prototype.bark = function () &#123; console.log(&apos;Woof-Woof!&apos;) this.energy -= .1&#125;const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;) Alright, well… we just recreated the Animal class and added a few new properties to it. If we wanted to create another animal, say a Cat, at this point we’d again have to create a Cat class, duplicate all the common logic located in the Animal class to it, then add on Cat specific properties just like we did with the Dog class. In fact, we’d have to do this for each different type of animal we created. 12345678function Dog (name, energy, breed) &#123;&#125;function Cat (name, energy, declawed) &#123;&#125;function Giraffe (name, energy, height) &#123;&#125;function Monkey (name, energy, domesticated) &#123;&#125; This work, but it seems wasteful. The Animal class is the perfect base class. What that means is that it has all the properties that each one of our animals has in common. Whether we’re creating a dog, cat, giraffe, or monkey, all of them will have a name, energy level, and the ability to eat, sleep, and play. With that said, is there a way we can utilize the Animal class whenever we create the individual classes for each different animal? Let’s try it out. I’ll paste the Animal class again below for easy reference. 123456789101112131415161718192021222324function Animal (name, energy) &#123; this.name = name this.energy = energy&#125;Animal.prototype.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Animal.prototype.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Animal.prototype.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125;function Dog (name, energy, breed) &#123;&#125; What are some things we know about the Dog constructor function above? First, we know it takes 3 arguments, name, energy, and breed. Second, we know it’s going to be called with the new keyword so we’ll have a this object. And third, we know we need to utilize the Animal function so that any instance of dog will have a name, energy level, and be able to eat, sleep, and play. It’s the third one that’s the tricky one. The way you “utilize” a function is by calling it. So we know that inside of Dog, we want to call Animal. What we need to figure out though is how we can invoke Animal in the context of Dog. What that means it that we want to call Animal with the this keyword from Dog. If we do that correctly, then this inside of the Dog function will have all the properties of Animal (name, energy). If you remember from a previous section, every function in JavaScript has a .call method on it. .call() is a method on every function that allows you to invoke the function specifying in what context the function will be invoked. This sounds like exactly what we need. We want to invoke Animal in the context of Dog. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;) charlie.name // Charlie charlie.energy // 10 charlie.breed // GoldendoodleSolid, we’re half-way there. You’ll notice in the code above that because of this line Animal.call(this, name, energy), every instance of Dog will now have a name and energy property. Again, the reason for that is because it’s as if we ran the Animal function with the this keyword generated from Dog. Then after we added a name and energy property to this, we also added a breed property just as we normally would. Remember the goal here is to have each instance of Dog have not only all the properties of Animal, but also all the methods as well. If you run the code above, you’ll notice that if you try to run charlie.eat(10) you’ll get an error. Currently every instance of Dog will have the properties of Animal (name and energy), but we haven’t done anything to make sure that they also have the methods (play, eat, sleep). Let’s think about how we can solve this. We know that all the Animal’s methods are located on Animal.prototype. What that means is we somehow want to make sure that all instances of Dog will have access to the methods on Animal.prototype. What if we used our good friend Object.create here? If you’ll remember, Object.create allows you to create an object which will delegate to another object on failed lookups. So in our case, the object we want to create is going to be Dog’s prototype and the object we want to delegate to on failed lookups is Animal.prototype. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype)Now, whenever there’s a failed lookup on an instance of Dog, JavaScript will delegate that lookup to Animal.prototype. If this is still a little fuzzy, re-read A Beginner’s Guide to JavaScript’s Prototype where we talk all about Object.create and JavaScript’s prototype. Let’s look at the full code together then we’ll walk through what happens. function Animal (name, energy) { this.name = name this.energy = energy } Animal.prototype.eat = function (amount) { console.log(`${this.name} is eating.`) this.energy += amount } Animal.prototype.sleep = function (length) { console.log(`${this.name} is sleeping.`) this.energy += length } Animal.prototype.play = function (length) { console.log(`${this.name} is playing.`) this.energy -= length } function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype)Now we’ve created our base class (Animal) as well as our subclass (Dog), let’s see what it looks like under the hood when we create an instance of Dog. const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;) charlie.name // Charlie charlie.energy // 10 charlie.breed // GoldendoodleNothing fancy so far, but let’s look at what happens when we invoke a method located on Animal. 1234567891011 charlie.eat(10)/*1) JavaScript checks if charlie has an eat property - it doesn&apos;t.2) JavaScript then checks if Dog.prototype has an eat property - it doesn&apos;t.3) JavaScript then checks if Animal.prototype has an eat property - it does so it calls it.*/ The reason Dog.prototype gets checked is because when we created a new instance of Dog, we used the new keyword. Under the hood, the this object that was created for us delegates to Dog.prototype (seen in comments below). function Dog (name, energy, breed) { // this = Object.create(Dog.prototype) Animal.call(this, name, energy) this.breed = breed // return this }The reason Animal.prototype gets checked is because we overwrote Dog.prototype to delegate to Animal.prototype on failed lookups with this line Dog.prototype = Object.create(Animal.prototype)Now one thing we haven’t talked about is what if Dog has its own methods? Well, that’s a simple solution. Just like with Animal, if we want to share a method across all instances of that class, we add it to the function’s prototype. 123456789101112131415...function Dog (name, energy, breed) &#123; Animal.call(this, name, energy) this.breed = breed&#125;Dog.prototype = Object.create(Animal.prototype)Dog.prototype.bark = function () &#123; console.log(&apos;Woof Woof!&apos;) this.energy -= .1&#125; very nice. There’s just one small addition we need to make. If you remember back to the Beginner’s Guide to JavaScript’s Prototype post, we were able to get access to the instances’ constructor function by using instance.constructor. function Animal (name, energy) { this.name = name this.energy = energy } const leo = new Animal(&apos;Leo&apos;, 7) console.log(leo.constructor) // Logs the constructor functionAs explained in the previous post, “the reason this works is because any instances of Animal are going to delegate to Animal.prototype on failed lookups. So when you try to access leo.prototype, leo doesn’t have a prototype property so it will delegate that lookup to Animal.prototype which indeed does have a constructor property.” The reason I bring this up is because in our implementation, we overwrote Dog.prototype with an object that delegates to Animal.prototype. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&apos;Woof Woof!&apos;) this.energy -= .1 }What that means is that now, any instances of Dog which log instance.constructor are going to get the Animal constructor rather than the Dog constructor. You can see for yourself by running this code - function Animal (name, energy) { this.name = name this.energy = energy } Animal.prototype.eat = function (amount) { console.log(`${this.name} is eating.`) this.energy += amount } Animal.prototype.sleep = function (length) { console.log(`${this.name} is sleeping.`) this.energy += length } Animal.prototype.play = function (length) { console.log(`${this.name} is playing.`) this.energy -= length } function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&apos;Woof Woof!&apos;) this.energy -= .1 } const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;) console.log(charlie.constructor)Notice it gives you the Animal constructor even though charlie is a direct instance of Dog. Again, we can walk through what’s happening here just like we did above. 1234567891011const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;)console.log(charlie.constructor)/*1) JavaScript checks if charlie has a constructor property - it doesn&apos;t.2) JavaScript then checks if Dog.prototype has a constructor property - it doesn&apos;t because it was deleted when we overwrote Dog.prototype.3) JavaScript then checks if Animal.prototype has a constructor property - it does so it logs that.*/ How can we fix this? Well, it’s pretty simple. We can just add the correct constructor property to Dog.prototype once we overwrite it. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&apos;Woof Woof!&apos;) this.energy -= .1 } Dog.prototype.constructor = DogAt this point if we wanted to make another subclass, say Cat, we’d follow the same pattern. function Cat (name, energy, declawed) { Animal.call(this, name, energy) this.declawed = declawed } Cat.prototype = Object.create(Animal.prototype) Cat.prototype.constructor = Cat Cat.prototype.meow = function () { console.log(&apos;Meow!&apos;) this.energy -= .1 }This concept of having a base class with subclasses that delegate to it is called inheritance and it’s a staple of Object Oriented Programming (OOP). If you’re coming from a different programming language, odds are you’re already familiar with OOP and inheritance. Before ES6 classes, in JavaScript, inheritance was quite the task as you can see above. You need to understand now only when to use inheritance, but also a nice mix of .call, Object.create, this, and FN.prototype - all pretty advanced JS topics. Let’s see how we’d accomplish the same thing using ES6 classes though. First, let’s review what it looks like to go from an ES5 “class” to an ES6 class using our Animal class. function Animal (name, energy) { this.name = name this.energy = energy } Animal.prototype.eat = function (amount) { console.log(`${this.name} is eating.`) this.energy += amount } Animal.prototype.sleep = function (length) { console.log(`${this.name} is sleeping.`) this.energy += length } Animal.prototype.play = function (length) { console.log(`${this.name} is playing.`) this.energy -= length } const leo = new Animal(&apos;Leo&apos;, 7)123456789101112131415161718192021class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep() &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play() &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;const leo = new Animal(&apos;Leo&apos;, 7) Now that we’ve refactored our Animal constructor function into an ES6 class, the next thing we need to do is figure out how to refactor our base class (Dog). The good news is it’s much more intuitive. For reference, in ES5, here’s what we had. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&apos;Woof Woof!&apos;) this.energy -= .1 } Dog.prototype.constructor = DogBefore we get into inheritance, let’s refactor Dog to use an ES6 class as we learned in a previous post. 12345678910class Dog &#123; constructor(name, energy, breed) &#123; this.breed = breed &#125; bark() &#123; console.log(&apos;Woof Woof!&apos;) this.energy -= .1 &#125;&#125; Looks great. Now, let’s figure out how to make sure that Dog inherits from Animal. The first step we need to make is a pretty straight forward one. With ES6 classes, you can extend a base class with this syntax class Subclass extends Baseclass {}Translated into our example, that would make our Dog class look like this 1234567891011121314151617181920212223242526272829class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep() &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play() &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;class Dog extends Animal &#123; constructor(name, energy, breed) &#123; this.breed = breed &#125; bark() &#123; console.log(&apos;Woof Woof!&apos;) this.energy -= .1 &#125;&#125; In ES5 in order to make sure that every instance of Dog had a name and an energy property, we used .call in order to invoke the Animal constructor function in the context of the Dog instance. Luckily for us, in ES6 it’s much more straight forward. Whenever you are extending a baseclass and you need to invoke that baseclass’ constructor function, you invoke super passing it any arguments it needs. So in our example, our Dog constructor gets refactored to look like this 12345678910111213141516171819202122232425262728293031class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep() &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play() &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;class Dog extends Animal &#123; constructor(name, energy, breed) &#123; super(name, energy) // calls Animal&apos;s constructor this.breed = breed &#125; bark() &#123; console.log(&apos;Woof Woof!&apos;) this.energy -= .1 &#125;&#125; And that’s it. No using .call, no using Object.create, no worrying about resetting constructor on the prototype - just extends the baseclass and make sure to call super. What’s interesting about JavaScript is the same patterns you’ve learned these last few posts are directly caked into the language itself. Previously you learned that the reason all instances of Array have access to the array methods like pop, slice, filter, etc are because all of those methods live on Array.prototype. 123456789101112131415161718192021222324252627282930313233343536console.log(Array.prototype)/* concat: ƒn concat() constructor: ƒn Array() copyWithin: ƒn copyWithin() entries: ƒn entries() every: ƒn every() fill: ƒn fill() filter: ƒn filter() find: ƒn find() findIndex: ƒn findIndex() forEach: ƒn forEach() includes: ƒn includes() indexOf: ƒn indexOf() join: ƒn join() keys: ƒn keys() lastIndexOf: ƒn lastIndexOf() length: 0n map: ƒn map() pop: ƒn pop() push: ƒn push() reduce: ƒn reduce() reduceRight: ƒn reduceRight() reverse: ƒn reverse() shift: ƒn shift() slice: ƒn slice() some: ƒn some() sort: ƒn sort() splice: ƒn splice() toLocaleString: ƒn toLocaleString() toString: ƒn toString() unshift: ƒn unshift() values: ƒn values()*/ You also learned that the reason all instances of Object have access to methods like hasOwnProperty and toString is because those methods live on Object.prototype. 123456789101112console.log(Object.prototype)/* constructor: ƒn Object() hasOwnProperty: ƒn hasOwnProperty() isPrototypeOf: ƒn isPrototypeOf() propertyIsEnumerable: ƒn propertyIsEnumerable() toLocaleString: ƒn toLocaleString() toString: ƒn toString() valueOf: ƒn valueOf()*/ Here’s a challenge for you. With the list of Array methods and Object methods above, why does this code below work? 1234const friends = [&apos;Mikenzi&apos;, &apos;Jake&apos;, &apos;Ean&apos;]friends.hasOwnProperty(&apos;push&apos;) // false If you look at Array.prototype, there isn’t a hasOwnProperty method. Well if there isn’t a hasOwnProperty method located on Array.prototype, how does the friends array in the example above have access to hasOwnProperty? The reason for that is because the Array class extends the Object class. So in our example above, when JavaScript sees that friends doesn’t have a hasOwnProperty property, it checks if Array.prototype does. When Array.prototype doesn’t, it checks if Object.prototype does, then it invokes it. It’s the same process we’ve seen throughout this blog post. JavaScript has two types - Primitive types and Reference types. Primitive types are boolean, number, string, null, and undefined and are immutable. Everything else is a reference type and they all extend Object.prototype. That’s why you can add properties to functions and arrays and that’s why both functions and arrays have access to the methods located on Object.prototype. 12345678function speak()&#123;&#125;speak.woahFunctionsAreLikeObjects = trueconsole.log(speak.woahFunctionsAreLikeObjects) // trueconst friends = [&apos;Mikenzi&apos;, &apos;Jake&apos;, &apos;Ean&apos;]friends.woahArraysAreLikeObjectsToo = trueconsole.log(friends.woahArraysAreLikeObjectsToo) // true –未完待续]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel入门]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F01%2Fbabel%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1、babel Babel is a toolchain that is mainly used to convert ECMAScript 2015+ code into a backwards compatible version of JavaScript in current and older browsers or environments. 参考 https://babeljs.io/setup#installation 1)生成package.json文件(描述项目所需要的各种模块，以及项目的配置信息—比如名称、版本、许可证等元数据) npm init D:\mytest\babel&gt;npm init2)安装项目依赖 install Babel CLI locally D:\mytest\babel&gt;npm install --save-dev @babel/core @babel/cli3）添加编译运行脚本命令 &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;babel src -d src_build&quot; },结果 4）运行脚本命令 D:\mytest\babel&gt;npm run build此时并没有成功的将es6的语法转成es5 5）添加.babelrc文件 Great! You’ve configured Babel but you haven’t made it actually do anything. Create a .babelrc config in your project root and enable some plugins. To start, you can use the env preset, which enables transforms for ES2015+ D:\mytest\babel&gt;npm install @babel/preset-env --save-dev结果 6）重新运行脚本命令 D:\mytest\babel&gt;npm run build 7)使用编译后的js &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&apos;../src_build/1.js&apos;&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;babel官网参考手册 https://babeljs.io/docs/en/usage]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>babel</tag>
        <tag>npm</tag>
      </tags>
  </entry>
</search>

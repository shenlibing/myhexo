<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[oracle11g安装_客户端工具管理oracle数据库]]></title>
    <url>%2Fmyhexo%2F2019%2F05%2F20%2Foracle11g%E5%AE%89%E8%A3%85-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E5%85%B7%E7%AE%A1%E7%90%86oracle%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[oracle11g安装单机版集群版客户端工具管理oracle数据库web方式管理工具sql developer下载 PL\SQL下载配置TNS]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jdk多版本设置]]></title>
    <url>%2Fmyhexo%2F2019%2F05%2F19%2Fjdk%E5%A4%9A%E7%89%88%E6%9C%AC%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[jdk多版本设置Windows安装jdk1.6 jdk1.7 jdk1.8 删除或者重命名 C:\Windows\System32下的java.exe、javaw.exe、javaws.exe C:\Program Files (x86)\Common Files\Oracle\Java\javapath下的java.exe、javaw.exe、javaws.exe 配置自己的jdk环境变量 Linux]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ajax2.0的FormData和跨域Cors]]></title>
    <url>%2Fmyhexo%2F2019%2F05%2F15%2FAjax2-0%E7%9A%84FormData%E5%92%8C%E8%B7%A8%E5%9F%9FCors%2F</url>
    <content type="text"><![CDATA[formdata前台浏览器ajax2.0的东西 入门 set(key, value) 会覆盖 append(key, value) 不覆盖 get(key)=&gt;value delete(key) 1.html 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let data=new FormData(); data.set('user', 'blue'); data.append('user', 'blue2'); console.log(data.getAll('user')); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 控制提交数据原生实现前台2.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; window.onload=function ()&#123; let oUser=document.getElementById('user'); let oPass=document.getElementById('pass'); let oBtn=document.getElementById('btn1'); oBtn.onclick=function ()&#123; let data=new FormData(); data.set('user', oUser.value); data.set('pass', oPass.value); // let oAjax=new XMLHttpRequest(); //GET let arr=[]; data.forEach((value, key)=&gt;&#123; arr.push(`$&#123;encodeURIComponent(key)&#125;=$&#123;encodeURIComponent(value)&#125;`); &#125;); oAjax.open('GET', `http://localhost:8080/api?$&#123;arr.join('&amp;')&#125;`, true); oAjax.setRequestHeader('my-origin-blue', window.location.hostname); oAjax.send(); //POST /*oAjax.open('POST', `http://localhost:8080/api`, true); oAjax.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); oAjax.send(data);*/ oAjax.onreadystatechange=function ()&#123; if(oAjax.readyState==4)&#123; if(oAjax.status&gt;=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304)&#123; alert('成功:'+oAjax.responseText); &#125;else&#123; alert('失败'); &#125; &#125; &#125;; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 用户：&lt;input type="text" id="user" /&gt;&lt;br&gt; 密码：&lt;input type="password" id="pass" /&gt;&lt;br&gt; &lt;input type="button" value="提交" id="btn1"&gt; &lt;/body&gt;&lt;/html&gt; 后台server.js 123456789101112131415161718192021222324252627const http=require('http');const urlLib=require('url');const querystring=require('querystring');http.createServer((req, res)=&gt;&#123; console.log(req.headers['my-origin-blue']); //if(req.headers['origin']=='null' || /^https?:\/\/(\w+\.)+abc\.com/.test(req.headers['origin']))&#123; if(req.headers['origin']=='null' || req.headers['origin'].startsWith('http://localhost'))&#123; res.setHeader('Access-Control-Allow-Origin', '*'); &#125; let &#123;pathname: url, query: get&#125;=urlLib.parse(req.url, true); let arr=[]; req.on('data', data=&gt;&#123; arr.push(data); &#125;); req.on('end', ()=&gt;&#123; let post=querystring.parse(Buffer.concat(arr).toString()); console.log(url, get, post); res.write('asdfasdf'); res.end(); &#125;);&#125;).listen(8080); 文件上传express框架实现安装依赖package.json 123456789101112131415161718&#123; "name": "2018-2-6", "version": "1.0.0", "description": "", "main": "1.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "node server.js" &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "body-parser": "^1.18.2", "express": "^4.16.2", "multer": "^1.3.0" &#125;&#125; 前台3.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; window.onload=function ()&#123; let oUser=document.getElementById('user'); let oPass=document.getElementById('pass'); let oF=document.getElementById('f1'); let oBtn=document.getElementById('btn1'); oBtn.onclick=function ()&#123; let data=new FormData(); data.set('user', oUser.value); data.set('pass', oPass.value); Array.from(oF.files).forEach(file=&gt;&#123; data.append('f1', file); &#125;); // let oAjax=new XMLHttpRequest(); //POST oAjax.open('POST', `http://localhost:8080/api`, true); oAjax.send(data); oAjax.onreadystatechange=function ()&#123; if(oAjax.readyState==4)&#123; if(oAjax.status&gt;=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304)&#123; alert('成功'); &#125;else&#123; alert('失败'); &#125; &#125; &#125;; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 用户：&lt;input type="text" id="user" /&gt;&lt;br&gt; 密码：&lt;input type="password" id="pass" /&gt;&lt;br&gt; 头像：&lt;input type="file" id="f1" multiple /&gt;&lt;br&gt; &lt;input type="button" value="提交" id="btn1"&gt; &lt;/body&gt;&lt;/html&gt; 后台express_server.js 123456789101112131415161718192021222324252627282930const express=require('express'); //主体const body=require('body-parser'); //接收普通POST数据const multer=require('multer'); //接收文件POST数据//let server=http.createServer((req, res)=&gt;&#123;&#125;);//server.listen(8080);let server=express();server.listen(8080);//中间件server.use(body.urlencoded(&#123;extended: false&#125;));let multerObj=multer(&#123;dest: './upload/'&#125;);server.use(multerObj.any());//处理请求server.post('/api', (req, res)=&gt;&#123; if(req.headers['origin']=='null' || req.headers['origin'].startsWith('http://localhost'))&#123; res.setHeader('Access-Control-Allow-Origin', '*'); &#125; res.send("OK"); console.log(req.body); //普通POST数据 console.log(req.files); //文件POST数据，req.files来自于multer&#125;);//server.use(express.static('./www/')); cors跨域早期跨域解决方案是使用jsonp ajax1.0的时代，浏览器请求服务器的时候，请求头并不会携带origin,对于跨域的解决方案是使用其它的手段。 ajax2.0以后，浏览器请求服务器，请求头中会有origin ,服务器接到请求要验证请求头中的origin认不认识 认识的话则进行设置res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); 浏览器接收服务器的响应后，查看响应头中Access-Control-Allow-Origin是否进行了设置，如果设置了*，则表示允许本次请求后成功处理响应。 关键代码 文件拖拽 ondragenter 拖着东西进入 ondragleave 拖着东西离开 ondragover 悬停 ondrop 松手 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; .box &#123;width:400px; height:150px; border:1px solid black; background:#CCC; position: absolute; margin-left: -200px; margin-top: -75px; left:50%; top:50%; text-align:center; line-height:150px;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; let oBox=document.querySelector('.box'); oBox.ondragenter=function ()&#123; oBox.innerHTML='松手上传'; &#125;; oBox.ondragleave=function ()&#123; oBox.innerHTML='请拖到这里'; &#125;; oBox.ondragover=function ()&#123; //只要鼠标还没松手、并且还没离开，一直不停发生 console.log("aaaa"); //ondragover不阻止默认事件，ondrop不会触发 return false; &#125;; oBox.ondrop=function (ev)&#123; //alert('松手'); let data=new FormData(); Array.from(ev.dataTransfer.files).forEach(file=&gt;&#123; data.append('f1', file); &#125;); // let oAjax=new XMLHttpRequest(); //POST oAjax.open('POST', `http://localhost:8080/api`, true); oAjax.send(data); oAjax.onreadystatechange=function ()&#123; if(oAjax.readyState==4)&#123; if(oAjax.status&gt;=200 &amp;&amp; oAjax.status&lt;300 || oAjax.status==304)&#123; alert('上传成功'); &#125;else&#123; alert('上传失败'); &#125; &#125; &#125;; return false; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; 请拖到这里 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[websocket原理]]></title>
    <url>%2Fmyhexo%2F2019%2F05%2F12%2Fwebsocket%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[websocket 双向通信 性能高 WebSocket是前台的东西，是HTML5带的一种东西 只有前台有WebSocket这个东西 后台没有，后台有Socket 使用socket.io实现WebSocket引入依赖123456789101112131415&#123; "name": "2018-2-3", "version": "1.0.0", "description": "", "main": "server.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "node server.js" &#125;, "author": "", "license": "ISC", "devDependencies": &#123; "socket.io": "^2.0.4" &#125;&#125; 前台1.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; #ul1 &#123;width:400px; height:300px; border:1px solid black; overflow:auto;&#125; #ul1 li.me &#123;color:green&#125; .err_box &#123;width:100%; height:20px; line-height: 20px; text-align:center; color:red; display:none&#125; &lt;/style&gt; &lt;script src="http://localhost:8080/socket.io/socket.io.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; let sock=io.connect('ws://localhost:8080/'); sock.on('connect', ()=&gt;&#123; console.log('已连接'); document.getElementsByClassName('err_box')[0].style.display='none'; &#125;); sock.on('disconnect', ()=&gt;&#123; console.log('已断开'); document.getElementsByClassName('err_box')[0].style.display='block'; &#125;); //聊天室 window.onload=function ()&#123; let oTxt=document.getElementById('txt1'); let oBtn=document.getElementById('btn1'); let oUl=document.getElementById('ul1'); oBtn.onclick=function ()&#123; sock.emit('msg', oTxt.value); let oLi=document.createElement('li'); oLi.innerHTML=oTxt.value; oLi.className='me'; oTxt.value=''; oUl.appendChild(oLi); &#125;; sock.on('msg', str=&gt;&#123; let oLi=document.createElement('li'); oLi.innerHTML=str; oUl.appendChild(oLi); &#125;); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="err_box"&gt; 无法连接到服务器，请检查网络 &lt;/div&gt; &lt;ul id="ul1"&gt;&lt;/ul&gt; &lt;textarea rows="4" cols="60" id="txt1"&gt;&lt;/textarea&gt; &lt;input type="button" value="发送" id="btn1"&gt; &lt;/body&gt;&lt;/html&gt; 后台server.js 123456789101112131415161718192021222324252627282930313233343536const http=require('http');const io=require('socket.io');let httpServer=http.createServer((req, res)=&gt;&#123;&#125;);httpServer.listen(8080);//let wsServer=io.listen(httpServer);let aSock=[];wsServer.on('connection', sock=&gt;&#123; aSock.push(sock); //断开连接 sock.on('disconnect', ()=&gt;&#123; let n=aSock.indexOf(sock); if(n!=-1)&#123; aSock.splice(n, 1); &#125; &#125;); sock.on('msg', str=&gt;&#123; aSock.forEach(s=&gt;&#123; if(s!=sock)&#123; s.emit('msg', str); &#125; &#125;); &#125;);&#125;);setInterval(function ()&#123; console.log(aSock.length);&#125;, 500); 原生WebSocket实现前台raw_client.html 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let sock=new WebSocket('ws://localhost:8080/'); sock.emit=function (name, ...args)&#123; alert(JSON.stringify(&#123;name, data: [...args]&#125;)); sock.send(JSON.stringify(&#123;name, data: [...args]&#125;)); &#125;; //连上了 sock.onopen=function ()&#123; alert('连接上了'); //发送数据 sock.emit('msg', 12, 5); &#125;; //有数据 sock.onmessage=function ()&#123; alert('有消息过来'); &#125;; //断开了 sock.onclose=function ()&#123; alert('断了'); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 后台建立连接原始数据1234567891011121314GET / HTTP/1.1Host: localhost:8080Connection: UpgradePragma: no-cacheCache-Control: no-cacheUpgrade: websocketOrigin: file://Sec-WebSocket-Version: 13User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, likeGecko) Chrome/65.0.3315.4 Safari/537.36Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7,es;q=0.6,fr;q=0.5,pt;q=0.4Sec-WebSocket-Key: +0jgXtYyVeG28Gn1CLUKIg==Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits 分析原始数据 第一行删掉 12345678910111213Host: localhost:8080Connection: UpgradePragma: no-cacheCache-Control: no-cacheUpgrade: websocketOrigin: file://Sec-WebSocket-Version: 13User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, likeGecko) Chrome/65.0.3315.4 Safari/537.36Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7,es;q=0.6,fr;q=0.5,pt;q=0.4Sec-WebSocket-Key: +0jgXtYyVeG28Gn1CLUKIg==Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits 舍弃第一行和最后两行 lines=lines.slice(1, lines.length-2); 每行数据用”: “切开 代码raw_server.js 引入net模块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const http=require('http');const net=require('net'); //TCP 原生Socketconst crypto=require('crypto');/*let server=http.createServer((req, res)=&gt;&#123; console.log('连接');&#125;);server.listen(8080);*/let server=net.createServer(sock=&gt;&#123; console.log('连接'); //数据过来——握手只有一次 sock.once('data', data=&gt;&#123; console.log('hand shake start...'); let str=data.toString(); let lines=str.split('\r\n'); //舍弃第一行和最后两行 lines=lines.slice(1, lines.length-2); //切开 let headers=&#123;&#125;; lines.forEach(line=&gt;&#123; let [key, val]=line.split(': '); headers[key.toLowerCase()]=val; &#125;); //console.log(headers); if(headers['upgrade']!='websocket')&#123; console.log('其他协议', headers['upgrade']); sock.end(); &#125;else if(headers['sec-websocket-version']!=13)&#123; console.log('版本不对', headers['sec-websocket-version']); sock.end(); &#125;else&#123; let key=headers['sec-websocket-key']; let mask='258EAFA5-E914-47DA-95CA-C5AB0DC85B11'; //sha1(key+mask)-&gt;base64=&gt;client let hash=crypto.createHash('sha1'); hash.update(key+mask); let key2=hash.digest('base64'); sock.write(`HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: $&#123;key2&#125;\r\n\r\n`); console.log('hand shake end'); //真正的数据 sock.on('data', data=&gt;&#123; console.log('有数据'); console.log(data); &#125;); &#125; &#125;); //断开了 sock.on('end', ()=&gt;&#123; console.log('客户端已断开'); &#125;);&#125;);server.listen(8080); 解析真正数据真正数据 1234567891011121381 9c 11 2d f8 bd 数据.....10000001 10011100 00010001 00101101 11111000 1011110111 2d f8 bd6a 0f 96 dc 7c 48 da 87 33 40 8b da 33 01 da d9 70 59 99 9f 2b 76 c9 8f 3d 18 a5 c01 000 0001 1 0011100 00010001 00101101 11111000 10111101F RSV opcode M payload masking-keyI A 28个字N S K 帧结构1234567891011121314151617181920212223242526272829 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7+-+-+-+-+-------+-+-------------+-------------------------------+|F|R|R|R| opcode|M| Payload len | Extended payload length ||I|S|S|S| (4) |A| (7) | (16/64) ||N|V|V|V| |S| | (if payload len==126/127) || |1|2|3| |K| | |+-+-+-+-+-------+-+-------------+-------------------------------+| Extended payload length continued, if payload len == 127 |+-------------------------------+-------------------------------+| |Masking-key, if MASK set to 1 |+-------------------------------+-------------------------------+| Masking-key (continued) | Payload Data |+-------------------------------+-------------------------------+| Payload Data continued ... |+---------------------------------------------------------------+| Payload Data continued ... |+---------------------------------------------------------------+FIN 1bit 是否最后一帧RSV 3bit 预留Opcode 4bit 帧类型Mask 1bit 掩码，是否加密数据，默认必须置为1Payload 7bit 长度Masking-key 1 or 4 bit 掩码Payload data (x + y) bytes 数据Extension data x bytes 扩展数据Application data y bytes 程序数据 传递数据单位1位(bit)8位等于1字节(byte) 代码raw_server2.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const http=require('http');const net=require('net'); //TCP 原生Socketconst crypto=require('crypto');/*let server=http.createServer((req, res)=&gt;&#123; console.log('连接');&#125;);server.listen(8080);*/let server=net.createServer(sock=&gt;&#123; console.log('连接'); //数据过来——握手只有一次 sock.once('data', data=&gt;&#123; console.log('hand shake start...'); let str=data.toString(); let lines=str.split('\r\n'); //舍弃第一行和最后两行 lines=lines.slice(1, lines.length-2); //切开 let headers=&#123;&#125;; lines.forEach(line=&gt;&#123; let [key, val]=line.split(': '); headers[key.toLowerCase()]=val; &#125;); //console.log(headers); if(headers['upgrade']!='websocket')&#123; console.log('其他协议', headers['upgrade']); sock.end(); &#125;else if(headers['sec-websocket-version']!=13)&#123; console.log('版本不对', headers['sec-websocket-version']); sock.end(); &#125;else&#123; let key=headers['sec-websocket-key']; let mask='258EAFA5-E914-47DA-95CA-C5AB0DC85B11'; //sha1(key+mask)-&gt;base64=&gt;client let hash=crypto.createHash('sha1'); hash.update(key+mask); let key2=hash.digest('base64'); sock.write(`HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: $&#123;key2&#125;\r\n\r\n`); console.log('hand shake end'); //真正的数据 sock.on('data', data=&gt;&#123; console.log('有数据'); let FIN=data[0]&amp;0x001; let opcode=data[0]&amp;0x0F0; let mask=data[1]&amp;0x001; let payload=data[1]&amp;0x0FE; console.log(FIN, opcode); console.log(mask, payload); &#125;); &#125; &#125;); //断开了 sock.on('end', ()=&gt;&#123; console.log('客户端已断开'); &#125;);&#125;);server.listen(8080); 总结流程引入net模块握手12客户端:version:13、sec-websocket-key:xxxxx、sha1(key+mask)=&gt;base64服务端:101 Switching Protocols、sec-websocket-accept: base64 客户端 onopen onmessage onclose 服务端 net.createServer(sock=&gt;{}); sock.once(‘data’, 握手); sock.on(‘data’, 数据请求); sock.on(‘end’); 数据帧解析参考WebSocket 实战 WebSocket - Wikipedia]]></content>
  </entry>
  <entry>
    <title><![CDATA[JUC多线程并发、JVM和GC]]></title>
    <url>%2Fmyhexo%2F2019%2F05%2F07%2FJUC%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E3%80%81JVM%E5%92%8CGC%2F</url>
    <content type="text"><![CDATA[Callable接口Runnable和Callable的区别 Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的 Callable规定的方法是call(),Runnable规定的方法是run() Callable的任务执行后可返回值，而Runnable的任务是不能返回值(是void) call方法可以抛出异常，run方法不可以 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。 加入线程池运行，Runnable使用ExecutorService的execute方法，Callable使用submit方法。 Callable接口callable有个&lt;V&gt;,这个V就是call函数的返回值类型 12345678910111213141516171819202122232425262728293031package java.util.concurrent;/** * A task that returns a result and may throw an exception. * Implementors define a single method with no arguments called * &#123;@code call&#125;. * * &lt;p&gt;The &#123;@code Callable&#125; interface is similar to &#123;@link * java.lang.Runnable&#125;, in that both are designed for classes whose * instances are potentially executed by another thread. A * &#123;@code Runnable&#125;, however, does not return a result and cannot * throw a checked exception. * * &lt;p&gt;The &#123;@link Executors&#125; class contains utility methods to * convert from other common forms to &#123;@code Callable&#125; classes. * * @see Executor * @since 1.5 * @author Doug Lea * @param &lt;V&gt; the result type of method &#123;@code call&#125; */@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; FutureTask类12345678910111213141516171819202122232425/** * A cancellable asynchronous computation. This class provides a base * implementation of &#123;@link Future&#125;, with methods to start and cancel * a computation, query to see if the computation is complete, and * retrieve the result of the computation. The result can only be * retrieved when the computation has completed; the &#123;@code get&#125; * methods will block if the computation has not yet completed. Once * the computation has completed, the computation cannot be restarted * or cancelled (unless the computation is invoked using * &#123;@link #runAndReset&#125;). * * &lt;p&gt;A &#123;@code FutureTask&#125; can be used to wrap a &#123;@link Callable&#125; or * &#123;@link Runnable&#125; object. Because &#123;@code FutureTask&#125; implements * &#123;@code Runnable&#125;, a &#123;@code FutureTask&#125; can be submitted to an * &#123;@link Executor&#125; for execution. * * &lt;p&gt;In addition to serving as a standalone class, this class provides * &#123;@code protected&#125; functionality that may be useful when creating * customized task classes. * * @since 1.5 * @author Doug Lea * @param &lt;V&gt; The result type returned by this FutureTask's &#123;@code get&#125; methods */public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; 12345678910111213/** * Creates a &#123;@code FutureTask&#125; that will, upon running, execute the * given &#123;@code Callable&#125;. * * @param callable the callable task * @throws NullPointerException if the callable is null */public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable&#125; RunnableFuture接口12345678910111213141516171819package java.util.concurrent;/** * A &#123;@link Future&#125; that is &#123;@link Runnable&#125;. Successful execution of * the &#123;@code run&#125; method causes completion of the &#123;@code Future&#125; * and allows access to its results. * @see FutureTask * @see Executor * @since 1.6 * @author Doug Lea * @param &lt;V&gt; The result type returned by this Future's &#123;@code get&#125; method */public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run();&#125; 测试12345678910111213141516171819202122232425262728public class CallableTest &#123; public static void main(String[] args) throws Exception &#123; MyThread mt = new MyThread(); FutureTask&lt;Integer&gt; result = new FutureTask&lt;Integer&gt;(mt); new Thread(result).start(); // 获取运算结果是同步过程，即 call 方法执行完成，才能获取结果 Integer sum = result.get(); System.out.println(sum); &#125;&#125;class MyThread implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; int sum = 0; for (int i = 1; i &lt;= 100; i++) &#123; sum += i; &#125; return sum; &#125; &#125; 当某个请求需要在后端完成 N 次统计结果时，我们就可以使用该方式创建 N 个线程进行（并行）统计，而不需要同步等待其他统计操作完成后才统计另一个结果。 线程池线程池3个常用方式Executors.newFixedThreadPool 123456789101112131415161718192021/** * Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue. At any point, at most * &#123;@code nThreads&#125; threads will be active processing tasks. * If additional tasks are submitted when all threads are active, * they will wait in the queue until a thread is available. * If any thread terminates due to a failure during execution * prior to shutdown, a new one will take its place if needed to * execute subsequent tasks. The threads in the pool will exist * until it is explicitly &#123;@link ExecutorService#shutdown shutdown&#125;. * * @param nThreads the number of threads in the pool * @return the newly created thread pool * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125; */public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; Executors.newSingleThreadExecutor 12345678910111213141516171819/** * Creates an Executor that uses a single worker thread operating * off an unbounded queue. (Note however that if this single * thread terminates due to a failure during execution prior to * shutdown, a new one will take its place if needed to execute * subsequent tasks.) Tasks are guaranteed to execute * sequentially, and no more than one task will be active at any * given time. Unlike the otherwise equivalent * &#123;@code newFixedThreadPool(1)&#125; the returned executor is * guaranteed not to be reconfigurable to use additional threads. * * @return the newly created single-threaded Executor */public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; Executors.newCachedThreadPool 123456789101112131415161718192021/** * Creates a thread pool that creates new threads as needed, but * will reuse previously constructed threads when they are * available. These pools will typically improve the performance * of programs that execute many short-lived asynchronous tasks. * Calls to &#123;@code execute&#125; will reuse previously constructed * threads if available. If no existing thread is available, a new * thread will be created and added to the pool. Threads that have * not been used for sixty seconds are terminated and removed from * the cache. Thus, a pool that remains idle for long enough will * not consume any resources. Note that pools with similar * properties but different details (for example, timeout parameters) * may be created using &#123;@link ThreadPoolExecutor&#125; constructors. * * @return the newly created thread pool */public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 线程池7大参数Java 多线程开发之 Callable 与线程池（三） - 后端 - 掘金 int corePoolSize 线程池核心线程个数，默认线程池线程个数为 0，只有接到任务才新建线程 int maximumPoolSize 线程池最大线程数量 long keepAliveTime 线程池空闲时，线程存活的时间，当线程池中的线程数大于 corePoolSize 时才会起作用 TimeUnit unit 时间单位 BlockingQueue workQueue 阻塞队列，当达到线程数达到 corePoolSize 时，将任务放入队列等待线程处理 ThreadFactory threadFactory 线程工厂 RejectedExecutionHandler handler 线程拒绝策略，当队列满了并且线程个数达到 maximumPoolSize 后采取的策略 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters and default thread factory. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; * or &#123;@code handler&#125; is null */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);&#125;/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @param threadFactory the factory to use when the executor * creates a new thread * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; * or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 线程池的合理配置获取系统设备处理器核数1Runtime.getRuntime().availableProcessors() 考虑因素CPU密集型线程数 = CPU可用核心数/(1 - 阻塞系数)，其中阻塞系数的取值在0和1之间 IO密集型线程池的工作原理 execute方法执行逻辑核心线程数如果当前运行的线程少于corePoolSize，则会创建新的线程来执行新的任务 加入阻塞队列如果运行的线程个数等于或者大于corePoolSize，则会将提交的任务存放到阻塞队列workQueue中 扩容如果当前workQueue队列已满的话，则会创建新的线程来执行任务 拒绝策略如果线程个数已经超过了maximumPoolSize，则会使用饱和策略RejectedExecutionHandler来进行处理]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java8深入剖析与实战]]></title>
    <url>%2Fmyhexo%2F2019%2F05%2F04%2Fjava8%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[函数式接口 定义 如果一个接口只有一个抽象方法，那么该接口就是一个函数式接口 如果在某个接口上声明了FunctionalInterface注解，那么编译器就会按照函数式接口的定义来要求该接口 如果某个接口只有一个抽象方法，但我们并没有给该接口声明FunctionalInterface注解，那么编译器依旧会将该接口看作是函数式接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * * * */package java.lang;import java.lang.annotation.*;/** * An informative annotation type used to indicate that an interface * type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as * defined by the Java Language Specification. * * Conceptually, a functional interface has exactly one abstract * method. Since &#123;@linkplain java.lang.reflect.Method#isDefault() * default methods&#125; have an implementation, they are not abstract. If * an interface declares an abstract method overriding one of the * public methods of &#123;@code java.lang.Object&#125;, that also does * &lt;em&gt;not&lt;/em&gt; count toward the interface's abstract method count * since any implementation of the interface will have an * implementation from &#123;@code java.lang.Object&#125; or elsewhere. * * &lt;p&gt;Note that instances of functional interfaces can be created with * lambda expressions, method references, or constructor references. * * &lt;p&gt;If a type is annotated with this annotation type, compilers are * required to generate an error message unless: * * &lt;ul&gt; * &lt;li&gt; The type is an interface type and not an annotation type, enum, or class. * &lt;li&gt; The annotated type satisfies the requirements of a functional interface. * &lt;/ul&gt; * * &lt;p&gt;However, the compiler will treat any interface meeting the * definition of a functional interface as a functional interface * regardless of whether or not a &#123;@code FunctionalInterface&#125; * annotation is present on the interface declaration. * * @jls 4.3.2. The Class Object * @jls 9.8 Functional Interfaces * @jls 9.4.3 Interface Method Body * @since 1.8 */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface FunctionalInterface &#123;&#125; Runnable接口 函数式接口的创建 lambda表达式、方法引用、构造函数引用 Note that instances of functional interfaces can be created withlambda expressions, method references, or constructor references. Stream流 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129/* * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * * * */package java.util.stream;import java.nio.charset.Charset;import java.nio.file.Files;import java.nio.file.Path;import java.util.Arrays;import java.util.Collection;import java.util.Comparator;import java.util.Iterator;import java.util.Objects;import java.util.Optional;import java.util.Spliterator;import java.util.Spliterators;import java.util.concurrent.ConcurrentHashMap;import java.util.function.BiConsumer;import java.util.function.BiFunction;import java.util.function.BinaryOperator;import java.util.function.Consumer;import java.util.function.Function;import java.util.function.IntFunction;import java.util.function.Predicate;import java.util.function.Supplier;import java.util.function.ToDoubleFunction;import java.util.function.ToIntFunction;import java.util.function.ToLongFunction;import java.util.function.UnaryOperator;/** * A sequence of elements supporting sequential and parallel aggregate * operations. The following example illustrates an aggregate operation using * &#123;@link Stream&#125; and &#123;@link IntStream&#125;: * * &lt;pre&gt;&#123;@code * int sum = widgets.stream() * .filter(w -&gt; w.getColor() == RED) * .mapToInt(w -&gt; w.getWeight()) * .sum(); * &#125;&lt;/pre&gt; * * In this example, &#123;@code widgets&#125; is a &#123;@code Collection&lt;Widget&gt;&#125;. We create * a stream of &#123;@code Widget&#125; objects via &#123;@link Collection#stream Collection.stream()&#125;, * filter it to produce a stream containing only the red widgets, and then * transform it into a stream of &#123;@code int&#125; values representing the weight of * each red widget. Then this stream is summed to produce a total weight. * * &lt;p&gt;In addition to &#123;@code Stream&#125;, which is a stream of object references, * there are primitive specializations for &#123;@link IntStream&#125;, &#123;@link LongStream&#125;, * and &#123;@link DoubleStream&#125;, all of which are referred to as "streams" and * conform to the characteristics and restrictions described here. * * &lt;p&gt;To perform a computation, stream * &lt;a href="package-summary.html#StreamOps"&gt;operations&lt;/a&gt; are composed into a * &lt;em&gt;stream pipeline&lt;/em&gt;. A stream pipeline consists of a source (which * might be an array, a collection, a generator function, an I/O channel, * etc), zero or more &lt;em&gt;intermediate operations&lt;/em&gt; (which transform a * stream into another stream, such as &#123;@link Stream#filter(Predicate)&#125;), and a * &lt;em&gt;terminal operation&lt;/em&gt; (which produces a result or side-effect, such * as &#123;@link Stream#count()&#125; or &#123;@link Stream#forEach(Consumer)&#125;). * Streams are lazy; computation on the source data is only performed when the * terminal operation is initiated, and source elements are consumed only * as needed. * * &lt;p&gt;Collections and streams, while bearing some superficial similarities, * have different goals. Collections are primarily concerned with the efficient * management of, and access to, their elements. By contrast, streams do not * provide a means to directly access or manipulate their elements, and are * instead concerned with declaratively describing their source and the * computational operations which will be performed in aggregate on that source. * However, if the provided stream operations do not offer the desired * functionality, the &#123;@link #iterator()&#125; and &#123;@link #spliterator()&#125; operations * can be used to perform a controlled traversal. * * &lt;p&gt;A stream pipeline, like the "widgets" example above, can be viewed as * a &lt;em&gt;query&lt;/em&gt; on the stream source. Unless the source was explicitly * designed for concurrent modification (such as a &#123;@link ConcurrentHashMap&#125;), * unpredictable or erroneous behavior may result from modifying the stream * source while it is being queried. * * &lt;p&gt;Most stream operations accept parameters that describe user-specified * behavior, such as the lambda expression &#123;@code w -&gt; w.getWeight()&#125; passed to * &#123;@code mapToInt&#125; in the example above. To preserve correct behavior, * these &lt;em&gt;behavioral parameters&lt;/em&gt;: * &lt;ul&gt; * &lt;li&gt;must be &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt; * (they do not modify the stream source); and&lt;/li&gt; * &lt;li&gt;in most cases must be &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * (their result should not depend on any state that might change during execution * of the stream pipeline).&lt;/li&gt; * &lt;/ul&gt; * * &lt;p&gt;Such parameters are always instances of a * &lt;a href="../function/package-summary.html"&gt;functional interface&lt;/a&gt; such * as &#123;@link java.util.function.Function&#125;, and are often lambda expressions or * method references. Unless otherwise specified these parameters must be * &lt;em&gt;non-null&lt;/em&gt;. * * &lt;p&gt;A stream should be operated on (invoking an intermediate or terminal stream * operation) only once. This rules out, for example, "forked" streams, where * the same source feeds two or more pipelines, or multiple traversals of the * same stream. A stream implementation may throw &#123;@link IllegalStateException&#125; * if it detects that the stream is being reused. However, since some stream * operations may return their receiver rather than a new stream object, it may * not be possible to detect reuse in all cases. * * &lt;p&gt;Streams have a &#123;@link #close()&#125; method and implement &#123;@link AutoCloseable&#125;, * but nearly all stream instances do not actually need to be closed after use. * Generally, only streams whose source is an IO channel (such as those returned * by &#123;@link Files#lines(Path, Charset)&#125;) will require closing. Most streams * are backed by collections, arrays, or generating functions, which require no * special resource management. (If a stream does require closing, it can be * declared as a resource in a &#123;@code try&#125;-with-resources statement.) * * &lt;p&gt;Stream pipelines may execute either sequentially or in * &lt;a href="package-summary.html#Parallelism"&gt;parallel&lt;/a&gt;. This * execution mode is a property of the stream. Streams are created * with an initial choice of sequential or parallel execution. (For example, * &#123;@link Collection#stream() Collection.stream()&#125; creates a sequential stream, * and &#123;@link Collection#parallelStream() Collection.parallelStream()&#125; creates * a parallel one.) This choice of execution mode may be modified by the * &#123;@link #sequential()&#125; or &#123;@link #parallel()&#125; methods, and may be queried with * the &#123;@link #isParallel()&#125; method. * * @param &lt;T&gt; the type of the stream elements * @since 1.8 * @see IntStream * @see LongStream * @see DoubleStream * @see &lt;a href="package-summary.html"&gt;java.util.stream&lt;/a&gt; */public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123; /** * Returns a stream consisting of the elements of this stream that match * the given predicate. * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate * operation&lt;/a&gt;. * * @param predicate a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * predicate to apply to each element to determine if it * should be included * @return the new stream */ Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); /** * Returns a stream consisting of the results of applying the given * function to the elements of this stream. * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate * operation&lt;/a&gt;. * * @param &lt;R&gt; The element type of the new stream * @param mapper a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function to apply to each element * @return the new stream */ &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); /** * Returns an &#123;@code IntStream&#125; consisting of the results of applying the * given function to the elements of this stream. * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt; * intermediate operation&lt;/a&gt;. * * @param mapper a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function to apply to each element * @return the new stream */ IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper); /** * Returns a &#123;@code LongStream&#125; consisting of the results of applying the * given function to the elements of this stream. * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate * operation&lt;/a&gt;. * * @param mapper a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function to apply to each element * @return the new stream */ LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper); /** * Returns a &#123;@code DoubleStream&#125; consisting of the results of applying the * given function to the elements of this stream. * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate * operation&lt;/a&gt;. * * @param mapper a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function to apply to each element * @return the new stream */ DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper); /** * Returns a stream consisting of the results of replacing each element of * this stream with the contents of a mapped stream produced by applying * the provided mapping function to each element. Each mapped stream is * &#123;@link java.util.stream.BaseStream#close() closed&#125; after its contents * have been placed into this stream. (If a mapped stream is &#123;@code null&#125; * an empty stream is used, instead.) * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate * operation&lt;/a&gt;. * * @apiNote * The &#123;@code flatMap()&#125; operation has the effect of applying a one-to-many * transformation to the elements of the stream, and then flattening the * resulting elements into a new stream. * * &lt;p&gt;&lt;b&gt;Examples.&lt;/b&gt; * * &lt;p&gt;If &#123;@code orders&#125; is a stream of purchase orders, and each purchase * order contains a collection of line items, then the following produces a * stream containing all the line items in all the orders: * &lt;pre&gt;&#123;@code * orders.flatMap(order -&gt; order.getLineItems().stream())... * &#125;&lt;/pre&gt; * * &lt;p&gt;If &#123;@code path&#125; is the path to a file, then the following produces a * stream of the &#123;@code words&#125; contained in that file: * &lt;pre&gt;&#123;@code * Stream&lt;String&gt; lines = Files.lines(path, StandardCharsets.UTF_8); * Stream&lt;String&gt; words = lines.flatMap(line -&gt; Stream.of(line.split(" +"))); * &#125;&lt;/pre&gt; * The &#123;@code mapper&#125; function passed to &#123;@code flatMap&#125; splits a line, * using a simple regular expression, into an array of words, and then * creates a stream of words from that array. * * @param &lt;R&gt; The element type of the new stream * @param mapper a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function to apply to each element which produces a stream * of new values * @return the new stream */ &lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper); /** * Returns an &#123;@code IntStream&#125; consisting of the results of replacing each * element of this stream with the contents of a mapped stream produced by * applying the provided mapping function to each element. Each mapped * stream is &#123;@link java.util.stream.BaseStream#close() closed&#125; after its * contents have been placed into this stream. (If a mapped stream is * &#123;@code null&#125; an empty stream is used, instead.) * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate * operation&lt;/a&gt;. * * @param mapper a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function to apply to each element which produces a stream * of new values * @return the new stream * @see #flatMap(Function) */ IntStream flatMapToInt(Function&lt;? super T, ? extends IntStream&gt; mapper); /** * Returns an &#123;@code LongStream&#125; consisting of the results of replacing each * element of this stream with the contents of a mapped stream produced by * applying the provided mapping function to each element. Each mapped * stream is &#123;@link java.util.stream.BaseStream#close() closed&#125; after its * contents have been placed into this stream. (If a mapped stream is * &#123;@code null&#125; an empty stream is used, instead.) * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate * operation&lt;/a&gt;. * * @param mapper a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function to apply to each element which produces a stream * of new values * @return the new stream * @see #flatMap(Function) */ LongStream flatMapToLong(Function&lt;? super T, ? extends LongStream&gt; mapper); /** * Returns an &#123;@code DoubleStream&#125; consisting of the results of replacing * each element of this stream with the contents of a mapped stream produced * by applying the provided mapping function to each element. Each mapped * stream is &#123;@link java.util.stream.BaseStream#close() closed&#125; after its * contents have placed been into this stream. (If a mapped stream is * &#123;@code null&#125; an empty stream is used, instead.) * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate * operation&lt;/a&gt;. * * @param mapper a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function to apply to each element which produces a stream * of new values * @return the new stream * @see #flatMap(Function) */ DoubleStream flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt; mapper); /** * Returns a stream consisting of the distinct elements (according to * &#123;@link Object#equals(Object)&#125;) of this stream. * * &lt;p&gt;For ordered streams, the selection of distinct elements is stable * (for duplicated elements, the element appearing first in the encounter * order is preserved.) For unordered streams, no stability guarantees * are made. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;stateful * intermediate operation&lt;/a&gt;. * * @apiNote * Preserving stability for &#123;@code distinct()&#125; in parallel pipelines is * relatively expensive (requires that the operation act as a full barrier, * with substantial buffering overhead), and stability is often not needed. * Using an unordered stream source (such as &#123;@link #generate(Supplier)&#125;) * or removing the ordering constraint with &#123;@link #unordered()&#125; may result * in significantly more efficient execution for &#123;@code distinct()&#125; in parallel * pipelines, if the semantics of your situation permit. If consistency * with encounter order is required, and you are experiencing poor performance * or memory utilization with &#123;@code distinct()&#125; in parallel pipelines, * switching to sequential execution with &#123;@link #sequential()&#125; may improve * performance. * * @return the new stream */ Stream&lt;T&gt; distinct(); /** * Returns a stream consisting of the elements of this stream, sorted * according to natural order. If the elements of this stream are not * &#123;@code Comparable&#125;, a &#123;@code java.lang.ClassCastException&#125; may be thrown * when the terminal operation is executed. * * &lt;p&gt;For ordered streams, the sort is stable. For unordered streams, no * stability guarantees are made. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;stateful * intermediate operation&lt;/a&gt;. * * @return the new stream */ Stream&lt;T&gt; sorted(); /** * Returns a stream consisting of the elements of this stream, sorted * according to the provided &#123;@code Comparator&#125;. * * &lt;p&gt;For ordered streams, the sort is stable. For unordered streams, no * stability guarantees are made. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;stateful * intermediate operation&lt;/a&gt;. * * @param comparator a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * &#123;@code Comparator&#125; to be used to compare stream elements * @return the new stream */ Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator); /** * Returns a stream consisting of the elements of this stream, additionally * performing the provided action on each element as elements are consumed * from the resulting stream. * * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate * operation&lt;/a&gt;. * * &lt;p&gt;For parallel stream pipelines, the action may be called at * whatever time and in whatever thread the element is made available by the * upstream operation. If the action modifies shared state, * it is responsible for providing the required synchronization. * * @apiNote This method exists mainly to support debugging, where you want * to see the elements as they flow past a certain point in a pipeline: * &lt;pre&gt;&#123;@code * Stream.of("one", "two", "three", "four") * .filter(e -&gt; e.length() &gt; 3) * .peek(e -&gt; System.out.println("Filtered value: " + e)) * .map(String::toUpperCase) * .peek(e -&gt; System.out.println("Mapped value: " + e)) * .collect(Collectors.toList()); * &#125;&lt;/pre&gt; * * @param action a &lt;a href="package-summary.html#NonInterference"&gt; * non-interfering&lt;/a&gt; action to perform on the elements as * they are consumed from the stream * @return the new stream */ Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action); /** * Returns a stream consisting of the elements of this stream, truncated * to be no longer than &#123;@code maxSize&#125; in length. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;short-circuiting * stateful intermediate operation&lt;/a&gt;. * * @apiNote * While &#123;@code limit()&#125; is generally a cheap operation on sequential * stream pipelines, it can be quite expensive on ordered parallel pipelines, * especially for large values of &#123;@code maxSize&#125;, since &#123;@code limit(n)&#125; * is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the * &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered * stream source (such as &#123;@link #generate(Supplier)&#125;) or removing the * ordering constraint with &#123;@link #unordered()&#125; may result in significant * speedups of &#123;@code limit()&#125; in parallel pipelines, if the semantics of * your situation permit. If consistency with encounter order is required, * and you are experiencing poor performance or memory utilization with * &#123;@code limit()&#125; in parallel pipelines, switching to sequential execution * with &#123;@link #sequential()&#125; may improve performance. * * @param maxSize the number of elements the stream should be limited to * @return the new stream * @throws IllegalArgumentException if &#123;@code maxSize&#125; is negative */ Stream&lt;T&gt; limit(long maxSize); /** * Returns a stream consisting of the remaining elements of this stream * after discarding the first &#123;@code n&#125; elements of the stream. * If this stream contains fewer than &#123;@code n&#125; elements then an * empty stream will be returned. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;stateful * intermediate operation&lt;/a&gt;. * * @apiNote * While &#123;@code skip()&#125; is generally a cheap operation on sequential * stream pipelines, it can be quite expensive on ordered parallel pipelines, * especially for large values of &#123;@code n&#125;, since &#123;@code skip(n)&#125; * is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the * &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered * stream source (such as &#123;@link #generate(Supplier)&#125;) or removing the * ordering constraint with &#123;@link #unordered()&#125; may result in significant * speedups of &#123;@code skip()&#125; in parallel pipelines, if the semantics of * your situation permit. If consistency with encounter order is required, * and you are experiencing poor performance or memory utilization with * &#123;@code skip()&#125; in parallel pipelines, switching to sequential execution * with &#123;@link #sequential()&#125; may improve performance. * * @param n the number of leading elements to skip * @return the new stream * @throws IllegalArgumentException if &#123;@code n&#125; is negative */ Stream&lt;T&gt; skip(long n); /** * Performs an action for each element of this stream. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * &lt;p&gt;The behavior of this operation is explicitly nondeterministic. * For parallel stream pipelines, this operation does &lt;em&gt;not&lt;/em&gt; * guarantee to respect the encounter order of the stream, as doing so * would sacrifice the benefit of parallelism. For any given element, the * action may be performed at whatever time and in whatever thread the * library chooses. If the action accesses shared state, it is * responsible for providing the required synchronization. * * @param action a &lt;a href="package-summary.html#NonInterference"&gt; * non-interfering&lt;/a&gt; action to perform on the elements */ void forEach(Consumer&lt;? super T&gt; action); /** * Performs an action for each element of this stream, in the encounter * order of the stream if the stream has a defined encounter order. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * &lt;p&gt;This operation processes the elements one at a time, in encounter * order if one exists. Performing the action for one element * &lt;a href="../concurrent/package-summary.html#MemoryVisibility"&gt;&lt;i&gt;happens-before&lt;/i&gt;&lt;/a&gt; * performing the action for subsequent elements, but for any given element, * the action may be performed in whatever thread the library chooses. * * @param action a &lt;a href="package-summary.html#NonInterference"&gt; * non-interfering&lt;/a&gt; action to perform on the elements * @see #forEach(Consumer) */ void forEachOrdered(Consumer&lt;? super T&gt; action); /** * Returns an array containing the elements of this stream. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * @return an array containing the elements of this stream */ Object[] toArray(); /** * Returns an array containing the elements of this stream, using the * provided &#123;@code generator&#125; function to allocate the returned array, as * well as any additional arrays that might be required for a partitioned * execution or for resizing. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * @apiNote * The generator function takes an integer, which is the size of the * desired array, and produces an array of the desired size. This can be * concisely expressed with an array constructor reference: * &lt;pre&gt;&#123;@code * Person[] men = people.stream() * .filter(p -&gt; p.getGender() == MALE) * .toArray(Person[]::new); * &#125;&lt;/pre&gt; * * @param &lt;A&gt; the element type of the resulting array * @param generator a function which produces a new array of the desired * type and the provided length * @return an array containing the elements in this stream * @throws ArrayStoreException if the runtime type of the array returned * from the array generator is not a supertype of the runtime type of every * element in this stream */ &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator); /** * Performs a &lt;a href="package-summary.html#Reduction"&gt;reduction&lt;/a&gt; on the * elements of this stream, using the provided identity value and an * &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt; * accumulation function, and returns the reduced value. This is equivalent * to: * &lt;pre&gt;&#123;@code * T result = identity; * for (T element : this stream) * result = accumulator.apply(result, element) * return result; * &#125;&lt;/pre&gt; * * but is not constrained to execute sequentially. * * &lt;p&gt;The &#123;@code identity&#125; value must be an identity for the accumulator * function. This means that for all &#123;@code t&#125;, * &#123;@code accumulator.apply(identity, t)&#125; is equal to &#123;@code t&#125;. * The &#123;@code accumulator&#125; function must be an * &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt; function. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * @apiNote Sum, min, max, average, and string concatenation are all special * cases of reduction. Summing a stream of numbers can be expressed as: * * &lt;pre&gt;&#123;@code * Integer sum = integers.reduce(0, (a, b) -&gt; a+b); * &#125;&lt;/pre&gt; * * or: * * &lt;pre&gt;&#123;@code * Integer sum = integers.reduce(0, Integer::sum); * &#125;&lt;/pre&gt; * * &lt;p&gt;While this may seem a more roundabout way to perform an aggregation * compared to simply mutating a running total in a loop, reduction * operations parallelize more gracefully, without needing additional * synchronization and with greatly reduced risk of data races. * * @param identity the identity value for the accumulating function * @param accumulator an &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt;, * &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function for combining two values * @return the result of the reduction */ T reduce(T identity, BinaryOperator&lt;T&gt; accumulator); /** * Performs a &lt;a href="package-summary.html#Reduction"&gt;reduction&lt;/a&gt; on the * elements of this stream, using an * &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt; accumulation * function, and returns an &#123;@code Optional&#125; describing the reduced value, * if any. This is equivalent to: * &lt;pre&gt;&#123;@code * boolean foundAny = false; * T result = null; * for (T element : this stream) &#123; * if (!foundAny) &#123; * foundAny = true; * result = element; * &#125; * else * result = accumulator.apply(result, element); * &#125; * return foundAny ? Optional.of(result) : Optional.empty(); * &#125;&lt;/pre&gt; * * but is not constrained to execute sequentially. * * &lt;p&gt;The &#123;@code accumulator&#125; function must be an * &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt; function. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * @param accumulator an &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt;, * &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function for combining two values * @return an &#123;@link Optional&#125; describing the result of the reduction * @throws NullPointerException if the result of the reduction is null * @see #reduce(Object, BinaryOperator) * @see #min(Comparator) * @see #max(Comparator) */ Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator); /** * Performs a &lt;a href="package-summary.html#Reduction"&gt;reduction&lt;/a&gt; on the * elements of this stream, using the provided identity, accumulation and * combining functions. This is equivalent to: * &lt;pre&gt;&#123;@code * U result = identity; * for (T element : this stream) * result = accumulator.apply(result, element) * return result; * &#125;&lt;/pre&gt; * * but is not constrained to execute sequentially. * * &lt;p&gt;The &#123;@code identity&#125; value must be an identity for the combiner * function. This means that for all &#123;@code u&#125;, &#123;@code combiner(identity, u)&#125; * is equal to &#123;@code u&#125;. Additionally, the &#123;@code combiner&#125; function * must be compatible with the &#123;@code accumulator&#125; function; for all * &#123;@code u&#125; and &#123;@code t&#125;, the following must hold: * &lt;pre&gt;&#123;@code * combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t) * &#125;&lt;/pre&gt; * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * @apiNote Many reductions using this form can be represented more simply * by an explicit combination of &#123;@code map&#125; and &#123;@code reduce&#125; operations. * The &#123;@code accumulator&#125; function acts as a fused mapper and accumulator, * which can sometimes be more efficient than separate mapping and reduction, * such as when knowing the previously reduced value allows you to avoid * some computation. * * @param &lt;U&gt; The type of the result * @param identity the identity value for the combiner function * @param accumulator an &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt;, * &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function for incorporating an additional element into a result * @param combiner an &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt;, * &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function for combining two values, which must be * compatible with the accumulator function * @return the result of the reduction * @see #reduce(BinaryOperator) * @see #reduce(Object, BinaryOperator) */ &lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner); /** * Performs a &lt;a href="package-summary.html#MutableReduction"&gt;mutable * reduction&lt;/a&gt; operation on the elements of this stream. A mutable * reduction is one in which the reduced value is a mutable result container, * such as an &#123;@code ArrayList&#125;, and elements are incorporated by updating * the state of the result rather than by replacing the result. This * produces a result equivalent to: * &lt;pre&gt;&#123;@code * R result = supplier.get(); * for (T element : this stream) * accumulator.accept(result, element); * return result; * &#125;&lt;/pre&gt; * * &lt;p&gt;Like &#123;@link #reduce(Object, BinaryOperator)&#125;, &#123;@code collect&#125; operations * can be parallelized without requiring additional synchronization. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * @apiNote There are many existing classes in the JDK whose signatures are * well-suited for use with method references as arguments to &#123;@code collect()&#125;. * For example, the following will accumulate strings into an &#123;@code ArrayList&#125;: * &lt;pre&gt;&#123;@code * List&lt;String&gt; asList = stringStream.collect(ArrayList::new, ArrayList::add, * ArrayList::addAll); * &#125;&lt;/pre&gt; * * &lt;p&gt;The following will take a stream of strings and concatenates them into a * single string: * &lt;pre&gt;&#123;@code * String concat = stringStream.collect(StringBuilder::new, StringBuilder::append, * StringBuilder::append) * .toString(); * &#125;&lt;/pre&gt; * * @param &lt;R&gt; type of the result * @param supplier a function that creates a new result container. For a * parallel execution, this function may be called * multiple times and must return a fresh value each time. * @param accumulator an &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt;, * &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function for incorporating an additional element into a result * @param combiner an &lt;a href="package-summary.html#Associativity"&gt;associative&lt;/a&gt;, * &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * function for combining two values, which must be * compatible with the accumulator function * @return the result of the reduction */ &lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner); /** * Performs a &lt;a href="package-summary.html#MutableReduction"&gt;mutable * reduction&lt;/a&gt; operation on the elements of this stream using a * &#123;@code Collector&#125;. A &#123;@code Collector&#125; * encapsulates the functions used as arguments to * &#123;@link #collect(Supplier, BiConsumer, BiConsumer)&#125;, allowing for reuse of * collection strategies and composition of collect operations such as * multiple-level grouping or partitioning. * * &lt;p&gt;If the stream is parallel, and the &#123;@code Collector&#125; * is &#123;@link Collector.Characteristics#CONCURRENT concurrent&#125;, and * either the stream is unordered or the collector is * &#123;@link Collector.Characteristics#UNORDERED unordered&#125;, * then a concurrent reduction will be performed (see &#123;@link Collector&#125; for * details on concurrent reduction.) * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * &lt;p&gt;When executed in parallel, multiple intermediate results may be * instantiated, populated, and merged so as to maintain isolation of * mutable data structures. Therefore, even when executed in parallel * with non-thread-safe data structures (such as &#123;@code ArrayList&#125;), no * additional synchronization is needed for a parallel reduction. * * @apiNote * The following will accumulate strings into an ArrayList: * &lt;pre&gt;&#123;@code * List&lt;String&gt; asList = stringStream.collect(Collectors.toList()); * &#125;&lt;/pre&gt; * * &lt;p&gt;The following will classify &#123;@code Person&#125; objects by city: * &lt;pre&gt;&#123;@code * Map&lt;String, List&lt;Person&gt;&gt; peopleByCity * = personStream.collect(Collectors.groupingBy(Person::getCity)); * &#125;&lt;/pre&gt; * * &lt;p&gt;The following will classify &#123;@code Person&#125; objects by state and city, * cascading two &#123;@code Collector&#125;s together: * &lt;pre&gt;&#123;@code * Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; peopleByStateAndCity * = personStream.collect(Collectors.groupingBy(Person::getState, * Collectors.groupingBy(Person::getCity))); * &#125;&lt;/pre&gt; * * @param &lt;R&gt; the type of the result * @param &lt;A&gt; the intermediate accumulation type of the &#123;@code Collector&#125; * @param collector the &#123;@code Collector&#125; describing the reduction * @return the result of the reduction * @see #collect(Supplier, BiConsumer, BiConsumer) * @see Collectors */ &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector); /** * Returns the minimum element of this stream according to the provided * &#123;@code Comparator&#125;. This is a special case of a * &lt;a href="package-summary.html#Reduction"&gt;reduction&lt;/a&gt;. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal operation&lt;/a&gt;. * * @param comparator a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * &#123;@code Comparator&#125; to compare elements of this stream * @return an &#123;@code Optional&#125; describing the minimum element of this stream, * or an empty &#123;@code Optional&#125; if the stream is empty * @throws NullPointerException if the minimum element is null */ Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator); /** * Returns the maximum element of this stream according to the provided * &#123;@code Comparator&#125;. This is a special case of a * &lt;a href="package-summary.html#Reduction"&gt;reduction&lt;/a&gt;. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal * operation&lt;/a&gt;. * * @param comparator a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * &#123;@code Comparator&#125; to compare elements of this stream * @return an &#123;@code Optional&#125; describing the maximum element of this stream, * or an empty &#123;@code Optional&#125; if the stream is empty * @throws NullPointerException if the maximum element is null */ Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator); /** * Returns the count of elements in this stream. This is a special case of * a &lt;a href="package-summary.html#Reduction"&gt;reduction&lt;/a&gt; and is * equivalent to: * &lt;pre&gt;&#123;@code * return mapToLong(e -&gt; 1L).sum(); * &#125;&lt;/pre&gt; * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;terminal operation&lt;/a&gt;. * * @return the count of elements in this stream */ long count(); /** * Returns whether any elements of this stream match the provided * predicate. May not evaluate the predicate on all elements if not * necessary for determining the result. If the stream is empty then * &#123;@code false&#125; is returned and the predicate is not evaluated. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;short-circuiting * terminal operation&lt;/a&gt;. * * @apiNote * This method evaluates the &lt;em&gt;existential quantification&lt;/em&gt; of the * predicate over the elements of the stream (for some x P(x)). * * @param predicate a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * predicate to apply to elements of this stream * @return &#123;@code true&#125; if any elements of the stream match the provided * predicate, otherwise &#123;@code false&#125; */ boolean anyMatch(Predicate&lt;? super T&gt; predicate); /** * Returns whether all elements of this stream match the provided predicate. * May not evaluate the predicate on all elements if not necessary for * determining the result. If the stream is empty then &#123;@code true&#125; is * returned and the predicate is not evaluated. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;short-circuiting * terminal operation&lt;/a&gt;. * * @apiNote * This method evaluates the &lt;em&gt;universal quantification&lt;/em&gt; of the * predicate over the elements of the stream (for all x P(x)). If the * stream is empty, the quantification is said to be &lt;em&gt;vacuously * satisfied&lt;/em&gt; and is always &#123;@code true&#125; (regardless of P(x)). * * @param predicate a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * predicate to apply to elements of this stream * @return &#123;@code true&#125; if either all elements of the stream match the * provided predicate or the stream is empty, otherwise &#123;@code false&#125; */ boolean allMatch(Predicate&lt;? super T&gt; predicate); /** * Returns whether no elements of this stream match the provided predicate. * May not evaluate the predicate on all elements if not necessary for * determining the result. If the stream is empty then &#123;@code true&#125; is * returned and the predicate is not evaluated. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;short-circuiting * terminal operation&lt;/a&gt;. * * @apiNote * This method evaluates the &lt;em&gt;universal quantification&lt;/em&gt; of the * negated predicate over the elements of the stream (for all x ~P(x)). If * the stream is empty, the quantification is said to be vacuously satisfied * and is always &#123;@code true&#125;, regardless of P(x). * * @param predicate a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;, * &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt; * predicate to apply to elements of this stream * @return &#123;@code true&#125; if either no elements of the stream match the * provided predicate or the stream is empty, otherwise &#123;@code false&#125; */ boolean noneMatch(Predicate&lt;? super T&gt; predicate); /** * Returns an &#123;@link Optional&#125; describing the first element of this stream, * or an empty &#123;@code Optional&#125; if the stream is empty. If the stream has * no encounter order, then any element may be returned. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;short-circuiting * terminal operation&lt;/a&gt;. * * @return an &#123;@code Optional&#125; describing the first element of this stream, * or an empty &#123;@code Optional&#125; if the stream is empty * @throws NullPointerException if the element selected is null */ Optional&lt;T&gt; findFirst(); /** * Returns an &#123;@link Optional&#125; describing some element of the stream, or an * empty &#123;@code Optional&#125; if the stream is empty. * * &lt;p&gt;This is a &lt;a href="package-summary.html#StreamOps"&gt;short-circuiting * terminal operation&lt;/a&gt;. * * &lt;p&gt;The behavior of this operation is explicitly nondeterministic; it is * free to select any element in the stream. This is to allow for maximal * performance in parallel operations; the cost is that multiple invocations * on the same source may not return the same result. (If a stable result * is desired, use &#123;@link #findFirst()&#125; instead.) * * @return an &#123;@code Optional&#125; describing some element of this stream, or an * empty &#123;@code Optional&#125; if the stream is empty * @throws NullPointerException if the element selected is null * @see #findFirst() */ Optional&lt;T&gt; findAny(); // Static factories /** * Returns a builder for a &#123;@code Stream&#125;. * * @param &lt;T&gt; type of elements * @return a stream builder */ public static&lt;T&gt; Builder&lt;T&gt; builder() &#123; return new Streams.StreamBuilderImpl&lt;&gt;(); &#125; /** * Returns an empty sequential &#123;@code Stream&#125;. * * @param &lt;T&gt; the type of stream elements * @return an empty sequential stream */ public static&lt;T&gt; Stream&lt;T&gt; empty() &#123; return StreamSupport.stream(Spliterators.&lt;T&gt;emptySpliterator(), false); &#125; /** * Returns a sequential &#123;@code Stream&#125; containing a single element. * * @param t the single element * @param &lt;T&gt; the type of stream elements * @return a singleton sequential stream */ public static&lt;T&gt; Stream&lt;T&gt; of(T t) &#123; return StreamSupport.stream(new Streams.StreamBuilderImpl&lt;&gt;(t), false); &#125; /** * Returns a sequential ordered stream whose elements are the specified values. * * @param &lt;T&gt; the type of stream elements * @param values the elements of the new stream * @return the new stream */ @SafeVarargs @SuppressWarnings("varargs") // Creating a stream from an array is safe public static&lt;T&gt; Stream&lt;T&gt; of(T... values) &#123; return Arrays.stream(values); &#125; /** * Returns an infinite sequential ordered &#123;@code Stream&#125; produced by iterative * application of a function &#123;@code f&#125; to an initial element &#123;@code seed&#125;, * producing a &#123;@code Stream&#125; consisting of &#123;@code seed&#125;, &#123;@code f(seed)&#125;, * &#123;@code f(f(seed))&#125;, etc. * * &lt;p&gt;The first element (position &#123;@code 0&#125;) in the &#123;@code Stream&#125; will be * the provided &#123;@code seed&#125;. For &#123;@code n &gt; 0&#125;, the element at position * &#123;@code n&#125;, will be the result of applying the function &#123;@code f&#125; to the * element at position &#123;@code n - 1&#125;. * * @param &lt;T&gt; the type of stream elements * @param seed the initial element * @param f a function to be applied to to the previous element to produce * a new element * @return a new sequential &#123;@code Stream&#125; */ public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) &#123; Objects.requireNonNull(f); final Iterator&lt;T&gt; iterator = new Iterator&lt;T&gt;() &#123; @SuppressWarnings("unchecked") T t = (T) Streams.NONE; @Override public boolean hasNext() &#123; return true; &#125; @Override public T next() &#123; return t = (t == Streams.NONE) ? seed : f.apply(t); &#125; &#125;; return StreamSupport.stream(Spliterators.spliteratorUnknownSize( iterator, Spliterator.ORDERED | Spliterator.IMMUTABLE), false); &#125; /** * Returns an infinite sequential unordered stream where each element is * generated by the provided &#123;@code Supplier&#125;. This is suitable for * generating constant streams, streams of random elements, etc. * * @param &lt;T&gt; the type of stream elements * @param s the &#123;@code Supplier&#125; of generated elements * @return a new infinite sequential unordered &#123;@code Stream&#125; */ public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) &#123; Objects.requireNonNull(s); return StreamSupport.stream( new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s), false); &#125; /** * Creates a lazily concatenated stream whose elements are all the * elements of the first stream followed by all the elements of the * second stream. The resulting stream is ordered if both * of the input streams are ordered, and parallel if either of the input * streams is parallel. When the resulting stream is closed, the close * handlers for both input streams are invoked. * * @implNote * Use caution when constructing streams from repeated concatenation. * Accessing an element of a deeply concatenated stream can result in deep * call chains, or even &#123;@code StackOverflowException&#125;. * * @param &lt;T&gt; The type of stream elements * @param a the first stream * @param b the second stream * @return the concatenation of the two input streams */ public static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) &#123; Objects.requireNonNull(a); Objects.requireNonNull(b); @SuppressWarnings("unchecked") Spliterator&lt;T&gt; split = new Streams.ConcatSpliterator.OfRef&lt;&gt;( (Spliterator&lt;T&gt;) a.spliterator(), (Spliterator&lt;T&gt;) b.spliterator()); Stream&lt;T&gt; stream = StreamSupport.stream(split, a.isParallel() || b.isParallel()); return stream.onClose(Streams.composedClose(a, b)); &#125; /** * A mutable builder for a &#123;@code Stream&#125;. This allows the creation of a * &#123;@code Stream&#125; by generating elements individually and adding them to the * &#123;@code Builder&#125; (without the copying overhead that comes from using * an &#123;@code ArrayList&#125; as a temporary buffer.) * * &lt;p&gt;A stream builder has a lifecycle, which starts in a building * phase, during which elements can be added, and then transitions to a built * phase, after which elements may not be added. The built phase begins * when the &#123;@link #build()&#125; method is called, which creates an ordered * &#123;@code Stream&#125; whose elements are the elements that were added to the stream * builder, in the order they were added. * * @param &lt;T&gt; the type of stream elements * @see Stream#builder() * @since 1.8 */ public interface Builder&lt;T&gt; extends Consumer&lt;T&gt; &#123; /** * Adds an element to the stream being built. * * @throws IllegalStateException if the builder has already transitioned to * the built state */ @Override void accept(T t); /** * Adds an element to the stream being built. * * @implSpec * The default implementation behaves as if: * &lt;pre&gt;&#123;@code * accept(t) * return this; * &#125;&lt;/pre&gt; * * @param t the element to add * @return &#123;@code this&#125; builder * @throws IllegalStateException if the builder has already transitioned to * the built state */ default Builder&lt;T&gt; add(T t) &#123; accept(t); return this; &#125; /** * Builds the stream, transitioning this builder to the built state. * An &#123;@code IllegalStateException&#125; is thrown if there are further attempts * to operate on the builder after it has entered the built state. * * @return the built stream * @throws IllegalStateException if the builder has already transitioned to * the built state */ Stream&lt;T&gt; build(); &#125;&#125; 串行流、并行流 Collection接口 123456789101112131415161718192021222324252627282930313233343536373839/** * Returns a sequential &#123;@code Stream&#125; with this collection as its source. * * &lt;p&gt;This method should be overridden when the &#123;@link #spliterator()&#125; * method cannot return a spliterator that is &#123;@code IMMUTABLE&#125;, * &#123;@code CONCURRENT&#125;, or &lt;em&gt;late-binding&lt;/em&gt;. (See &#123;@link #spliterator()&#125; * for details.) * * @implSpec * The default implementation creates a sequential &#123;@code Stream&#125; from the * collection's &#123;@code Spliterator&#125;. * * @return a sequential &#123;@code Stream&#125; over the elements in this collection * @since 1.8 */default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false);&#125;/** * Returns a possibly parallel &#123;@code Stream&#125; with this collection as its * source. It is allowable for this method to return a sequential stream. * * &lt;p&gt;This method should be overridden when the &#123;@link #spliterator()&#125; * method cannot return a spliterator that is &#123;@code IMMUTABLE&#125;, * &#123;@code CONCURRENT&#125;, or &lt;em&gt;late-binding&lt;/em&gt;. (See &#123;@link #spliterator()&#125; * for details.) * * @implSpec * The default implementation creates a parallel &#123;@code Stream&#125; from the * collection's &#123;@code Spliterator&#125;. * * @return a possibly parallel &#123;@code Stream&#125; over the elements in this * collection * @since 1.8 */default Stream&lt;E&gt; parallelStream() &#123; return StreamSupport.stream(spliterator(), true);&#125; Function接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * * */package java.util.function;import java.util.Objects;/** * Represents a function that accepts one argument and produces a result. * * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt; * whose functional method is &#123;@link #apply(Object)&#125;. * * @param &lt;T&gt; the type of the input to the function * @param &lt;R&gt; the type of the result of the function * * @since 1.8 */@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); /** * Returns a composed function that first applies the &#123;@code before&#125; * function to its input, and then applies this function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param &lt;V&gt; the type of input to the &#123;@code before&#125; function, and to the * composed function * @param before the function to apply before this function is applied * @return a composed function that first applies the &#123;@code before&#125; * function and then applies this function * @throws NullPointerException if before is null * * @see #andThen(Function) */ default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123; Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); &#125; /** * Returns a composed function that first applies this function to * its input, and then applies the &#123;@code after&#125; function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param &lt;V&gt; the type of output of the &#123;@code after&#125; function, and of the * composed function * @param after the function to apply after this function is applied * @return a composed function that first applies this function and then * applies the &#123;@code after&#125; function * @throws NullPointerException if after is null * * @see #compose(Function) */ default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); &#125; /** * Returns a function that always returns its input argument. * * @param &lt;T&gt; the type of the input and output objects to the function * @return a function that always returns its input argument */ static &lt;T&gt; Function&lt;T, T&gt; identity() &#123; return t -&gt; t; &#125;&#125;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[索引库]]></title>
    <url>%2Fmyhexo%2F2019%2F05%2F02%2F%E7%B4%A2%E5%BC%95%E5%BA%93%2F</url>
    <content type="text"><![CDATA[worktechnologygitWorld Hello - WorldHello Pro Git（中文版） Git 完整教程–idea使用git进行项目管理 - it技术专业户 - 博客园 Git教程 - 廖雪峰的官方网站 Git 使用规范流程_慕课手记 Git - Book 使用webstorm操作git - 金广国 - 博客园 (9+条消息)Git/GitHub教程2-与本地和GitHub上删除repository和folder相关 - ljsnail的博客 - CSDN博客 如何撰写 Git 提交信息 - 囧克斯 Plugin ANZEclipse 安装 SVN 在线插件教程_java_脚本之家 Mysql5.7.14安装配置方法操作图文教程(密码问题解决办法)_Mysql_脚本之家 ideaIntelliJ_13书签 - 扯 - 博客园 Intellij IDEA 快捷键大全 - IntelliJ IDEA - 开发语言与工具 - 深度开源 介绍 - IntelliJ IDEA 使用教程 - 极客学院Wiki IDEA中对应eclipse ctrl + 2 + L的快捷键 是哪个 IDEA中对应eclipse ctrl + 2 + L的快捷键 是哪个？ - 知乎 IntelliJ IDEA 使用心得与常用快捷键 - 码农往事 - BlogJava IDEA 2018 激活 IDEA 2018.3激活教程 最新的（三种）—2018.11.26亲测 - HALEN的博客 - CSDN博客 IntelliJ IDEA 注册码 IDEA插件JRebel安装配置与破解激活详细教程 - Zephyrus007 - 博客园 Intellij IDEA 安装jrebel插件 - CSDN博客 Intellij IDEA神器居然还有这些小技巧 - CSDN博客 IDEA 主题样式 idea翻译插件Translation的安装与使用 - 简书 (9条消息)两分钟解决IntelliJ IDEA中文乱码问题 - 一生伏首拜阳明 - CSDN博客 IntelliJ IDEA 14.1 导入MyEclipse2015工程的过程及所遇问题整理 - 综合编程类其他综合 - 红黑联盟 (9条消息)idea项目全局去掉严格的语法校验 - 坚持积累坚持记录 - CSDN博客 goole赛风 | 下载 Android 应用和 Windows 客户端 如何安装CRX格式？Chrome插件离线安装，CRX格式安装方法 - Chrome插件网 Chrome 浏览器 必知必会的小技巧 你不知道的Chrome DevTools（2）：那些debug的技巧 - civerzhu - SegmentFault 思否 Javascript调试命令——你只会Console.log() ? - 前端小记 - SegmentFault 思否 必备的JS调试技巧汇总_javascript技巧_脚本之家 Google Chrome 网络浏览器 chrome开发者工具各种骚技巧 - 掘金 自建ss服务器教程 · Alvin9999/new-pac Wiki · GitHub ss免费账号 · Alvin9999/new-pac Wiki · GitHub Vultr充值送50美元，2019年大促-Vultr VPS My Subscriptions - Vultr.com gradleGradle - Help | IntelliJ IDEA 慕课网_《新一代构建工具gradle》学习总结 - study - SegmentFault 思否 Gradle用户指南官方文档中文版_Gradle 教程_Gradle_极客学院 Wiki (9+条消息)IDEA 及 Gradle 使用总结 - cluzax的专栏 - CSDN博客 TomcatTomcat源码分析(一)之源码下载与导入IDEA - 宸明 cssCSS-Secrets/notes at master · cssmagic/CSS-Secrets CSS森林(CSS Forest) - 标签 学习CSS布局 关于css水平垂直居中的总结 · Issue #12 · hawx1993/tech-blog 个人总结（css3新特性） - 守候书阁 - SegmentFault 思否 关于「圣杯布局」 - 天道酬勤 - SegmentFault 思否 CSS3 动画 | 菜鸟教程 A Complete Guide to Flexbox | CSS-Tricks 浅谈display:flex - love星期六 - 博客园 Can I use… Support tables for HTML5, CSS3, etc jsVS Code - Debugger for Chrome调试JavaScript的两种方式 - SolidMango - 博客园 Understanding JavaScript’s async await 【JS实用技巧】优化动态创建元素的方式，让代码更加优雅且利于维护 - Web开发之路 - SegmentFault 思否 JavaScript如何一次性展示几万条数据 - 陈宏鸿 - 博客园 JavaScript 运行机制–Event Loop详解 - 掘金 跟着9张思维导图学习Javascript - ChokCoco - 博客园 JavaScript性能优化小窍门实例汇总 - 性能优化 - 开发语言与工具 - 深度开源 45个有用的JavaScript技巧，窍门和最佳实践 - 掘金 JavaScript深入系列15篇正式完结！ - 掘金 JavaScript性能优化小窍门实例汇总 - 性能优化 - 开发语言与工具 - 深度开源 pythonPython爬虫入门 | Linux运维部落 【超全整理】《Python自动化全能开发从入门到精通》python基础教程笔记全放送 | 马哥教育官网-专业linux培训|python培训 人生苦短，我用Python（目录） - 海燕。 - 博客园 pycharm项目上传到Github - Jacck - 博客园 数据提取之JSON与JsonPATH-博客-云栖社区-阿里云 MarkdownMastering Markdown · GitHub Guides hexohexo史上最全搭建教程 - Fangzh的技术博客 - CSDN博客 如何优雅地发布Hexo博客 - 简书 绝配：hexo+next主题及我走过的坑 - 简书 为NexT主题添加文章阅读量统计功能 | Doublemine 备份Hexo博客源文件 | Doublemine Interview questions从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！ - 前端 - 掘金 springjQueryjava深入理解Java：SimpleDateFormat安全的时间格式化 - peida - 博客园 java-生成任意格式的json数据 - web喵神 - 博客园 segmentfault-lessons/「一入 Java 深似海 」 at master · mercyblitz/segmentfault-lessons ssmMAC下使用IDEA搭建SSM的Maven项目 - 后端 - 掘金 databasePL/SQL游标 - PL/SQL教程™ inner join 与 left join 之间的区别 - 十七年的夏天 - 博客园 oracle查询重复数据方法 - 小人物的奋斗 - 博客园 关于本书 - Oracle-RAC 体验 - 极客学院Wiki Using Oracle Real Application Clusters (RAC) for High Availability Oracle数据库18c - 教程 达梦数据库-国产数据库-掌握全部源代码-拥有完全自主知识产权-大数据-云平台-DCA认证培训-数据库培训-柔性替代方案 mybatismybatis – MyBatis 3 | Introduction mybatis-spring – MyBatis-Spring | 简介 mybaits入门（含实例教程和源码） - CSDN博客 MavenEclipse上Maven环境配置使用 (全) - java_2017_csdn的博客 - CSDN博客 (9+条消息)使用IntelliJ IDEA 配置Maven（入门） - 记事本 - CSDN博客 IntelliJ IDEA 15 创建maven项目 - Angelaboy - 博客园 svn(9+条消息)IntelliJ IDEA 下的svn配置及使用的非常详细的图文总结 - 请叫我大师兄 - CSDN博客 (9条消息)Idea SVN导出MyEclipse项目部署问题 - 小白笔记本 - CSDN博客 linuxLinux基础教程之vim编辑器使用入门 | 马哥教育官网-专业linux培训|python培训 《Linux就该这么学》 - 必读的Linux系统与红帽RHCE认证免费自学书籍 详解Ubuntu 16.04 几个国内更新源_Linux_脚本之家 Linux 中国◆开源社区|技术 Ubuntu 18.04 安装微信（Linux通用） - 毒逆天 - 博客园 如何在Ubuntu上使用微信客户端 | 《Linux就该这么学》 如何使用 U 盘安装 Ubuntu 操作系统？ - 知乎 springbootIntroduction · spring-boot-book 「一入 Java 深似海 」系列 2019年第一季（第一、二、三期合集） - 思否编程 SpringBoot系列一：SpringBoot入门 - ImportNew iptvJava实现将文本内容、网址链接url,生成二维码与反解析（转） - frank1998819 - ITeye博客 Java利用Google Zxing实现在线生成二维码和二维码解码 - yoodb - 素文宅博客 Java Code Examples com.google.zxing.client.j2se.BufferedImageLuminanceSource EnglishCourse逆风学习网 - Powered by Discuz! GitHubmercyblitz (Mercy Ma) 开发环境Putty的安装和使用 - 阿亮的博客 - CSDN博客 8 Reasons Why Typora Might Be Your Favorite Markdown Editor Release pandoc 2.0.6 · jgm/pandoc Eclipse Packages | The Eclipse Foundation - home to a global community, the Eclipse IDE, Jakarta EE and over 350 open source projects… 数据结构与算法如果天空不死的主页 - 博客园 windowsHow To Fix Kernel Data Inpage Error in Windows 10? 小米帮助中心-小米商城 springmvcspringmvc前台访问404，不能进入controller，后台不报错问题解决方案心得 - ITwelision的博客 - CSDN博客 blog静觅 崔庆才的个人博客 Nikkkki’s Notes 奇舞周刊 Web前端导航 前端圈——打造专业的前端技术会议– 个人分享–web前端学习资源分享 - 掘金 小马哥的技术博客 - 小马哥的技术博客 ZhongFuCheng3y/3y: 3y文章导航 https://yuzhouwan.com/ hijiangtao (Joe Jiang) Eloquent JavaScript Snailclimb (SnailClimb) 前端开发博客-前端开发,前端博客 41个网站每个Java开发人员都应该收藏 11个最值得Java开发者收藏的网站 - ImportNew IBM developerWorks 中国 : Java technology : 文档库 Tutorials on JavaScript, React, Vue, GraphQL, and more 过往记忆 芋道源码 —— 纯源码解析博客 apiSpring Framework Documentation The Python Tutorial — Python 3.8.0a0 documentation The Python Standard Library — Python 3.7.1 documentation mybatis – MyBatis 3 | Introduction Spring Boot Reference Guide Spring Cloud jQuery API Documentation Cycle.js Cycle.js ECMAScript 2015 Language Specification – ECMA-262 6th Edition GitHub Developer | GitHub Developer Guide_测试接口 jQuery API 中文文档 | jQuery API 中文在线手册 | jquery api 下载 | jquery api chm ECharts nefe/You-Dont-Need-jQuery: Examples of how to do query, style, dom, ajax, event etc like jQuery with plain javascript. Guides | Node.js React Router: Declarative Routing for React.js 菜鸟教程 - 学的不仅是技术，更是梦想！ MySQL :: MySQL 5.7 Reference Manual Home - Wiki - 码云 Gitee.com Python Module Index — Python 3.8.0a3 documentation lyj8330328/leyou: 乐优商城项目后台 MDN Web 文档 Bootstrap中文网 Wikipedia devAtom IntelliJ IDEA: The Java IDE for Professional Developers by JetBrains Download PuTTY: latest release (0.70) 淘宝 NPM 镜像 Babel · The compiler for next generation JavaScript Index of /]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[day19-下单]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F27%2Fday19-%E4%B8%8B%E5%8D%95%2F</url>
    <content type="text"><![CDATA[学习目标 会调用订单系统接口 实现订单结算功能 实现微信支付功能 订单系统接口 我们不做开发，只讲解 导入订单服务 把课前资料提供的leyou-order复制到D:\heima\code\leyou目录。 然后在工程内导入： 然后导入module： 选择导入module： 选择目录中的 ly-order： 打开父工程leyou的pom文件，添加ly-order模块： Swagger-UI 丝袜哥 什么是OpenAPI 随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了：前端渲染、前后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。 前端和后端的唯一联系，变成了API接口；API文档变成了前后端开发人员联系的纽带，变得越来越重要。 没有API文档工具之前，大家都是手写API文档的，在什么地方书写的都有，而且API文档没有统一规范和格式，每个公司都不一样。这无疑给开发带来了灾难。 OpenAPI规范（OpenAPI Specification 简称OAS）是Linux基金会的一个项目，试图通过定义一种用来描述API格式或API定义的语言，来规范RESTful服务开发过程。目前V3.0版本的OpenAPI规范已经发布并开源在github上 。 官网：https://github.com/OAI/OpenAPI-Specification 什么是swagger？ OpenAPI是一个编写API文档的规范，然而如果手动去编写OpenAPI规范的文档，是非常麻烦的。而Swagger就是一个实现了OpenAPI规范的工具集。 官网：https://swagger.io/ 看官方的说明： Swagger包含的工具集： Swagger编辑器： Swagger Editor允许您在浏览器中编辑YAML中的OpenAPI规范并实时预览文档。 Swagger UI： Swagger UI是HTML，Javascript和CSS资产的集合，可以从符合OAS标准的API动态生成漂亮的文档。 Swagger Codegen：允许根据OpenAPI规范自动生成API客户端库（SDK生成），服务器存根和文档。 Swagger Parser：用于解析来自Java的OpenAPI定义的独立库 Swagger Core：与Java相关的库，用于创建，使用和使用OpenAPI定义 Swagger Inspector（免费）： API测试工具，可让您验证您的API并从现有API生成OpenAPI定义 SwaggerHub（免费和商业）： API设计和文档，为使用OpenAPI的团队构建。 快速入门 SpringBoot已经集成了Swagger，使用简单注解即可生成swagger的API文档。 引入依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt; 编写配置 12345678910111213141516171819202122@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket api() &#123; return new Docket(DocumentationType.SWAGGER_2) .host("http://order.leyou.com") .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.leyou.order.controller")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("乐优商城订单系统") .description("乐优商城订单系统接口文档") .version("1.0") .build(); &#125;&#125; 接口声明 在controller的每个handler上添加接口说明注解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@RestController@RequestMapping("order")@Api("订单服务接口")public class OrderController &#123; @Autowired private OrderService orderService; @Autowired private PayHelper payHelper; /** * 创建订单 * * @param order 订单对象 * @return 订单编号 */ @PostMapping @ApiOperation(value = "创建订单接口，返回订单编号", notes = "创建订单") @ApiImplicitParam(name = "order", required = true, value = "订单的json对象,包含订单条目和物流信息") public ResponseEntity&lt;Long&gt; createOrder(@RequestBody @Valid Order order) &#123; Long id = this.orderService.createOrder(order); return new ResponseEntity&lt;&gt;(id, HttpStatus.CREATED); &#125; /** * 分页查询当前用户订单 * * @param status 订单状态 * @return 分页订单数据 */ @GetMapping("list") @ApiOperation(value = "分页查询当前用户订单，并且可以根据订单状态过滤", notes = "分页查询当前用户订单") @ApiImplicitParams(&#123; @ApiImplicitParam(name = "page", value = "当前页", defaultValue = "1", type = "Integer"), @ApiImplicitParam(name = "rows", value = "每页大小", defaultValue = "5", type = "Integer"), @ApiImplicitParam( name = "status", value = "订单状态：1未付款，2已付款未发货，3已发货未确认，4已确认未评价，5交易关闭，6交易成功，已评价", type = "Integer"), &#125;) public ResponseEntity&lt;PageResult&lt;Order&gt;&gt; queryUserOrderList( @RequestParam(value = "page", defaultValue = "1") Integer page, @RequestParam(value = "rows", defaultValue = "5") Integer rows, @RequestParam(value = "status", required = false) Integer status) &#123; PageResult&lt;Order&gt; result = this.orderService.queryUserOrderList(page, rows, status); if (result == null) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(result); &#125;&#125; 常用注解说明： 12345678910111213/** @Api：修饰整个类，描述Controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口 @ApiParam：单个参数描述 @ApiModel：用对象来接收参数 @ApiProperty：用对象接收参数时，描述对象的一个字段 @ApiResponse：HTTP响应其中1个描述 @ApiResponses：HTTP响应整体描述 @ApiIgnore：使用该注解忽略这个API @ApiError ：发生错误返回的信息 @ApiImplicitParam：一个请求参数 @ApiImplicitParams：多个请求参数 */ 启动测试 启动服务，然后访问：http://localhost:8089/swagger-ui.html 点击order-controller，查看接口信息： 点击任意一个接口，即可看到详细信息： 测试接口 创建订单接口 可以通过页面看到接口信息： 请求方式：POST 请求路径：/order 请求参数：包含订单、订单详情等数据的json对象。 返回结果：订单编号 点击Try It Out来测试： 输入数据： 123456789101112131415161718192021222324252627&#123; "totalPay": 236800, "postFee": 0, "paymentType": 2, "actualPay": 236800, "buyerMessage": null, "buyerNick": "huge", "orderDetails": [ &#123; "skuId": 3893493, "num": 1, "title": "苹果（Apple）iPhone 6 (A1586) 16GB 金色 移动联通电信4G手机3", "price": 236800, "ownSpec": "&#123;\"机身颜色\":\"钻雕蓝\",\"内存\":\"4GB\",\"机身存储\":\"64GB\"&#125;", "image": "http://image.leyou.com/images/9/4/1524297342728.jpg" &#125; ], "receiver": "锋哥", "receiverMobile": "15800000000", "receiverState": "上海", "receiverCity": "上海", "receiverDistrict": "浦东新签", "receiverAddress": "航头镇航头路18号传智播客3号楼", "receiverZip": "210000", "invoiceType": 0, "sourceType":2&#125; 然后点击execute： 结果： 下单需要登录，通过登录生成token： 把token的值手动加入到浏览器的cookie中： 添加成功，响应订单编号。但是和数据库保存的订单编号不太一样（后几位不一样，浏览器展示长整型会出现精度损失） 生成ID的方式 订单id的特殊性 订单数据非常庞大，将来一定会做分库分表。那么这种情况下， 要保证id的唯一，就不能靠数据库自增，而是自己来实现算法，生成唯一id。 雪花算法 这里的订单id是通过一个工具类生成的： 而工具类所采用的生成id算法，是由Twitter公司开源的snowflake（雪花）算法。 简单原理 雪花算法会生成一个64位的二进制数据，为一个Long型。(转换成字符串后长度最多19位) ，其基本结构： 第一位：为未使用 第二部分：41位为毫秒级时间(41位的长度可以使用69年) 第三部分：5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点） 第四部分：最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号） snowflake生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和workerId作区分），并且效率较高。经测试snowflake每秒能够产生26万个ID。 配置 为了保证不重复，我们给每个部署的节点都配置机器id： 1234leyou: worker: workerId: 1 datacenterId: 1 加载属性： 1234567891011121314151617181920212223@ConfigurationProperties(prefix = "leyou.worker")public class IdWorkerProperties &#123; private long workerId;// 当前机器id private long datacenterId;// 序列号 public long getWorkerId() &#123; return workerId; &#125; public void setWorkerId(long workerId) &#123; this.workerId = workerId; &#125; public long getDatacenterId() &#123; return datacenterId; &#125; public void setDatacenterId(long datacenterId) &#123; this.datacenterId = datacenterId; &#125;&#125; 编写配置类： 123456789@Configuration@EnableConfigurationProperties(IdWorkerProperties.class)public class IdWorkerConfig &#123; @Bean public IdWorker idWorker(IdWorkerProperties prop) &#123; return new IdWorker(prop.getWorkerId(), prop.getDatacenterId()); &#125;&#125; 使用： 查询订单接口 接口说明： 请求方式：GET 请求路径：/order/{id} 请求参数：id，订单编号 返回结果：Order，订单的json对象 测试： 结果： 更新订单状态 接口说明： 请求参数：PUT 请求路径：/order/{id}/{status} 请求参数： id：订单编号，String类型，不能为空 status：订单状态，不能为空 返回结果：null 测试： 结果： 数据库中也发生了改变： 分页查询订单 接口说明： 请求方式：Get 请求路径：/order/list 请求参数： page：当前页，Integer类型，默认为1 rows：每页大小，Integer类型，默认为5 status：订单状态，String类型，默认查询全部状态订单 返回结果：PageResult 对象，包含下面属性： total：总条数 items：当前页订单数组 订单对象 测试： 结果： 生成微信付款链接 接口说明： 请求方式：Get 请求路径：/order/url/{id} 请求参数：id，订单编号 返回结果：String类型，生成的微信支付链接 测试： 结果： 微信支付工具 PayHelper 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108@Componentpublic class PayHelper &#123; private WXPay wxPay; private static final Logger logger = LoggerFactory.getLogger(PayHelper.class); @Autowired private StringRedisTemplate redisTemplate; @Autowired private OrderService orderService; public PayHelper(PayConfig payConfig) &#123; // 真实开发时 wxPay = new WXPay(payConfig); // 测试时 // wxPay = new WXPay(payConfig, WXPayConstants.SignType.MD5, true); &#125; public String createPayUrl(Long orderId) &#123; String key = "ly.pay.url." + orderId; try &#123; String url = this.redisTemplate.opsForValue().get(key); if (StringUtils.isNotBlank(url)) &#123; return url; &#125; &#125; catch (Exception e) &#123; logger.error("查询缓存付款链接异常,订单编号：&#123;&#125;", orderId, e); &#125; try &#123; Map&lt;String, String&gt; data = new HashMap&lt;&gt;(); // 商品描述 data.put("body", "乐优商城测试"); // 订单号 data.put("out_trade_no", orderId.toString()); //货币 data.put("fee_type", "CNY"); //金额，单位是分 data.put("total_fee", "1"); //调用微信支付的终端IP（estore商城的IP） data.put("spbill_create_ip", "127.0.0.1"); //回调地址 data.put("notify_url", "http://test.leyou.com/wxpay/notify"); // 交易类型为扫码支付 data.put("trade_type", "NATIVE"); //商品id,使用假数据 data.put("product_id", "1234567"); Map&lt;String, String&gt; result = this.wxPay.unifiedOrder(data); if ("SUCCESS".equals(result.get("return_code"))) &#123; String url = result.get("code_url"); // 将付款地址缓存，时间为10分钟 try &#123; this.redisTemplate.opsForValue().set(key, url, 10, TimeUnit.MINUTES); &#125; catch (Exception e) &#123; logger.error("缓存付款链接异常,订单编号：&#123;&#125;", orderId, e); &#125; return url; &#125; else &#123; logger.error("创建预交易订单失败，错误信息：&#123;&#125;", result.get("return_msg")); return null; &#125; &#125; catch (Exception e) &#123; logger.error("创建预交易订单异常", e); return null; &#125; &#125; /** * 查询订单状态 * * @param orderId * @return */ public PayState queryOrder(Long orderId) &#123; Map&lt;String, String&gt; data = new HashMap&lt;&gt;(); // 订单号 data.put("out_trade_no", orderId.toString()); try &#123; Map&lt;String, String&gt; result = this.wxPay.orderQuery(data); if (result == null) &#123; // 未查询到结果，认为是未付款 return PayState.NOT_PAY; &#125; String state = result.get("trade_state"); if ("SUCCESS".equals(state)) &#123; // success，则认为付款成功 // 修改订单状态 this.orderService.updateStatus(orderId, 2); return PayState.SUCCESS; &#125; else if (StringUtils.equals("USERPAYING", state) || StringUtils.equals("NOTPAY", state)) &#123; // 未付款或正在付款，都认为是未付款 return PayState.NOT_PAY; &#125; else &#123; // 其它状态认为是付款失败 return PayState.FAIL; &#125; &#125; catch (Exception e) &#123; logger.error("查询订单状态异常", e); return PayState.NOT_PAY; &#125; &#125;&#125; 跟支付相关的其它几个类： 查询支付状态 接口说明： 请求方式： Get 请求路径： /state/{id} 请求参数： id，订单编号 返回结果：0, 未查询到支付信息 1,支付成功 2,支付失败（查询失败，或者订单过期） 未付款 未付款时查询，测试： 结果： 因为尚未付款，所以查询返回0。 付款 通过JS把链接变成二维码。 找到课前资料提供的JS页面： 进入，并输入刚刚生成的地址： 已付款 扫码支付，然后再次查询： 状态码为1，代表支付成功了！ 订单结算页 页面跳转 在购物车页面的最下方，有一个去结算按钮： 当点击结算，我们应该跳转到订单结算页，即：getOrderInfo.html 查看购物车的结算按钮： 可以看到，地址是正确的。但是只有登录用户才可以去结算付款，因此我们不能直接跳转，而是在跳转前校验用户的登录状态，如果发现是未登录，应该重定向到登录页！ 我们给这个按钮绑定点击事件： 事件中判断登录状态，进行页面跳转： 12345678910toOrderInfo() &#123; // 判断是否登录 ly.verifyUser().then(() =&gt; &#123; // 已登录 window.location.href = "/getOrderInfo.html" &#125;).catch(() =&gt; &#123; // 未登录 window.location.href = "/login.html?returnUrl=" + window.location.href; &#125;)&#125; 登录后测试： 此处页面需要渲染的内容主要包含3部分： 收货人信息 支付方式 商品信息 收货人信息（作业） 这里的收货人信息肯定是当前登录用户的收货地址。所以需要根据当前登录用户去查询，目前我们在页面是写的假数据： 大家可以在在后台提供地址的增删改查接口，然后页面加载时根据当前登录用户查询，而后赋值给addresses即可。 支付方式 支付方式有2种： 微信支付 货到付款 与我们订单数据中的paymentType关联： 所以我们可以在Vue实例中定义一个属性来记录支付方式： 然后在页面渲染时与这个变量关联： 商品列表 效果图： 这里的送货清单，其实就是购物车中用户选择的要付款的商品 因此，我们需要在购物车跳转过来的同时，携带选中的购物车的信息 购物车信息获取 我们修改cart.html中的页面跳转逻辑，把用户选中的购物车信息传递过来： 然后在created钩子函数中获取购物车数据，保存到本地属性，要注意的是，我们应该在获取数据前校验用户登录状态，如果发现未登录，则直接重定向到登录页： 然后重新加载页面，查看控制台： 页面渲染 要修改的页面位置：每一个li就是一件商品 我们修改为： 1234567891011121314151617181920212223242526&lt;ul class="send-detail"&gt; &lt;li v-for="(cart,index) in carts" :key="index"&gt; &lt;div class="sendGoods"&gt; &lt;ul class="yui3-g"&gt; &lt;li class="yui3-u-1-6"&gt; &lt;span&gt;&lt;img width="70px" height="70px" :src="cart.image"/&gt;&lt;/span&gt; &lt;/li&gt; &lt;li class="yui3-u-7-12"&gt; &lt;div class="desc"&gt;&#123;&#123;cart.title&#125;&#125;&lt;/div&gt; &lt;div class="seven"&gt; &lt;span v-for="(v) in JSON.parse(cart.ownSpec)"&gt;&#123;&#123;v + " "&#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="yui3-u-1-12"&gt; &lt;div class="price"&gt;￥&#123;&#123;ly.formatPrice(cart.price * cart.num)&#125;&#125;&lt;/div&gt; &lt;/li&gt; &lt;li class="yui3-u-1-12"&gt; &lt;div class="num"&gt;&#123;&#123;cart.num&#125;&#125;&lt;/div&gt; &lt;/li&gt; &lt;li class="yui3-u-1-12"&gt; &lt;div class="exit"&gt;有货&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; 总金额 另外在商品列表下面，还有一个总金额的计算： 可以看出这里主要有4个数据： 总金额：totalPay 优惠返现：discount 运费：postFee 实付金额：actualPay 不过我们没有做优惠活动，另外运费需要结合物流系统来计算，暂时我们都设置为0，在order属性中写死： 我们通过计算属性来得到totalPay和actualPay值： 1234567891011computed: &#123; totalNum()&#123; return this.carts.reduce((c1, c2) =&gt; c1 + c2.num, 0) &#125;, totalPay()&#123; return this.carts.reduce((c1, c2) =&gt; c1 + c2.price * c2.num, 0); &#125;, actualPay()&#123; return this.totalPay + this.order.postFee - this.order.discount; &#125;&#125;, 然后在页面渲染： 效果： 提交订单 页面提交 来看下订单接口所需要的数据： 分为3部分，分别是 订单本身的基本信息 总金额 实付金额 付款类型 买家信息就是当前用户 订单详情 就是购物车中的商品，不过购物车数据会多出一个userId，我们去除即可： 物流信息 当前用户选中的物流地址信息 给提交按钮绑定事件： 然后编写方法，组织数据并提交： 123456789101112131415161718192021222324252627282930methods: &#123; submit() &#123; // 把购物车数据处理成订单详情 const orderDetails = this.carts.map((&#123;userId, ...rest&#125;) =&gt; rest); // 处理物流信息 const addr = this.addresses[this.selectedAddress]; const obj = &#123; receiver: addr.name, receiverState: addr.state, receiverCity: addr.city, receiverAddress: addr.address, receiverDistrict: addr.district, receiverMobile: addr.phone, receiverZip: addr.zipCode &#125;; // 复制到订单对象 Object.assign(this.order, obj, &#123; orderDetails, totalPay: this.totalPay, actualPay: this.actualPay, &#125;); // 提交订单 ly.http.post("/order", this.order).then((&#123;data&#125;) =&gt; &#123; // 在线支付，需要到付款页 window.location = "pay.html?orderId=" + data; &#125;).catch((resp) =&gt; &#123; alert("订单提交失败，可能是缺货!") &#125;) &#125;&#125;, 精度损失问题 在页面点击提交测试： 成功生成订单！ 然后看页面跳转： 好像有什么不对？订单号的最后2位不正确啊！ 这其实是因为JS的长整数精度有限，java的Long类型数据超出了范围，所以出现了精度损失。 我们后台返回的是Json的字符串，在axios内部会自动调用 JSON.parse()方法把json字符串转为JS数据，就会出现进度损失。如果不进行转换，依然当做字符串来使用，就不会有问题了。 因此，我们重写axios对响应的处理回调函数： 再次测试，就OK了。 接下来就轮到支付了。 微信支付 介绍 微信支付官方文档：https://pay.weixin.qq.com/index.php/core/home/login?return_url=%2F 我们选择开发文档，而后进入选择页面： 选择扫码支付： 此处我们使用模式二来开发： 开发流程 模式二与模式一相比，流程更为简单，不依赖设置的回调支付URL。 商户后台系统先调用微信支付的统一下单接口，微信后台系统返回链接参数code_url； 商户后台系统将code_url值生成二维码图片，用户使用微信客户端扫码后发起支付。 注意：code_url有效期为2小时，过期后扫码不能再发起支付。 流程图： 这里我们把商户（我们）要做的事情总结一下： 1、商户生成订单 2、商户调用微信下单接口，获取预交易的链接 3、商户将链接生成二维码图片，展示给用户； 4、用户支付并确认 5、支付结果通知： 微信异步通知商户支付结果，商户告知微信支付接收情况 商户如果没有收到通知，可以调用接口，查询支付状态 6、如果支付成功，发货，修改订单状态 在前面的业务中，我们已经完成了： 1、生成订单 接下来，我们需要做的是： 2、调用微信接口，生成链接。 3、并且生成二维码图片 生成二维码 生成预交易链接 我们先根据订单的编号，调用后台服务，生成交易链接，而后才能根据链接生成二维码。 在页面发起请求： 12345678910111213141516171819202122232425var payVm = new Vue(&#123; el:"#payVm", data:&#123; ly, orderId:0,// 订单编号 &#125;, created()&#123; // 判断登录状态 ly.http.get("/auth/verify").then(() =&gt; &#123; // 获取订单编号 this.orderId = ly.getUrlParam("orderId"); // 获取请求链接 ly.http.get("/order/url/" + this.orderId) .then(resp =&gt; &#123; console.log(resp.data); &#125;) &#125;.catch(() =&gt; &#123; // 未登录，跳转至登录页 location.href = "/login.html?returnUrl=" + location.href; &#125;) &#125;, components: &#123; shortcut: () =&gt; import("./js/pages/shortcut.js") &#125;&#125;); 后台已经定义好生成付款地址的接口。 刷新页面查看： 生成二维码 这里我们使用一个生成二维码的JS插件：qrcode，官网：https://github.com/davidshimjs/qrcodejs 我们把课这个js脚本引入到项目中： 官方使用案例： 然后在页面引用： 页面定义一个div，用于展示二维码： 然后获取到付款链接后，根据链接生成二维码： 1234567891011121314151617181920// 判断登录状态ly.http.get("/auth/verify").then(() =&gt; &#123; // 获取订单编号 this.orderId = ly.getUrlParam("orderId"); // 获取请求链接 ly.http.get("/order/url/" + this.orderId) .then(resp =&gt; &#123; new QRCode(document.getElementById("qrImage"), &#123; text: resp.data, width: 250, height: 250, colorDark: "#000000", colorLight: "#ffffff", correctLevel: QRCode.CorrectLevel.H &#125;); &#125;)&#125;).catch(() =&gt; &#123; // 未登录，跳转至登录页 location.href = "/login.html?returnUrl=" + location.href;&#125;) 刷新页面，查看效果： 此时，客户用手机扫描二维码，可以看到付款页面。 付款状态查询 跳转到支付页面后，我们等待用户付款，付款完成则跳转到付款成功页面。 页面循环查询支付状态 不过，因为不清楚用户何时会付款，因此这里采用循环的方式，不断请求判断是否支付成功。 123456789101112131415161718// 开启定时任务，查询付款状态const taskId = setInterval(() =&gt; &#123; ly.http.get("/order/state/" + this.orderId) .then(resp =&gt; &#123; let i = resp.data; if (i === 1) &#123; // 付款成功 clearInterval(taskId); // 跳转到付款成功页 location.href = "/paysuccess.html?orderId=" + this.orderId; &#125; else if (i === 2) &#123; // 付款失败 clearInterval(taskId); // 跳转到付款失败页 location.href = "/payfail.html"; &#125; &#125;)&#125;, 3000); 付款成功页面 当付款成功后，自动跳转到付款成功页面：]]></content>
  </entry>
  <entry>
    <title><![CDATA[day18-购物车]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F27%2Fday18-%E8%B4%AD%E7%89%A9%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[学习目标 搭建购物车服务 创建module pom依赖 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-cart&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 配置文件 123456789101112131415161718server: port: 8088spring: application: name: cart-service redis: host: 192.168.56.101eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka registry-fetch-interval-seconds: 10 instance: prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;eureka.instance.ip-address&#125;.$&#123;server.port&#125; lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 15 启动类 123456789@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class LeyouCartApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouCartApplication.class, args); &#125;&#125; 购物车功能分析 需求 需求描述： 用户可以在登录状态下将商品添加到购物车 放入数据库 放入redis（采用） 用户可以在未登录状态下将商品添加到购物车 放入localstorage 用户可以使用购物车一起结算下单 用户可以查询自己的购物车 用户可以在购物车中修改购买商品的数量。 用户可以在购物车中删除商品。 在购物车中展示商品优惠信息 提示购物车商品价格变化 流程图 这幅图主要描述了两个功能：新增商品到购物车、查询购物车。 新增商品： 判断是否登录 是：则添加商品到后台Redis中 否：则添加商品到本地的Localstorage 无论哪种新增，完成后都需要查询购物车列表： 判断是否登录 否：直接查询localstorage中数据并展示 是：已登录，则需要先看本地是否有数据， 有：需要提交到后台添加到redis，合并数据，而后查询 否：直接去后台查询redis，而后返回 未登录购物车 准备 购物车的数据结构 首先分析一下未登录购物车的数据结构。 我们看下页面展示需要什么数据： 因此每一个购物车信息，都是一个对象，包含： 12345678&#123; skuId:2131241, title:"小米6", image:"", price:190000, num:1, ownSpec:"&#123;"机身颜色":"陶瓷黑尊享版","内存":"6GB","机身存储":"128GB"&#125;"&#125; 另外，购物车中不止一条数据，因此最终会是对象的数组。即： 123[ &#123;...&#125;,&#123;...&#125;,&#123;...&#125;] web本地存储 知道了数据结构，下一个问题，就是如何保存购物车数据。前面我们分析过，可以使用Localstorage来实现。Localstorage是web本地存储的一种，那么，什么是web本地存储呢？ 什么是web本地存储？ web本地存储主要有两种方式： LocalStorage：localStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 SessionStorage：sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。 LocalStorage的用法 语法非常简单： 123localStorage.setItem("key","value"); // 存储数据localStorage.getItem("key"); // 获取数据localStorage.removeItem("key"); // 删除数据 注意：localStorage和SessionStorage都只能保存字符串。 不过，在我们的common.js中，已经对localStorage进行了简单的封装： 示例： 获取num 添加购物车需要知道购物的数量，所以我们需要获取数量大小。我们在Vue中定义num，保存数量： 然后将num与页面的input框绑定，同时给+和-的按钮绑定事件： 编写方法： 添加购物车 点击事件 我们看下商品详情页： 现在点击加入购物车会跳转到购物车成功页面。 不过我们不这么做，我们绑定点击事件，然后实现添加购物车功能。 addCart方法中判断用户的登录状态： 1234567addCart()&#123; ly.http.get("/auth/verify").then(res=&gt;&#123; // 已登录发送信息到后台，保存到redis中 &#125;).catch(()=&gt;&#123; // 未登录保存在浏览器本地的localStorage中 &#125;)&#125; 获取数量，添加购物车 12345678910111213141516171819202122232425262728293031addCart()&#123; ly.verifyUser().then(res=&gt;&#123; // 已登录发送信息到后台，保存到redis中 &#125;).catch(()=&gt;&#123; // 未登录保存在浏览器本地的localStorage中 // 1、查询本地购物车 let carts = ly.store.get("carts") || []; let cart = carts.find(c=&gt;c.skuId===this.sku.id); // 2、判断是否存在 if (cart) &#123; // 3、存在更新数量 cart.num += this.num; &#125; else &#123; // 4、不存在，新增 cart = &#123; skuId: this.sku.id, title: this.sku.title, price: this.sku.price, image: this.sku.images, num: this.num, ownSpec: JSON.stringify(this.ownSpec) &#125; carts.push(cart); &#125; // 把carts写回localstorage ly.store.set("carts", carts); // 跳转 window.location.href = "http://www.leyou.com/cart.html"; &#125;);&#125; 结果： 添加完成后，页面会跳转到购物车结算页面：cart.html 查询购物车 校验用户登录 因为会多次校验用户登录状态，因此我们封装一个校验的方法： 在common.js中： 在页面item.html中使用该方法： 查询购物车 页面加载时，就应该去查询购物车。 1234567891011121314151617181920212223242526var cartVm = new Vue(&#123; el: "#cartApp", data: &#123; ly, carts: [],// 购物车数据 &#125;, created() &#123; this.loadCarts(); &#125;, methods: &#123; loadCarts() &#123; // 先判断登录状态 ly.verifyUser().then(() =&gt; &#123; // 已登录 &#125;).catch(() =&gt; &#123; // 未登录 this.carts = ly.store.get("carts") || []; this.selected = this.carts; &#125;) &#125; &#125; components: &#123; shortcut: () =&gt; import("/js/pages/shortcut.js") &#125;&#125;) 刷新页面，查看控制台Vue实例： 渲染到页面 接下来，我们在页面中展示carts的数据： 要注意，价格的展示需要进行格式化，这里使用的是我们在common.js中定义的formatPrice方法 效果： 修改数量 我们给页面的 + 和 -绑定点击事件，修改num 的值： 两个事件： 123456789101112131415161718192021increment(c) &#123; c.num++; ly.verifyUser().then(() =&gt; &#123; // TODO 已登录，向后台发起请求 &#125;).catch(() =&gt; &#123; // 未登录，直接操作本地数据 ly.store.set("carts", this.carts); &#125;)&#125;,decrement(c) &#123; if (c.num &lt;= 1) &#123; return; &#125; c.num--; ly.verifyUser().then(() =&gt; &#123; // TODO 已登录，向后台发起请求 &#125;).catch(() =&gt; &#123; // 未登录，直接操作本地数据 ly.store.set("carts", this.carts); &#125;)&#125; 删除商品 给删除按钮绑定事件： 点击事件中删除商品： 123456789deleteCart(i)&#123; ly.verifyUser().then(res=&gt;&#123; // TODO，已登录购物车 &#125;).catch(()=&gt;&#123; // 未登录购物车 this.carts.splice(i, 1); ly.store.set("carts", this.carts); &#125;)&#125; 选中商品 在页面中，每个购物车商品左侧，都有一个复选框，用户可以选择部分商品进行下单，而不一定是全部： 我们定义一个变量，记录所有被选中的商品： 选中一个 我们给商品前面的复选框与selected绑定，并且指定其值为当前购物车商品： 初始化全选 我们在加载完成购物车查询后，初始化全选： 总价格 然后编写一个计算属性，计算出选中商品总价格： 12345computed: &#123; totalPrice() &#123; return ly.formatPrice(this.selected.reduce((c1, c2) =&gt; c1 + c2.num * c2.price, 0)); &#125;&#125; 在页面中展示总价格： 效果： 已登录购物车 接下来，我们完成已登录购物车。 在刚才的未登录购物车编写时，我们已经预留好了编写代码的位置，逻辑也基本一致。 添加登录校验 购物车系统只负责登录状态的购物车处理，因此需要添加登录校验，我们通过JWT鉴权即可实现。 引入JWT相关依赖 我们引入之前写的鉴权工具：leyou-auth-common 12345&lt;dependency&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;artifactId&gt;leyou-auth-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 配置公钥 1234leyou: jwt: pubKeyPath: D:/heima/rsa/rsa.pub # 公钥地址 cookieName: LY_TOKEN # cookie的名称 加载公钥 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@ConfigurationProperties(prefix = "leyou.jwt")public class JwtProperties &#123; private String pubKeyPath;// 公钥 private PublicKey publicKey; // 公钥 private String cookieName; private static final Logger logger = LoggerFactory.getLogger(JwtProperties.class); @PostConstruct public void init()&#123; try &#123; // 获取公钥和私钥 this.publicKey = RsaUtils.getPublicKey(pubKeyPath); &#125; catch (Exception e) &#123; logger.error("初始化公钥失败！", e); throw new RuntimeException(); &#125; &#125; public String getPubKeyPath() &#123; return pubKeyPath; &#125; public void setPubKeyPath(String pubKeyPath) &#123; this.pubKeyPath = pubKeyPath; &#125; public PublicKey getPublicKey() &#123; return publicKey; &#125; public void setPublicKey(PublicKey publicKey) &#123; this.publicKey = publicKey; &#125; public String getCookieName() &#123; return cookieName; &#125; public void setCookieName(String cookieName) &#123; this.cookieName = cookieName; &#125;&#125; 编写拦截器 因为很多接口都需要进行登录，我们直接编写SpringMVC拦截器，进行统一登录校验。同时，我们还要把解析得到的用户信息保存起来，以便后续的接口可以使用。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class LoginInterceptor extends HandlerInterceptorAdapter &#123; private JwtProperties jwtProperties; // 定义一个线程域，存放登录用户 private static final ThreadLocal&lt;UserInfo&gt; tl = new ThreadLocal&lt;&gt;(); public LoginInterceptor(JwtProperties jwtProperties) &#123; this.jwtProperties = jwtProperties; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 查询token String token = CookieUtils.getCookieValue(request, "LY_TOKEN"); if (StringUtils.isBlank(token)) &#123; // 未登录,返回401 response.setStatus(HttpStatus.UNAUTHORIZED.value()); return false; &#125; // 有token，查询用户信息 try &#123; // 解析成功，证明已经登录 UserInfo user = JwtUtils.getInfoFromToken(token, jwtProperties.getPublicKey()); // 放入线程域 tl.set(user); return true; &#125; catch (Exception e)&#123; // 抛出异常，证明未登录,返回401 response.setStatus(HttpStatus.UNAUTHORIZED.value()); return false; &#125; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; tl.remove(); &#125; public static UserInfo getLoginUser() &#123; return tl.get(); &#125;&#125; 注意： 这里我们使用了ThreadLocal来存储查询到的用户信息，线程内共享，因此请求到达Controller后可以共享User 并且对外提供了静态的方法：getLoginUser()来获取User信息 配置过滤器 配置SpringMVC，使过滤器生效： 1234567891011121314151617@Configuration@EnableConfigurationProperties(JwtProperties.class)public class MvcConfig implements WebMvcConfigurer &#123; @Autowired private JwtProperties jwtProperties; @Bean public LoginInterceptor loginInterceptor() &#123; return new LoginInterceptor(jwtProperties); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(loginInterceptor()).addPathPatterns("/**"); &#125;&#125; 后台购物车设计 当用户登录时，我们需要把购物车数据保存到后台，可以选择保存在数据库。但是购物车是一个读写频率很高的数据。因此我们这里选择读写效率比较高的Redis作为购物车存储。 Redis有5种不同数据结构，这里选择哪一种比较合适呢？ 首先不同用户应该有独立的购物车，因此购物车应该以用户的作为key来存储，Value是用户的所有购物车信息。这样看来基本的k-v结构就可以了。 但是，我们对购物车中的商品进行增、删、改操作，基本都需要根据商品id进行判断，为了方便后期处理，我们的购物车也应该是k-v结构，key是商品id，value才是这个商品的购物车信息。 综上所述，我们的购物车结构是一个双层Map：Map&lt;String,Map&lt;String,String&gt;&gt; 第一层Map，Key是用户id 第二层Map，Key是购物车中商品id，值是购物车数据 实体类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Cart &#123; private Long userId;// 用户id private Long skuId;// 商品id private String title;// 标题 private String image;// 图片 private Long price;// 加入购物车时的价格 private Integer num;// 购买数量 private String ownSpec;// 商品规格参数 public Long getUserId() &#123; return userId; &#125; public void setUserId(Long userId) &#123; this.userId = userId; &#125; public Long getSkuId() &#123; return skuId; &#125; public void setSkuId(Long skuId) &#123; this.skuId = skuId; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getImage() &#123; return image; &#125; public void setImage(String image) &#123; this.image = image; &#125; public Long getPrice() &#123; return price; &#125; public void setPrice(Long price) &#123; this.price = price; &#125; public Integer getNum() &#123; return num; &#125; public void setNum(Integer num) &#123; this.num = num; &#125; public String getOwnSpec() &#123; return ownSpec; &#125; public void setOwnSpec(String ownSpec) &#123; this.ownSpec = ownSpec; &#125;&#125; 添加商品到购物车 页面发起请求 已登录情况下，向后台添加购物车： 123ly.http.post("/cart", &#123;skuId: this.sku.id, num: this.num&#125;).then(res=&gt;&#123; window.location = "http://www.leyou.com/cart.html";&#125;) 这里发起的是Json请求。那么我们后台也要以json接收。 编写controller 先分析一下： 请求方式：新增，肯定是Post 请求路径：/cart ，这个其实是Zuul路由的路径，我们可以不管 请求参数：Json对象，包含skuId和num属性 返回结果：无 1234567891011121314151617@Controllerpublic class CartController &#123; @Autowired private CartService cartService; /** * 添加购物车 * * @return */ @PostMapping public ResponseEntity&lt;Void&gt; addCart(@RequestBody Cart cart) &#123; this.cartService.addCart(cart); return ResponseEntity.ok().build(); &#125;&#125; 在leyou-gateway中添加路由配置： CartService 这里我们不访问数据库，而是直接操作Redis。基本思路： 先查询之前的购物车数据 判断要添加的商品是否存在 存在：则直接修改数量后写回Redis 不存在：新建一条数据，然后写入Redis 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Servicepublic class CartService &#123; @Autowired private StringRedisTemplate redisTemplate; @Autowired private GoodsClient goodsClient; static final String KEY_PREFIX = "ly:cart:uid:"; static final Logger logger = LoggerFactory.getLogger(CartService.class); public void addCart(Cart cart) &#123; // 获取登录用户 UserInfo user = LoginInterceptor.getLoginUser(); // Redis的key String key = KEY_PREFIX + user.getId(); // 获取hash操作对象 BoundHashOperations&lt;String, Object, Object&gt; hashOps = this.redisTemplate.boundHashOps(key); // 查询是否存在 Long skuId = cart.getSkuId(); Integer num = cart.getNum(); Boolean boo = hashOps.hasKey(skuId.toString()); if (boo) &#123; // 存在，获取购物车数据 String json = hashOps.get(skuId.toString()).toString(); cart = JsonUtils.parse(json, Cart.class); // 修改购物车数量 cart.setNum(cart.getNum() + num); &#125; else &#123; // 不存在，新增购物车数据 cart.setUserId(user.getId()); // 其它商品信息， 需要查询商品服务 Sku sku = this.goodsClient.querySkuById(skuId); cart.setImage(StringUtils.isBlank(sku.getImages()) ? "" : StringUtils.split(sku.getImages(), ",")[0]); cart.setPrice(sku.getPrice()); cart.setTitle(sku.getTitle()); cart.setOwnSpec(sku.getOwnSpec()); &#125; // 将购物车数据写入redis hashOps.put(cart.getSkuId().toString(), JsonUtils.serialize(cart)); &#125;&#125; 需要引入leyou-item-interface依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.leyou.item&lt;/groupId&gt; &lt;artifactId&gt;leyou-item-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; GoodClient 参照搜索工程，添加GoodClient，提供根据id查询sku的接口： 123@FeignClient("item-service")public interface GoodsClient extends GoodsApi &#123;&#125; 在leyou-item-service中的GoodsController添加方法： 12345678@GetMapping("sku/&#123;id&#125;")public ResponseEntity&lt;Sku&gt; querySkuById(@PathVariable("id")Long id)&#123; Sku sku = this.goodsService.querySkuById(id); if (sku == null)&#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(sku);&#125; 在leyou-item-service中的GoodsService添加方法： 123public Sku querySkuById(Long id) &#123; return this.skuMapper.selectByPrimaryKey(id);&#125; 结果 查询购物车 页面发起请求 购物车页面：cart.html 后台实现 Controller 12345678910111213/** * 查询购物车列表 * * @return */@GetMappingpublic ResponseEntity&lt;List&lt;Cart&gt;&gt; queryCartList() &#123; List&lt;Cart&gt; carts = this.cartService.queryCartList(); if (carts == null) &#123; return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null); &#125; return ResponseEntity.ok(carts);&#125; Service 12345678910111213141516171819public List&lt;Cart&gt; queryCartList() &#123; // 获取登录用户 UserInfo user = LoginInterceptor.getLoginUser(); // 判断是否存在购物车 String key = KEY_PREFIX + user.getId(); if(!this.redisTemplate.hasKey(key))&#123; // 不存在，直接返回 return null; &#125; BoundHashOperations&lt;String, Object, Object&gt; hashOps = this.redisTemplate.boundHashOps(key); List&lt;Object&gt; carts = hashOps.values(); // 判断是否有数据 if(CollectionUtils.isEmpty(carts))&#123; return null; &#125; // 查询购物车数据 return carts.stream().map(o -&gt; JsonUtils.parse(o.toString(), Cart.class)).collect(Collectors.toList());&#125; 测试 修改商品数量 页面发起请求 后台实现 Controller 123456@PutMappingpublic ResponseEntity&lt;Void&gt; updateNum(@RequestParam("skuId") Long skuId, @RequestParam("num") Integer num) &#123; this.cartService.updateNum(skuId, num); return ResponseEntity.ok().build();&#125; Service 123456789101112public void updateNum(Long skuId, Integer num) &#123; // 获取登录用户 UserInfo user = LoginInterceptor.getLoginUser(); String key = KEY_PREFIX + user.getId(); BoundHashOperations&lt;String, Object, Object&gt; hashOps = this.redisTemplate.boundHashOps(key); // 获取购物车 String json = hashOps.get(skuId.toString()).toString(); Cart cart = JsonUtils.parse(json, Cart.class); cart.setNum(num); // 写入购物车 hashOps.put(skuId.toString(), JsonUtils.serialize(cart));&#125; 删除购物车商品 页面发起请求 注意：后台成功响应后，要把页面的购物车中数据也删除 后台实现 Controller 12345@DeleteMapping("&#123;skuId&#125;")public ResponseEntity&lt;Void&gt; deleteCart(@PathVariable("skuId") String skuId) &#123; this.cartService.deleteCart(skuId); return ResponseEntity.ok().build();&#125; Service 1234567public void deleteCart(String skuId) &#123; // 获取登录用户 UserInfo user = LoginInterceptor.getLoginUser(); String key = KEY_PREFIX + user.getId(); BoundHashOperations&lt;String, Object, Object&gt; hashOps = this.redisTemplate.boundHashOps(key); hashOps.delete(skuId);&#125; 登录后购物车合并（作业） 当跳转到购物车页面，查询购物车列表前，需要判断用户登录状态， 如果登录： 首先检查用户的LocalStorage中是否有购物车信息， 如果有，则提交到后台保存， 清空LocalStorage 如果未登录，直接查询即可]]></content>
  </entry>
  <entry>
    <title><![CDATA[day17-授权中心]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F27%2Fday17-%E6%8E%88%E6%9D%83%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[学习目标 无状态登录原理 什么是有状态？ 有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如tomcat中的session。 例如登录：用户登录后，我们把登录者的信息保存在服务端session中，并且给用户一个cookie值，记录对应的session。然后下次请求，用户携带cookie值来，我们就能识别到对应session，从而找到用户的信息。 缺点是什么？ 服务端保存大量数据，增加服务端压力 服务端保存用户状态，无法进行水平扩展 客户端请求依赖服务端，多次请求必须访问同一台服务器 什么是无状态 微服务集群中的每个服务，对外提供的都是Rest风格的接口。而Rest风格的一个最重要的规范就是：服务的无状态性，即： 服务端不保存任何客户端请求者信息 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份 带来的好处是什么呢？ 客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务 服务端的集群和状态对客户端透明 服务端可以任意的迁移和伸缩 减小服务端存储压力 如何实现无状态 无状态登录的流程： 当客户端第一次请求服务时，服务端对用户进行信息认证（登录） 认证通过，将用户信息进行加密形成token，返回给客户端，作为登录凭证 以后每次请求，客户端都携带认证的token 服务端对token进行解密，判断是否有效。 流程图： 整个登录过程中，最关键的点是什么？ token的安全性 token是识别客户端身份的唯一标示，如果加密不够严密，被人伪造那就完蛋了。 采用何种方式加密才是安全可靠的呢？ 我们将采用JWT + RSA非对称加密 JWT 简介 JWT，全称是Json Web Token， 是JSON风格轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权；官网：https://jwt.io GitHub上jwt的java客户端：https://github.com/jwtk/jjwt 数据格式 JWT包含三部分数据： Header：头部，通常头部有两部分信息： 声明类型，这里是JWT 加密算法，自定义 我们会对头部进行base64加密（可解密），得到第一部分数据 Payload：载荷，就是有效数据，一般包含下面信息： 用户身份信息（注意，这里因为采用base64加密，可解密，因此不要存放敏感信息） 注册声明：如token的签发时间，过期时间，签发人等 这部分也会采用base64加密，得到第二部分数据 Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥（secret）（不要泄漏，最好周期性更换），通过加密算法生成。用于验证整个数据完整和可靠性 生成的数据格式： 可以看到分为3段，每段就是上面的一部分数据 JWT交互流程 流程图： 步骤翻译： 1、用户登录 2、服务的认证，通过后根据secret生成token 3、将生成的token返回给浏览器 4、用户每次请求携带token 5、服务端利用公钥解读jwt签名，判断签名有效后，从Payload中获取用户信息 6、处理请求，返回响应结果 因为JWT签发的token中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，完全符合了Rest的无状态规范。 非对称加密 加密技术是对信息进行编码和解码的技术，编码是把原来可读信息（又称明文）译成代码形式（又称密文），其逆过程就是解码（解密），加密技术的要点是加密算法，加密算法可以分为三类： 对称加密，如AES 基本原理：将明文分成N个组，然后使用密钥对各个组进行加密，形成各自的密文，最后把所有的分组密文进行合并，形成最终的密文。 优势：算法公开、计算量小、加密速度快、加密效率高 缺陷：双方都使用同样密钥，安全性得不到保证 非对称加密，如RSA 基本原理：同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端 私钥加密，持有私钥或公钥才可以解密 公钥加密，持有私钥才可解密 优点：安全，难以破解 缺点：算法比较耗时 不可逆加密，如MD5，SHA 基本原理：加密过程中不需要使用密钥，输入明文后由系统直接经过加密算法处理成密文，这种加密后的数据是无法被解密的，无法根据密文推算出明文。 RSA算法历史： 1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字缩写：RSA 结合Zuul的鉴权流程 我们逐步演进系统架构设计。需要注意的是：secret是签名的关键，因此一定要保密，我们放到鉴权中心保存，其它任何服务中都不能获取secret。 没有RSA加密时 在微服务架构中，我们可以把服务的鉴权操作放到网关中，将未通过鉴权的请求直接拦截，如图： 1、用户请求登录 2、Zuul将请求转发到授权中心，请求授权 3、授权中心校验完成，颁发JWT凭证 4、客户端请求其它功能，携带JWT 5、Zuul将jwt交给授权中心校验，通过后放行 6、用户请求到达微服务 7、微服务将jwt交给鉴权中心，鉴权同时解析用户信息 8、鉴权中心返回用户数据给微服务 9、微服务处理请求，返回响应 发现什么问题了？ 每次鉴权都需要访问鉴权中心，系统间的网络请求频率过高，效率略差，鉴权中心的压力较大。 结合RSA的鉴权 直接看图： 我们首先利用RSA生成公钥和私钥。私钥保存在授权中心，公钥保存在Zuul和各个微服务 用户请求登录 授权中心校验，通过后用私钥对JWT进行签名加密 返回jwt给用户 用户携带JWT访问 Zuul直接通过公钥解密JWT，进行验证，验证通过则放行 请求到达微服务，微服务直接用公钥解析JWT，获取用户信息，无需访问授权中心 授权中心 创建授权中心 授权中心的主要职责： 用户鉴权： 接收用户的登录请求，通过用户中心的接口进行校验，通过后生成JWT 使用私钥生成JWT并返回 服务鉴权：微服务间的调用不经过Zuul，会有风险，需要鉴权中心进行认证 原理与用户鉴权类似，但逻辑稍微复杂一些（此处我们不做实现） 因为生成jwt，解析jwt这样的行为以后在其它微服务中也会用到，因此我们会抽取成工具。我们把鉴权中心进行聚合，一个工具module，一个提供服务的module 创建父module 我们先创建父module，名称为：leyou-auth 将pom打包方式改为pom： 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;artifactId&gt;leyou-auth&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/project&gt; 通用module 然后是授权服务的通用模块：leyou-auth-common： pom.xml： 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou-auth&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;artifactId&gt;leyou-auth-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/project&gt; 结构： 授权服务 pom.xml： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou-auth&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;artifactId&gt;leyou-auth-service&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;artifactId&gt;leyou-auth-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;leyou-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 引导类： 123456789@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class LeyouAuthApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouAuthApplication.class, args); &#125;&#125; application.yml 12345678910111213141516server: port: 8087spring: application: name: auth-serviceeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka registry-fetch-interval-seconds: 10 instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 结构： 在leyou-gateway工程的application.yml中，修改路由： 1234567zuul: prefix: /api # 路由路径前缀 routes: item-service: /item/** # 商品微服务的映射路径 search-service: /search/** # 搜索微服务 user-service: /user/** # 用户微服务 auth-service: /auth/** # 授权中心微服务 JWT工具类 我们在leyou-auth-common中导入课前资料中的工具类： 需要在leyou-auth-common中引入JWT依赖： 123456789101112131415&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 测试工具类 我们在leyou-auth-common中编写测试类： 1234567891011121314151617181920212223242526272829303132333435363738public class JwtTest &#123; private static final String pubKeyPath = "C:\\tmp\\rsa\\rsa.pub"; private static final String priKeyPath = "C:\\tmp\\rsa\\rsa.pri"; private PublicKey publicKey; private PrivateKey privateKey; @Test public void testRsa() throws Exception &#123; RsaUtils.generateKey(pubKeyPath, priKeyPath, "234"); &#125; @Before public void testGetRsa() throws Exception &#123; this.publicKey = RsaUtils.getPublicKey(pubKeyPath); this.privateKey = RsaUtils.getPrivateKey(priKeyPath); &#125; @Test public void testGenerateToken() throws Exception &#123; // 生成token String token = JwtUtils.generateToken(new UserInfo(20L, "jack"), privateKey, 5); System.out.println("token = " + token); &#125; @Test public void testParseToken() throws Exception &#123; String token = "eyJhbGciOiJSUzI1NiJ9.eyJpZCI6MjAsInVzZXJuYW1lIjoiamFjayIsImV4cCI6MTUzMzI4MjQ3N30.EPo35Vyg1IwZAtXvAx2TCWuOPnRwPclRNAM4ody5CHk8RF55wdfKKJxjeGh4H3zgruRed9mEOQzWy79iF1nGAnvbkraGlD6iM-9zDW8M1G9if4MX579Mv1x57lFewzEo-zKnPdFJgGlAPtNWDPv4iKvbKOk1-U7NUtRmMsF1Wcg"; // 解析token UserInfo user = JwtUtils.getInfoFromToken(token, publicKey); System.out.println("id: " + user.getId()); System.out.println("userName: " + user.getUsername()); &#125;&#125; 测试生成公钥和私钥，我们运行这段代码： 运行之后，查看目标目录： 公钥和私钥已经生成了！ 测试生成token，把@Before的注释去掉的： 测试解析token： 正常情况： 任意改动token，发现报错了： 编写登录授权接口 接下来，我们需要在leyou-auth-servcice编写一个接口，对外提供登录授权服务。基本流程如下： 客户端携带用户名和密码请求登录 授权中心调用客户中心接口，根据用户名和密码查询用户信息 如果用户名密码正确，能获取用户，否则为空，则登录失败 如果校验成功，则生成JWT并返回 生成公钥和私钥 我们需要在授权中心生成真正的公钥和私钥。我们必须有一个生成公钥和私钥的secret，这个可以配置到application.yml中： 123456leyou: jwt: secret: leyou@Login(Auth&#125;*^31)&amp;heiMa% # 登录校验的密钥 pubKeyPath: C:\\tmp\\rsa\\rsa.pub # 公钥地址 priKeyPath: C:\\tmp\\rsa\\rsa.pri # 私钥地址 expire: 30 # 过期时间,单位分钟 然后编写属性类，加载这些数据： 12345678910111213141516171819202122232425262728293031323334353637383940@ConfigurationProperties(prefix = "ly.jwt")public class JwtProperties &#123; private String secret; // 密钥 private String pubKeyPath;// 公钥 private String priKeyPath;// 私钥 private int expire;// token过期时间 private PublicKey publicKey; // 公钥 private PrivateKey privateKey; // 私钥 private static final Logger logger = LoggerFactory.getLogger(JwtProperties.class); /** * @PostContruct：在构造方法执行之后执行该方法 */ @PostConstruct public void init()&#123; try &#123; File pubKey = new File(pubKeyPath); File priKey = new File(priKeyPath); if (!pubKey.exists() || !priKey.exists()) &#123; // 生成公钥和私钥 RsaUtils.generateKey(pubKeyPath, priKeyPath, secret); &#125; // 获取公钥和私钥 this.publicKey = RsaUtils.getPublicKey(pubKeyPath); this.privateKey = RsaUtils.getPrivateKey(priKeyPath); &#125; catch (Exception e) &#123; logger.error("初始化公钥和私钥失败！", e); throw new RuntimeException(); &#125; &#125; // getter setter ...&#125; Controller 编写授权接口，我们接收用户名和密码，校验成功后，写入cookie中。 请求方式：post 请求路径：/accredit 请求参数：username和password 返回结果：无 代码： 12345678910111213141516171819202122232425262728293031323334@RestController@EnableConfigurationProperties(JwtProperties.class)public class AuthController &#123; @Autowired private AuthService authService; @Autowired private JwtProperties prop; /** * 登录授权 * * @param username * @param password * @return */ @PostMapping("accredit") public ResponseEntity&lt;Void&gt; authentication( @RequestParam("username") String username, @RequestParam("password") String password, HttpServletRequest request, HttpServletResponse response) &#123; // 登录校验 String token = this.authService.authentication(username, password); if (StringUtils.isBlank(token)) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.UNAUTHORIZED); &#125; // 将token写入cookie,并指定httpOnly为true，防止通过JS获取和修改 CookieUtils.setCookie(request, response, prop.getCookieName(), token, prop.getCookieMaxAge(), null, true); return ResponseEntity.ok().build(); &#125;&#125; 这里的cookie的name和生存时间，我们配置到属性文件：application.yml： 然后在JwtProperties中添加属性： CookieUtils 要注意，这里我们使用了一个工具类，CookieUtils，可以在课前资料中找到，我们把它添加到leyou-common中，然后引入servlet相关依赖即可： 1234&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;&lt;/dependency&gt; 代码：略 UserClient 接下来我们肯定要对用户密码进行校验，所以我们需要通过FeignClient去访问 user-service微服务： 引入user-service依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.leyou.user&lt;/groupId&gt; &lt;artifactId&gt;leyou-user-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 编写FeignClient： 123@FeignClient(value = "user-service")public interface UserClient extends UserApi &#123;&#125; 在leyou-user-interface工程中添加api接口： 内容： 12345678@RequestMapping("user")public interface UserApi &#123; @GetMapping("query") public User queryUser( @RequestParam("username") String username, @RequestParam("password") String password);&#125; Service 123456789101112131415161718192021222324252627282930@Servicepublic class AuthService &#123; @Autowired private UserClient userClient; @Autowired private JwtProperties properties; public String authentication(String username, String password) &#123; try &#123; // 调用微服务，执行查询 User user = this.userClient.queryUser(username, password); // 如果查询结果为null，则直接返回null if (user == null) &#123; return null; &#125; // 如果有查询结果，则生成token String token = JwtUtils.generateToken(new UserInfo(user.getId(), user.getUsername()), properties.getPrivateKey(), properties.getExpire()); return token; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 项目结构 测试 登录页面 接下来，我们看看登录页面，是否能够正确的发出请求。 我们在页面输入登录信息，然后点击登录： 查看控制台： 发现请求的路径不对，我们的认证接口是： 1/api/auth/accredit 我们打开login.html，修改路径信息： 页面ajax请求： 然后再次测试，成功跳转到了首页： 解决cookie写入问题 接下来我们查看首页cookie： 什么都没有，为什么？ 问题分析 我们在之前测试时，清晰的看到了响应头中，有Set-Cookie属性，为什么在这里却什么都没有？ 我们之前在讲cors跨域时，讲到过跨域请求cookie生效的条件： 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名 浏览器发起ajax需要指定withCredentials 为true 看看我们的服务端cors配置： 没有任何问题。 再看客户端浏览器的ajax配置，我们在js/common.js中对axios进行了统一配置： 一切OK。 那说明，问题一定出在响应的set-cookie头中。我们再次仔细看看刚才的响应头： 我们发现cookie的 domain属性似乎不太对。 cookie也是有域 的限制，一个网页，只能操作当前域名下的cookie，但是现在我们看到的地址是0.0.1，而页面是www.leyou.com,域名不匹配，cookie设置肯定失败了！ 跟踪CookieUtils 我们去Debug跟踪CookieUtils，看看到底是怎么回事： 我们发现内部有一个方法，用来获取Domain： 它获取domain是通过服务器的host来计算的，然而我们的地址竟然是：127.0.0.1:8087，因此后续的运算，最终得到的domain就变成了： 问题找到了：我们请求时的serverName明明是：api.leyou.com，现在却被变成了：127.0.0.1，因此计算domain是错误的，从而导致cookie设置失败！ 解决host地址的变化 那么问题来了：为什么我们这里的请求serverName变成了：127.0.0.1:8087呢？ 这里的server name其实就是请求时的主机名：Host，之所以改变，有两个原因： 我们使用了nginx反向代理，当监听到api.leyou.com的时候，会自动将请求转发至127.0.0.1:10010，即Zuul。 而后请求到达我们的网关Zuul，Zuul就会根据路径匹配，我们的请求是/api/auth，根据规则被转发到了 127.0.0.1:8087 ，即我们的授权中心。 我们首先去更改nginx配置，让它不要修改我们的host：proxy_set_header Host $host; 把nginx进行reload： 1nginx -s reload 这样就解决了nginx这里的问题。但是Zuul还会有一次转发，所以要去修改网关的配置（leyou-gateway工程）： 重启后，我们再次测试。 最后计算得到的domain： 完美！ 再次测试 我们再次登录，发现依然没有cookie！！ 怎么回事呢？ 我们通过RestClient访问下看看： 发现，响应头中根本没有set-cookie了。 这是怎么回事？？ Zuul的敏感头过滤 Zuul内部有默认的过滤器，会对请求和响应头信息进行重组，过滤掉敏感的头信息： 会发现，这里会通过一个属性为SensitiveHeaders的属性，来获取敏感头列表，然后添加到IgnoredHeaders中，这些头信息就会被忽略。 而这个SensitiveHeaders的默认值就包含了set-cookie： 解决方案有两种： 全局设置： zuul.sensitive-headers= 指定路由设置： zuul.routes.&lt;routeName&gt;.sensitive-headers= zuul.routes.&lt;routeName&gt;.custom-sensitive-headers=true 思路都是把敏感头设置为null 最后的测试 再次重启后测试： 首页判断登录状态 虽然cookie已经成功写入，但是我们首页的顶部，登录状态依然没能判断出用户信息： 这里需要向后台发起请求，根据cookie获取当前用户的信息。 我们先看页面实现 页面JS代码 页面的顶部已经被我们封装为一个独立的Vue组件，在/js/pages/shortcut.js中 打开js，发现里面已经定义好了Vue组件，并且在created函数中，查询用户信息： 查看网络控制台，发现发起了请求： 因为token在cookie中，因此本次请求肯定会携带token信息在头中。 后台实现校验用户接口 我们在leyou-auth-service中定义用户的校验接口，通过cookie获取token，然后校验通过返回用户信息。 请求方式：GET 请求路径：/verify 请求参数：无，不过我们需要从cookie中获取token信息 返回结果：UserInfo，校验成功返回用户信息；校验失败，则返回401 代码： 123456789101112131415161718/** * 验证用户信息 * @param token * @return */@GetMapping("verify")public ResponseEntity&lt;UserInfo&gt; verifyUser(@CookieValue("LY_TOKEN")String token)&#123; try &#123; // 从token中解析token信息 UserInfo userInfo = JwtUtils.getInfoFromToken(token, this.properties.getPublicKey()); // 解析成功返回用户信息 return ResponseEntity.ok(userInfo); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 出现异常则，响应500 return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();&#125; 测试 页面效果： 刷新token 每当用户在页面进行新的操作，都应该刷新token的过期时间，否则30分钟后用户的登录信息就无效了。而刷新其实就是重新生成一份token，然后写入cookie即可。 那么问题来了：我们怎么知道用户有操作呢？ 事实上，每当用户来查询其个人信息，就证明他正在浏览网页，此时刷新cookie是比较合适的时机。因此我们可以对刚刚的校验用户登录状态的接口进行改进，加入刷新token的逻辑。 1234567891011121314151617181920212223/** * 验证用户信息 * @param token * @return */@GetMapping("verify")public ResponseEntity&lt;UserInfo&gt; verifyUser(@CookieValue("LY_TOKEN")String token, HttpServletRequest request, HttpServletResponse response)&#123; try &#123; // 从token中解析token信息 UserInfo userInfo = JwtUtils.getInfoFromToken(token, this.properties.getPublicKey()); // 解析成功要重新刷新token token = JwtUtils.generateToken(userInfo, this.properties.getPrivateKey(), this.properties.getExpire()); // 更新cookie中的token CookieUtils.setCookie(request, response, this.properties.getCookieName(), token, this.properties.getCookieMaxAge()); // 解析成功返回用户信息 return ResponseEntity.ok(userInfo); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 出现异常则，响应500 return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();&#125; 网关的登录拦截器 接下来，我们在Zuul编写拦截器，对用户的token进行校验，如果发现未登录，则进行拦截。 引入jwt相关配置 既然是登录拦截，一定是前置拦截器，我们在leyou-gateway中定义。 首先在pom.xml中，引入所需要的依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;leyou-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;artifactId&gt;leyou-auth-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 然后编写application.yml属性文件，添加如下内容： 1234leyou: jwt: pubKeyPath: C:\\tmp\\rsa\\rsa.pub # 公钥地址 cookieName: LY_TOKEN # cookie的名称 编写属性类，读取公钥： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@ConfigurationProperties(prefix = "leyou.jwt")public class JwtProperties &#123; private String pubKeyPath;// 公钥 private PublicKey publicKey; // 公钥 private String cookieName; private static final Logger logger = LoggerFactory.getLogger(JwtProperties.class); @PostConstruct public void init()&#123; try &#123; // 获取公钥和私钥 this.publicKey = RsaUtils.getPublicKey(pubKeyPath); &#125; catch (Exception e) &#123; logger.error("初始化公钥失败！", e); throw new RuntimeException(); &#125; &#125; public String getPubKeyPath() &#123; return pubKeyPath; &#125; public void setPubKeyPath(String pubKeyPath) &#123; this.pubKeyPath = pubKeyPath; &#125; public PublicKey getPublicKey() &#123; return publicKey; &#125; public void setPublicKey(PublicKey publicKey) &#123; this.publicKey = publicKey; &#125; public String getCookieName() &#123; return cookieName; &#125; public void setCookieName(String cookieName) &#123; this.cookieName = cookieName; &#125;&#125; 编写过滤器逻辑 基本逻辑： 获取cookie中的token 通过JWT对token进行校验 通过：则放行；不通过：则重定向到登录页 123456789101112131415161718192021222324252627282930313233343536373839404142@Component@EnableConfigurationProperties(JwtProperties.class)public class LoginFilter extends ZuulFilter &#123; @Autowired private JwtProperties properties; @Override public String filterType() &#123; return "pre"; &#125; @Override public int filterOrder() &#123; return 5; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() throws ZuulException &#123; // 获取上下文 RequestContext context = RequestContext.getCurrentContext(); // 获取request HttpServletRequest request = context.getRequest(); // 获取token String token = CookieUtils.getCookieValue(request, this.properties.getCookieName()); // 校验 try &#123; // 校验通过什么都不做，即放行 JwtUtils.getInfoFromToken(token, this.properties.getPublicKey()); &#125; catch (Exception e) &#123; // 校验出现异常，返回403 context.setSendZuulResponse(false); context.setResponseStatusCode(HttpStatus.FORBIDDEN.value()); &#125; return null; &#125;&#125; 重启，刷新页面，发现请求校验的接口也被拦截了： 证明我们的拦截器生效了，但是，似乎有什么不对的。这个路径似乎不应该被拦截啊！ 白名单 要注意，并不是所有的路径我们都需要拦截，例如： 登录校验接口：/auth/** 注册接口：/user/register 数据校验接口：/user/check/** 发送验证码接口：/user/code 搜索接口：/search/** 另外，跟后台管理相关的接口，因为我们没有做登录和权限，因此暂时都放行，但是生产环境中要做登录校验： 后台商品服务：/item/** 所以，我们需要在拦截时，配置一个白名单，如果在名单内，则不进行拦截。 在application.yaml中添加规则： 123456789leyou: filter: allowPaths: - /api/auth - /api/search - /api/user/register - /api/user/check - /api/user/code - /api/item 然后读取这些属性： 内容： 12345678910111213@ConfigurationProperties(prefix = "leyou.filter")public class FilterProperties &#123; private List&lt;String&gt; allowPaths; public List&lt;String&gt; getAllowPaths() &#123; return allowPaths; &#125; public void setAllowPaths(List&lt;String&gt; allowPaths) &#123; this.allowPaths = allowPaths; &#125;&#125; 在过滤器中的shouldFilter方法中添加判断逻辑： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@Component@EnableConfigurationProperties(&#123;JwtProperties.class, FilterProperties.class&#125;)public class LoginFilter extends ZuulFilter &#123; @Autowired private JwtProperties jwtProp; @Autowired private FilterProperties filterProp; private static final Logger logger = LoggerFactory.getLogger(LoginFilter.class); @Override public String filterType() &#123; return "pre"; &#125; @Override public int filterOrder() &#123; return 5; &#125; @Override public boolean shouldFilter() &#123; // 获取上下文 RequestContext ctx = RequestContext.getCurrentContext(); // 获取request HttpServletRequest req = ctx.getRequest(); // 获取路径 String requestURI = req.getRequestURI(); // 判断白名单 return !isAllowPath(requestURI); &#125; private boolean isAllowPath(String requestURI) &#123; // 定义一个标记 boolean flag = false; // 遍历允许访问的路径 for (String path : this.filterProp.getAllowPaths()) &#123; // 然后判断是否是符合 if(requestURI.startsWith(path))&#123; flag = true; break; &#125; &#125; return flag; &#125; @Override public Object run() throws ZuulException &#123; // 获取上下文 RequestContext ctx = RequestContext.getCurrentContext(); // 获取request HttpServletRequest request = ctx.getRequest(); // 获取token String token = CookieUtils.getCookieValue(request, jwtProp.getCookieName()); // 校验 try &#123; // 校验通过什么都不做，即放行 JwtUtils.getInfoFromToken(token, jwtProp.getPublicKey()); &#125; catch (Exception e) &#123; // 校验出现异常，返回403 ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(403); logger.error("非法访问，未登录，地址：&#123;&#125;", request.getRemoteHost(), e ); &#125; return null; &#125;&#125; 再次测试：]]></content>
  </entry>
  <entry>
    <title><![CDATA[day16-用户注册]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F27%2Fday16-%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[学习目标 独立创建用户中心 了解面向接口开发方式 实现数据校验功能 实现短信发送功能 实现注册功能 实现根据用户名和密码查询用户功能 创建用户中心 用户搜索到自己心仪的商品，接下来就要去购买，但是购买必须先登录。所以接下来我们编写用户中心，实现用户的登录和注册功能。 用户中心的提供的服务： 用户的注册 用户登录 用户个人信息管理 用户地址管理 用户收藏管理 我的订单 优惠券管理 这里我们暂时先实现基本的：注册和登录功能，其它功能大家可以自行补充完整。 因为用户中心的服务其它微服务也会调用，因此这里我们做聚合。 leyou-user：父工程，包含2个子工程： leyou-user-interface：实体及接口 leyou-user-service：业务和服务 创建父module 创建 位置： 创建leyou-user-interface 在leyou-user下，创建module： pom： 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou-user&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.user&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.user&lt;/groupId&gt; &lt;artifactId&gt;leyou-user-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/project&gt; 创建leyou-user-service 创建module pom 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou-user&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.user&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.user&lt;/groupId&gt; &lt;artifactId&gt;leyou-user-service&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.user&lt;/groupId&gt; &lt;artifactId&gt;leyou-user-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 启动类 123456789@SpringBootApplication@EnableDiscoveryClient@MapperScan("com.leyou.user.mapper")public class LeyouUserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouUserApplication.class, args); &#125;&#125; 配置： 1234567891011121314151617181920212223server: port: 8085spring: application: name: user-service datasource: url: jdbc:mysql://127.0.0.1:3306/leyou username: root password: root driver-class-name: com.mysql.jdbc.Drivereureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;eureka.instance.ip-address&#125;.$&#123;server.port&#125; lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 15mybatis: type-aliases-package: com.leyou.user.pojo 父工程leyou-user的pom： 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.user&lt;/groupId&gt; &lt;artifactId&gt;leyou-user&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;leyou-user-interface&lt;/module&gt; &lt;module&gt;leyou-user-service&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 添加网关路由 我们修改leyou-gateway，添加路由规则，对leyou-user-service进行路由: 后台功能准备 接口文档 整个用户中心的开发，我们将模拟公司内面向接口的开发。 现在假设项目经理已经设计好了接口文档，详见：《用户中心接口说明.md》 我们将根据文档直接编写后台功能，不关心页面实现。 数据结构 12345678910CREATE TABLE `tb_user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `username` varchar(50) NOT NULL COMMENT &apos;用户名&apos;, `password` varchar(32) NOT NULL COMMENT &apos;密码，加密存储&apos;, `phone` varchar(20) DEFAULT NULL COMMENT &apos;注册手机号&apos;, `created` datetime NOT NULL COMMENT &apos;创建时间&apos;, `salt` varchar(32) NOT NULL COMMENT &apos;密码加密的salt值&apos;, PRIMARY KEY (`id`), UNIQUE KEY `username` (`username`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8 COMMENT=&apos;用户表&apos;; 数据结构比较简单，因为根据用户名查询的频率较高，所以我们给用户名创建了索引 基本代码 实体类 123456789101112131415161718@Table(name = "tb_user")public class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String username;// 用户名 @JsonIgnore private String password;// 密码 private String phone;// 电话 private Date created;// 创建时间 @JsonIgnore private String salt;// 密码的盐值&#125; 注意：为了安全考虑。这里对password和salt添加了注解@JsonIgnore，这样在json序列化时，就不会把password和salt返回。 mapper 12public interface UserMapper extends Mapper&lt;User&gt; &#123;&#125; Service 123456@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper;&#125; controller 1234567@Controllerpublic class UserController &#123; @Autowired private UserService userService; &#125; 数据验证功能 接口说明 实现用户数据的校验，主要包括对：手机号、用户名的唯一性校验。 接口路径： 1GET /check/&#123;data&#125;/&#123;type&#125; 参数说明： 参数 说明 是否必须 数据类型 默认值 data 要校验的数据 是 String 无 type 要校验的数据类型：1，用户名；2，手机； 否 Integer 1 返回结果： 返回布尔类型结果： true：可用 false：不可用 状态码： 200：校验成功 400：参数有误 500：服务器内部异常 controller 因为有了接口，我们可以不关心页面，所有需要的东西都一清二楚： 请求方式：GET 请求路径：/check/{param}/{type} 请求参数：param,type 返回结果：true或false 1234567891011121314/** * 校验数据是否可用 * @param data * @param type * @return */@GetMapping("check/&#123;data&#125;/&#123;type&#125;")public ResponseEntity&lt;Boolean&gt; checkUserData(@PathVariable("data") String data, @PathVariable(value = "type", defaultValue="1") Integer type) &#123; Boolean boo = this.userService.checkData(data, type); if (boo == null) &#123; return ResponseEntity.status(HttpStatus.BAD_REQUEST).build(); &#125; return ResponseEntity.ok(boo);&#125; Service 1234567891011121314public Boolean checkData(String data, Integer type) &#123; User record = new User(); switch (type) &#123; case 1: record.setUsername(data); break; case 2: record.setPhone(data); break; default: return null; &#125; return this.userMapper.selectCount(record) == 0;&#125; 测试 我们在数据库插入一条假数据： 然后在浏览器调用接口，测试： 阿里短信服务 demo 注册页面上有短信发送的按钮，当用户点击发送短信，我们需要生成验证码，发送给用户。我们将使用阿里提供的阿里大于来实现短信发送。 参考课前资料的《阿里短信.md》学习demo入门 创建短信微服务 因为系统中不止注册一个地方需要短信发送，因此我们将短信发送抽取为微服务：leyou-sms-service，凡是需要的地方都可以使用。 另外，因为短信发送API调用时长的不确定性，为了提高程序的响应速度，短信发送我们都将采用异步发送方式，即： 短信服务监听MQ消息，收到消息后发送短信。 其它服务要发送短信时，通过MQ通知短信微服务。 创建module pom 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.sms&lt;/groupId&gt; &lt;artifactId&gt;leyou-sms-service&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 编写启动类 123456@SpringBootApplicationpublic class LeyouSmsApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouSmsApplication.class, args); &#125;&#125; 编写application.yml 12345678910server: port: 8086spring: application: name: sms-service rabbitmq: host: 192.168.56.101 username: leyou password: leyou virtual-host: /leyou 编写短信工具类 属性抽取 我们首先把一些常量抽取到application.yml中： 123456leyou: sms: accessKeyId: JWffwFJIwada # 你自己的accessKeyId accessKeySecret: aySRliswq8fe7rF9gQyy1Izz4MQ # 你自己的AccessKeySecret signName: 乐优商城 # 签名名称 verifyCodeTemplate: SMS_133976814 # 模板名称 然后注入到属性类中： 12345678910111213141516171819202122232425262728293031323334353637383940414243@ConfigurationProperties(prefix = "leyou.sms")public class SmsProperties &#123; String accessKeyId; String accessKeySecret; String signName; String verifyCodeTemplate; public String getAccessKeyId() &#123; return accessKeyId; &#125; public void setAccessKeyId(String accessKeyId) &#123; this.accessKeyId = accessKeyId; &#125; public String getAccessKeySecret() &#123; return accessKeySecret; &#125; public void setAccessKeySecret(String accessKeySecret) &#123; this.accessKeySecret = accessKeySecret; &#125; public String getSignName() &#123; return signName; &#125; public void setSignName(String signName) &#123; this.signName = signName; &#125; public String getVerifyCodeTemplate() &#123; return verifyCodeTemplate; &#125; public void setVerifyCodeTemplate(String verifyCodeTemplate) &#123; this.verifyCodeTemplate = verifyCodeTemplate; &#125;&#125; 工具类 我们把阿里提供的demo进行简化和抽取，封装一个工具类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Component@EnableConfigurationProperties(SmsProperties.class)public class SmsUtils &#123; @Autowired private SmsProperties prop; //产品名称:云通信短信API产品,开发者无需替换 static final String product = "Dysmsapi"; //产品域名,开发者无需替换 static final String domain = "dysmsapi.aliyuncs.com"; static final Logger logger = LoggerFactory.getLogger(SmsUtils.class); public SendSmsResponse sendSms(String phone, String code, String signName, String template) throws ClientException &#123; //可自助调整超时时间 System.setProperty("sun.net.client.defaultConnectTimeout", "10000"); System.setProperty("sun.net.client.defaultReadTimeout", "10000"); //初始化acsClient,暂不支持region化 IClientProfile profile = DefaultProfile.getProfile("cn-hangzhou", prop.getAccessKeyId(), prop.getAccessKeySecret()); DefaultProfile.addEndpoint("cn-hangzhou", "cn-hangzhou", product, domain); IAcsClient acsClient = new DefaultAcsClient(profile); //组装请求对象-具体描述见控制台-文档部分内容 SendSmsRequest request = new SendSmsRequest(); request.setMethod(MethodType.POST); //必填:待发送手机号 request.setPhoneNumbers(phone); //必填:短信签名-可在短信控制台中找到 request.setSignName(signName); //必填:短信模板-可在短信控制台中找到 request.setTemplateCode(template); //可选:模板中的变量替换JSON串,如模板内容为"亲爱的$&#123;name&#125;,您的验证码为$&#123;code&#125;"时,此处的值为 request.setTemplateParam("&#123;\"code\":\"" + code + "\"&#125;"); //选填-上行短信扩展码(无特殊需求用户请忽略此字段) //request.setSmsUpExtendCode("90997"); //可选:outId为提供给业务方扩展字段,最终在短信回执消息中将此值带回给调用者 request.setOutId("123456"); //hint 此处可能会抛出异常，注意catch SendSmsResponse sendSmsResponse = acsClient.getAcsResponse(request); logger.info("发送短信状态：&#123;&#125;", sendSmsResponse.getCode()); logger.info("发送短信消息：&#123;&#125;", sendSmsResponse.getMessage()); return sendSmsResponse; &#125;&#125; 属性加载： 12345678910111213141516171819202122232425262728293031323334353637383940414243@ConfigurationProperties(prefix = "leyou.sms")public class SmsProperties &#123; String accessKeyId; String accessKeySecret; String signName; String verifyCodeTemplate; public String getAccessKeyId() &#123; return accessKeyId; &#125; public void setAccessKeyId(String accessKeyId) &#123; this.accessKeyId = accessKeyId; &#125; public String getAccessKeySecret() &#123; return accessKeySecret; &#125; public void setAccessKeySecret(String accessKeySecret) &#123; this.accessKeySecret = accessKeySecret; &#125; public String getSignName() &#123; return signName; &#125; public void setSignName(String signName) &#123; this.signName = signName; &#125; public String getVerifyCodeTemplate() &#123; return verifyCodeTemplate; &#125; public void setVerifyCodeTemplate(String verifyCodeTemplate) &#123; this.verifyCodeTemplate = verifyCodeTemplate; &#125;&#125; 编写消息监听器 接下来，编写消息监听器，当接收到消息后，我们发送短信。 1234567891011121314151617181920212223242526272829303132333435@Component@EnableConfigurationProperties(SmsProperties.class)public class SmsListener &#123; @Autowired private SmsUtils smsUtils; @Autowired private SmsProperties prop; @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "leyou.sms.queue", durable = "true"), exchange = @Exchange(value = "leyou.sms.exchange", ignoreDeclarationExceptions = "true"), key = &#123;"sms.verify.code"&#125;)) public void listenSms(Map&lt;String, String&gt; msg) throws Exception &#123; if (msg == null || msg.size() &lt;= 0) &#123; // 放弃处理 return; &#125; String phone = msg.get("phone"); String code = msg.get("code"); if (StringUtils.isBlank(phone) || StringUtils.isBlank(code)) &#123; // 放弃处理 return; &#125; // 发送消息 SendSmsResponse resp = this.smsUtils.sendSms(phone, code, prop.getSignName(), prop.getVerifyCodeTemplate()); // 发送失败 throw new RuntimeException(); &#125;&#125; 我们注意到，消息体是一个Map，里面有两个属性： phone：电话号码 code：短信验证码 启动 启动项目，然后查看RabbitMQ控制台，发现交换机已经创建： 队列也已经创建： 并且绑定： 发送短信功能 短信微服务已经准备好，我们就可以继续编写用户中心接口了。 接口说明 这里的业务逻辑是这样的： 1）我们接收页面发送来的手机号码 2）生成一个随机验证码 3）将验证码保存在服务端 4）发送短信，将验证码发送到用户手机 那么问题来了：验证码保存在哪里呢？ 验证码有一定有效期，一般是5分钟，我们可以利用Redis的过期机制来保存。 Redis 安装 参考课前资料中的：《centos下的redis安装配置.md》 Spring Data Redis 官网：http://projects.spring.io/spring-data-redis/ Spring Data Redis，是Spring Data 家族的一部分。 对Jedis客户端进行了封装，与spring进行了整合。可以非常方便的来实现redis的配置和操作。 RedisTemplate基本操作 Spring Data Redis 提供了一个工具类：RedisTemplate。里面封装了对于Redis的五种数据结构的各种操作，包括： redisTemplate.opsForValue() ：操作字符串 redisTemplate.opsForHash() ：操作hash redisTemplate.opsForList()：操作list redisTemplate.opsForSet()：操作set redisTemplate.opsForZSet()：操作zset 其它一些通用命令，如expire，可以通过redisTemplate.xx()来直接调用 5种结构： String：等同于java中的，Map&lt;String,String&gt; list：等同于java中的Map&lt;String,List&lt;String&gt;&gt; set：等同于java中的Map&lt;String,Set&lt;String&gt;&gt; sort_set：可排序的set hash：等同于java中的：`Map&lt;String,Map&lt;String,String&gt;&gt; StringRedisTemplate RedisTemplate在创建时，可以指定其泛型类型： K：代表key 的数据类型 V: 代表value的数据类型 注意：这里的类型不是Redis中存储的数据类型，而是Java中的数据类型，RedisTemplate会自动将Java类型转为Redis支持的数据类型：字符串、字节、二进制等等。 不过RedisTemplate默认会采用JDK自带的序列化（Serialize）来对对象进行转换。生成的数据十分庞大，因此一般我们都会指定key和value为String类型，这样就由我们自己把对象序列化为json字符串来存储即可。 因为大部分情况下，我们都会使用key和value都为String的RedisTemplate，因此Spring就默认提供了这样一个实现： 测试 我们在项目中编写一个测试案例： 首先在项目中引入Redis启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 然后在配置文件中指定Redis地址： 123spring: redis: host: 192.168.56.101 然后就可以直接注入StringRedisTemplate对象了： 123456789101112131415161718192021222324252627282930313233343536373839404142@RunWith(SpringRunner.class)@SpringBootTest(classes = LyUserService.class)public class RedisTest &#123; @Autowired private StringRedisTemplate redisTemplate; @Test public void testRedis() &#123; // 存储数据 this.redisTemplate.opsForValue().set("key1", "value1"); // 获取数据 String val = this.redisTemplate.opsForValue().get("key1"); System.out.println("val = " + val); &#125; @Test public void testRedis2() &#123; // 存储数据，并指定剩余生命时间,5小时 this.redisTemplate.opsForValue().set("key2", "value2", 5, TimeUnit.HOURS); &#125; @Test public void testHash()&#123; BoundHashOperations&lt;String, Object, Object&gt; hashOps = this.redisTemplate.boundHashOps("user"); // 操作hash数据 hashOps.put("name", "jack"); hashOps.put("age", "21"); // 获取单个数据 Object name = hashOps.get("name"); System.out.println("name = " + name); // 获取所有数据 Map&lt;Object, Object&gt; map = hashOps.entries(); for (Map.Entry&lt;Object, Object&gt; me : map.entrySet()) &#123; System.out.println(me.getKey() + " : " + me.getValue()); &#125; &#125;&#125; controller 12345678910111213/** * 发送手机验证码 * @param phone * @return */@PostMapping("code")public ResponseEntity&lt;Void&gt; sendVerifyCode(String phone) &#123; Boolean boo = this.userService.sendVerifyCode(phone); if (boo == null || !boo) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.INTERNAL_SERVER_ERROR); &#125; return new ResponseEntity&lt;&gt;(HttpStatus.CREATED);&#125; service 这里的逻辑会稍微复杂： 生成随机验证码 将验证码保存到Redis中，用来在注册的时候验证 发送验证码到leyou-sms-service服务，发送短信 因此，我们需要引入Redis和AMQP： 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 添加RabbitMQ和Redis配置： 123456789101112131415spring: redis: host: 192.168.56.101 rabbitmq: host: 192.168.56.101 username: leyou password: leyou virtual-host: /leyou template: retry: enabled: true initial-interval: 10000ms max-interval: 210000ms multiplier: 2 publisher-confirms: true 另外还要用到工具类，生成6位随机码，这个我们封装到了leyou-common中，因此需要引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;$&#123;leyou.latest.version&#125;&lt;/version&gt;&lt;/dependency&gt; 生成随机码的工具： 123456789101112/** * 生成指定位数的随机数字 * @param len 随机数的位数 * @return 生成的随机数 */public static String generateCode(int len)&#123; len = Math.min(len, 8); int min = Double.valueOf(Math.pow(10, len - 1)).intValue(); int num = new Random().nextInt( Double.valueOf(Math.pow(10, len + 1)).intValue() - 1) + min; return String.valueOf(num).substring(0,len);&#125; Service代码： 123456789101112131415161718192021222324252627@Autowiredprivate StringRedisTemplate redisTemplate;@Autowiredprivate AmqpTemplate amqpTemplate;static final String KEY_PREFIX = "user:code:phone:";static final Logger logger = LoggerFactory.getLogger(UserService.class);public Boolean sendVerifyCode(String phone) &#123; // 生成验证码 String code = NumberUtils.generateCode(6); try &#123; // 发送短信 Map&lt;String, String&gt; msg = new HashMap&lt;&gt;(); msg.put("phone", phone); msg.put("code", code); this.amqpTemplate.convertAndSend("ly.sms.exchange", "sms.verify.code", msg); // 将code存入redis this.redisTemplate.opsForValue().set(KEY_PREFIX + phone, code, 5, TimeUnit.MINUTES); return true; &#125; catch (Exception e) &#123; logger.error("发送短信失败。phone：&#123;&#125;， code：&#123;&#125;", phone, code); return false; &#125;&#125; 注意：要设置短信验证码在Redis的缓存时间为5分钟 测试 通过RestClient发送请求试试： 查看Redis中的数据： 查看短信： 注册功能 接口说明 controller 1234567891011121314/** * 注册 * @param user * @param code * @return */@PostMapping("register")public ResponseEntity&lt;Void&gt; register(User user, @RequestParam("code") String code) &#123; Boolean boo = this.userService.register(user, code); if (boo == null || !boo) &#123; return ResponseEntity.status(HttpStatus.BAD_REQUEST).build(); &#125; return new ResponseEntity&lt;&gt;(HttpStatus.CREATED);&#125; service 基本逻辑： 1）校验短信验证码 2）生成盐 3）对密码加密 4）写入数据库 5）删除Redis中的验证码 1234567891011121314151617181920212223242526272829public Boolean register(User user, String code) &#123; String key = KEY_PREFIX + user.getPhone(); // 从redis取出验证码 String codeCache = this.redisTemplate.opsForValue().get(key); // 检查验证码是否正确 if (!code.equals(codeCache)) &#123; // 不正确，返回 return false; &#125; user.setId(null); user.setCreated(new Date()); // 生成盐 String salt = CodecUtils.generateSalt(); user.setSalt(salt); // 对密码进行加密 user.setPassword(CodecUtils.md5Hex(user.getPassword(), salt)); // 写入数据库 boolean boo = this.userMapper.insertSelective(user) == 1; // 如果注册成功，删除redis中的code if (boo) &#123; try &#123; this.redisTemplate.delete(key); &#125; catch (Exception e) &#123; logger.error("删除缓存验证码失败，code：&#123;&#125;", code, e); &#125; &#125; return boo;&#125; 测试 我们通过RestClient测试： 查看数据库： 服务端数据校验 刚才虽然实现了注册，但是服务端并没有进行数据校验，而前端的校验是很容易被有心人绕过的。所以我们必须在后台添加数据校验功能： 我们这里会使用Hibernate-Validator框架完成数据校验： 而SpringBoot的web启动器中已经集成了相关依赖： 什么是Hibernate Validator Hibernate Validator是Hibernate提供的一个开源框架，使用注解方式非常方便的实现服务端的数据校验。 官网：http://hibernate.org/validator/ hibernate Validator 是 Bean Validation 的参考实现 。 Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint（约束） 的实现，除此之外还有一些附加的 constraint。 在日常开发中，Hibernate Validator经常用来验证bean的字段，基于注解，方便快捷高效。 Bean校验的注解 常用注解如下： Constraint 详细信息 @Valid 被注释的元素是一个对象，需要检查此对象的所有字段值 @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max, min) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(value) 被注释的元素必须符合指定的正则表达式 @Email 被注释的元素必须是电子邮箱地址 @Length 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range 被注释的元素必须在合适的范围内 @NotBlank 被注释的字符串的必须非空 @URL(protocol=,host=, port=,regexp=, flags=) 被注释的字符串必须是一个有效的url @CreditCardNumber 被注释的字符串必须通过Luhn校验算法，银行卡，信用卡等号码一般都用Luhn计算合法性 给User添加校验 我们在ly-user-interface中添加Hibernate-Validator依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;&lt;/dependency&gt; 我们在User对象的部分属性上添加注解： 1234567891011121314151617181920@Table(name = "tb_user")public class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Length(min = 4, max = 30, message = "用户名只能在4~30位之间") private String username;// 用户名 @JsonIgnore @Length(min = 4, max = 30, message = "用户名只能在4~30位之间") private String password;// 密码 @Pattern(regexp = "^1[35678]\\d&#123;9&#125;$", message = "手机号格式不正确") private String phone;// 电话 private Date created;// 创建时间 @JsonIgnore private String salt;// 密码的盐值&#125; 在controller上进行控制 在controller中只需要给User添加 @Valid注解即可。 测试 我们故意填错： 然后SpringMVC会自动返回错误信息： 根据用户名和密码查询用户 接口说明 功能说明 查询功能，根据参数中的用户名和密码查询指定用户 接口路径 1GET /query 参数说明： form表单格式 参数 说明 是否必须 数据类型 默认值 username 用户名，格式为4~30位字母、数字、下划线 是 String 无 password 用户密码，格式为4~30位字母、数字、下划线 是 String 无 返回结果： 用户的json格式数据 123456&#123; "id": 6572312, "username":"test", "phone":"13688886666", "created": 1342432424&#125; 状态码： 200：注册成功 400：用户名或密码错误 500：服务器内部异常，注册失败 controller 1234567891011121314151617/** * 根据用户名和密码查询用户 * @param username * @param password * @return */@GetMapping("query")public ResponseEntity&lt;User&gt; queryUser( @RequestParam("username") String username, @RequestParam("password") String password ) &#123; User user = this.userService.queryUser(username, password); if (user == null) &#123; return ResponseEntity.status(HttpStatus.BAD_REQUEST).build(); &#125; return ResponseEntity.ok(user); &#125; service 12345678910111213141516public User queryUser(String username, String password) &#123; // 查询 User record = new User(); record.setUsername(username); User user = this.userMapper.selectOne(record); // 校验用户名 if (user == null) &#123; return null; &#125; // 校验密码 if (!user.getPassword().equals(CodecUtils.md5Hex(password, user.getSalt()))) &#123; return null; &#125; // 用户名密码都正确 return user;&#125; 要注意，查询时也要对密码进行加密后判断是否一致。 测试 我们通过RestClient测试： 在注册页进行测试 在注册页填写信息： 提交发现页面自动跳转到了登录页，查看数据库：]]></content>
  </entry>
  <entry>
    <title><![CDATA[day15-rabbitmq及数据同步]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F27%2Fday15-rabbitmq%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[学习目标 了解常见的MQ产品 了解RabbitMQ的5种消息模型 会使用Spring AMQP 利用MQ实现搜索和静态页的数据同步 RabbitMQ 搜索与商品服务的问题 目前我们已经完成了商品详情和搜索系统的开发。我们思考一下，是否存在问题？ 商品的原始数据保存在数据库中，增删改查都在数据库中完成。 搜索服务数据来源是索引库，如果数据库商品发生变化，索引库数据不能及时更新。 商品详情做了页面静态化，静态页面数据也不会随着数据库商品发生变化。 如果我们在后台修改了商品的价格，搜索页面和商品详情页显示的依然是旧的价格，这样显然不对。该如何解决？ 这里有两种解决方案： 方案1：每当后台对商品做增删改操作，同时要修改索引库数据及静态页面 方案2：搜索服务和商品页面服务对外提供操作接口，后台在商品增删改后，调用接口 以上两种方式都有同一个严重问题：就是代码耦合，后台服务中需要嵌入搜索和商品页面服务，违背了微服务的独立原则。 所以，我们会通过另外一种方式来解决这个问题：消息队列 消息队列（MQ） 什么是消息队列 消息队列，即MQ，Message Queue。 消息队列是典型的：生产者、消费者模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。 结合前面所说的问题： 商品服务对商品增删改以后，无需去操作索引库或静态页面，只是发送一条消息，也不关心消息被谁接收。 搜索服务和静态页面服务接收消息，分别去处理索引库和静态页面。 如果以后有其它系统也依赖商品服务的数据，同样监听消息即可，商品服务无需任何代码修改。 AMQP和JMS MQ是消息通信的模型，并不是具体实现。现在实现MQ的有两种主流方式：AMQP、JMS。 两者间的区别和联系： JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式 JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。 JMS规定了两种消息模型；而AMQP的消息模型更加丰富 常见MQ产品 ActiveMQ：基于JMS RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好 RocketMQ：基于JMS，阿里巴巴产品，目前交由Apache基金会 Kafka：分布式消息系统，高吞吐量 RabbitMQ RabbitMQ是基于AMQP的一款消息管理系统 官网： http://www.rabbitmq.com/ 官方教程：http://www.rabbitmq.com/getstarted.html 下载和安装 下载 官网下载地址：http://www.rabbitmq.com/download.html 目前最新版本是：3.7.5 我们的课程中使用的是：3.4.1版本 课前资料提供了安装包： 安装 详见课前资料中的： 五种消息模型RabbitMQ提供了6种消息模型，但是第6种其实是RPC，并不是MQ，因此不予学习。那么也就剩下5种。 但是其实3、4、5这三种都属于订阅模型，只不过进行路由的方式不同。 我们通过一个demo工程来了解下RabbitMQ的工作方式： 导入工程： 导入后： 依赖： 123456789101112131415161718192021222324252627282930&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;itcast-rabbitmq&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 我们抽取一个建立RabbitMQ连接的工具类，方便其他程序获取连接： 12345678910111213141516171819202122public class ConnectionUtil &#123; /** * 建立与RabbitMQ的连接 * @return * @throws Exception */ public static Connection getConnection() throws Exception &#123; //定义连接工厂 ConnectionFactory factory = new ConnectionFactory(); //设置服务地址 factory.setHost("192.168.56.101"); //端口 factory.setPort(5672); //设置账号信息，用户名、密码、vhost factory.setVirtualHost("/leyou"); factory.setUsername("leyou"); factory.setPassword("leyou"); // 通过工程获取连接 Connection connection = factory.newConnection(); return connection; &#125;&#125; 基本消息模型 官方介绍： RabbitMQ是一个消息代理：它接受和转发消息。 你可以把它想象成一个邮局：当你把邮件放在邮箱里时，你可以确定邮差先生最终会把邮件发送给你的收件人。 在这个比喻中，RabbitMQ是邮政信箱，邮局和邮递员。 RabbitMQ与邮局的主要区别是它不处理纸张，而是接受，存储和转发数据消息的二进制数据块。 P（producer/ publisher）：生产者，一个发送消息的用户应用程序。 C（consumer）：消费者，消费和接收有类似的意思，消费者是一个主要用来等待接收消息的用户应用程序 队列（红色区域）：rabbitmq内部类似于邮箱的一个概念。虽然消息流经rabbitmq和你的应用程序，但是它们只能存储在队列中。队列只受主机的内存和磁盘限制，实质上是一个大的消息缓冲区。许多生产者可以发送消息到一个队列，许多消费者可以尝试从一个队列接收数据。 总之： 生产者将消息发送到队列，消费者从队列中获取消息，队列是存储消息的缓冲区。 我们将用Java编写两个程序;发送单个消息的生产者，以及接收消息并将其打印出来的消费者。我们将详细介绍Java API中的一些细节，这是一个消息传递的“Hello World”。 我们将调用我们的消息发布者（发送者）Send和我们的消息消费者（接收者）Recv。发布者将连接到RabbitMQ，发送一条消息，然后退出。 生产者发送消息 123456789101112131415161718192021222324public class Send &#123; private final static String QUEUE_NAME = "simple_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); // 从连接中创建通道，这是完成大部分API的地方。 Channel channel = connection.createChannel(); // 声明（创建）队列，必须声明队列才能够发送消息，我们可以把消息发送到队列中。 // 声明一个队列是幂等的 - 只有当它不存在时才会被创建 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 消息内容 String message = "Hello World!"; channel.basicPublish("", QUEUE_NAME, null, message.getBytes()); System.out.println(" [x] Sent '" + message + "'"); //关闭通道和连接 channel.close(); connection.close(); &#125;&#125; 控制台： 管理工具中查看消息 进入队列页面，可以看到新建了一个队列：simple_queue 点击队列名称，进入详情页，可以查看消息： 在控制台查看消息并不会将消息消费，所以消息还在。 消费者获取消息 12345678910111213141516171819202122232425public class Recv &#123; private final static String QUEUE_NAME = "simple_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 创建通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [x] received : " + msg + "!"); &#125; &#125;; // 监听队列，第二个参数：是否自动进行消息确认。 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 控制台： 这个时候，队列中的消息就没了： 我们发现，消费者已经获取了消息，但是程序没有停止，一直在监听队列中是否有新的消息。一旦有新的消息进入队列，就会立即打印. 消息确认机制（ACK） 通过刚才的案例可以看出，消息一旦被消费者接收，队列中的消息就会被删除。 那么问题来了：RabbitMQ怎么知道消息被接收了呢？ 如果消费者领取消息后，还没执行操作就挂掉了呢？或者抛出了异常？消息消费失败，但是RabbitMQ无从得知，这样消息就丢失了！ 因此，RabbitMQ有一个ACK机制。当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。不过这种回执ACK分两种情况： 自动ACK：消息一旦被接收，消费者自动发送ACK 手动ACK：消息接收后，不会发送ACK，需要手动调用 大家觉得哪种更好呢？ 这需要看消息的重要性： 如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便 如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了。 我们之前的测试都是自动ACK的，如果要手动ACK，需要改动我们的代码： 123456789101112131415161718192021222324252627public class Recv2 &#123; private final static String QUEUE_NAME = "simple_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 创建通道 final Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [x] received : " + msg + "!"); // 手动进行ACK channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; // 监听队列，第二个参数false，手动进行ACK channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; 注意到最后一行代码： 1channel.basicConsume(QUEUE_NAME, false, consumer); 如果第二个参数为true，则会自动进行ACK；如果为false，则需要手动ACK。方法的声明： 自动ACK存在的问题 修改消费者，添加异常，如下： 生产者不做任何修改，直接运行，消息发送成功： 运行消费者，程序抛出异常。但是消息依然被消费： 管理界面： 演示手动ACK 修改消费者，把自动改成手动（去掉之前制造的异常） 生产者不变，再次运行： 运行消费者 但是，查看管理界面，发现： 停掉消费者的程序，发现： 这是因为虽然我们设置了手动ACK，但是代码中并没有进行消息确认！所以消息并未被真正消费掉。 当我们关掉这个消费者，消息的状态再次称为Ready 修改代码手动ACK： 执行： 消息消费成功！ work消息模型 工作队列或者竞争消费者模式 在第一篇教程中，我们编写了一个程序，从一个命名队列中发送并接受消息。在这里，我们将创建一个工作队列，在多个工作者之间分配耗时任务。 工作队列，又称任务队列。主要思想就是避免执行资源密集型任务时，必须等待它执行完成。相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列。 在后台运行的工作进程将获取任务并最终执行作业。当你运行许多工人时，任务将在他们之间共享，但是一个消息只能被一个消费者获取。 这个概念在Web应用程序中特别有用，因为在短的HTTP请求窗口中无法处理复杂的任务。 接下来我们来模拟这个流程： ​ P：生产者：任务的发布者 ​ C1：消费者，领取任务并且完成任务，假设完成速度较快 ​ C2：消费者2：领取任务并完成任务，假设完成速度慢 面试题：避免消息堆积？ 1） 采用workqueue，多个消费者监听同一队列。 2）接收到消息以后，而是通过线程池，异步消费。 生产者 生产者与案例1中的几乎一样： 123456789101112131415161718192021222324public class Send &#123; private final static String QUEUE_NAME = "test_work_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 循环发布任务 for (int i = 0; i &lt; 50; i++) &#123; // 消息内容 String message = "task .. " + i; channel.basicPublish("", QUEUE_NAME, null, message.getBytes()); System.out.println(" [x] Sent '" + message + "'"); Thread.sleep(i * 2); &#125; // 关闭通道和连接 channel.close(); connection.close(); &#125;&#125; 不过这里我们是循环发送50条消息。 消费者1 消费者2 与消费者1基本类似，就是没有设置消费耗时时间。 这里是模拟有些消费者快，有些比较慢。 接下来，两个消费者一同启动，然后发送50条消息： 可以发现，两个消费者各自消费了25条消息，而且各不相同，这就实现了任务的分发。 能者多劳 刚才的实现有问题吗？ 消费者1比消费者2的效率要低，一次任务的耗时较长 然而两人最终消费的消息数量是一样的 消费者2大量时间处于空闲状态，消费者1一直忙碌 现在的状态属于是把任务平均分配，正确的做法应该是消费越快的人，消费的越多。 怎么实现呢？ 我们可以使用basicQos方法和prefetchCount = 1设置。 这告诉RabbitMQ一次不要向工作人员发送多于一条消息。 或者换句话说，不要向工作人员发送新消息，直到它处理并确认了前一个消息。 相反，它会将其分派给不是仍然忙碌的下一个工作人员。 再次测试： 订阅模型分类 在之前的模式中，我们创建了一个工作队列。 工作队列背后的假设是：每个任务只被传递给一个工作人员。 在这一部分，我们将做一些完全不同的事情 - 我们将会传递一个信息给多个消费者。 这种模式被称为“发布/订阅”。 订阅模型示意图： 解读： 1、1个生产者，多个消费者 2、每一个消费者都有自己的一个队列 3、生产者没有将消息直接发送到队列，而是发送到了交换机 4、每个队列都要绑定到交换机 5、生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者获取的目的 X（Exchanges）：交换机一方面：接收生产者发送的消息。另一方面：知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。 Exchange类型有以下几种： ​ Fanout：广播，将消息交给所有绑定到交换机的队列 ​ Direct：定向，把消息交给符合指定routing key 的队列 ​ Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列 我们这里先学习 ​ Fanout：即广播模式 Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！ 订阅模型-Fanout Fanout，也称为广播。 流程图： 在广播模式下，消息发送流程是这样的： 1） 可以有多个消费者 2） 每个消费者有自己的queue（队列） 3） 每个队列都要绑定到Exchange（交换机） 4） 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定。 5） 交换机把消息发送给绑定过的所有队列 6） 队列的消费者都能拿到消息。实现一条消息被多个消费者消费 生产者 两个变化： 1） 声明Exchange，不再声明Queue 2） 发送消息到Exchange，不再发送到Queue 1234567891011121314151617181920212223public class Send &#123; private final static String EXCHANGE_NAME = "fanout_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明exchange，指定类型为fanout channel.exchangeDeclare(EXCHANGE_NAME, "fanout"); // 消息内容 String message = "Hello everyone"; // 发布消息到Exchange channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes()); System.out.println(" [生产者] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125; 消费者1 12345678910111213141516171819202122232425262728293031public class Recv &#123; private final static String QUEUE_NAME = "fanout_exchange_queue_1"; private final static String EXCHANGE_NAME = "fanout_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ""); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者1] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动返回完成 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 要注意代码中：队列需要和交换机绑定 消费者2 12345678910111213141516171819202122232425262728293031public class Recv2 &#123; private final static String QUEUE_NAME = "fanout_exchange_queue_2"; private final static String EXCHANGE_NAME = "fanout_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ""); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者2] received : " + msg + "!"); &#125; &#125;; // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 测试 我们运行两个消费者，然后发送1条消息： 订阅模型-Direct 有选择性的接收消息 在订阅模式中，生产者发布消息，所有消费者都可以获取所有消息。 在路由模式中，我们将添加一个功能 - 我们将只能订阅一部分消息。 例如，我们只能将重要的错误消息引导到日志文件（以节省磁盘空间），同时仍然能够在控制台上打印所有日志消息。 但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。 在Direct模型下，队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key） 消息的发送方在向Exchange发送消息时，也必须指定消息的routing key。 P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。 X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列 C1：消费者，其所在队列指定了需要routing key 为 error 的消息 C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息 生产者 此处我们模拟商品的增删改，发送消息的RoutingKey分别是：insert、update、delete 1234567891011121314151617181920public class Send &#123; private final static String EXCHANGE_NAME = "direct_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明exchange，指定类型为direct channel.exchangeDeclare(EXCHANGE_NAME, "direct"); // 消息内容 String message = "商品新增了， id = 1001"; // 发送消息，并且指定routing key 为：insert ,代表新增商品 channel.basicPublish(EXCHANGE_NAME, "insert", null, message.getBytes()); System.out.println(" [商品服务：] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125; 消费者1 我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品。 12345678910111213141516171819202122232425262728293031public class Recv &#123; private final static String QUEUE_NAME = "direct_exchange_queue_1"; private final static String EXCHANGE_NAME = "direct_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。假设此处需要update和delete消息 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "update"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "delete"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者1] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 消费者2 我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。 1234567891011121314151617181920212223242526272829303132public class Recv2 &#123; private final static String QUEUE_NAME = "direct_exchange_queue_2"; private final static String EXCHANGE_NAME = "direct_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "insert"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "update"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "delete"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者2] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 测试 我们分别发送增、删、改的RoutingKey，发现结果： 订阅模型-Topic Topic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！ Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert 通配符规则： ​ #：匹配一个或多个词 ​ *：匹配不多不少恰好1个词 举例： ​ audit.#：能够匹配audit.irs.corporate 或者 audit.irs ​ audit.*：只能匹配audit.irs 在这个例子中，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“..”。 我们创建了三个绑定：Q1绑定了绑定键“* .orange.”，Q2绑定了“.*.rabbit”和“lazy.＃”。 Q1匹配所有的橙色动物。 Q2匹配关于兔子以及懒惰动物的消息。 练习，生产者发送如下消息，会进入那个队列： quick.orange.rabbit à Q1 Q2 lazy.orange.elephant à Q1 Q2 quick.orange.fox à Q1 lazy.pink.rabbit à Q2 quick.brown.fox à 不匹配任意队列，被丢弃 quick.orange.male.rabbit à orange à 生产者 使用topic类型的Exchange，发送消息的routing key有3种： item.isnert、item.update、item.delete： 1234567891011121314151617181920public class Send &#123; private final static String EXCHANGE_NAME = "topic_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明exchange，指定类型为topic channel.exchangeDeclare(EXCHANGE_NAME, "topic"); // 消息内容 String message = "新增商品 : id = 1001"; // 发送消息，并且指定routing key 为：insert ,代表新增商品 channel.basicPublish(EXCHANGE_NAME, "item.insert", null, message.getBytes()); System.out.println(" [商品服务：] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125; 消费者1 我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品 12345678910111213141516171819202122232425262728293031public class Recv &#123; private final static String QUEUE_NAME = "topic_exchange_queue_1"; private final static String EXCHANGE_NAME = "topic_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。需要 update、delete channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "item.update"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "item.delete"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者1] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 消费者2 我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。 123456789101112131415161718192021222324252627282930313233/** * 消费者2 */public class Recv2 &#123; private final static String QUEUE_NAME = "topic_exchange_queue_2"; private final static String EXCHANGE_NAME = "topic_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "item.*"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者2] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 持久化 如何避免消息丢失？ 1） 消费者的ACK机制。可以防止消费者丢失消息。 2） 但是，如果在消费者消费之前，MQ就宕机了，消息就没了。 是可以将消息进行持久化呢？ 要将消息持久化，前提是：队列、Exchange都持久化 交换机持久化 队列持久化 消息持久化 Spring AMQP 简介 Sprin有很多不同的项目，其中就有对AMQP的支持： Spring AMQP的页面：http://spring.io/projects/spring-amqp 注意这里一段描述： ​ Spring-amqp是对AMQP协议的抽象实现，而spring-rabbit 是对协议的具体实现，也是目前的唯一实现。底层使用的就是RabbitMQ。 依赖和配置 添加AMQP的启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 在application.yml中添加RabbitMQ地址： 123456spring: rabbitmq: host: 192.168.56.101 username: leyou password: leyou virtual-host: /leyou 监听者 在SpringAmqp中，对消息的消费者进行了封装和抽象，一个普通的JavaBean中的普通方法，只要通过简单的注解，就可以成为一个消费者。 123456789101112131415@Componentpublic class Listener &#123; @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "spring.test.queue", durable = "true"), exchange = @Exchange( value = "spring.test.exchange", ignoreDeclarationExceptions = "true", type = ExchangeTypes.TOPIC ), key = &#123;"#.#"&#125;)) public void listen(String msg)&#123; System.out.println("接收到消息：" + msg); &#125;&#125; @Componet：类上的注解，注册到Spring容器 @RabbitListener：方法上的注解，声明这个方法是一个消费者方法，需要指定下面的属性： bindings：指定绑定关系，可以有多个。值是@QueueBinding的数组。@QueueBinding包含下面属性： value：这个消费者关联的队列。值是@Queue，代表一个队列 exchange：队列所绑定的交换机，值是@Exchange类型 key：队列和交换机绑定的RoutingKey 类似listen这样的方法在一个类中可以写多个，就代表多个消费者。 AmqpTemplate Spring最擅长的事情就是封装，把他人的框架进行封装和整合。 Spring为AMQP提供了统一的消息处理模板：AmqpTemplate，非常方便的发送消息，其发送方法： 红框圈起来的是比较常用的3个方法，分别是： 指定交换机、RoutingKey和消息体 指定消息 指定RoutingKey和消息，会向默认的交换机发送消息 测试代码 123456789101112131415@RunWith(SpringRunner.class)@SpringBootTest(classes = Application.class)public class MqDemo &#123; @Autowired private AmqpTemplate amqpTemplate; @Test public void testSend() throws InterruptedException &#123; String msg = "hello, Spring boot amqp"; this.amqpTemplate.convertAndSend("spring.test.exchange","a.b", msg); // 等待10秒后再结束 Thread.sleep(10000); &#125;&#125; 运行后查看日志： 项目改造 接下来，我们就改造项目，实现搜索服务、商品静态页的数据同步。 思路分析 发送方：商品微服务 什么时候发？ 当商品服务对商品进行写操作：增、删、改的时候，需要发送一条消息，通知其它服务。 发送什么内容？ 对商品的增删改时其它服务可能需要新的商品数据，但是如果消息内容中包含全部商品信息，数据量太大，而且并不是每个服务都需要全部的信息。因此我们只发送商品id，其它服务可以根据id查询自己需要的信息。 接收方：搜索微服务、静态页微服务 接收消息后如何处理？ 搜索微服务： 增/改：添加新的数据到索引库 删：删除索引库数据 静态页微服务： 增：创建新的静态页 删：删除原来的静态页 改：创建新的静态页并删除原来的 商品服务发送消息 我们先在商品微服务leyou-item-service中实现发送消息。 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 我们在application.yml中添加一些有关RabbitMQ的配置： 123456789spring: rabbitmq: host: 192.168.56.101 username: leyou password: leyou virtual-host: /leyou template: exchange: leyou.item.exchange publisher-confirms: true template：有关AmqpTemplate的配置 retry：失败重试 enabled：开启失败重试 initial-interval：第一次重试的间隔时长 max-interval：最长重试间隔，超过这个间隔将不再重试 multiplier：下次重试间隔的倍数，此处是2即下次重试间隔是上次的2倍 exchange：缺省的交换机名称，此处配置后，发送消息如果不指定交换机就会使用这个 publisher-confirms：生产者确认机制，确保消息会正确发送，如果发送失败会有错误回执，从而触发重试 改造GoodsService 在GoodsService中封装一个发送消息到mq的方法： 12345678private void sendMessage(Long id, String type)&#123; // 发送消息 try &#123; this.amqpTemplate.convertAndSend("item." + type, id); &#125; catch (Exception e) &#123; logger.error("&#123;&#125;商品消息发送异常，商品id：&#123;&#125;", type, id, e); &#125;&#125; 这里没有指定交换机，因此默认发送到了配置中的：leyou.item.exchange 注意：这里要把所有异常都try起来，不能让消息的发送影响到正常的业务逻辑 然后在新增的时候调用： 修改的时候调用： 搜索服务接收消息 搜索服务接收到消息后要做的事情： 增：添加新的数据到索引库 删：删除索引库数据 改：修改索引库数据 因为索引库的新增和修改方法是合二为一的，因此我们可以将这两类消息一同处理，删除另外处理。 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 添加配置 123456spring: rabbitmq: host: 192.168.56.101 username: leyou password: leyou virtual-host: /leyou 这里只是接收消息而不发送，所以不用配置template相关内容。 编写监听器 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Componentpublic class GoodsListener &#123; @Autowired private SearchService searchService; /** * 处理insert和update的消息 * * @param id * @throws Exception */ @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "leyou.create.index.queue", durable = "true"), exchange = @Exchange( value = "leyou.item.exchange", ignoreDeclarationExceptions = "true", type = ExchangeTypes.TOPIC), key = &#123;"item.insert", "item.update"&#125;)) public void listenCreate(Long id) throws Exception &#123; if (id == null) &#123; return; &#125; // 创建或更新索引 this.searchService.createIndex(id); &#125; /** * 处理delete的消息 * * @param id */ @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "leyou.delete.index.queue", durable = "true"), exchange = @Exchange( value = "leyou.item.exchange", ignoreDeclarationExceptions = "true", type = ExchangeTypes.TOPIC), key = "item.delete")) public void listenDelete(Long id) &#123; if (id == null) &#123; return; &#125; // 删除索引 this.searchService.deleteIndex(id); &#125;&#125; 编写创建和删除索引方法 这里因为要创建和删除索引，我们需要在SearchService中拓展两个方法，创建和删除索引： 12345678910111213public void createIndex(Long id) throws IOException &#123; Spu spu = this.goodsClient.querySpuById(id); // 构建商品 Goods goods = this.buildGoods(spu); // 保存数据到索引库 this.goodsRepository.save(goods);&#125;public void deleteIndex(Long id) &#123; this.goodsRepository.deleteById(id);&#125; 创建索引的方法可以从之前导入数据的测试类中拷贝和改造。 静态页服务接收消息 商品静态页服务接收到消息后的处理： 增：创建新的静态页 删：删除原来的静态页 改：创建新的静态页并删除原来的 不过，我们编写的创建静态页的方法也具备覆盖以前页面的功能，因此：增和改的消息可以放在一个方法中处理，删除消息放在另一个方法处理。 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 添加配置 123456spring: rabbitmq: host: 192.168.56.101 username: leyou password: leyou virtual-host: /leyou 这里只是接收消息而不发送，所以不用配置template相关内容。 编写监听器 代码： 123456789101112131415161718192021222324252627282930313233343536@Componentpublic class GoodsListener &#123; @Autowired private GoodsHtmlService goodsHtmlService; @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "leyou.create.web.queue", durable = "true"), exchange = @Exchange( value = "leyou.item.exchange", ignoreDeclarationExceptions = "true", type = ExchangeTypes.TOPIC), key = &#123;"item.insert", "item.update"&#125;)) public void listenCreate(Long id) throws Exception &#123; if (id == null) &#123; return; &#125; // 创建页面 goodsHtmlService.createHtml(id); &#125; @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "leyou.delete.web.queue", durable = "true"), exchange = @Exchange( value = "leyou.item.exchange", ignoreDeclarationExceptions = "true", type = ExchangeTypes.TOPIC), key = "item.delete")) public void listenDelete(Long id) &#123; if (id == null) &#123; return; &#125; // 创建页面 goodsHtmlService.deleteHtml(id); &#125;&#125; 添加删除页面方法 1234public void deleteHtml(Long id) &#123; File file = new File("C:\\project\\nginx-1.14.0\\html\\item\\", id + ".html"); file.deleteOnExit();&#125; 测试 查看RabbitMQ控制台 重新启动项目，并且登录RabbitMQ管理界面：http://192.168.56.101:15672 可以看到，交换机已经创建出来了： 队列也已经创建完毕： 并且队列都已经绑定到交换机： 修改数据试一试 在后台修改商品数据的价格，分别在搜索及商品详情页查看是否统一。]]></content>
  </entry>
  <entry>
    <title><![CDATA[day14-商品详情及静态化]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F27%2Fday14-%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E5%8F%8A%E9%9D%99%E6%80%81%E5%8C%96%2F</url>
    <content type="text"><![CDATA[学习目标 了解Thymeleaf的基本使用 实现商品详情页的渲染 知道页面静态化的作用 实现页面静态化功能 商品详情 当用户搜索到商品，肯定会点击查看，就会进入商品详情页，接下来我们完成商品详情页的展示， Thymeleaf 在商品详情页中，我们会使用到Thymeleaf来渲染页面，所以需要先了解Thymeleaf的语法。 详见课前资料中《Thymeleaf语法入门.md》 商品详情页服务 商品详情浏览量比较大，并发高，我们会独立开启一个微服务，用来展示商品详情。 创建module 商品的详情页服务，命名为：leyou-goods-web 目录： pom依赖 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.goods&lt;/groupId&gt; &lt;artifactId&gt;leyou-goods-web&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.item&lt;/groupId&gt; &lt;artifactId&gt;leyou-item-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 编写启动类 12345678@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class LeyouGoodsWebApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouGoodsWebApplication.class, args); &#125;&#125; application.yml文件 1234567891011121314151617server: port: 8084spring: application: name: goods-page thymeleaf: cache: falseeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;.$&#123;server.port&#125; 页面模板 我们从leyou-portal中复制item.html模板到当前项目resource目录下的templates中： 页面跳转 修改页面跳转路径 首先我们需要修改搜索结果页的商品地址，目前所有商品的地址都是：http://www.leyou.com/item.html 我们应该跳转到对应的商品的详情页才对。 那么问题来了：商品详情页是一个SKU？还是多个SKU的集合？ 通过详情页的预览，我们知道它是多个SKU的集合，即SPU。 所以，页面跳转时，我们应该携带SPU的id信息。 例如：http://www.leyou.com/item/2314123.html 这里就采用了路径占位符的方式来传递spu的id，我们打开search.html，修改其中的商品路径： 刷新页面后再看： nginx反向代理 接下来，我们要把这个地址指向我们刚刚创建的服务：leyou-goods-web，其端口为8084 我们在nginx.conf中添加一段逻辑： 把以/item开头的请求，代理到我们的8084端口。 编写跳转controller 在leyou-goods-web中编写controller，接收请求，并跳转到商品详情页： 12345678910111213141516@Controller@RequestMapping("item")public class GoodsController &#123; /** * 跳转到商品详情页 * @param model * @param id * @return */ @GetMapping("&#123;id&#125;.html") public String toItemPage(Model model, @PathVariable("id")Long id)&#123; return "item"; &#125;&#125; 测试 启动leyou-goods-page，点击搜索页面商品，看是能够正常跳转： 现在看到的依然是静态的数据。我们接下来开始页面的渲染 封装模型数据 首先我们一起来分析一下，在这个页面中需要哪些数据 我们已知的条件是传递来的spu的id，我们需要根据spu的id查询到下面的数据： spu信息 spu的详情 spu下的所有sku 品牌 商品三级分类 商品规格参数、规格参数组 商品微服务提供接口 查询spu 以上所需数据中，查询spu的接口目前还没有，我们需要在商品微服务中提供这个接口： GoodsApi 1234567/** * 根据spu的id查询spu * @param id * @return */@GetMapping("spu/&#123;id&#125;")public Spu querySpuById(@PathVariable("id") Long id); GoodsController 12345678@GetMapping("spu/&#123;id&#125;")public ResponseEntity&lt;Spu&gt; querySpuById(@PathVariable("id") Long id)&#123; Spu spu = this.goodsService.querySpuById(id); if(spu == null)&#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(spu);&#125; GoodsService 123public Spu querySpuById(Long id) &#123; return this.spuMapper.selectByPrimaryKey(id);&#125; 查询规格参数组 我们在页面展示规格时，需要按组展示： 组内有多个参数，为了方便展示。我们提供一个接口，查询规格组，同时在规格组中持有组内的所有参数。 拓展SpecGroup类： 我们在SpecGroup中添加一个SpecParam的集合，保存改组下所有规格参数 1234567891011121314@Table(name = "tb_spec_group")public class SpecGroup &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long cid; private String name; @Transient private List&lt;SpecParam&gt; params; // 该组下的所有规格参数集合&#125; 然后提供查询接口： SpecificationAPI： 1234567891011121314151617@RequestMapping("spec")public interface SpecificationApi &#123; @GetMapping("groups/&#123;cid&#125;") public ResponseEntity&lt;List&lt;SpecGroup&gt;&gt; querySpecGroups(@PathVariable("cid") Long cid); @GetMapping("/params") public List&lt;SpecParam&gt; querySpecParam( @RequestParam(value = "gid", required = false) Long gid, @RequestParam(value = "cid", required = false) Long cid, @RequestParam(value = "searching", required = false) Boolean searching, @RequestParam(value = "generic", required = false) Boolean generic); // 查询规格参数组，及组内参数 @GetMapping("&#123;cid&#125;") List&lt;SpecGroup&gt; querySpecsByCid(@PathVariable("cid") Long cid);&#125; SpecificationController 12345678@GetMapping("&#123;cid&#125;")public ResponseEntity&lt;List&lt;SpecGroup&gt;&gt; querySpecsByCid(@PathVariable("cid") Long cid)&#123; List&lt;SpecGroup&gt; list = this.specificationService.querySpecsByCid(cid); if(list == null || list.size() == 0)&#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(list);&#125; SpecificationService 12345678910public List&lt;SpecGroup&gt; querySpecsByCid(Long cid) &#123; // 查询规格组 List&lt;SpecGroup&gt; groups = this.querySpecGroups(cid); SpecParam param = new SpecParam(); groups.forEach(g -&gt; &#123; // 查询组内参数 g.setParams(this.querySpecParams(g.getId(), null, null, null)); &#125;); return groups;&#125; 在service中，我们调用之前编写过的方法，查询规格组，和规格参数，然后封装返回。 创建FeignClient 我们在leyou-goods-web服务中，创建FeignClient： BrandClient： 123@FeignClient("item-service")public interface BrandClient extends BrandApi &#123;&#125; CategoryClient 123@FeignClient("item-service")public interface CategoryClient extends CategoryApi &#123;&#125; GoodsClient: 123@FeignClient("item-service")public interface GoodsClient extends GoodsApi &#123;&#125; SpecificationClient： 123@FeignClient(value = "item-service")public interface SpecificationClient extends SpecificationApi&#123;&#125; 封装数据模型 我们创建一个GoodsService，在里面来封装数据模型。 这里要查询的数据： SPU SpuDetail SKU集合 商品分类 这里值需要分类的id和name就够了，因此我们查询到以后自己需要封装数据 品牌 规格组 查询规格组的时候，把规格组下所有的参数也一并查出，上面提供的接口中已经实现该功能，我们直接调 sku的特有规格参数 有了规格组，为什么这里还要查询？ 因为在SpuDetail中的SpecialSpec中，是以id作为规格参数id作为key，如图： 但是，在页面渲染时，需要知道参数的名称，如图： 我们就需要把id和name一一对应起来，因此需要额外查询sku的特有规格参数，然后变成一个id:name的键值对格式。也就是一个Map，方便将来根据id查找！ Service代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384@Servicepublic class GoodsService &#123; @Autowired private GoodsClient goodsClient; @Autowired private BrandClient brandClient; @Autowired private CategoryClient categoryClient; @Autowired private SpecificationClient specificationClient; private static final Logger logger = LoggerFactory.getLogger(GoodsService.class); public Map&lt;String, Object&gt; loadModel(Long spuId)&#123; try &#123; // 查询spu Spu spu = this.goodsClient.querySpuById(spuId); // 查询spu详情 SpuDetail spuDetail = this.goodsClient.querySpuDetailById(spuId); // 查询sku List&lt;Sku&gt; skus = this.goodsClient.querySkuBySpuId(spuId); // 查询品牌 List&lt;Brand&gt; brands = this.brandClient.queryBrandByIds(Arrays.asList(spu.getBrandId())); // 查询分类 List&lt;Category&gt; categories = getCategories(spu); // 查询组内参数 List&lt;SpecGroup&gt; specGroups = this.specificationClient.querySpecsByCid(spu.getCid3()); // 查询所有特有规格参数 List&lt;SpecParam&gt; specParams = this.specificationClient.querySpecParam(null, spu.getCid3(), null, false); // 处理规格参数 Map&lt;Long, String&gt; paramMap = new HashMap&lt;&gt;(); specParams.forEach(param-&gt;&#123; paramMap.put(param.getId(), param.getName()); &#125;); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("spu", spu); map.put("spuDetail", spuDetail); map.put("skus", skus); map.put("brand", brands.get(0)); map.put("categories", categories); map.put("groups", specGroups); map.put("params", paramMap); return map; &#125; catch (Exception e) &#123; logger.error("加载商品数据出错,spuId:&#123;&#125;", spuId, e); &#125; return null; &#125; private List&lt;Category&gt; getCategories(Spu spu) &#123; try &#123; List&lt;String&gt; names = this.categoryClient.queryNameByIds( Arrays.asList(spu.getCid1(), spu.getCid2(), spu.getCid3())); Category c1 = new Category(); c1.setName(names.get(0)); c1.setId(spu.getCid1()); Category c2 = new Category(); c2.setName(names.get(1)); c2.setId(spu.getCid2()); Category c3 = new Category(); c3.setName(names.get(2)); c3.setId(spu.getCid3()); return Arrays.asList(c1, c2, c3); &#125; catch (Exception e) &#123; logger.error("查询商品分类出错，spuId：&#123;&#125;", spu.getId(), e); &#125; return null; &#125;&#125; 然后在controller中把数据放入model： 123456789101112131415161718192021@Controller@RequestMapping("item")public class GoodsController &#123; @Autowired private GoodsService goodsService; /** * 跳转到商品详情页 * @param model * @param id * @return */ @GetMapping("&#123;id&#125;.html") public String toItemPage(Model model, @PathVariable("id")Long id)&#123; // 加载所需的数据 Map&lt;String, Object&gt; modelMap = this.goodsService.loadModel(id); // 放入模型 model.addAllAttributes(modelMap); return "item"; &#125;&#125; 页面测试数据 我们在页面中先写一段JS，把模型中的数据取出观察，看是否成功： 123456789&lt;script th:inline="javascript"&gt; const a = /*[[$&#123;groups&#125;]]*/ []; const b = /*[[$&#123;params&#125;]]*/ []; const c = /*[[$&#123;categories&#125;]]*/ []; const d = /*[[$&#123;spu&#125;]]*/ &#123;&#125;; const e = /*[[$&#123;spuDetail&#125;]]*/ &#123;&#125;; const f = /*[[$&#123;skus&#125;]]*/ []; const g = /*[[$&#123;brand&#125;]]*/ &#123;&#125;;&lt;/script&gt; 然后查看页面源码： 数据都成功查到了！ 渲染面包屑 在商品展示页的顶部，有一个商品分类、品牌、标题的面包屑 其数据有3部分： 商品分类 商品品牌 spu标题 我们的模型中都有，所以直接渲染即可（页面101行开始）： 1234567891011&lt;div class="crumb-wrap"&gt; &lt;ul class="sui-breadcrumb"&gt; &lt;li th:each="category : $&#123;categories&#125;"&gt; &lt;a href="#" th:text="$&#123;category.name&#125;"&gt;手机&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#" th:text="$&#123;brand.name&#125;"&gt;Apple&lt;/a&gt; &lt;/li&gt; &lt;li class="active" th:text="$&#123;spu.title&#125;"&gt;Apple iPhone 6s&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 渲染商品列表 先看下整体效果： 这个部分需要渲染的数据有5块： sku图片 sku标题 副标题 sku价格 特有规格属性列表 其中，sku 的图片、标题、价格，都必须在用户选中一个具体sku后，才能渲染。而特有规格属性列表可以在spuDetail中查询到。而副标题则是在spu中，直接可以在页面渲染 因此，我们先对特有规格属性列表进行渲染。等用户选择一个sku，再通过js对其它sku属性渲染 副标题 副标题是在spu中，所以我们直接通过Thymeleaf渲染： 在第146行左右： 1&lt;div class="news"&gt;&lt;span th:utext="$&#123;spu.subTitle&#125;"&gt;&lt;/span&gt;&lt;/div&gt; 副标题中可能会有超链接，因此这里也用th:utext来展示，效果： 渲染规格属性列表 规格属性列表将来会有事件和动态效果。我们需要有js代码参与，不能使用Thymeleaf来渲染了。 因此，这里我们用vue，不过需要先把数据放到js对象中，方便vue使用 初始化数据 我们在页面的head中，定义一个js标签，然后在里面定义变量，保存与sku相关的一些数据： 12345678&lt;script th:inline="javascript"&gt; // sku集合 const skus = /*[[$&#123;skus&#125;]]*/ []; // 规格参数id与name对 const paramMap = /*[[$&#123;params&#125;]]*/ &#123;&#125;; // 特有规格参数集合 const specialSpec = JSON.parse(/*[[$&#123;spuDetail.specialSpec&#125;]]*/ "");&lt;/script&gt; specialSpec：这是SpuDetail中唯一与Sku相关的数据 因此我们并没有保存整个spuDetail，而是只保留了这个属性，而且需要手动转为js对象。 paramMap：规格参数的id和name对，方便页面根据id获取参数名 sku：特有规格参数集合 我们来看下页面获取的数据： 通过Vue渲染 我们把刚才获得的几个变量保存在Vue实例中： 然后在页面中渲染： 1234567891011121314&lt;div id="specification" class="summary-wrap clearfix"&gt; &lt;dl v-for="(v,k) in specialSpec" :key="k"&gt; &lt;dt&gt; &lt;div class="fl title"&gt; &lt;i&gt;&#123;&#123;paramMap[k]&#125;&#125;&lt;/i&gt; &lt;/div&gt; &lt;/dt&gt; &lt;dd v-for="(str,j) in v" :key="j"&gt; &lt;a href="javascript:;" class="selected"&gt; &#123;&#123;str&#125;&#125;&lt;span title="点击取消选择"&gt;&amp;nbsp;&lt;/span&gt; &lt;/a&gt; &lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt; 然后刷新页面查看： 数据成功渲染了。不过我们发现所有的规格都被勾选了。这是因为现在，每一个规格都有样式：selected，我们应该只选中一个，让它的class样式为selected才对！ 那么问题来了，我们该如何确定用户选择了哪一个？ 规格属性的筛选 分析 规格参数的格式是这样的： 每一个规格项是数组中的一个元素，因此我们只要保存被选择的规格项的索引，就能判断哪个是用户选择的了！ 我们需要一个对象来保存用户选择的索引，格式如下： 12345&#123; "4":0, "12":0, "13":0&#125; 但问题是，第一次进入页面时，用户并未选择任何参数。因此索引应该有一个默认值，我们将默认值设置为0。 我们在head的script标签中，对索引对象进行初始化： 然后在vue中保存： 页面改造 我们在页面中，通过判断indexes的值来判断当前规格是否被选中，并且给规格绑定点击事件，点击规格项后，修改indexes中的对应值： 1234567891011121314&lt;div id="specification" class="summary-wrap clearfix"&gt; &lt;dl v-for="(v,k) in specialSpec" :key="k"&gt; &lt;dt&gt; &lt;div class="fl title"&gt; &lt;i&gt;&#123;&#123;paramMap[k]&#125;&#125;&lt;/i&gt; &lt;/div&gt; &lt;/dt&gt; &lt;dd v-for="(str,j) in v" :key="j"&gt; &lt;a href="javascript:;" :class="&#123;selected: j===indexes[k]&#125;" @click="indexes[k]=j"&gt; &#123;&#123;str&#125;&#125;&lt;span v-if="j===indexes[k]" title="点击取消选择"&gt;&amp;nbsp;&lt;/span&gt; &lt;/a&gt; &lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt; 效果： 确定SKU 在我们设计sku数据的时候，就已经添加了一个字段：indexes： 这其实就是规格参数的索引组合。 而我们在页面中，用户点击选择规格后，就会把对应的索引保存起来： 因此，我们可以根据这个indexes来确定用户要选择的sku 我们在vue中定义一个计算属性，来计算与索引匹配的sku： 123456computed:&#123; sku()&#123; const index = Object.values(this.indexes).join("_"); return this.skus.find(s =&gt; s.indexes = index); &#125;&#125; 在浏览器工具中查看： 渲染sku列表 既然已经拿到了用户选中的sku，接下来，就可以在页面渲染数据了 图片列表 商品图片是一个字符串，以,分割，页面展示比较麻烦，所以我们编写一个计算属性:images()，将图片字符串变成数组： 123456789computed: &#123; sku()&#123; const index = Object.values(this.indexes).join("_"); return this.skus.find(s=&gt;s.indexes==index); &#125;, images()&#123; return this.sku.images ? this.sku.images.split(",") : ['']; &#125;&#125;, 页面改造： 123456789101112131415161718192021&lt;div class="zoom"&gt; &lt;!--默认第一个预览--&gt; &lt;div id="preview" class="spec-preview"&gt; &lt;span class="jqzoom"&gt; &lt;img :jqimg="images[0]" :src="images[0]" width="400px" height="400px"/&gt; &lt;/span&gt; &lt;/div&gt; &lt;!--下方的缩略图--&gt; &lt;div class="spec-scroll"&gt; &lt;a class="prev"&gt;&amp;lt;&lt;/a&gt; &lt;!--左右按钮--&gt; &lt;div class="items"&gt; &lt;ul&gt; &lt;li v-for="(image, i) in images" :key="i"&gt; &lt;img :src="image" :bimg="image" onmousemove="preview(this)" /&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;a class="next"&gt;&amp;gt;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 效果： 标题和价格 完整效果 商品详情 商品详情页面如下图所示： 分成上下两部分： 上部：展示的是规格属性列表 下部：展示的是商品详情 属性列表（作业） 这部分内容与规格参数部分重复，我就不带大家做了，大家可以自己完成 商品详情 商品详情是HTML代码，我们不能使用 th:text，应该使用th:utext 在页面的第444行左右： 123&lt;!--商品详情--&gt;&lt;div class="intro-detail" th:utext="$&#123;spuDetail.description&#125;"&gt;&lt;/div&gt; 最终展示效果： 规格包装： 规格包装分成两部分： 规格参数 包装列表 而且规格参数需要按照组来显示 规格参数 最终的效果： 我们模型中有一个groups，跟这个数据结果很像： 分成8个组，组内都有params，里面是所有的参数。不过，这些参数都没有值！ 规格参数的值分为两部分： 通用规格参数：保存在SpuDetail中的genericSpec中 特有规格参数：保存在sku的ownSpec中 我们需要把这两部分值取出来，放到groups中。 从spuDetail中取出genericSpec并取出groups： 把genericSpec引入到Vue实例： 因为sku是动态的，所以我们编写一个计算属性，来进行值的组合： 1234567891011121314groups()&#123; groups.forEach(group =&gt; &#123; group.params.forEach(param =&gt; &#123; if(param.generic)&#123; // 通用属性，去spu的genericSpec中获取 param.v = this.genericSpec[param.id] || '其它'; &#125;else&#123; // 特有属性值，去SKU中获取 param.v = JSON.parse(this.sku.ownSpec)[param.id] &#125; &#125;) &#125;) return groups;&#125; 然后在页面渲染： 12345678910&lt;div class="Ptable"&gt; &lt;div class="Ptable-item" v-for="group in groups" :key="group.name"&gt; &lt;h3&gt;&#123;&#123;group.name&#125;&#125;&lt;/h3&gt; &lt;dl&gt; &lt;div v-for="p in group.params"&gt; &lt;dt&gt;&#123;&#123;p.name&#125;&#125;&lt;/dt&gt;&lt;dd&gt;&#123;&#123;p.v + (p.unit || '')&#125;&#125;&lt;/dd&gt; &lt;/div&gt; &lt;/dl&gt; &lt;/div&gt;&lt;/div&gt; 包装列表 包装列表在商品详情中，我们一开始并没有赋值到Vue实例中，但是可以通过Thymeleaf来渲染 1234&lt;div class="package-list"&gt; &lt;h3&gt;包装清单&lt;/h3&gt; &lt;p th:text="$&#123;spuDetail.packingList&#125;"&gt;&lt;/p&gt;&lt;/div&gt; 最终效果： 售后服务 售后服务也可以通过Thymeleaf进行渲染： 1234&lt;div id="three" class="tab-pane"&gt; &lt;p&gt;售后保障&lt;/p&gt; &lt;p th:text="$&#123;spuDetail.afterService&#125;"&gt;&lt;/p&gt;&lt;/div&gt; 效果： 页面静态化 简介 问题分析 现在，我们的页面是通过Thymeleaf模板引擎渲染后返回到客户端。在后台需要大量的数据查询，而后渲染得到HTML页面。会对数据库造成压力，并且请求的响应时间过长，并发能力不高。 大家能想到什么办法来解决这个问题？ 首先我们能想到的就是缓存技术，比如之前学习过的Redis。不过Redis适合数据规模比较小的情况。假如数据量比较大，例如我们的商品详情页。每个页面如果10kb，100万商品，就是10GB空间，对内存占用比较大。此时就给缓存系统带来极大压力，如果缓存崩溃，接下来倒霉的就是数据库了。 所以缓存并不是万能的，某些场景需要其它技术来解决，比如静态化。 什么是静态化 静态化是指把动态生成的HTML页面变为静态内容保存，以后用户的请求到来，直接访问静态页面，不再经过服务的渲染。 而静态的HTML页面可以部署在nginx中，从而大大提高并发能力，减小tomcat压力。 如何实现静态化 目前，静态化页面都是通过模板引擎来生成，而后保存到nginx服务器来部署。常用的模板引擎比如： Freemarker Velocity Thymeleaf 我们之前就使用的Thymeleaf，来渲染html返回给用户。Thymeleaf除了可以把渲染结果写入Response，也可以写到本地文件，从而实现静态化。 Thymeleaf实现静态化 概念 先说下Thymeleaf中的几个概念： Context：运行上下文 TemplateResolver：模板解析器 TemplateEngine：模板引擎 Context 上下文： 用来保存模型数据，当模板引擎渲染时，可以从Context上下文中获取数据用于渲染。 当与SpringBoot结合使用时，我们放入Model的数据就会被处理到Context，作为模板渲染的数据使用。 TemplateResolver 模板解析器：用来读取模板相关的配置，例如：模板存放的位置信息，模板文件名称，模板文件的类型等等。 当与SpringBoot结合时，TemplateResolver已经由其创建完成，并且各种配置也都有默认值，比如模板存放位置，其默认值就是：templates。比如模板文件类型，其默认值就是html。 TemplateEngine 模板引擎：用来解析模板的引擎，需要使用到上下文、模板解析器。分别从两者中获取模板中需要的数据，模板文件。然后利用内置的语法规则解析，从而输出解析后的文件。来看下模板引擎进行处理的函数： 1templateEngine.process("模板名", context, writer); 三个参数： 模板名称 上下文：里面包含模型数据 writer：输出目的地的流 在输出时，我们可以指定输出的目的地，如果目的地是Response的流，那就是网络响应。如果目的地是本地文件，那就实现静态化了。 而在SpringBoot中已经自动配置了模板引擎，因此我们不需要关心这个。现在我们做静态化，就是把输出的目的地改成本地文件即可！ 具体实现 Service代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Servicepublic class GoodsHtmlService &#123; @Autowired private GoodsService goodsService; @Autowired private TemplateEngine templateEngine; private static final Logger LOGGER = LoggerFactory.getLogger(GoodsHtmlService.class); /** * 创建html页面 * * @param spuId * @throws Exception */ public void createHtml(Long spuId) &#123; PrintWriter writer = null; try &#123; // 获取页面数据 Map&lt;String, Object&gt; spuMap = this.goodsService.loadModel(spuId); // 创建thymeleaf上下文对象 Context context = new Context(); // 把数据放入上下文对象 context.setVariables(spuMap); // 创建输出流 File file = new File("C:\\project\\nginx-1.14.0\\html\\item\\" + spuId + ".html"); writer = new PrintWriter(file); // 执行页面静态化方法 templateEngine.process("item", context, writer); &#125; catch (Exception e) &#123; LOGGER.error("页面静态化出错：&#123;&#125;，"+ e, spuId); &#125; finally &#123; if (writer != null) &#123; writer.close(); &#125; &#125; &#125; /** * 新建线程处理页面静态化 * @param spuId */ public void asyncExcute(Long spuId) &#123; ThreadUtils.execute(()-&gt;createHtml(spuId)); /*ThreadUtils.execute(new Runnable() &#123; @Override public void run() &#123; createHtml(spuId); &#125; &#125;);*/ &#125;&#125; 线程工具类： 12345678public class ThreadUtils &#123; private static final ExecutorService es = Executors.newFixedThreadPool(10); public static void execute(Runnable runnable) &#123; es.submit(runnable); &#125;&#125; 什么时候创建静态文件 我们编写好了创建静态文件的service，那么问题来了：什么时候去调用它呢 想想这样的场景： 假如大部分的商品都有了静态页面。那么用户的请求都会被nginx拦截下来，根本不会到达我们的leyou-goods-web服务。只有那些还没有页面的请求，才可能会到达这里。 因此，如果请求到达了这里，我们除了返回页面视图外，还应该创建一个静态页面，那么下次就不会再来麻烦我们了。 所以，我们在GoodsController中添加逻辑，去生成静态html文件： 12345678910111213@GetMapping("&#123;id&#125;.html")public String toItemPage(@PathVariable("id")Long id, Model model)&#123; // 加载所需的数据 Map&lt;String, Object&gt; map = this.goodsService.loadModel(id); // 把数据放入数据模型 model.addAllAttributes(map); // 页面静态化 this.goodsHtmlService.asyncExcute(id); return "item";&#125; 注意：生成html 的代码不能对用户请求产生影响，所以这里我们使用额外的线程进行异步创建。 重启测试： 访问一个商品详情，然后查看nginx目录： nginx代理静态页面 接下来，我们修改nginx，让它对商品请求进行监听，指向本地静态页面，如果本地没找到，才进行反向代理： 1234567891011121314151617181920212223server &#123; listen 80; server_name www.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location /item &#123; # 先找本地 root html; if (!-f $request_filename) &#123; #请求的文件不存在，就反向代理 proxy_pass http://127.0.0.1:8084; break; &#125; &#125; location / &#123; proxy_pass http://127.0.0.1:9002; proxy_connect_timeout 600; proxy_read_timeout 600; &#125;&#125; 重启测试： 发现请求速度得到了极大提升：]]></content>
  </entry>
  <entry>
    <title><![CDATA[day13-搜索过滤]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F27%2Fday13-%E6%90%9C%E7%B4%A2%E8%BF%87%E6%BB%A4%2F</url>
    <content type="text"><![CDATA[学习目标 了解过滤功能的基本思路 独立实现分类和品牌展示 了解规格参数展示 实现过滤条件筛选 实现已选过滤项回显 实现取消选择过滤项 过滤功能分析 首先看下页面要实现的效果： 整个过滤部分有3块： 顶部的导航，已经选择的过滤条件展示： 商品分类面包屑，根据用户选择的商品分类变化 其它已选择过滤参数 过滤条件展示，又包含3部分 商品分类展示 品牌展示 其它规格参数 展开或收起的过滤条件的按钮 顶部导航要展示的内容跟用户选择的过滤条件有关。 比如用户选择了某个商品分类，则面包屑中才会展示具体的分类 比如用户选择了某个品牌，列表中才会有品牌信息。 所以，这部分需要依赖第二部分：过滤条件的展示和选择。因此我们先不着急去做。 展开或收起的按钮是否显示，取决于过滤条件有多少，如果很少，那么就没必要展示。所以也是跟第二部分的过滤条件有关。 这样分析来看，我们必须先做第二部分：过滤条件展示。 生成分类和品牌过滤 先来看分类和品牌。在我们的数据库中已经有所有的分类和品牌信息。在这个位置，是不是把所有的分类和品牌信息都展示出来呢？ 显然不是，用户搜索的条件会对商品进行过滤，而在搜索结果中，不一定包含所有的分类和品牌，直接展示出所有商品分类，让用户选择显然是不合适的。 无论是分类信息，还是品牌信息，都应该从搜索的结果商品中进行聚合得到。 扩展返回的结果 原来，我们返回的结果是PageResult对象，里面只有total、totalPage、items3个属性。但是现在要对商品分类和品牌进行聚合，数据显然不够用，我们需要对返回的结果进行扩展，添加分类和品牌的数据。 那么问题来了：以什么格式返回呢？ 看页面： 分类：页面显示了分类名称，但背后肯定要保存id信息。所以至少要有id和name 品牌：页面展示的有logo，有文字，当然肯定有id，基本上是品牌的完整数据 我们新建一个类，继承PageResult，然后扩展两个新的属性：分类集合和品牌集合： 123456789101112public class SearchResult extends PageResult&lt;Goods&gt;&#123; private List&lt;Category&gt; categories; private List&lt;Brand&gt; brands; public SearchResult(Long total, Integer totalPage, List&lt;Goods&gt; items, List&lt;Category&gt; categories, List&lt;Brand&gt; brands) &#123; super(total, totalPage, items); this.categories = categories; this.brands = brands; &#125;&#125; 聚合商品分类和品牌 我们修改搜索的业务逻辑，对分类和品牌聚合。 因为索引库中只有id，所以我们根据id聚合，然后再根据id去查询完整数据。 所以，商品微服务需要提供一个接口：根据品牌id集合，批量查询品牌。 提供查询品牌接口 BrandApi 123456@RequestMapping("brand")public interface BrandApi &#123; @GetMapping("list") List&lt;Brand&gt; queryBrandByIds(@RequestParam("ids") List&lt;Long&gt; ids);&#125; BrandController 12345678910111213/** * 根据多个id查询品牌 * @param ids * @return */@GetMapping("list")public ResponseEntity&lt;List&lt;Brand&gt;&gt; queryBrandByIds(@RequestParam("ids") List&lt;Long&gt; ids)&#123; List&lt;Brand&gt; list = this.brandService.queryBrandByIds(ids); if(list == null)&#123; new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(list);&#125; BrandService 123public List&lt;Brand&gt; queryBrandByIds(List&lt;Long&gt; ids) &#123; return this.brandMapper.selectByIdList(ids);&#125; BrandMapper 继承通用mapper的 SelectByIdListMapper即可 1public interface BrandMapper extends Mapper&lt;Brand&gt;, SelectByIdListMapper&lt;Brand,Long&gt; &#123;&#125; 搜索功能改造 添加BrandClient 123@FeignClient("item-service")public interface BrandClient extends BrandApi &#123;&#125; 修改SearchService： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116@Servicepublic class SearchService &#123; @Autowired private GoodsRepository goodsRepository; @Autowired private CategoryClient categoryClient; @Autowired private BrandClient brandClient; private static final Logger logger = LoggerFactory.getLogger(SearchService.class); public PageResult&lt;Goods&gt; search(SearchRequest request) &#123; // 判断是否有搜索条件，如果没有，直接返回null。不允许搜索全部商品 if (StringUtils.isBlank(request.getKey())) &#123; return null; &#125; // 1、构建查询条件 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 1.1、基本查询 queryBuilder.withQuery(QueryBuilders.matchQuery("all", request.getKey())); // 通过sourceFilter设置返回的结果字段,我们只需要id、skus、subTitle queryBuilder.withSourceFilter(new FetchSourceFilter( new String[]&#123;"id", "skus", "subTitle"&#125;, null)); // 1.2.分页排序 searchWithPageAndSort(queryBuilder,request); // 1.3、聚合 String categoryAggName = "category"; // 商品分类聚合名称 String brandAggName = "brand"; // 品牌聚合名称 // 对商品分类进行聚合 queryBuilder.addAggregation(AggregationBuilders.terms(categoryAggName).field("cid3")); // 对品牌进行聚合 queryBuilder.addAggregation(AggregationBuilders.terms(brandAggName).field("brandId")); // 2、查询，获取结果 AggregatedPage&lt;Goods&gt; pageInfo = (AggregatedPage&lt;Goods&gt;) this.goodsRepository.search(queryBuilder.build()); // 3、解析查询结果 // 3.1、分页信息 Long total = pageInfo.getTotalElements(); int totalPage = (total.intValue() + request.getSize() - 1) / request.getSize(); // 3.2、商品分类的聚合结果 List&lt;Category&gt; categories = getCategoryAggResult(pageInfo.getAggregation(categoryAggName)); // 3.3、品牌的聚合结果 List&lt;Brand&gt; brands = getBrandAggResult(pageInfo.getAggregation(brandAggName)); // 返回结果 return new SearchResult(goodsPage.getTotalElements(), goodsPage.getTotalPages(), goodsPage.getContent(), categories, brands); &#125; // 解析品牌聚合结果 private List&lt;Brand&gt; getBrandAggResult(Aggregation aggregation) &#123; try &#123; LongTerms brandAgg = (LongTerms) aggregation; List&lt;Long&gt; bids = new ArrayList&lt;&gt;(); for (LongTerms.Bucket bucket : brandAgg.getBuckets()) &#123; bids.add(bucket.getKeyAsNumber().longValue()); &#125; // 根据id查询品牌 return this.brandClient.queryBrandByIds(bids); &#125; catch (Exception e)&#123; logger.error("品牌聚合出现异常：", e); return null; &#125; &#125; // 解析商品分类聚合结果 private List&lt;Category&gt; getCategoryAggResult(Aggregation aggregation) &#123; try&#123; List&lt;Category&gt; categories = new ArrayList&lt;&gt;(); LongTerms categoryAgg = (LongTerms) aggregation; List&lt;Long&gt; cids = new ArrayList&lt;&gt;(); for (LongTerms.Bucket bucket : categoryAgg.getBuckets()) &#123; cids.add(bucket.getKeyAsNumber().longValue()); &#125; // 根据id查询分类名称 List&lt;String&gt; names = this.categoryClient.queryNameByIds(cids); for (int i = 0; i &lt; names.size(); i++) &#123; Category c = new Category(); c.setId(cids.get(i)); c.setName(names.get(i)); categories.add(c); &#125; return categories; &#125; catch (Exception e)&#123; logger.error("分类聚合出现异常：", e); return null; &#125; &#125; // 构建基本查询条件 private void searchWithPageAndSort(NativeSearchQueryBuilder queryBuilder, SearchRequest request) &#123; // 准备分页参数 int page = request.getPage(); int size = request.getSize(); // 1、分页 queryBuilder.withPageable(PageRequest.of(page - 1, size)); // 2、排序 String sortBy = request.getSortBy(); Boolean desc = request.getDescending(); if (StringUtils.isNotBlank(sortBy)) &#123; // 如果不为空，则进行排序 queryBuilder.withSort(SortBuilders.fieldSort(sortBy).order(desc ? SortOrder.DESC : SortOrder.ASC)); &#125; &#125;&#125; 测试： 页面渲染数据 过滤参数数据结构 来看下页面的展示效果： 虽然分类、品牌内容都不太一样，但是结构相似，都是key和value的结构。 而且页面结构也极为类似： 所以，我们可以把所有的过滤条件放入一个数组中，然后在页面利用v-for遍历一次生成。 其基本结构是这样的： 123456[ &#123; k:"过滤字段名", options:[&#123;/*过滤字段值对象*/&#125;,&#123;/*过滤字段值对象*/&#125;] &#125;] 我们先在data中定义数组：filter，等待组装过滤参数： 1234567891011data: &#123; ly, search:&#123; key: "", page: 1 &#125;, goodsList:[], // 接收搜索得到的结果 total: 0, // 总条数 totalPage: 0, // 总页数 filters:[] // 过滤参数集合&#125;, 然后在查询搜索结果的回调函数中，对过滤参数进行封装： 然后刷新页面，通过浏览器工具，查看封装的结果： 页面渲染数据 首先看页面原来的代码： 我们注意到，虽然页面元素是一样的，但是品牌会比其它搜索条件多出一些样式，因为品牌是以图片展示。需要进行特殊处理。数据展示是一致的，我们采用v-for处理： 123456789101112131415161718192021222324252627&lt;div class="type-wrap" v-for="(f,i) in filters" :key="i" v-if="f.k !== '品牌'"&gt; &lt;div class="fl key"&gt;&#123;&#123;f.k&#125;&#125;&lt;/div&gt; &lt;div class="fl value"&gt; &lt;ul class="type-list"&gt; &lt;li v-for="(option, j) in f.options" :key="j"&gt; &lt;a&gt;&#123;&#123;option.name&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="fl ext"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="type-wrap logo" v-else&gt; &lt;div class="fl key brand"&gt;&#123;&#123;f.k&#125;&#125;&lt;/div&gt; &lt;div class="value logos"&gt; &lt;ul class="logo-list"&gt; &lt;li v-for="(option, j) in f.options" v-if="option.image"&gt; &lt;img :src="option.image" /&gt; &lt;/li&gt; &lt;li style="text-align: center" v-else&gt; &lt;a style="line-height: 30px; font-size: 12px" href="#"&gt;&#123;&#123;option.name&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="fl ext"&gt; &lt;a href="javascript:void(0);" class="sui-btn"&gt;多选&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 结果： 生成规格参数过滤 谋而后动 有四个问题需要先思考清楚： 什么时候显示规格参数过滤？ 如何知道哪些规格需要过滤？ 要过滤的参数，其可选值是如何获取的？ 规格过滤的可选值，其数据格式怎样的？ 什么情况下显示有关规格参数的过滤？ 如果用户尚未选择商品分类，或者聚合得到的分类数大于1，那么就没必要进行规格参数的聚合。因为不同分类的商品，其规格是不同的。 因此，我们在后台需要对聚合得到的商品分类数量进行判断，如果等于1，我们才继续进行规格参数的聚合。 如何知道哪些规格需要过滤？ 我们不能把数据库中的所有规格参数都拿来过滤。因为并不是所有的规格参数都可以用来过滤，参数的值是不确定的。 值的庆幸的是，我们在设计规格参数时，已经标记了某些规格可搜索，某些不可搜索。 因此，一旦商品分类确定，我们就可以根据商品分类查询到其对应的规格，从而知道哪些规格要进行搜索。 要过滤的参数，其可选值是如何获取的？ 虽然数据库中有所有的规格参数，但是不能把一切数据都用来供用户选择。 与商品分类和品牌一样，应该是从用户搜索得到的结果中聚合，得到与结果品牌的规格参数可选值。 规格过滤的可选值，其数据格式怎样的？ 我们直接看页面效果： 我们之前存储时已经将数据分段，恰好符合这里的需求 实战 接下来，我们就用代码实现刚才的思路。 总结一下，应该是以下几步： 1）用户搜索得到商品，并聚合出商品分类 2）判断分类数量是否等于1，如果是则进行规格参数聚合 3）先根据分类，查找可以用来搜索的规格 4）对规格参数进行聚合 5）将规格参数聚合结果整理后返回 扩展返回结果 返回结果中需要增加新数据，用来保存规格参数过滤条件。这里与前面的品牌和分类过滤的json结构类似： 123456[ &#123; "k":"规格参数名", "options":["规格参数值","规格参数值"] &#125;] 因此，在java中我们用List&lt;Map&lt;String, String&gt;&gt;来表示。 1234567891011121314151617public class SearchResult extends PageResult&lt;Goods&gt;&#123; private List&lt;Category&gt; categories;// 分类过滤条件 private List&lt;Brand&gt; brands; // 品牌过滤条件 private List&lt;Map&lt;String,String&gt;&gt; specs; // 规格参数过滤条件 public SearchResult(Long total, Integer totalPage, List&lt;Goods&gt; items, List&lt;Category&gt; categories, List&lt;Brand&gt; brands, List&lt;Map&lt;String,String&gt;&gt; specs) &#123; super(total, totalPage, items); this.categories = categories; this.brands = brands; this.specs = specs; &#125;&#125; 判断是否需要聚合 首先，在聚合得到商品分类后，判断分类的个数，如果是1个则进行规格聚合： 我们将聚合的代码抽取到了一个getSpecs方法中。 获取需要聚合的规格参数 然后，我们需要根据商品分类，查询所有可用于搜索的规格参数： 要注意的是，这里我们需要根据id查询规格，而规格参数接口需要从商品微服务提供 聚合规格参数 因为规格参数保存时不做分词，因此其名称会自动带上一个.keyword后缀： 解析聚合结果 最终的完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171@Servicepublic class SearchService &#123; @Autowired private CategoryClient categoryClient; @Autowired private GoodsClient goodsClient; @Autowired private SpecificationClient specificationClient; @Autowired private GoodsRepository goodsRepository; @Autowired private BrandClient brandClient; @Autowired private ElasticsearchTemplate elasticsearchTemplate; private ObjectMapper mapper = new ObjectMapper(); private static final Logger logger = LoggerFactory.getLogger(SearchService.class); public SearchResult search(SearchRequest request) &#123; String key = request.getKey(); // 判断是否有搜索条件，如果没有，直接返回null。不允许搜索全部商品 if (StringUtils.isBlank(key)) &#123; return null; &#125; // 构建查询条件 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); MatchQueryBuilder basicQuery = QueryBuilders.matchQuery("all", key).operator(Operator.AND); queryBuilder.withQuery(basicQuery); // 通过sourceFilter设置返回的结果字段,我们只需要id、skus、subTitle queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;"id", "skus", "subTitle"&#125;, null)); // 分页 searchWithPageAndSort(queryBuilder, request); // 聚合 queryBuilder.addAggregation(AggregationBuilders.terms("brands").field("cid3")); queryBuilder.addAggregation(AggregationBuilders.terms("category").field("brandId")); // 执行查询获取结果集 AggregatedPage&lt;Goods&gt; goodsPage = (AggregatedPage&lt;Goods&gt;) this.goodsRepository.search(queryBuilder.build()); // 获取聚合结果集 // 商品分类的聚合结果 List&lt;Category&gt; categories = getCategoryAggResult(goodsPage.getAggregation("brands")); // 品牌的聚合结果 List&lt;Brand&gt; brands = getBrandAggResult(goodsPage.getAggregation("category")); // 根据商品分类判断是否需要聚合 List&lt;Map&lt;String, Object&gt;&gt; specs = new ArrayList&lt;&gt;(); if (categories.size() == 1) &#123; // 如果商品分类只有一个才进行聚合，并根据分类与基本查询条件聚合 specs = getSpec(categories.get(0).getId(), basicQuery); &#125; return new SearchResult(goodsPage.getTotalElements(), goodsPage.getTotalPages(), goodsPage.getContent(), categories, brands, specs); &#125; /** * 聚合出规格参数 * * @param cid * @param query * @return */ private List&lt;Map&lt;String, Object&gt;&gt; getSpec(Long cid, QueryBuilder query) &#123; try &#123; // 不管是全局参数还是sku参数，只要是搜索参数，都根据分类id查询出来 List&lt;SpecParam&gt; params = this.specificationClient.querySpecParam(null, cid, true, null); List&lt;Map&lt;String, Object&gt;&gt; specs = new ArrayList&lt;&gt;(); NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); queryBuilder.withQuery(query); // 聚合规格参数 params.forEach(p -&gt; &#123; String key = p.getName(); queryBuilder.addAggregation(AggregationBuilders.terms(key).field("specs." + key + ".keyword")); &#125;); // 查询 Map&lt;String, Aggregation&gt; aggs = this.elasticsearchTemplate.query(queryBuilder.build(), SearchResponse::getAggregations).asMap(); // 解析聚合结果 params.forEach(param -&gt; &#123; Map&lt;String, Object&gt; spec = new HashMap&lt;&gt;(); String key = param.getName(); spec.put("k", key); StringTerms terms = (StringTerms) aggs.get(key); spec.put("options", terms.getBuckets().stream().map(StringTerms.Bucket::getKeyAsString)); specs.add(spec); &#125;); return specs; &#125; catch ( Exception e) &#123; logger.error("规格聚合出现异常：", e); return null; &#125; &#125; // 构建基本查询条件 private void searchWithPageAndSort(NativeSearchQueryBuilder queryBuilder, SearchRequest request) &#123; // 准备分页参数 int page = request.getPage(); int size = request.getSize(); // 1、分页 queryBuilder.withPageable(PageRequest.of(page - 1, size)); // 2、排序 String sortBy = request.getSortBy(); Boolean desc = request.getDescending(); if (StringUtils.isNotBlank(sortBy)) &#123; // 如果不为空，则进行排序 queryBuilder.withSort(SortBuilders.fieldSort(sortBy).order(desc ? SortOrder.DESC : SortOrder.ASC)); &#125; &#125; // 解析品牌聚合结果 private List&lt;Brand&gt; getBrandAggResult(Aggregation aggregation) &#123; try &#123; LongTerms brandAgg = (LongTerms) aggregation; List&lt;Long&gt; bids = new ArrayList&lt;&gt;(); for (LongTerms.Bucket bucket : brandAgg.getBuckets()) &#123; bids.add(bucket.getKeyAsNumber().longValue()); &#125; // 根据id查询品牌 return this.brandClient.queryBrandByIds(bids); &#125; catch (Exception e) &#123; logger.error("品牌聚合出现异常：", e); return null; &#125; &#125; // 解析商品分类聚合结果 private List&lt;Category&gt; getCategoryAggResult(Aggregation aggregation) &#123; try &#123; List&lt;Category&gt; categories = new ArrayList&lt;&gt;(); LongTerms categoryAgg = (LongTerms) aggregation; List&lt;Long&gt; cids = new ArrayList&lt;&gt;(); for (LongTerms.Bucket bucket : categoryAgg.getBuckets()) &#123; cids.add(bucket.getKeyAsNumber().longValue()); &#125; // 根据id查询分类名称 List&lt;String&gt; names = this.categoryClient.queryNameByIds(cids); for (int i = 0; i &lt; names.size(); i++) &#123; Category c = new Category(); c.setId(cids.get(i)); c.setName(names.get(i)); categories.add(c); &#125; return categories; &#125; catch (Exception e) &#123; logger.error("分类聚合出现异常：", e); return null; &#125; &#125;&#125; 测试结果 页面渲染 渲染规格过滤条件 首先把后台传递过来的specs添加到filters数组： 要注意：分类、品牌的option选项是对象，里面有name属性，而specs中的option是简单的字符串，所以需要进行封装，变为相同的结构： 最后的结果： 展示或收起过滤条件 是不是感觉显示的太多了，我们可以通过按钮点击来展开和隐藏部分内容： 我们在data中定义变量，记录展开或隐藏的状态： 然后在按钮绑定点击事件，以改变show的取值： 在展示规格时，对show进行判断： OK！ 过滤条件的筛选 当我们点击页面的过滤项，要做哪些事情？ 把过滤条件保存在search对象中（watch监控到search变化后就会发送到后台） 在页面顶部展示已选择的过滤项 把商品分类展示到顶部面包屑 保存过滤项 定义属性 我们把已选择的过滤项保存在search中： 要注意，在created构造函数中会对search进行初始化，所以要在构造函数中对filter进行初始化： search.filter是一个对象，结构： 123&#123; "过滤项名":"过滤项值"&#125; 绑定点击事件 给所有的过滤项绑定点击事件： 要注意，点击事件传2个参数： k：过滤项的key option：当前过滤项对象 在点击事件中，保存过滤项到selectedFilter： 123456789selectFilter(k, o)&#123; const obj = &#123;&#125;; Object.assign(obj, this.search); if(k === '分类' || k === '品牌')&#123; o = o.id; &#125; obj.filter[k] = o.name; this.search = obj;&#125; 另外，这里search对象中嵌套了filter对象，请求参数格式化时需要进行特殊处理，修改common.js中的一段代码： 我们刷新页面，点击后通过浏览器功能查看search.filter的属性变化： 并且，此时浏览器地址也发生了变化： 1http://www.leyou.com/search.html?key=%E6%89%8B%E6%9C%BA&amp;page=1&amp;filter.%E5%93%81%E7%89%8C=2032&amp;filter.CPU%E5%93%81%E7%89%8C=%E6%B5%B7%E6%80%9D%EF%BC%88Hisilicon%EF%BC%89&amp;filter.CPU%E6%A0%B8%E6%95%B0=%E5%8D%81%E6%A0%B8 网络请求也正常发出： 后台添加过滤条件 既然请求已经发送到了后台，那接下来我们就在后台去添加这些条件： 拓展请求对象 我们需要在请求类：SearchRequest中添加属性，接收过滤属性。过滤属性都是键值对格式，但是key不确定，所以用一个map来接收即可。 添加过滤条件 目前，我们的基本查询是这样的： 现在，我们要把页面传递的过滤条件也进入进去。 因此不能在使用普通的查询，而是要用到BooleanQuery，基本结构是这样的： 1234567891011GET /heima/_search&#123; "query":&#123; "bool":&#123; "must":&#123; "match": &#123; "title": "小米手机",operator:"and"&#125;&#125;, "filter":&#123; "range":&#123;"price":&#123;"gt":2000.00,"lt":3800.00&#125;&#125; &#125; &#125; &#125;&#125; 所以，我们对原来的基本查询进行改造： 因为比较复杂，我们将其封装到一个方法中： 1234567891011121314151617181920212223// 构建基本查询条件private QueryBuilder buildBasicQueryWithFilter(SearchRequest request) &#123; BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery(); // 基本查询条件 queryBuilder.must(QueryBuilders.matchQuery("all", request.getKey()).operator(Operator.AND)); // 过滤条件构建器 BoolQueryBuilder filterQueryBuilder = QueryBuilders.boolQuery(); // 整理过滤条件 Map&lt;String, String&gt; filter = request.getFilter(); for (Map.Entry&lt;String, String&gt; entry : filter.entrySet()) &#123; String key = entry.getKey(); String value = entry.getValue(); // 商品分类和品牌要特殊处理 if (key != "cid3" &amp;&amp; key != "brandId") &#123; key = "specs." + key + ".keyword"; &#125; // 字符串类型，进行term查询 filterQueryBuilder.must(QueryBuilders.termQuery(key, value)); &#125; // 添加过滤条件 queryBuilder.filter(filterQueryBuilder); return queryBuilder;&#125; 其它不变。 页面测试 我们先不点击过滤条件，直接搜索手机： 总共184条 接下来，我们点击一个过滤条件： 得到的结果： 页面展示选择的过滤项(作业) 商品分类面包屑 当用户选择一个商品分类以后，我们应该在过滤模块的上方展示一个面包屑，把三级商品分类都显示出来。 用户选择的商品分类就存放在search.filter中，但是里面只有第三级分类的id：cid3 我们需要根据它查询出所有三级分类的id及名称 提供查询分类接口 我们在商品微服务中提供一个根据三级分类id查询1~3级分类集合的方法： Controller 12345678910111213/** * 根据3级分类id，查询1~3级的分类 * @param id * @return */@GetMapping("all/level")public ResponseEntity&lt;List&lt;Category&gt;&gt; queryAllByCid3(@RequestParam("id") Long id)&#123; List&lt;Category&gt; list = this.categoryService.queryAllByCid3(id); if (list == null || list.size() &lt; 1) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(list);&#125; Service 123456public List&lt;Category&gt; queryAllByCid3(Long id) &#123; Category c3 = this.categoryMapper.selectByPrimaryKey(id); Category c2 = this.categoryMapper.selectByPrimaryKey(c3.getParentId()); Category c1 = this.categoryMapper.selectByPrimaryKey(c2.getParentId()); return Arrays.asList(c1,c2,c3);&#125; 测试： 页面展示面包屑 后台提供了接口，下面的问题是，我们在哪里去查询接口？ 大家首先想到的肯定是当用户点击以后。 但是我们思考一下：用户点击以后，就会重新发起请求，页面刷新，那么你渲染的结果就没了。 因此，应该是在页面重新加载完毕后，此时因为过滤条件中加入了商品分类的条件，所以查询的结果中只有1个分类。 我们判断商品分类是否只有1个，如果是，则查询三级商品分类，添加到面包屑即可。 渲染： 刷新页面： 其它过滤项 接下来，我们需要在页面展示用户已选择的过滤项，如图： 我们知道，所有已选择过滤项都保存在search.filter中，因此在页面遍历并展示即可。 但这里有个问题，filter中数据的格式： 基本有四类数据： 商品分类：这个不需要展示，分类展示在面包屑位置 品牌：这个要展示，但是其key和值不合适，我们不能显示一个id在页面。需要找到其name值 数值类型规格：这个展示的时候，需要把单位查询出来 非数值类型规格：这个直接展示其值即可 因此，我们在页面上这样处理： 1234567&lt;!--已选择过滤项--&gt;&lt;ul class="tags-choose"&gt; &lt;li class="tag" v-for="(v,k) in search.filter" v-if="k !== 'cid3'" :key="k"&gt; &#123;&#123;k === 'brandId' ? '品牌' : k&#125;&#125;:&lt;span style="color: red"&gt;&#123;&#123;getFilterValue(k,v)&#125;&#125;&lt;/span&gt;&lt;/span&gt;&lt;i class="sui-icon icon-tb-close"&gt;&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt; 判断如果 k === &#39;cid3&#39;说明是商品分类，直接忽略 判断k === &#39;brandId&#39;说明是品牌，页面显示品牌，其它规格则直接显示k的值 值的处理比较复杂，我们用一个方法getFilterValue(k,v)来处理，调用时把k和v都传递 方法内部： 12345678910111213getFilterValue(k,v)&#123; // 如果没有过滤参数，我们跳过展示 if(!this.filters || this.filters.length === 0)&#123; return null; &#125; let filter = null; // 判断是否是品牌 if(k === 'brandId')&#123; // 返回品牌名称 return this.filters.find(f =&gt; f.k === 'brandId').options[0].name; &#125; return v;&#125; 然后刷新页面，即可看到效果： 隐藏已经选择的过滤项 现在，我们已经实现了已选择过滤项的展示，但是你会发现一个问题： 已经选择的过滤项，在过滤列表中依然存在： 这些已经选择的过滤项，应该从列表中移除。 怎么做呢？ 你必须先知道用户选择了什么。用户选择的项保存在search.filter中： 我们可以编写一个计算属性，把filters中的 已经被选择的key过滤掉： 123456789101112computed:&#123; remainFilters()&#123; const keys = Object.keys(this.search.filter); if(this.search.filter.cid3)&#123; keys.push("cid3") &#125; if(this.search.filter.brandId)&#123; keys.push("brandId") &#125; return this.filters.filter(f =&gt; !keys.includes(f.k)); &#125;&#125; 然后页面不再直接遍历filters，而是遍历remainFilters 刷新页面： 最后发现，还剩下一堆没选过的。但是都只有一个可选项，此时再过滤没有任何意义，应该隐藏，所以，在刚才的过滤条件中，还应该添加一条：如果只剩下一个可选项，不显示 取消过滤项（作业） 我们能够看到，每个过滤项后面都有一个小叉，当点击后，应该取消对应条件的过滤。 思路非常简单： 给小叉绑定点击事件 点击后把过滤项从search.filter中移除，页面会自动刷新，OK 绑定点击事件： 绑定点击事件时，把k传递过去，方便删除 删除过滤项 123removeFilter(k)&#123; this.search.filter[k] = null;&#125; 优化 搜索系统需要优化的点： 查询规格参数部分可以添加缓存 聚合计算interval变化频率极低，所以可以设计为定时任务计算（周期为天），然后缓存起来。 elasticsearch本身有查询缓存，可以不进行优化 商品图片应该采用缩略图，减少流量，提高页面加载速度 图片采用延迟加载 图片还可以采用CDN服务器 sku信息应该在页面异步加载，而不是放到索引库]]></content>
  </entry>
  <entry>
    <title><![CDATA[day12-elasticsearch2]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F27%2Fday12-elasticsearch2%2F</url>
    <content type="text"><![CDATA[学习目标 独立编写数据导入功能 独立实现基本搜索 独立实现页面分页 独立实现结果排序 索引库数据导入 昨天我们学习了Elasticsearch的基本应用。今天就学以致用，搭建搜索微服务，实现搜索功能。 创建搜索服务 创建module： Pom文件： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.search&lt;/groupId&gt; &lt;artifactId&gt;leyou-search&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- elasticsearch --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- feign --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml： 12345678910111213141516171819server: port: 8083spring: application: name: search-service data: elasticsearch: cluster-name: elasticsearch cluster-nodes: 192.168.56.101:9300eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 启动类： 123456789@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class LySearchService &#123; public static void main(String[] args) &#123; SpringApplication.run(LySearchService.class, args); &#125;&#125; 索引库数据格式分析 接下来，我们需要商品数据导入索引库，便于用户搜索。 那么问题来了，我们有SPU和SKU，到底如何保存到索引库？ 以结果为导向 大家来看下搜索结果页： 可以看到，每一个搜索结果都有至少1个商品，当我们选择大图下方的小图，商品会跟着变化。 因此，搜索的结果是SPU，即多个SKU的集合。 既然搜索的结果是SPU，那么我们索引库中存储的应该也是SPU，但是却需要包含SKU的信息。 需要什么数据 再来看看页面中有什么数据： 直观能看到的：图片、价格、标题、副标题 暗藏的数据：spu的id，sku的id 另外，页面还有过滤条件： 这些过滤条件也都需要存储到索引库中，包括： 商品分类、品牌、可用来搜索的规格参数等 综上所述，我们需要的数据格式有： spuId、SkuId、商品分类id、品牌id、图片、价格、商品的创建时间、sku信息集、可搜索的规格参数 最终的数据结构 我们创建一个类，封装要保存到索引库的数据，并设置映射属性： 123456789101112131415161718@Document(indexName = "goods", type = "docs", shards = 1, replicas = 0)public class Goods &#123; @Id private Long id; // spuId @Field(type = FieldType.Text, analyzer = "ik_max_word") private String all; // 所有需要被搜索的信息，包含标题，分类，甚至品牌 @Field(type = FieldType.Keyword, index = false) private String subTitle;// 卖点 private Long brandId;// 品牌id private Long cid1;// 1级分类id private Long cid2;// 2级分类id private Long cid3;// 3级分类id private Date createTime;// 创建时间 private List&lt;Long&gt; price;// 价格 @Field(type = FieldType.Keyword, index = false) private String skus;// sku信息的json结构 private Map&lt;String, Object&gt; specs;// 可搜索的规格参数，key是参数名，值是参数值&#125; 一些特殊字段解释： all：用来进行全文检索的字段，里面包含标题、商品分类信息 price：价格数组，是所有sku的价格集合。方便根据价格进行筛选过滤 skus：用于页面展示的sku信息，不索引，不搜索。包含skuId、image、price、title字段 specs：所有规格参数的集合。key是参数名，值是参数值。 例如：我们在specs中存储 内存：4G,6G，颜色为红色，转为json就是： 123456&#123; "specs":&#123; "内存":[4G,6G], "颜色":"红色" &#125;&#125; 当存储到索引库时，elasticsearch会处理为两个字段： specs.内存：[4G,6G] specs.颜色：红色 另外， 对于字符串类型，还会额外存储一个字段，这个字段不会分词，用作聚合。 specs.颜色.keyword：红色 商品微服务提供接口 索引库中的数据来自于数据库，我们不能直接去查询商品的数据库，因为真实开发中，每个微服务都是相互独立的，包括数据库也是一样。所以我们只能调用商品微服务提供的接口服务。 先思考我们需要的数据： SPU信息 SKU信息 SPU的详情 商品分类名称（拼接all字段） 再思考我们需要哪些服务： 第一：分批查询spu的服务，已经写过。 第二：根据spuId查询sku的服务，已经写过 第三：根据spuId查询SpuDetail的服务，已经写过 第四：根据商品分类id，查询商品分类名称，没写过 第五：根据商品品牌id，查询商品的品牌，没写过 因此我们需要额外提供一个查询商品分类名称的接口。 商品分类名称查询 controller： 12345678910111213/** * 根据商品分类id查询名称 * @param ids 要查询的分类id集合 * @return 多个名称的集合 */@GetMapping("names")public ResponseEntity&lt;List&lt;String&gt;&gt; queryNameByIds(@RequestParam("ids") List&lt;Long&gt; ids)&#123; List&lt;String &gt; list = this.categoryService.queryNameByIds(ids); if (list == null || list.size() &lt; 1) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(list);&#125; 测试： 编写FeignClient 问题展现 操作leyou-search工程 现在，我们要在搜索微服务调用商品微服务的接口。 第一步要引入商品微服务依赖：leyou-item-interface。 123456&lt;!--商品微服务--&gt;&lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-interface&lt;/artifactId&gt; &lt;version&gt;$&#123;leyou.latest.version&#125;&lt;/version&gt;&lt;/dependency&gt; 第二步，编写FeignClient 1234567891011121314151617181920212223242526272829303132333435@FeignClient(value = "item-service")@RequestMapping("/goods")public interface GoodsClient &#123; /** * 分页查询商品 * @param page * @param rows * @param saleable * @param key * @return */ @GetMapping("/spu/page") ResponseEntity&lt;PageResult&lt;SpuBo&gt;&gt; querySpuByPage( @RequestParam(value = "page", defaultValue = "1") Integer page, @RequestParam(value = "rows", defaultValue = "5") Integer rows, @RequestParam(value = "saleable", defaultValue = "true") Boolean saleable, @RequestParam(value = "key", required = false) String key); /** * 根据spu商品id查询详情 * @param id * @return */ @GetMapping("/spu/detail/&#123;id&#125;") ResponseEntity&lt;SpuDetail&gt; querySpuDetailById(@PathVariable("id") Long id); /** * 根据spu的id查询sku * @param id * @return */ @GetMapping("sku/list") ResponseEntity&lt;List&lt;Sku&gt;&gt; querySkuBySpuId(@RequestParam("id") Long id);&#125; 以上的这些代码直接从商品微服务中拷贝而来，完全一致。差别就是没有方法的具体实现。大家觉得这样有没有问题？ 而FeignClient代码遵循SpringMVC的风格，因此与商品微服务的Controller完全一致。这样就存在一定的问题： 代码冗余。尽管不用写实现，只是写接口，但服务调用方要写与服务controller一致的代码，有几个消费者就要写几次。 增加开发成本。调用方还得清楚知道接口的路径，才能编写正确的FeignClient。 解决方案 因此，一种比较友好的实践是这样的： 我们的服务提供方不仅提供实体类，还要提供api接口声明 调用方不用字自己编写接口方法声明，直接继承提供方给的Api接口即可， 第一步：服务的提供方在leyou-item-interface中提供API接口，并编写接口声明： 商品分类服务接口： 123456@RequestMapping("category")public interface CategoryApi &#123; @GetMapping("names") ResponseEntity&lt;List&lt;String&gt;&gt; queryNameByIds(@RequestParam("ids") List&lt;Long&gt; ids);&#125; 商品服务接口，返回值不再使用ResponseEntity： 12345678910111213141516171819202122232425262728293031323334@RequestMapping("/goods")public interface GoodsApi &#123; /** * 分页查询商品 * @param page * @param rows * @param saleable * @param key * @return */ @GetMapping("/spu/page") PageResult&lt;SpuBo&gt; querySpuByPage( @RequestParam(value = "page", defaultValue = "1") Integer page, @RequestParam(value = "rows", defaultValue = "5") Integer rows, @RequestParam(value = "saleable", defaultValue = "true") Boolean saleable, @RequestParam(value = "key", required = false) String key); /** * 根据spu商品id查询详情 * @param id * @return */ @GetMapping("/spu/detail/&#123;id&#125;") SpuDetail querySpuDetailById(@PathVariable("id") Long id); /** * 根据spu的id查询sku * @param id * @return */ @GetMapping("sku/list") List&lt;Sku&gt; querySkuBySpuId(@RequestParam("id") Long id);&#125; 需要引入springMVC及leyou-common的依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;leyou-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 第二步：在调用方leyou-search中编写FeignClient，但不要写方法声明了，直接继承leyou-item-interface提供的api接口： 商品的FeignClient： 123@FeignClient(value = "item-service")public interface GoodsClient extends GoodsApi &#123;&#125; 商品分类的FeignClient： 123@FeignClient(value = "item-service")public interface CategoryClient extends CategoryApi &#123;&#125; 是不是简单多了？ 项目结构： 测试 在leyou-search中引入springtest依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 创建测试类： 在接口上按快捷键：Ctrl + Shift + T 测试代码： 12345678910111213@RunWith(SpringRunner.class)@SpringBootTest(classes = LeyouSearchApplication.class)public class CategoryClientTest &#123; @Autowired private CategoryClient categoryClient; @Test public void testQueryCategories() &#123; List&lt;String&gt; names = this.categoryClient.queryNameByIds(Arrays.asList(1L, 2L, 3L)); names.forEach(System.out::println); &#125;&#125; 结果： 导入数据 导入数据只做一次,以后的更新删除等操作通过消息队列来操作索引库 创建GoodsRepository java代码： 12public interface GoodsRepository extends ElasticsearchRepository&lt;Goods, Long&gt; &#123;&#125; 创建索引 我们新建一个测试类，在里面进行数据的操作： 123456789101112131415161718@RunWith(SpringRunner.class)@SpringBootTest(classes = LeyouSearchApplication.class)public class ElasticsearchTest &#123; @Autowired private GoodsRepository goodsRepository; @Autowired private ElasticsearchTemplate elasticsearchTemplate; @Test public void createIndex()&#123; // 创建索引 this.elasticsearchTemplate.createIndex(Goods.class); // 配置映射 this.elasticsearchTemplate.putMapping(Goods.class); &#125;&#125; 通过kibana查看： 导入数据 导入数据其实就是查询数据，然后把查询到的Spu转变为Goods来保存，因此我们先编写一个SearchService，然后在里面定义一个方法， 把Spu转为Goods 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778@Servicepublic class SearchService &#123; @Autowired private CategoryClient categoryClient; @Autowired private GoodsClient goodsClient; @Autowired private SpecificationClient specificationClient; private ObjectMapper mapper = new ObjectMapper(); public Goods buildGoods(Spu spu) throws IOException &#123; Goods goods = new Goods(); // 查询商品分类名称 List&lt;String&gt; names = this.categoryClient.queryNameByIds(Arrays.asList(spu.getCid1(), spu.getCid2(), spu.getCid3())); // 查询sku List&lt;Sku&gt; skus = this.goodsClient.querySkuBySpuId(spu.getId()); // 查询详情 SpuDetail spuDetail = this.goodsClient.querySpuDetailById(spu.getId()); // 查询规格参数 List&lt;SpecParam&gt; params = this.specificationClient.querySpecParam(null, spu.getCid3(), true, null); // 处理sku，仅封装id、价格、标题、图片，并获得价格集合 List&lt;Long&gt; prices = new ArrayList&lt;&gt;(); List&lt;Map&lt;String, Object&gt;&gt; skuList = new ArrayList&lt;&gt;(); skus.forEach(sku -&gt; &#123; prices.add(sku.getPrice()); Map&lt;String, Object&gt; skuMap = new HashMap&lt;&gt;(); skuMap.put("id", sku.getId()); skuMap.put("title", sku.getTitle()); skuMap.put("price", sku.getPrice()); skuMap.put("image", StringUtils.isBlank(sku.getImages()) ? "" : StringUtils.split(sku.getImages(), ",")[0]); skuList.add(skuMap); &#125;); // 处理规格参数 Map&lt;String, Object&gt; genericSpecs = mapper.readValue(spuDetail.getGenericSpec(), new TypeReference&lt;Map&lt;String, Object&gt;&gt;() &#123; &#125;); Map&lt;String, Object&gt; specialSpecs = mapper.readValue(spuDetail.getSpecialSpec(), new TypeReference&lt;Map&lt;String, Object&gt;&gt;() &#123; &#125;); // 获取可搜索的规格参数 Map&lt;String, Object&gt; searchSpec = new HashMap&lt;&gt;(); // 过滤规格模板，把所有可搜索的信息保存到Map中 Map&lt;String, Object&gt; specMap = new HashMap&lt;&gt;(); params.forEach(p -&gt; &#123; if (p.getSearching()) &#123; if (p.getGeneric()) &#123; String value = genericSpecs.get(p.getId().toString()).toString(); if(p.getNumeric())&#123; value = chooseSegment(value, p); &#125; specMap.put(p.getName(), StringUtils.isBlank(value) ? "其它" : value); &#125; else &#123; specMap.put(p.getName(), specialSpecs.get(p.getId().toString())); &#125; &#125; &#125;); goods.setId(spu.getId()); goods.setSubTitle(spu.getSubTitle()); goods.setBrandId(spu.getBrandId()); goods.setCid1(spu.getCid1()); goods.setCid2(spu.getCid2()); goods.setCid3(spu.getCid3()); goods.setCreateTime(spu.getCreateTime()); goods.setAll(spu.getTitle() + " " + StringUtils.join(names, " ")); goods.setPrice(prices); goods.setSkus(mapper.writeValueAsString(skuList)); goods.setSpecs(specMap); return goods; &#125; &#125; 因为过滤参数中有一类比较特殊，就是数值区间： 所以我们在存入时要进行处理： 1234567891011121314151617181920212223242526private String chooseSegment(String value, SpecParam p) &#123; double val = NumberUtils.toDouble(value); String result = "其它"; // 保存数值段 for (String segment : p.getSegments().split(",")) &#123; String[] segs = segment.split("-"); // 获取数值范围 double begin = NumberUtils.toDouble(segs[0]); double end = Double.MAX_VALUE; if(segs.length == 2)&#123; end = NumberUtils.toDouble(segs[1]); &#125; // 判断是否在范围内 if(val &gt;= begin &amp;&amp; val &lt; end)&#123; if(segs.length == 1)&#123; result = segs[0] + p.getUnit() + "以上"; &#125;else if(begin == 0)&#123; result = segs[1] + p.getUnit() + "以下"; &#125;else&#123; result = segment + p.getUnit(); &#125; break; &#125; &#125; return result;&#125; 然后编写一个测试类，循环查询Spu，然后调用IndexService中的方法，把SPU变为Goods，然后写入索引库： 123456789101112131415161718192021222324252627282930@Testpublic void loadData()&#123; // 创建索引 this.elasticsearchTemplate.createIndex(Goods.class); // 配置映射 this.elasticsearchTemplate.putMapping(Goods.class); int page = 1; int rows = 100; int size = 0; do &#123; // 查询分页数据 PageResult&lt;SpuBo&gt; result = this.goodsClient.querySpuByPage(page, rows, true, null); List&lt;SpuBo&gt; spus = result.getItems(); size = spus.size(); // 创建Goods集合 List&lt;Goods&gt; goodsList = new ArrayList&lt;&gt;(); // 遍历spu for (SpuBo spu : spus) &#123; try &#123; Goods goods = this.searchService.buildGoods(spu); goodsList.add(goods); &#125; catch (Exception e) &#123; break; &#125; &#125; this.goodsRepository.saveAll(goodsList); page++; &#125; while (size == 100);&#125; 通过kibana查询， 可以看到数据成功导入： 实现基本搜索 页面分析 页面跳转 在首页的顶部，有一个输入框： 当我们输入任何文本，点击搜索，就会跳转到搜索页search.html了： 并且将搜索关键字以请求参数携带过来： 我们打开search.html，在最下面会有提前定义好的Vue实例： 1234567891011&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: "#searchApp", data: &#123; &#125;, components:&#123; // 加载页面顶部组件 lyTop: () =&gt; import("./js/pages/top.js") &#125; &#125;);&lt;/script&gt; 这个Vue实例中，通过import导入的方式，加载了另外一个js：top.js并作为一个局部组件。top其实是页面顶部导航组件，我们暂时不管 发起异步请求 要想在页面加载后，就展示出搜索结果。我们应该在页面加载时，获取地址栏请求参数，并发起异步请求，查询后台数据，然后在页面渲染。 我们在data中定义一个对象，记录请求的参数： 12345data: &#123; search:&#123; key:"", // 搜索页面的关键字 &#125;&#125; 我们通过钩子函数created，在页面加载时获取请求参数，并记录下来。 12345678910111213created()&#123; // 判断是否有请求参数 if(!location.search)&#123; return; &#125; // 将请求参数转为对象 const search = ly.parse(location.search.substring(1)); // 记录在data的search对象中 this.search = search; // 发起请求，根据条件搜索 this.loadData();&#125; 然后发起请求，搜索数据。 12345678methods: &#123; loadData()&#123; // ly.http.post("/search/page", ly.stringify(this.search)).then(resp=&gt;&#123; ly.http.post("/search/page", this.search).then(resp=&gt;&#123; console.log(resp); &#125;); &#125;&#125; 我们这里使用ly是common.js中定义的工具对象。 这里使用的是post请求，这样可以携带更多参数，并且以json格式发送 在leyou-gateway中，添加允许信任域名： 并添加网关映射： 刷新页面试试： 因为后台没有提供接口，所以无法访问。没关系，接下来我们实现后台接口 后台提供搜索接口 controller 首先分析几个问题： 请求方式：Post 请求路径：/search/page，不过前面的/search应该是网关的映射路径，因此真实映射路径page，代表分页查询 请求参数：json格式，目前只有一个属性：key-搜索关键字，但是搜索结果页一定是带有分页查询的，所以将来肯定会有page属性，因此我们可以用一个对象来接收请求的json数据： 1234567891011121314151617181920212223242526272829303132public class SearchRequest &#123; private String key;// 搜索条件 private Integer page;// 当前页 private static final Integer DEFAULT_SIZE = 20;// 每页大小，不从页面接收，而是固定大小 private static final Integer DEFAULT_PAGE = 1;// 默认页 public String getKey() &#123; return key; &#125; public void setKey(String key) &#123; this.key = key; &#125; public Integer getPage() &#123; if(page == null)&#123; return DEFAULT_PAGE; &#125; // 获取页码时做一些校验，不能小于1 return Math.max(DEFAULT_PAGE, page); &#125; public void setPage(Integer page) &#123; this.page = page; &#125; public Integer getSize() &#123; return DEFAULT_SIZE; &#125;&#125; 返回结果：作为分页结果，一般都两个属性：当前页数据、总条数信息，我们可以使用之前定义的PageResult类 代码： 12345678910111213141516171819202122@RestController@RequestMappingpublic class SearchController &#123; @Autowired private SearchService searchService; /** * 搜索商品 * * @param request * @return */ @PostMapping("page") public ResponseEntity&lt;PageResult&lt;Goods&gt;&gt; search(@RequestBody SearchRequest request) &#123; PageResult&lt;Goods&gt; result = this.searchService.search(request); if (result == null) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(result); &#125;&#125; service 123456789101112131415161718192021222324252627282930313233343536@Servicepublic class SearchService &#123; @Autowired private GoodsRepository goodsRepository; public PageResult&lt;Goods&gt; search(SearchRequest request) &#123; String key = request.getKey(); // 判断是否有搜索条件，如果没有，直接返回null。不允许搜索全部商品 if (StringUtils.isBlank(key)) &#123; return null; &#125; // 构建查询条件 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 1、对key进行全文检索查询 queryBuilder.withQuery(QueryBuilders.matchQuery("all", key).operator(Operator.AND)); // 2、通过sourceFilter设置返回的结果字段,我们只需要id、skus、subTitle queryBuilder.withSourceFilter(new FetchSourceFilter( new String[]&#123;"id","skus","subTitle"&#125;, null)); // 3、分页 // 准备分页参数 int page = request.getPage(); int size = request.getSize(); queryBuilder.withPageable(PageRequest.of(page - 1, size)); // 4、查询，获取结果 Page&lt;Goods&gt; pageInfo = this.goodsRepository.search(queryBuilder.build()); // 封装结果并返回 return new PageResult&lt;&gt;(goodsPage.getTotalElements(), goodsPage.getTotalPages(), goodsPage.getContent()); &#125;&#125; 注意点：我们要设置SourceFilter，来选择要返回的结果，否则返回一堆没用的数据，影响查询效率。 测试 刷新页面测试： 数据是查到了，但是因为我们只查询部分字段，所以结果json 数据中有很多null，这很不优雅。 解决办法很简单，在leyou-search的application.yml中添加一行配置，json处理时忽略空值： 123spring: jackson: default-property-inclusion: non_null # 配置json处理时忽略空值 结果： 页面渲染 页面已经拿到了结果，接下来就要渲染样式了。 保存搜索结果 首先，在data中定义属性，保存搜索的结果： 在loadData的异步查询中，将结果赋值给goodsList： 循环展示商品 在search.html的中部，有一个div，用来展示所有搜索到的商品： 可以看到，div中有一个无序列表ul，内部的每一个li就是一个商品spu了。 我们删除多余的，只保留一个li，然后利用vue的循环来展示搜索到的结果： 多sku展示 分析 接下来展示具体的商品信息，来看图： 这里我们可以发现，一个商品位置，是多个sku的信息集合。当用户鼠标选择某个sku，对应的图片、价格、标题会随之改变！ 我们先来实现sku的选择，才能去展示不同sku的数据。 可以看到，在列表中默认第一个是被选中的，那我们就需要做两件事情： 在搜索到数据时，先默认把第一个sku作为被选中的，记录下来 记录当前被选中的是哪一个sku，记录在哪里比较合适呢？显然是遍历到的goods对象自己内部，因为每一个goods都会有自己的sku信息。 初始化sku 查询出的结果集skus是一个json类型的字符串，不是js对象 我们在查询成功的回调函数中，对goods进行遍历，把skus转化成对象，并添加一个selected属性保存被选中的sku： 多sku图片列表 接下来，我们看看多个sku的图片列表位置： 看到又是一个无序列表，这里我们也一样删掉多余的，保留一个li，需要注意选中的项有一个样式类：selected 我们的代码： 1234567&lt;!--多sku图片列表--&gt;&lt;ul class=&quot;skus&quot;&gt; &lt;li :class=&quot;&#123;selected: sku.id == goods.selected.id&#125;&quot; v-for=&quot;sku in goods.skus&quot; :key=&quot;sku.id&quot; @mouseEnter=&quot;goods.selected=sku&quot;&gt; &lt;img :src=&quot;sku.image&quot;&gt; &lt;/li&gt;&lt;/ul&gt; 注意： class样式通过 goods.selected的id是否与当前sku的id一致来判断 绑定了鼠标事件，鼠标进入后把当前sku赋值到goods.selected 展示sku其它属性 现在，我们已经可以通过goods.selected获取用户选中的sku，那么我们就可以在页面展示了： 刷新页面： 看起来很完美是吧！ 但其实有一些瑕疵 几个问题 价格显示的是分 首先价格显示就不正确，我们数据库中存放的是以分为单位，所以这里要格式化。 好在我们之前common.js中定义了工具类，可以帮我们转换。 改造： 结果报错： 为啥？ 因为在Vue范围内使用任何变量，都会默认去Vue实例中寻找，我们使用ly，但是Vue实例中没有这个变量。所以解决办法就是把ly记录到Vue实例： 然后刷新页面： 标题过长 标题内容太长了，已经无法完全显示，怎么办？ 截取一下： 最好在加个悬停展示所有内容的效果 sku点击不切换 还有一个错误比较隐蔽，不容易被发现。我们点击sku 的图片列表，发现没有任何变化。 这不科学啊，为什么？ 通过控制台观察，发现数据其实是变化了，但是Vue却没有重新渲染视图。 这是因为Vue的自动渲染是基于对象的属性变化的。比如页面使用GoodsList进行渲染，如果GoodsList变化，或者其内部的任何子对象变化，都会Vue感知，从而从新渲染页面。 然而，这一切有一个前提，那就是当你第一次渲染时，对象中有哪些属性，Vue就只监视这些属性，后来添加的属性发生改变，是不会被监视到的。 而我们的goods对象中，本身是没有selected属性的，是我们后来才添加进去的： 这段代码稍微改造一下，即可： 也就是说，我们先把selected属性初始化完毕，然后才把整个对象赋值给goodsList，这样，goodsList已初始化时就有selected属性，以后就会被正常监控了。 页面分页效果 刚才的查询中，我们默认了查询的页码和每页大小，因此所有的分页功能都无法使用，接下来我们一起看看分页功能条该如何制作。 这里要分两步， 第一步：如何生成分页条 第二步：点击分页按钮，我们做什么 如何生成分页条 先看下页面关于分页部分的代码： 可以看到所有的分页栏内容都是写死的。 需要的数据 分页数据应该是根据总页数、当前页、总条数等信息来计算得出。 当前页：肯定是由页面来决定的，点击按钮会切换到对应的页 总页数：需要后台传递给我们 总条数：需要后台传递给我们 我们首先在data中记录下这几个值：page-当前页，total-总条数，totalPage-总页数 12345678910data: &#123; ly, search:&#123; key: "", page: 1 &#125;, goodsList:[], // 接收搜索得到的结果 total: 0, // 总条数 totalPage: 0 // 总页数&#125; 因为page是搜索条件之一，所以记录在search对象中。 要注意：我们在created钩子函数中，会读取url路径的参数，然后赋值给search。如果是第一次请求页面，page是不存在的。因此为了避免page被覆盖，我们应该这么做： 不过，这个时候我们自己的search对象中的值就可有可无了 后台提供数据 后台返回的结果中，要包含total和totalPage，我们改造下刚才的接口： 在我们返回的PageResult对象中，其实是有totalPage字段的： 我们在返回时，把这个值填上： 页面测试一下： OK 页面计算分页条 首先，把后台提供的数据保存在data中： 然后看下我们要实现的效果： 这里最复杂的是中间的1~5的分页按钮，它需要动态变化。 思路分析： 最多有5个按钮，因此我们可以用v-for循环从1到5即可 但是分页条不一定是从1开始： 如果当前页值小于等于3的时候，分页条位置从1开始到5结束 如果总页数小于等于5的时候，分页条位置从1开始到5结束 如果当前页码大于3，应该从page-3开始 但是如果当前页码大于totalPage-3，应该从totalPage-5开始 所以，我们的页面这样来做： a标签中的分页数字通过index函数来计算，需要把i传递过去： 1234567891011index(i)&#123; if(this.search.page &lt;= 3 || this.totalPage &lt;= 5)&#123; // 如果当前页小于等于3或者总页数小于等于5 return i; &#125; else if(this.search.page &gt; 3) &#123; // 如果当前页大于3 return this.search.page - 3 + i; &#125; else &#123; return this.totalPage - 5 + i; &#125;&#125; 需要注意的是，如果总页数不足5页，我们就不应该遍历15，而是1总页数，稍作改进： 分页条的其它部分就比较简单了： 12345678910111213141516171819202122&lt;div class=&quot;sui-pagination pagination-large&quot;&gt; &lt;ul style=&quot;width: 550px&quot;&gt; &lt;li :class=&quot;&#123;prev:true,disabled:search.page === 1&#125;&quot;&gt; &lt;a href=&quot;#&quot;&gt;«上一页&lt;/a&gt; &lt;/li&gt; &lt;li :class=&quot;&#123;active: index(i) === search.page&#125;&quot; v-for=&quot;i in Math.min(5,totalPage)&quot; :key=&quot;i&quot;&gt; &lt;a href=&quot;#&quot;&gt;&#123;&#123;index(i)&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;dotted&quot; v-show=&quot;totalPage &gt; 5&quot;&gt;&lt;span&gt;...&lt;/span&gt;&lt;/li&gt; &lt;li :class=&quot;&#123;next:true,disabled:search.page === totalPage&#125;&quot;&gt; &lt;a href=&quot;#&quot;&gt;下一页»&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;span&gt;共&#123;&#123;totalPage&#125;&#125;页&amp;nbsp;&lt;/span&gt; &lt;span&gt; 到第 &lt;input type=&quot;text&quot; class=&quot;page-num&quot; :value=&quot;search.page&quot;&gt; 页 &lt;button class=&quot;page-confirm&quot; onclick=&quot;alert(1)&quot;&gt;确定&lt;/button&gt; &lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 点击分页做什么 点击分页按钮后，自然是要修改page的值 所以，我们在上一页、下一页按钮添加点击事件，对page进行修改，在数字按钮上绑定点击事件，点击直接修改page： 12345678910prevPage()&#123; if(this.search.page &gt; 1)&#123; this.search.page-- &#125;&#125;,nextPage()&#123; if(this.search.page &lt; this.totalPage)&#123; this.search.page++ &#125;&#125; 当page发生变化，我们应该去后台重新查询数据。 不过，如果我们直接发起ajax请求，那么浏览器的地址栏中是不会有变化的，没有记录下分页信息。如果用户刷新页面，那么就会回到第一页。 这样不太友好，我们应该把搜索条件记录在地址栏的查询参数中。 因此，我们监听search的变化，然后把search的过滤字段拼接在url路径后： 123456789watch:&#123; search:&#123; deep:true, handler(val)&#123; // 把search对象变成请求参数，拼接在url路径 window.location.href = "http://www.leyou.com/search.html?" + ly.stringify(val); &#125; &#125;&#125;, 刷新页面测试，然后就出现重大bug：页面无限刷新！为什么？ 因为Vue实例初始化的钩子函数中，我们读取请求参数，赋值给search的时候，也触发了watch监视！也就是说，每次页面创建完成，都会触发watch，然后就会去修改window.location路径，然后页面被刷新，再次触发created钩子，又触发watch，周而复始，无限循环。 所以，我们需要在watch中进行监控，如果发现是第一次初始化，则不继续向下执行。 那么问题是，如何判断是不是第一次？ 第一次初始化时，search中的key值肯定是空的，所以，我们这么做： 12345678910111213watch:&#123; search:&#123; deep:true, handler(val,old)&#123; if(!old || !old.key)&#123; // 如果旧的search值为空，或者search中的key为空，证明是第一次 return; &#125; // 把search对象变成请求参数，拼接在url路径 window.location.href = "http://www.leyou.com/search.html?" + ly.stringify(val); &#125; &#125;&#125; 再次刷新，OK了！ 页面顶部分页条 在页面商品列表的顶部，也有一个分页条： 我们把这一部分，也加上点击事件： 排序(作业) 页面搜索排序条件 在搜索商品列表的顶部，有这么一部分内容： 这是用来做排序的，默认按照综合排序。点击新品，应该按照商品创建时间排序，点击价格应该按照价格排序。因为我们没有统计销量和评价，这里咱们以新品和价格为例，进行讲解，做法是想通的。 排序需要知道两个内容： 排序的字段 排序的方式 因此，我们首先在search中记录这两个信息，因为created钩子函数会对search进行覆盖，因此我们在钩子函数中对这两个信息进行初始化即可： 然后，在页面上给按钮绑定点击事件，修改sortBy和descending的值： 1234567891011121314151617181920212223&lt;!--排序字段--&gt;&lt;ul class=&quot;sui-nav&quot;&gt; &lt;li :class=&quot;&#123;active:!search.sortBy&#125;&quot; @click=&quot;search.sortBy=&apos;&apos;&quot;&gt; &lt;a href=&quot;#&quot;&gt;综合&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;销量&lt;/a&gt; &lt;/li&gt; &lt;li @click=&quot;search.sortBy=&apos;createTime&apos;&quot; :class=&quot;&#123;active: search.sortBy===&apos;createTime&apos;&#125;&quot;&gt; &lt;a href=&quot;#&quot;&gt;新品&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;评价&lt;/a&gt; &lt;/li&gt; &lt;li @click=&quot;search.sortBy=&apos;price&apos;; search.descending = !search.descending&quot; :class=&quot;&#123;active: search.sortBy===&apos;price&apos;&#125;&quot;&gt; &lt;a href=&quot;#&quot;&gt; 价格 &lt;v-icon v-show=&quot;search.descending&quot;&gt;arrow_drop_down&lt;/v-icon&gt; &lt;v-icon v-show=&quot;!search.descending&quot;&gt;arrow_drop_up&lt;/v-icon&gt; &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 可以看到，页面请求参数中已经有了排序字段了： 后台添加排序逻辑 接下来，后台需要接收请求参数中的排序信息，然后在搜索中加入排序的逻辑。 现在，我们的请求参数对象SearchRequest中，只有page、key两个字段。需要进行扩展： 然后在搜索业务逻辑中，添加排序条件： 注意，因为我们存储在索引库中的的价格是一个数组，因此在按照价格排序时，会进行智能处理： 如果是价格降序，则会把数组中的最大值拿来排序 如果是价格升序，则会把数组中的最小值拿来排序]]></content>
  </entry>
  <entry>
    <title><![CDATA[day11-elasticsearch]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F27%2Fday11-elasticsearch%2F</url>
    <content type="text"><![CDATA[学习目标 独立安装Elasticsearch 会使用Rest的API操作索引 会使用Rest的API查询数据 会使用Rest的API聚合数据 掌握Spring Data Elasticsearch使用 Elasticsearch介绍和安装 用户访问我们的首页，一般都会直接搜索来寻找自己想要购买的商品。 而商品的数量非常多，而且分类繁杂。如果能正确的显示出用户想要的商品，并进行合理的过滤，尽快促成交易，是搜索系统要研究的核心。 面对这样复杂的搜索业务和数据量，使用传统数据库搜索就显得力不从心，一般我们都会使用全文检索技术，比如之前大家学习过的Solr。 不过今天，我们要讲的是另一个全文检索技术：Elasticsearch。 简介 Elastic Elastic官网：https://www.elastic.co/cn/ Elastic有一条完整的产品线及解决方案：Elasticsearch、Kibana、Logstash等，前面说的三个就是大家常说的ELK技术栈。 Elasticsearch Elasticsearch官网：https://www.elastic.co/cn/products/elasticsearch 如上所述，Elasticsearch具备以下特点： 分布式，无需人工搭建集群（solr就需要人为配置，使用Zookeeper作为注册中心） Restful风格，一切API都遵循Rest原则，容易上手 近实时搜索，数据更新在Elasticsearch中几乎是完全同步的。 版本 目前Elasticsearch最新的版本是6.3.1，我们就使用6.3.0 需要虚拟机JDK1.8及以上 安装和配置 为了模拟真实场景，我们将在linux下安装Elasticsearch。 新建一个用户leyou 出于安全考虑，elasticsearch默认不允许以root账号运行。 创建用户： 1useradd leyou 设置密码： 1passwd leyou 切换用户： 1su - leyou 上传安装包,并解压 我们将安装包上传到：/home/leyou目录 解压缩： 1tar -zxvf elasticsearch-6.2.4.tar.gz 我们把目录重命名： 1mv elasticsearch-6.2.4/ elasticsearch 进入，查看目录结构： 修改配置 我们进入config目录：cd config 需要修改的配置文件有两个： jvm.options Elasticsearch基于Lucene的，而Lucene底层是java实现，因此我们需要配置jvm参数。 编辑jvm.options： 1vim jvm.options 默认配置如下： 12-Xms1g-Xmx1g 内存占用太多了，我们调小一些： 12-Xms512m-Xmx512m elasticsearch.yml 1vim elasticsearch.yml 修改数据和日志目录： 12path.data: /home/leyou/elasticsearch/data # 数据目录位置path.logs: /home/leyou/elasticsearch/logs # 日志目录位置 我们把data和logs目录修改指向了elasticsearch的安装目录。但是这两个目录并不存在，因此我们需要创建出来。 进入elasticsearch的根目录，然后创建： 12mkdir datamkdir logs 修改绑定的ip： 1network.host: 0.0.0.0 # 绑定到0.0.0.0，允许任何ip来访问 默认只允许本机访问，修改为0.0.0.0后则可以远程访问 目前我们是做的单机安装，如果要做集群，只需要在这个配置文件中添加其它节点信息即可。 elasticsearch.yml的其它可配置信息： 属性名 说明 cluster.name 配置elasticsearch的集群名称，默认是elasticsearch。建议修改成一个有意义的名称。 node.name 节点名，es会默认随机指定一个名字，建议指定一个有意义的名称，方便管理 path.conf 设置配置文件的存储路径，tar或zip包安装默认在es根目录下的config文件夹，rpm安装默认在/etc/ elasticsearch path.data 设置索引数据的存储路径，默认是es根目录下的data文件夹，可以设置多个存储路径，用逗号隔开 path.logs 设置日志文件的存储路径，默认是es根目录下的logs文件夹 path.plugins 设置插件的存放路径，默认是es根目录下的plugins文件夹 bootstrap.memory_lock 设置为true可以锁住ES使用的内存，避免内存进行swap network.host 设置bind_host和publish_host，设置为0.0.0.0允许外网访问 http.port 设置对外服务的http端口，默认为9200。 transport.tcp.port 集群结点之间通信端口 discovery.zen.ping.timeout 设置ES自动发现节点连接超时的时间，默认为3秒，如果网络延迟高可设置大些 discovery.zen.minimum_master_nodes 主结点数量的最少值 ,此值的公式为：(master_eligible_nodes / 2) + 1 ，比如：有3个符合要求的主结点，那么这里要设置为2 运行 进入elasticsearch/bin目录，可以看到下面的执行文件： 然后输入命令： 1./elasticsearch 发现报错了，启动失败： 错误1：内核过低 我们使用的是centos6，其linux内核版本为2.6。而Elasticsearch的插件要求至少3.5以上版本。不过没关系，我们禁用这个插件即可。 修改elasticsearch.yml文件，在最下面添加如下配置： 1bootstrap.system_call_filter: false 然后重启 错误2：文件权限不足 再次启动，又出错了： 1[1]: max file descriptors [4096] for elasticsearch process likely too low, increase to at least [65536] 我们用的是leyou用户，而不是root，所以文件权限不足。 首先用root用户登录。 然后修改配置文件: 1vim /etc/security/limits.conf 添加下面的内容： 1234567* soft nofile 65536* hard nofile 131072* soft nproc 4096* hard nproc 4096 错误3：线程数不够 刚才报错中，还有一行： 1[1]: max number of threads [1024] for user [leyou] is too low, increase to at least [4096] 这是线程数不够。 继续修改配置： 1vim /etc/security/limits.d/90-nproc.conf 修改下面的内容： 1* soft nproc 1024 改为： 1* soft nproc 4096 错误4：进程虚拟内存 1[3]: max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144] vm.max_map_count：限制一个进程可以拥有的VMA(虚拟内存区域)的数量，继续修改配置文件， ： 1vim /etc/sysctl.conf 添加下面内容： 1vm.max_map_count=655360 然后执行命令： 1sysctl -p 重启终端窗口 所有错误修改完毕，一定要重启你的 Xshell终端，否则配置无效。 启动 再次启动，终于成功了！ 可以看到绑定了两个端口: 9300：集群节点间通讯接口 9200：客户端访问接口 我们在浏览器中访问：http://192.168.56.101:9200 安装kibana 什么是Kibana？ Kibana是一个基于Node.js的Elasticsearch索引库数据统计工具，可以利用Elasticsearch的聚合功能，生成各种图表，如柱形图，线状图，饼图等。 而且还提供了操作Elasticsearch索引数据的控制台，并且提供了一定的API提示，非常有利于我们学习Elasticsearch的语法。 安装 因为Kibana依赖于node，我们的虚拟机没有安装node，而window中安装过。所以我们选择在window下使用kibana。 最新版本与elasticsearch保持一致，也是6.3.0 解压到特定目录即可 配置运行 配置 进入安装目录下的config目录，修改kibana.yml文件： 修改elasticsearch服务器的地址： 1elasticsearch.url: &quot;http://192.168.56.101:9200&quot; 运行 进入安装目录下的bin目录： 双击运行： 发现kibana的监听端口是5601 我们访问：http://127.0.0.1:5601 控制台 选择左侧的DevTools菜单，即可进入控制台页面： 在页面右侧，我们就可以输入请求，访问Elasticsearch了。 安装ik分词器 Lucene的IK分词器早在2012年已经没有维护了，现在我们要使用的是在其基础上维护升级的版本，并且开发为ElasticSearch的集成插件了，与Elasticsearch一起维护升级，版本也保持一致，最新版本：6.3.0 安装 上传课前资料中的zip包，解压到Elasticsearch目录的plugins目录中： 使用unzip命令解压： 1unzip elasticsearch-analysis-ik-6.3.0.zip -d ik-analyzer 然后重启elasticsearch： 测试 大家先不管语法，我们先测试一波。 在kibana控制台输入下面的请求： 12345POST _analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;我是中国人&quot;&#125; 运行得到结果： 123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;tokens&quot;: [ &#123; &quot;token&quot;: &quot;我&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 1, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;是&quot;, &quot;start_offset&quot;: 1, &quot;end_offset&quot;: 2, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;中国人&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 5, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 2 &#125;, &#123; &quot;token&quot;: &quot;中国&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 3 &#125;, &#123; &quot;token&quot;: &quot;国人&quot;, &quot;start_offset&quot;: 3, &quot;end_offset&quot;: 5, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 4 &#125; ]&#125; API Elasticsearch提供了Rest风格的API，即http请求接口，而且也提供了各种语言的客户端API Rest风格API 文档地址：https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html 客户端API Elasticsearch支持的客户端非常多：https://www.elastic.co/guide/en/elasticsearch/client/index.html 点击Java Rest Client后，你会发现又有两个： Low Level Rest Client是低级别封装，提供一些基础功能，但更灵活 High Level Rest Client，是在Low Level Rest Client基础上进行的高级别封装，功能更丰富和完善，而且API会变的简单 如何学习 建议先学习Rest风格API，了解发起请求的底层实现，请求体格式等。 操作索引 基本概念 Elasticsearch也是基于Lucene的全文检索库，本质也是存储数据，很多概念与MySQL类似的。 对比关系： 索引（indices）——————————–Databases 数据库 ​ 类型（type）—————————–Table 数据表 ​ 文档（Document）—————-Row 行 ​ 字段（Field）——————-Columns 列 详细说明： 概念 说明 索引库（indices) indices是index的复数，代表许多的索引， 类型（type） 类型是模拟mysql中的table概念，一个索引库下可以有不同类型的索引，比如商品索引，订单索引，其数据格式不同。不过这会导致索引库混乱，因此未来版本中会移除这个概念 文档（document） 存入索引库原始的数据。比如每一条商品信息，就是一个文档 字段（field） 文档中的属性 映射配置（mappings） 字段的数据类型、属性、是否索引、是否存储等特性 是不是与Lucene和solr中的概念类似。 另外，在SolrCloud中，有一些集群相关的概念，在Elasticsearch也有类似的： 索引集（Indices，index的复数）：逻辑上的完整索引 分片（shard）：数据拆分后的各个部分 副本（replica）：每个分片的复制 要注意的是：Elasticsearch本身就是分布式的，因此即便你只有一个节点，Elasticsearch默认也会对你的数据进行分片和副本操作，当你向集群添加新数据时，数据也会在新加入的节点中进行平衡。 创建索引 语法 Elasticsearch采用Rest风格API，因此其API就是一次http请求，你可以用任何工具发起http请求 创建索引的请求格式： 请求方式：PUT 请求路径：/索引库名 请求参数：json格式： 123456&#123; "settings": &#123; "number_of_shards": 3, "number_of_replicas": 2 &#125;&#125; settings：索引库的设置 number_of_shards：分片数量 number_of_replicas：副本数量 测试 我们先用RestClient来试试 响应： 可以看到索引创建成功了。 使用kibana创建 kibana的控制台，可以对http请求进行简化，示例： 相当于是省去了elasticsearch的服务器地址 而且还有语法提示，非常舒服。 查看索引设置 语法 Get请求可以帮我们查看索引信息，格式： 1GET /索引库名 或者，我们可以使用*来查询所有索引库配置： 删除索引 删除索引使用DELETE请求 语法 1DELETE /索引库名 示例 再次查看heima2： 当然，我们也可以用HEAD请求，查看索引是否存在： 映射配置 索引有了，接下来肯定是添加数据。但是，在添加数据之前必须定义映射。 什么是映射？ ​ 映射是定义文档的过程，文档包含哪些字段，这些字段是否保存，是否索引，是否分词等 只有配置清楚，Elasticsearch才会帮我们进行索引库的创建（不一定） 创建映射字段 语法 请求方式依然是PUT 1234567891011PUT /索引库名/_mapping/类型名称&#123; &quot;properties&quot;: &#123; &quot;字段名&quot;: &#123; &quot;type&quot;: &quot;类型&quot;, &quot;index&quot;: true， &quot;store&quot;: true， &quot;analyzer&quot;: &quot;分词器&quot; &#125; &#125;&#125; 类型名称：就是前面将的type的概念，类似于数据库中的不同表字段名：任意填写 ，可以指定许多属性，例如： type：类型，可以是text、long、short、date、integer、object等 index：是否索引，默认为true store：是否存储，默认为false analyzer：分词器，这里的ik_max_word即使用ik分词器 示例 发起请求： 12345678910111213141516PUT heima/_mapping/goods&#123; "properties": &#123; "title": &#123; "type": "text", "analyzer": "ik_max_word" &#125;, "images": &#123; "type": "keyword", "index": "false" &#125;, "price": &#123; "type": "float" &#125; &#125;&#125; 响应结果： 123&#123; &quot;acknowledged&quot;: true&#125; 查看映射关系 语法： 1GET /索引库名/_mapping 示例： 1GET /heima/_mapping 响应： 123456789101112131415161718192021&#123; "heima": &#123; "mappings": &#123; "goods": &#123; "properties": &#123; "images": &#123; "type": "keyword", "index": false &#125;, "price": &#123; "type": "float" &#125;, "title": &#123; "type": "text", "analyzer": "ik_max_word" &#125; &#125; &#125; &#125; &#125;&#125; 字段属性详解 type Elasticsearch中支持的数据类型非常丰富： 我们说几个关键的： String类型，又分两种： text：可分词，不可参与聚合 keyword：不可分词，数据会作为完整字段进行匹配，可以参与聚合 Numerical：数值类型，分两类 基本数据类型：long、interger、short、byte、double、float、half_float 浮点数的高精度类型：scaled_float 需要指定一个精度因子，比如10或100。elasticsearch会把真实值乘以这个因子后存储，取出时再还原。 Date：日期类型 elasticsearch可以对日期格式化为字符串存储，但是建议我们存储为毫秒值，存储为long，节省空间。 index index影响字段的索引情况。 true：字段会被索引，则可以用来进行搜索。默认值就是true false：字段不会被索引，不能用来搜索 index的默认值就是true，也就是说你不进行任何配置，所有字段都会被索引。 但是有些字段是我们不希望被索引的，比如商品的图片信息，就需要手动设置index为false。 store 是否将数据进行额外存储。 在学习lucene和solr时，我们知道如果一个字段的store设置为false，那么在文档列表中就不会有这个字段的值，用户的搜索结果中不会显示出来。 但是在Elasticsearch中，即便store设置为false，也可以搜索到结果。 原因是Elasticsearch在创建文档索引时，会将文档中的原始数据备份，保存到一个叫做_source的属性中。而且我们可以通过过滤_source来选择哪些要显示，哪些不显示。 而如果设置store为true，就会在_source以外额外存储一份数据，多余，因此一般我们都会将store设置为false，事实上，store的默认值就是false。 boost 激励因子，这个与lucene中一样 其它的不再一一讲解，用的不多，大家参考官方文档： 新增数据 随机生成id 通过POST请求，可以向一个已经存在的索引库中添加数据。 语法： 1234POST /索引库名/类型名&#123; &quot;key&quot;:&quot;value&quot;&#125; 示例： 123456POST /heima/goods/&#123; "title":"小米手机", "images":"http://image.leyou.com/12479122.jpg", "price":2699.00&#125; 响应： 1234567891011121314&#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_version": 1, "result": "created", "_shards": &#123; "total": 3, "successful": 1, "failed": 0 &#125;, "_seq_no": 0, "_primary_term": 2&#125; 通过kibana查看数据： 123456get _search&#123; "query":&#123; "match_all":&#123;&#125; &#125;&#125; 123456789101112&#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_version": 1, "_score": 1, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125;&#125; _source：源文档信息，所有的数据都在里面。 _id：这条文档的唯一标示，与文档自己的id字段没有关联 自定义id 如果我们想要自己新增的时候指定id，可以这么做： 1234POST /索引库名/类型/id值&#123; ...&#125; 示例： 123456POST /heima/goods/2&#123; "title":"大米手机", "images":"http://image.leyou.com/12479122.jpg", "price":2899.00&#125; 得到的数据： 1234567891011&#123; "_index": "heima", "_type": "goods", "_id": "2", "_score": 1, "_source": &#123; "title": "大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899 &#125;&#125; 智能判断 在学习Solr时我们发现，我们在新增数据时，只能使用提前配置好映射属性的字段，否则就会报错。 不过在Elasticsearch中并没有这样的规定。 事实上Elasticsearch非常智能，你不需要给索引库设置任何mapping映射，它也可以根据你输入的数据来判断类型，动态添加数据映射。 测试一下： 12345678POST /heima/goods/3&#123; "title":"超米手机", "images":"http://image.leyou.com/12479122.jpg", "price":2899.00, "stock": 200, "saleable":true&#125; 我们额外添加了stock库存，和saleable是否上架两个字段。 来看结果： 1234567891011121314&#123; "_index": "heima", "_type": "goods", "_id": "3", "_version": 1, "_score": 1, "_source": &#123; "title": "超米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899, "stock": 200, "saleable": true &#125;&#125; 在看下索引库的映射关系: 123456789101112131415161718192021222324252627&#123; "heima": &#123; "mappings": &#123; "goods": &#123; "properties": &#123; "images": &#123; "type": "keyword", "index": false &#125;, "price": &#123; "type": "float" &#125;, "saleable": &#123; "type": "boolean" &#125;, "stock": &#123; "type": "long" &#125;, "title": &#123; "type": "text", "analyzer": "ik_max_word" &#125; &#125; &#125; &#125; &#125;&#125; stock和saleable都被成功映射了。 修改数据 把刚才新增的请求方式改为PUT，就是修改了。不过修改必须指定id， id对应文档存在，则修改 id对应文档不存在，则新增 比如，我们把id为3的数据进行修改： 12345678PUT /heima/goods/3&#123; "title":"超大米手机", "images":"http://image.leyou.com/12479122.jpg", "price":3899.00, "stock": 100, "saleable":true&#125; 结果： 1234567891011121314151617181920212223242526272829&#123; "took": 17, "timed_out": false, "_shards": &#123; "total": 9, "successful": 9, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "3", "_score": 1, "_source": &#123; "title": "超大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 3899, "stock": 100, "saleable": true &#125; &#125; ] &#125;&#125; 删除数据 删除使用DELETE请求，同样，需要根据id进行删除： 语法 1DELETE /索引库名/类型名/id值 示例： 查询 我们从4块来讲查询： 基本查询 _source过滤 结果过滤 高级查询 排序 基本查询： 基本语法 12345678GET /索引库名/_search&#123; "query":&#123; "查询类型":&#123; "查询条件":"查询条件值" &#125; &#125;&#125; 这里的query代表一个查询对象，里面可以有不同的查询属性 查询类型： 例如：match_all， match，term ， range 等等 查询条件：查询条件会根据类型的不同，写法也有差异，后面详细讲解 查询所有（match_all) 示例： 123456GET /heima/_search&#123; "query":&#123; "match_all": &#123;&#125; &#125;&#125; query：代表查询对象 match_all：代表查询所有 结果： 1234567891011121314151617181920212223242526272829303132333435363738&#123; "took": 2, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 2, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "2", "_score": 1, "_source": &#123; "title": "大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899 &#125; &#125;, &#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_score": 1, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125; &#125; ] &#125;&#125; took：查询花费时间，单位是毫秒 time_out：是否超时 _shards：分片信息 hits：搜索结果总览对象 total：搜索到的总条数 max_score：所有结果中文档得分的最高分 hits：搜索结果的文档对象数组，每个元素是一条搜索到的文档信息 _index：索引库 _type：文档类型 _id：文档id _score：文档得分 _source：文档的源数据 匹配查询（match） 我们先加入一条数据，便于测试： 123456PUT /heima/goods/3&#123; "title":"小米电视4A", "images":"http://image.leyou.com/12479122.jpg", "price":3899.00&#125; 现在，索引库中有2部手机，1台电视： or关系 match类型查询，会把查询条件进行分词，然后进行查询,多个词条之间是or的关系 12345678GET /heima/_search&#123; "query":&#123; "match":&#123; "title":"小米电视" &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728"hits": &#123; "total": 2, "max_score": 0.6931472, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "tmUBomQB_mwm6wH_EC1-", "_score": 0.6931472, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125; &#125;, &#123; "_index": "heima", "_type": "goods", "_id": "3", "_score": 0.5753642, "_source": &#123; "title": "小米电视4A", "images": "http://image.leyou.com/12479122.jpg", "price": 3899 &#125; &#125; ]&#125; 在上面的案例中，不仅会查询到电视，而且与小米相关的都会查询到，多个词之间是or的关系。 and关系 某些情况下，我们需要更精确查找，我们希望这个关系变成and，可以这样做： 1234567891011GET /heima/_search&#123; "query":&#123; "match": &#123; "title": &#123; "query": "小米电视", "operator": "and" &#125; &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627&#123; "took": 2, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 0.5753642, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "3", "_score": 0.5753642, "_source": &#123; "title": "小米电视4A", "images": "http://image.leyou.com/12479122.jpg", "price": 3899 &#125; &#125; ] &#125;&#125; 本例中，只有同时包含小米和电视的词条才会被搜索到。 or和and之间？ 在 or 与 and 间二选一有点过于非黑即白。 如果用户给定的条件分词后有 5 个查询词项，想查找只包含其中 4 个词的文档，该如何处理？将 operator 操作符参数设置成 and 只会将此文档排除。 有时候这正是我们期望的，但在全文搜索的大多数应用场景下，我们既想包含那些可能相关的文档，同时又排除那些不太相关的。换句话说，我们想要处于中间某种结果。 match 查询支持 minimum_should_match 最小匹配参数， 这让我们可以指定必须匹配的词项数用来表示一个文档是否相关。我们可以将其设置为某个具体数字，更常用的做法是将其设置为一个百分数，因为我们无法控制用户搜索时输入的单词数量： 1234567891011GET /heima/_search&#123; "query":&#123; "match":&#123; "title":&#123; "query":"小米曲面电视", "minimum_should_match": "75%" &#125; &#125; &#125;&#125; 本例中，搜索语句可以分为3个词，如果使用and关系，需要同时满足3个词才会被搜索到。这里我们采用最小品牌数：75%，那么也就是说只要匹配到总词条数量的75%即可，这里3*75% 约等于2。所以只要包含2个词条就算满足条件了。 结果： 多字段查询（multi_match） multi_match与match类似，不同的是它可以在多个字段中查询 123456789GET /heima/_search&#123; "query":&#123; "multi_match": &#123; "query": "小米", "fields": [ "title", "subTitle" ] &#125; &#125;&#125; 本例中，我们会在title字段和subtitle字段中查询小米这个词 词条匹配(term) term 查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些未分词的字符串 12345678GET /heima/_search&#123; "query":&#123; "term":&#123; "price":2699.00 &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627&#123; "took": 2, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_score": 1, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125; &#125; ] &#125;&#125; 多词条精确匹配(terms) terms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件： 12345678GET /heima/_search&#123; "query":&#123; "terms":&#123; "price":[2699.00,2899.00,3899.00] &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; "took": 4, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 3, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "2", "_score": 1, "_source": &#123; "title": "大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899 &#125; &#125;, &#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_score": 1, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125; &#125;, &#123; "_index": "heima", "_type": "goods", "_id": "3", "_score": 1, "_source": &#123; "title": "小米电视4A", "images": "http://image.leyou.com/12479122.jpg", "price": 3899 &#125; &#125; ] &#125;&#125; 结果过滤 默认情况下，elasticsearch在搜索的结果中，会把文档中保存在_source的所有字段都返回。 如果我们只想获取其中的部分字段，我们可以添加_source的过滤 直接指定字段 示例： 123456789GET /heima/_search&#123; "_source": ["title","price"], "query": &#123; "term": &#123; "price": 2699 &#125; &#125;&#125; 返回的结果： 1234567891011121314151617181920212223242526&#123; "took": 12, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_score": 1, "_source": &#123; "price": 2699, "title": "小米手机" &#125; &#125; ] &#125;&#125; 指定includes和excludes 我们也可以通过： includes：来指定想要显示的字段 excludes：来指定不想要显示的字段 二者都是可选的。 示例： 1234567891011GET /heima/_search&#123; "_source": &#123; "includes":["title","price"] &#125;, "query": &#123; "term": &#123; "price": 2699 &#125; &#125;&#125; 与下面的结果将是一样的： 1234567891011GET /heima/_search&#123; "_source": &#123; "excludes": ["images"] &#125;, "query": &#123; "term": &#123; "price": 2699 &#125; &#125;&#125; 高级查询 布尔组合（bool) bool把各种其它查询通过must（与）、must_not（非）、should（或）的方式进行组合 12345678910GET /heima/_search&#123; "query":&#123; "bool":&#123; "must": &#123; "match": &#123; "title": "大米" &#125;&#125;, "must_not": &#123; "match": &#123; "title": "电视" &#125;&#125;, "should": &#123; "match": &#123; "title": "手机" &#125;&#125; &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627&#123; "took": 10, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 0.5753642, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "2", "_score": 0.5753642, "_source": &#123; "title": "大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899 &#125; &#125; ] &#125;&#125; 范围查询(range) range 查询找出那些落在指定区间内的数字或者时间 1234567891011GET /heima/_search&#123; "query":&#123; "range": &#123; "price": &#123; "gte": 1000.0, "lt": 2800.00 &#125; &#125; &#125;&#125; range查询允许以下字符： 操作符 说明 gt 大于 gte 大于等于 lt 小于 lte 小于等于 模糊查询(fuzzy) 我们新增一个商品： 123456POST /heima/goods/4&#123; "title":"apple手机", "images":"http://image.leyou.com/12479122.jpg", "price":6899.00&#125; fuzzy 查询是 term 查询的模糊等价。它允许用户搜索词条与实际词条的拼写出现偏差，但是偏差的编辑距离不得超过2： 12345678GET /heima/_search&#123; "query": &#123; "fuzzy": &#123; "title": "appla" &#125; &#125;&#125; 上面的查询，也能查询到apple手机 我们可以通过fuzziness来指定允许的编辑距离： 1234567891011GET /heima/_search&#123; "query": &#123; "fuzzy": &#123; "title": &#123; "value":"appla", "fuzziness":1 &#125; &#125; &#125;&#125; 过滤(filter) 条件查询中进行过滤 所有的查询都会影响到文档的评分及排名。如果我们需要在查询结果中进行过滤，并且不希望过滤条件影响评分，那么就不要把过滤条件作为查询条件来用。而是使用filter方式： 1234567891011GET /heima/_search&#123; "query":&#123; "bool":&#123; "must":&#123; "match": &#123; "title": "小米手机" &#125;&#125;, "filter":&#123; "range":&#123;"price":&#123;"gt":2000.00,"lt":3800.00&#125;&#125; &#125; &#125; &#125;&#125; 注意：filter中还可以再次进行bool组合条件过滤。 无查询条件，直接过滤 如果一次查询只有过滤，没有查询条件，不希望进行评分，我们可以使用constant_score取代只有 filter 语句的 bool 查询。在性能上是完全相同的，但对于提高查询简洁性和清晰度有很大帮助。 123456789GET /heima/_search&#123; "query":&#123; "constant_score": &#123; "filter": &#123; "range":&#123;"price":&#123;"gt":2000.00,"lt":3000.00&#125;&#125; &#125; &#125;&#125; 排序 单字段排序 sort 可以让我们按照不同的字段进行排序，并且通过order指定排序的方式 123456789101112131415GET /heima/_search&#123; "query": &#123; "match": &#123; "title": "小米手机" &#125; &#125;, "sort": [ &#123; "price": &#123; "order": "desc" &#125; &#125; ]&#125; 多字段排序 假定我们想要结合使用 price和 _score（得分） 进行查询，并且匹配的结果首先按照价格排序，然后按照相关性得分排序： 123456789101112131415GET /goods/_search&#123; "query":&#123; "bool":&#123; "must":&#123; "match": &#123; "title": "小米手机" &#125;&#125;, "filter":&#123; "range":&#123;"price":&#123;"gt":200000,"lt":300000&#125;&#125; &#125; &#125; &#125;, "sort": [ &#123; "price": &#123; "order": "desc" &#125;&#125;, &#123; "_score": &#123; "order": "desc" &#125;&#125; ]&#125; 聚合aggregations 聚合可以让我们极其方便的实现对数据的统计、分析。例如： 什么品牌的手机最受欢迎？ 这些手机的平均价格、最高价格、最低价格？ 这些手机每月的销售情况如何？ 实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现实时搜索效果。 基本概念 Elasticsearch中的聚合，包含多种类型，最常用的两种，一个叫桶，一个叫度量： 桶（bucket） 桶的作用，是按照某种方式对数据进行分组，每一组数据在ES中称为一个桶，例如我们根据国籍对人划分，可以得到中国桶、英国桶，日本桶……或者我们按照年龄段对人进行划分：010,1020,2030,3040等。 Elasticsearch中提供的划分桶的方式有很多： Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组 Histogram Aggregation：根据数值阶梯分组，与日期类似 Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组 Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组 …… 综上所述，我们发现bucket aggregations 只负责对数据进行分组，并不进行计算，因此往往bucket中往往会嵌套另一种聚合：metrics aggregations即度量 度量（metrics） 分组完成以后，我们一般会对组中的数据进行聚合运算，例如求平均值、最大、最小、求和等，这些在ES中称为度量 比较常用的一些度量聚合方式： Avg Aggregation：求平均值 Max Aggregation：求最大值 Min Aggregation：求最小值 Percentiles Aggregation：求百分比 Stats Aggregation：同时返回avg、max、min、sum、count等 Sum Aggregation：求和 Top hits Aggregation：求前几 Value Count Aggregation：求总数 …… 为了测试聚合，我们先批量导入一些数据 创建索引： 12345678910111213141516171819PUT /cars&#123; "settings": &#123; "number_of_shards": 1, "number_of_replicas": 0 &#125;, "mappings": &#123; "transactions": &#123; "properties": &#123; "color": &#123; "type": "keyword" &#125;, "make": &#123; "type": "keyword" &#125; &#125; &#125; &#125;&#125; 注意：在ES中，需要进行聚合、排序、过滤的字段其处理方式比较特殊，因此不能被分词。这里我们将color和make这两个文字类型的字段设置为keyword类型，这个类型不会被分词，将来就可以参与聚合 导入数据 1234567891011121314151617POST /cars/transactions/_bulk&#123; "index": &#123;&#125;&#125;&#123; "price" : 10000, "color" : "red", "make" : "honda", "sold" : "2014-10-28" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 30000, "color" : "green", "make" : "ford", "sold" : "2014-05-18" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 15000, "color" : "blue", "make" : "toyota", "sold" : "2014-07-02" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 12000, "color" : "green", "make" : "toyota", "sold" : "2014-08-19" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 80000, "color" : "red", "make" : "bmw", "sold" : "2014-01-01" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 25000, "color" : "blue", "make" : "ford", "sold" : "2014-02-12" &#125; 聚合为桶 首先，我们按照 汽车的颜色color来划分桶 1234567891011GET /cars/_search&#123; "size" : 0, "aggs" : &#123; "popular_colors" : &#123; "terms" : &#123; "field" : "color" &#125; &#125; &#125;&#125; size： 查询条数，这里设置为0，因为我们不关心搜索到的数据，只关心聚合结果，提高效率 aggs：声明这是一个聚合查询，是aggregations的缩写 popular_colors：给这次聚合起一个名字，任意。 terms：划分桶的方式，这里是根据词条划分 field：划分桶的字段 结果： 1234567891011121314151617181920212223242526272829303132333435&#123; "took": 1, "timed_out": false, "_shards": &#123; "total": 1, "successful": 1, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 8, "max_score": 0, "hits": [] &#125;, "aggregations": &#123; "popular_colors": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "red", "doc_count": 4 &#125;, &#123; "key": "blue", "doc_count": 2 &#125;, &#123; "key": "green", "doc_count": 2 &#125; ] &#125; &#125;&#125; hits：查询结果为空，因为我们设置了size为0 aggregations：聚合的结果 popular_colors：我们定义的聚合名称 buckets：查找到的桶，每个不同的color字段值都会形成一个桶 key：这个桶对应的color字段的值 doc_count：这个桶中的文档数量 通过聚合的结果我们发现，目前红色的小车比较畅销！ 桶内度量 前面的例子告诉我们每个桶里面的文档数量，这很有用。 但通常，我们的应用需要提供更复杂的文档度量。 例如，每种颜色汽车的平均价格是多少？ 因此，我们需要告诉Elasticsearch使用哪个字段，使用何种度量方式进行运算，这些信息要嵌套在桶内，度量的运算会基于桶内的文档进行 现在，我们为刚刚的聚合结果添加 求价格平均值的度量： 123456789101112131415161718GET /cars/_search&#123; "size" : 0, "aggs" : &#123; "popular_colors" : &#123; "terms" : &#123; "field" : "color" &#125;, "aggs":&#123; "avg_price": &#123; "avg": &#123; "field": "price" &#125; &#125; &#125; &#125; &#125;&#125; aggs：我们在上一个aggs(popular_colors)中添加新的aggs。可见度量也是一个聚合,度量是在桶内的聚合 avg_price：聚合的名称 avg：度量的类型，这里是求平均值 field：度量运算的字段 结果： 12345678910111213141516171819202122232425262728293031... "aggregations": &#123; "popular_colors": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "red", "doc_count": 4, "avg_price": &#123; "value": 32500 &#125; &#125;, &#123; "key": "blue", "doc_count": 2, "avg_price": &#123; "value": 20000 &#125; &#125;, &#123; "key": "green", "doc_count": 2, "avg_price": &#123; "value": 21000 &#125; &#125; ] &#125; &#125;... 可以看到每个桶中都有自己的avg_price字段，这是度量聚合的结果 桶内嵌套桶 刚刚的案例中，我们在桶内嵌套度量运算。事实上桶不仅可以嵌套运算， 还可以再嵌套其它桶。也就是说在每个分组中，再分更多组。 比如：我们想统计每种颜色的汽车中，分别属于哪个制造商，按照make字段再进行分桶 1234567891011121314151617181920212223GET /cars/_search&#123; "size" : 0, "aggs" : &#123; "popular_colors" : &#123; "terms" : &#123; "field" : "color" &#125;, "aggs":&#123; "avg_price": &#123; "avg": &#123; "field": "price" &#125; &#125;, "maker":&#123; "terms":&#123; "field":"make" &#125; &#125; &#125; &#125; &#125;&#125; 原来的color桶和avg计算我们不变 maker：在嵌套的aggs下新添一个桶，叫做maker terms：桶的划分类型依然是词条 filed：这里根据make字段进行划分 部分结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374...&#123;"aggregations": &#123; "popular_colors": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "red", "doc_count": 4, "maker": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "honda", "doc_count": 3 &#125;, &#123; "key": "bmw", "doc_count": 1 &#125; ] &#125;, "avg_price": &#123; "value": 32500 &#125; &#125;, &#123; "key": "blue", "doc_count": 2, "maker": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "ford", "doc_count": 1 &#125;, &#123; "key": "toyota", "doc_count": 1 &#125; ] &#125;, "avg_price": &#123; "value": 20000 &#125; &#125;, &#123; "key": "green", "doc_count": 2, "maker": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "ford", "doc_count": 1 &#125;, &#123; "key": "toyota", "doc_count": 1 &#125; ] &#125;, "avg_price": &#123; "value": 21000 &#125; &#125; ] &#125; &#125;&#125;... 我们可以看到，新的聚合maker被嵌套在原来每一个color的桶中。 每个颜色下面都根据 make字段进行了分组 我们能读取到的信息： 红色车共有4辆 红色车的平均售价是 $32，500 美元。 其中3辆是 Honda 本田制造，1辆是 BMW 宝马制造。 划分桶的其它方式 前面讲了，划分桶的方式有很多，例如： Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组 Histogram Aggregation：根据数值阶梯分组，与日期类似 Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组 Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组 刚刚的案例中，我们采用的是Terms Aggregation，即根据词条划分桶。 接下来，我们再学习几个比较实用的： 阶梯分桶Histogram 原理： histogram是把数值类型的字段，按照一定的阶梯大小进行分组。你需要指定一个阶梯值（interval）来划分阶梯大小。 举例： 比如你有价格字段，如果你设定interval的值为200，那么阶梯就会是这样的： 0，200，400，600，… 上面列出的是每个阶梯的key，也是区间的启点。 如果一件商品的价格是450，会落入哪个阶梯区间呢？计算公式如下： 1bucket_key = Math.floor((value - offset) / interval) * interval + offset value：就是当前数据的值，本例中是450 offset：起始偏移量，默认为0 interval：阶梯间隔，比如200 因此你得到的key = Math.floor((450 - 0) / 200) * 200 + 0 = 400 操作一下： 比如，我们对汽车的价格进行分组，指定间隔interval为5000： 123456789101112GET /cars/_search&#123; "size":0, "aggs":&#123; "price":&#123; "histogram": &#123; "field": "price", "interval": 5000 &#125; &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&#123; "took": 21, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 8, "max_score": 0, "hits": [] &#125;, "aggregations": &#123; "price": &#123; "buckets": [ &#123; "key": 10000, "doc_count": 2 &#125;, &#123; "key": 15000, "doc_count": 1 &#125;, &#123; "key": 20000, "doc_count": 2 &#125;, &#123; "key": 25000, "doc_count": 1 &#125;, &#123; "key": 30000, "doc_count": 1 &#125;, &#123; "key": 35000, "doc_count": 0 &#125;, &#123; "key": 40000, "doc_count": 0 &#125;, &#123; "key": 45000, "doc_count": 0 &#125;, &#123; "key": 50000, "doc_count": 0 &#125;, &#123; "key": 55000, "doc_count": 0 &#125;, &#123; "key": 60000, "doc_count": 0 &#125;, &#123; "key": 65000, "doc_count": 0 &#125;, &#123; "key": 70000, "doc_count": 0 &#125;, &#123; "key": 75000, "doc_count": 0 &#125;, &#123; "key": 80000, "doc_count": 1 &#125; ] &#125; &#125;&#125; 你会发现，中间有大量的文档数量为0 的桶，看起来很丑。 我们可以增加一个参数min_doc_count为1，来约束最少文档数量为1，这样文档数量为0的桶会被过滤 示例： 12345678910111213GET /cars/_search&#123; "size":0, "aggs":&#123; "price":&#123; "histogram": &#123; "field": "price", "interval": 5000, "min_doc_count": 1 &#125; &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; "took": 15, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 8, "max_score": 0, "hits": [] &#125;, "aggregations": &#123; "price": &#123; "buckets": [ &#123; "key": 10000, "doc_count": 2 &#125;, &#123; "key": 15000, "doc_count": 1 &#125;, &#123; "key": 20000, "doc_count": 2 &#125;, &#123; "key": 25000, "doc_count": 1 &#125;, &#123; "key": 30000, "doc_count": 1 &#125;, &#123; "key": 80000, "doc_count": 1 &#125; ] &#125; &#125;&#125; 完美，！ 如果你用kibana将结果变为柱形图，会更好看： 范围分桶range 范围分桶与阶梯分桶类似，也是把数字按照阶段进行分组，只不过range方式需要你自己指定每一组的起始和结束大小。 Spring Data Elasticsearch Elasticsearch提供的Java客户端有一些不太方便的地方： 很多地方需要拼接Json字符串，在java中拼接字符串有多恐怖你应该懂的 需要自己把对象序列化为json存储 查询到结果也需要自己反序列化为对象 因此，我们这里就不讲解原生的Elasticsearch客户端API了。 而是学习Spring提供的套件：Spring Data Elasticsearch。 简介 Spring Data Elasticsearch是Spring Data项目下的一个子模块。 查看 Spring Data的官网：http://projects.spring.io/spring-data/ Spring Data的使命是为数据访问提供熟悉且一致的基于Spring的编程模型，同时仍保留底层数据存储的特殊特性。 它使得使用数据访问技术，关系数据库和非关系数据库，map-reduce框架和基于云的数据服务变得容易。这是一个总括项目，其中包含许多特定于给定数据库的子项目。这些令人兴奋的技术项目背后，是由许多公司和开发人员合作开发的。 Spring Data 的使命是给各种数据访问提供统一的编程接口，不管是关系型数据库（如MySQL），还是非关系数据库（如Redis），或者类似Elasticsearch这样的索引数据库。从而简化开发人员的代码，提高开发效率。 包含很多不同数据操作的模块： Spring Data Elasticsearch的页面：https://projects.spring.io/spring-data-elasticsearch/ 特征： 支持Spring的基于@Configuration的java配置方式，或者XML配置方式 提供了用于操作ES的便捷工具类ElasticsearchTemplate。包括实现文档到POJO之间的自动智能映射。 利用Spring的数据转换服务实现的功能丰富的对象映射 基于注解的元数据映射方式，而且可扩展以支持更多不同的数据格式 根据持久层接口自动生成对应实现方法，无需人工编写基本操作代码（类似mybatis，根据接口自动得到实现）。当然，也支持人工定制查询 创建Demo工程 我们新建一个demo，学习Elasticsearch pom依赖： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;elasticsearch&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml文件配置： 12345spring: data: elasticsearch: cluster-name: elasticsearch cluster-nodes: 192.168.56.101:9300 实体类及注解 首先我们准备好实体类： 12345678public class Item &#123; Long id; String title; //标题 String category;// 分类 String brand; // 品牌 Double price; // 价格 String images; // 图片地址&#125; 映射 Spring Data通过注解来声明字段的映射属性，有下面的三个注解： @Document 作用在类，标记实体类为文档对象，一般有两个属性 indexName：对应索引库名称 type：对应在索引库中的类型 shards：分片数量，默认5 replicas：副本数量，默认1 @Id 作用在成员变量，标记一个字段作为id主键 @Field 作用在成员变量，标记为文档的字段，并指定字段映射属性： type：字段类型，取值是枚举：FieldType index：是否索引，布尔类型，默认是true store：是否存储，布尔类型，默认是false analyzer：分词器名称 示例： 1234567891011121314151617181920@Document(indexName = "item",type = "docs", shards = 1, replicas = 0)public class Item &#123; @Id private Long id; @Field(type = FieldType.Text, analyzer = "ik_max_word") private String title; //标题 @Field(type = FieldType.Keyword) private String category;// 分类 @Field(type = FieldType.Keyword) private String brand; // 品牌 @Field(type = FieldType.Double) private Double price; // 价格 @Field(index = false, type = FieldType.Keyword) private String images; // 图片地址&#125; Template索引操作 创建索引和映射 创建索引 ElasticsearchTemplate中提供了创建索引的API： 可以根据类的信息自动生成，也可以手动指定indexName和Settings 映射 映射相关的API： 可以根据类的字节码信息（注解配置）来生成映射，或者手动编写映射 我们这里采用类的字节码信息创建索引并映射： 123456789101112131415@RunWith(SpringRunner.class)@SpringBootTest(classes = ItcastElasticsearchApplication.class)public class IndexTest &#123; @Autowired private ElasticsearchTemplate elasticsearchTemplate; @Test public void testCreate()&#123; // 创建索引，会根据Item类的@Document注解信息来创建 elasticsearchTemplate.createIndex(Item.class); // 配置映射，会根据Item类中的id、Field等字段来自动完成映射 elasticsearchTemplate.putMapping(Item.class); &#125;&#125; 结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445GET /item&#123; "item": &#123; "aliases": &#123;&#125;, "mappings": &#123; "docs": &#123; "properties": &#123; "brand": &#123; "type": "keyword" &#125;, "category": &#123; "type": "keyword" &#125;, "images": &#123; "type": "keyword", "index": false &#125;, "price": &#123; "type": "double" &#125;, "title": &#123; "type": "text", "analyzer": "ik_max_word" &#125; &#125; &#125; &#125;, "settings": &#123; "index": &#123; "refresh_interval": "1s", "number_of_shards": "1", "provided_name": "item", "creation_date": "1525405022589", "store": &#123; "type": "fs" &#125;, "number_of_replicas": "0", "uuid": "4sE9SAw3Sqq1aAPz5F6OEg", "version": &#123; "created": "6020499" &#125; &#125; &#125; &#125;&#125; 删除索引 删除索引的API： 可以根据类名或索引名删除。 示例： 1234@Testpublic void deleteIndex() &#123; esTemplate.deleteIndex("heima");&#125; 结果： Repository文档操作 Spring Data 的强大之处，就在于你不用写任何DAO处理，自动根据方法名或类的信息进行CRUD操作。只要你定义一个接口，然后继承Repository提供的一些子接口，就能具备各种基本的CRUD功能。 我们只需要定义接口，然后继承它就OK了。 12public interface ItemRepository extends ElasticsearchRepository&lt;Item,Long&gt; &#123;&#125; 来看下Repository的继承关系： 我们看到有一个ElasticsearchRepository接口： 新增文档 123456789@Autowiredprivate ItemRepository itemRepository;@Testpublic void index() &#123; Item item = new Item(1L, "小米手机7", " 手机", "小米", 3499.00, "http://image.leyou.com/13123.jpg"); itemRepository.save(item);&#125; 去页面查询看看： 1GET /item/_search 结果： 123456789101112131415161718192021222324252627282930&#123; "took": 14, "timed_out": false, "_shards": &#123; "total": 1, "successful": 1, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1, "hits": [ &#123; "_index": "item", "_type": "docs", "_id": "1", "_score": 1, "_source": &#123; "id": 1, "title": "小米手机7", "category": " 手机", "brand": "小米", "price": 3499, "images": "http://image.leyou.com/13123.jpg" &#125; &#125; ] &#125;&#125; 批量新增 代码： 12345678@Testpublic void indexList() &#123; List&lt;Item&gt; list = new ArrayList&lt;&gt;(); list.add(new Item(2L, "坚果手机R1", " 手机", "锤子", 3699.00, "http://image.leyou.com/123.jpg")); list.add(new Item(3L, "华为META10", " 手机", "华为", 4499.00, "http://image.leyou.com/3.jpg")); // 接收对象集合，实现批量新增 itemRepository.saveAll(list);&#125; 再次去页面查询： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#123; "took": 5, "timed_out": false, "_shards": &#123; "total": 1, "successful": 1, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 3, "max_score": 1, "hits": [ &#123; "_index": "item", "_type": "docs", "_id": "2", "_score": 1, "_source": &#123; "id": 2, "title": "坚果手机R1", "category": " 手机", "brand": "锤子", "price": 3699, "images": "http://image.leyou.com/13123.jpg" &#125; &#125;, &#123; "_index": "item", "_type": "docs", "_id": "3", "_score": 1, "_source": &#123; "id": 3, "title": "华为META10", "category": " 手机", "brand": "华为", "price": 4499, "images": "http://image.leyou.com/13123.jpg" &#125; &#125;, &#123; "_index": "item", "_type": "docs", "_id": "1", "_score": 1, "_source": &#123; "id": 1, "title": "小米手机7", "category": " 手机", "brand": "小米", "price": 3499, "images": "http://image.leyou.com/13123.jpg" &#125; &#125; ] &#125;&#125; 修改文档 修改和新增是同一个接口，区分的依据就是id，这一点跟我们在页面发起PUT请求是类似的。 基本查询 ElasticsearchRepository提供了一些基本的查询方法： 我们来试试查询所有： 123456@Testpublic void testFind()&#123; // 查询全部，并安装价格降序排序 Iterable&lt;Item&gt; items = this.itemRepository.findAll(Sort.by(Sort.Direction.DESC, "price")); items.forEach(item-&gt; System.out.println(item));&#125; 结果： 自定义方法 Spring Data 的另一个强大功能，是根据方法名称自动实现功能。 比如：你的方法名叫做：findByTitle，那么它就知道你是根据title查询，然后自动帮你完成，无需写实现类。 当然，方法名称要符合一定的约定： Keyword Sample Elasticsearch Query String And findByNameAndPrice {&quot;bool&quot; : {&quot;must&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;price&quot; : &quot;?&quot;}} ]}} Or findByNameOrPrice {&quot;bool&quot; : {&quot;should&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;price&quot; : &quot;?&quot;}} ]}} Is findByName {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}} Not findByNameNot {&quot;bool&quot; : {&quot;must_not&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}} Between findByPriceBetween {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} LessThanEqual findByPriceLessThan {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} GreaterThanEqual findByPriceGreaterThan {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} Before findByPriceBefore {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} After findByPriceAfter {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} Like findByNameLike {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true}}}}} StartingWith findByNameStartingWith {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true}}}}} EndingWith findByNameEndingWith {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;*?&quot;,&quot;analyze_wildcard&quot; : true}}}}} Contains/Containing findByNameContaining {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;**?**&quot;,&quot;analyze_wildcard&quot; : true}}}}} In findByNameIn(Collection&lt;String&gt;names) {&quot;bool&quot; : {&quot;must&quot; : {&quot;bool&quot; : {&quot;should&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}} ]}}}} NotIn findByNameNotIn(Collection&lt;String&gt;names) {&quot;bool&quot; : {&quot;must_not&quot; : {&quot;bool&quot; : {&quot;should&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}}}} Near findByStoreNear Not Supported Yet ! True findByAvailableTrue {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : true}}}} False findByAvailableFalse {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : false}}}} OrderBy findByAvailableTrueOrderByNameDesc {&quot;sort&quot; : [{ &quot;name&quot; : {&quot;order&quot; : &quot;desc&quot;} }],&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : true}}}} 例如，我们来按照价格区间查询，定义这样的一个方法： 12345678910public interface ItemRepository extends ElasticsearchRepository&lt;Item,Long&gt; &#123; /** * 根据价格区间查询 * @param price1 * @param price2 * @return */ List&lt;Item&gt; findByPriceBetween(double price1, double price2);&#125; 然后添加一些测试数据： 1234567891011@Testpublic void indexList() &#123; List&lt;Item&gt; list = new ArrayList&lt;&gt;(); list.add(new Item(1L, "小米手机7", "手机", "小米", 3299.00, "http://image.leyou.com/13123.jpg")); list.add(new Item(2L, "坚果手机R1", "手机", "锤子", 3699.00, "http://image.leyou.com/13123.jpg")); list.add(new Item(3L, "华为META10", "手机", "华为", 4499.00, "http://image.leyou.com/13123.jpg")); list.add(new Item(4L, "小米Mix2S", "手机", "小米", 4299.00, "http://image.leyou.com/13123.jpg")); list.add(new Item(5L, "荣耀V10", "手机", "华为", 2799.00, "http://image.leyou.com/13123.jpg")); // 接收对象集合，实现批量新增 itemRepository.saveAll(list);&#125; 不需要写实现类，然后我们直接去运行： 1234567@Testpublic void queryByPriceBetween()&#123; List&lt;Item&gt; list = this.itemRepository.findByPriceBetween(2000.00, 3500.00); for (Item item : list) &#123; System.out.println("item = " + item); &#125;&#125; 结果： 虽然基本查询和自定义方法已经很强大了，但是如果是复杂查询（模糊、通配符、词条查询等）就显得力不从心了。此时，我们只能使用原生查询。 高级查询 基本查询 先看看基本玩法 12345678@Testpublic void testQuery()&#123; // 词条查询 MatchQueryBuilder queryBuilder = QueryBuilders.matchQuery("title", "小米"); // 执行查询 Iterable&lt;Item&gt; items = this.itemRepository.search(queryBuilder); items.forEach(System.out::println);&#125; Repository的search方法需要QueryBuilder参数，elasticSearch为我们提供了一个对象QueryBuilders： QueryBuilders提供了大量的静态方法，用于生成各种不同类型的查询对象，例如：词条、模糊、通配符等QueryBuilder对象。 结果： elasticsearch提供很多可用的查询方式，但是不够灵活。如果想玩过滤或者聚合查询等就很难了。 自定义查询 先来看最基本的match query： 1234567891011121314@Testpublic void testNativeQuery()&#123; // 构建查询条件 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 添加基本的分词查询 queryBuilder.withQuery(QueryBuilders.matchQuery("title", "小米")); // 执行搜索，获取结果 Page&lt;Item&gt; items = this.itemRepository.search(queryBuilder.build()); // 打印总条数 System.out.println(items.getTotalElements()); // 打印总页数 System.out.println(items.getTotalPages()); items.forEach(System.out::println);&#125; NativeSearchQueryBuilder：Spring提供的一个查询条件构建器，帮助构建json格式的请求体 Page&lt;item&gt;：默认是分页查询，因此返回的是一个分页的结果对象，包含属性： totalElements：总条数 totalPages：总页数 Iterator：迭代器，本身实现了Iterator接口，因此可直接迭代得到当前页的数据 其它属性： 结果： 分页查询 利用NativeSearchQueryBuilder可以方便的实现分页： 12345678910111213141516171819202122232425@Testpublic void testNativeQuery()&#123; // 构建查询条件 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 添加基本的分词查询 queryBuilder.withQuery(QueryBuilders.termQuery("category", "手机")); // 初始化分页参数 int page = 0; int size = 3; // 设置分页参数 queryBuilder.withPageable(PageRequest.of(page, size)); // 执行搜索，获取结果 Page&lt;Item&gt; items = this.itemRepository.search(queryBuilder.build()); // 打印总条数 System.out.println(items.getTotalElements()); // 打印总页数 System.out.println(items.getTotalPages()); // 每页大小 System.out.println(items.getSize()); // 当前页 System.out.println(items.getNumber()); items.forEach(System.out::println);&#125; 结果： 可以发现，Elasticsearch中的分页是从第0页开始。 排序 排序也通用通过NativeSearchQueryBuilder完成： 12345678910111213141516@Testpublic void testSort()&#123; // 构建查询条件 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 添加基本的分词查询 queryBuilder.withQuery(QueryBuilders.termQuery("category", "手机")); // 排序 queryBuilder.withSort(SortBuilders.fieldSort("price").order(SortOrder.DESC)); // 执行搜索，获取结果 Page&lt;Item&gt; items = this.itemRepository.search(queryBuilder.build()); // 打印总条数 System.out.println(items.getTotalElements()); items.forEach(System.out::println);&#125; 结果： 聚合 聚合为桶 桶就是分组，比如这里我们按照品牌brand进行分组： 12345678910111213141516171819202122232425@Testpublic void testAgg()&#123; NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 不查询任何结果 queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;""&#125;, null)); // 1、添加一个新的聚合，聚合类型为terms，聚合名称为brands，聚合字段为brand queryBuilder.addAggregation( AggregationBuilders.terms("brands").field("brand")); // 2、查询,需要把结果强转为AggregatedPage类型 AggregatedPage&lt;Item&gt; aggPage = (AggregatedPage&lt;Item&gt;) this.itemRepository.search(queryBuilder.build()); // 3、解析 // 3.1、从结果中取出名为brands的那个聚合， // 因为是利用String类型字段来进行的term聚合，所以结果要强转为StringTerm类型 StringTerms agg = (StringTerms) aggPage.getAggregation("brands"); // 3.2、获取桶 List&lt;StringTerms.Bucket&gt; buckets = agg.getBuckets(); // 3.3、遍历 for (StringTerms.Bucket bucket : buckets) &#123; // 3.4、获取桶中的key，即品牌名称 System.out.println(bucket.getKeyAsString()); // 3.5、获取桶中的文档数量 System.out.println(bucket.getDocCount()); &#125;&#125; 显示的结果： 关键API： AggregationBuilders：聚合的构建工厂类。所有聚合都由这个类来构建，看看他的静态方法： AggregatedPage：聚合查询的结果类。它是Page&lt;T&gt;的子接口： AggregatedPage在Page功能的基础上，拓展了与聚合相关的功能，它其实就是对聚合结果的一种封装，大家可以对照聚合结果的JSON结构来看。 而返回的结果都是Aggregation类型对象，不过根据字段类型不同，又有不同的子类表示 我们看下页面的查询的JSON结果与Java类的对照关系： 嵌套聚合，求平均值 代码： 1234567891011121314151617181920212223242526272829@Testpublic void testSubAgg()&#123; NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 不查询任何结果 queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;""&#125;, null)); // 1、添加一个新的聚合，聚合类型为terms，聚合名称为brands，聚合字段为brand queryBuilder.addAggregation( AggregationBuilders.terms("brands").field("brand") .subAggregation(AggregationBuilders.avg("priceAvg").field("price")) // 在品牌聚合桶内进行嵌套聚合，求平均值 ); // 2、查询,需要把结果强转为AggregatedPage类型 AggregatedPage&lt;Item&gt; aggPage = (AggregatedPage&lt;Item&gt;) this.itemRepository.search(queryBuilder.build()); // 3、解析 // 3.1、从结果中取出名为brands的那个聚合， // 因为是利用String类型字段来进行的term聚合，所以结果要强转为StringTerm类型 StringTerms agg = (StringTerms) aggPage.getAggregation("brands"); // 3.2、获取桶 List&lt;StringTerms.Bucket&gt; buckets = agg.getBuckets(); // 3.3、遍历 for (StringTerms.Bucket bucket : buckets) &#123; // 3.4、获取桶中的key，即品牌名称 3.5、获取桶中的文档数量 System.out.println(bucket.getKeyAsString() + "，共" + bucket.getDocCount() + "台"); // 3.6.获取子聚合结果： InternalAvg avg = (InternalAvg) bucket.getAggregations().asMap().get("priceAvg"); System.out.println("平均售价：" + avg.getValue()); &#125;&#125; 结果：]]></content>
  </entry>
  <entry>
    <title><![CDATA[day10-商品管理]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F27%2Fday10-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[学习目标 独立实现商品新增后台 独立实现商品编辑后台 独立搭建前台系统页面 商品新增 当我们点击新增商品按钮： 就会出现一个弹窗： 里面把商品的数据分为了4部分来填写： 基本信息：主要是一些简单的文本数据，包含了SPU和SpuDetail的部分数据，如 商品分类：是SPU中的cid1，cid2，cid3属性 品牌：是spu中的brandId属性 标题：是spu中的title属性 子标题：是spu中的subTitle属性 售后服务：是SpuDetail中的afterService属性 包装列表：是SpuDetail中的packingList属性 商品描述：是SpuDetail中的description属性，数据较多，所以单独放一个页面 规格参数：商品规格信息，对应SpuDetail中的genericSpec属性 SKU属性：spu下的所有Sku信息 对应到页面中的四个stepper-content： 弹窗事件 弹窗是一个独立组件： 并且在Goods组件中已经引用它： 并且在页面中渲染： 在新增商品按钮的点击事件中，改变这个dialog的show属性： 基本数据 我们先来看下基本数据： 商品分类 商品分类信息查询我们之前已经做过，所以这里的级联选框已经实现完成： 刷新页面，可以看到请求已经发出： 效果： 品牌选择 页面 品牌也是一个下拉选框，不过其选项是不确定的，只有当用户选择了商品分类，才会把这个分类下的所有品牌展示出来。 所以页面编写了watch函数，监控商品分类的变化，每当商品分类值有变化，就会发起请求，查询品牌列表： 选择商品分类后，可以看到请求发起： 接下来，我们只要编写后台接口，根据商品分类id，查询对应品牌即可。 后台接口 页面需要去后台查询品牌信息，我们自然需要提供： 请求方式：GET 请求路径：/brand/cid/{cid} 请求参数：cid 响应数据：品牌集合 BrandController 12345678910111213141516/** * 根据分类查询品牌 * @param cid * @return */@GetMapping("cid/&#123;cid&#125;")public ResponseEntity&lt;List&lt;Brand&gt;&gt; queryBrandListByCid(@PathVariable("cid")Long cid)&#123; List&lt;Brand&gt; brandList = this.brandService.queryByCid(cid); if(CollectionUtils.isEmpty(brandList))&#123; // 响应404 return ResponseEntity.badRequest().build(); &#125; // 响应200 return ResponseEntity.ok(brandList);&#125; BrandService 123public List&lt;Brand&gt; queryBrandByCategory(Long cid) &#123; return this.brandMapper.queryByCategoryId(cid);&#125; BrandMapper 根据分类查询品牌有中间表，需要自己编写Sql： 12@Select("SELECT b.* FROM tb_brand b LEFT JOIN tb_category_brand cb ON b.id = cb.brand_id WHERE cb.category_id = #&#123;cid&#125;")List&lt;Brand&gt; queryByCategoryId(Long cid); 效果： 其它文本框 剩余的几个属性：标题、子标题等都是普通文本框，我们直接填写即可，没有需要特别注意的。 商品描述 商品描述信息比较复杂，而且图文并茂，甚至包括视频。 这样的内容，一般都会使用富文本编辑器。 什么是富文本编辑器 百度百科： 通俗来说：富文本，就是比较丰富的文本编辑器。普通的框只能输入文字，而富文本还能给文字加颜色样式等。 富文本编辑器有很多，例如：KindEditor、Ueditor。但并不原生支持vue 但是我们今天要说的，是一款支持Vue的富文本编辑器：vue-quill-editor Vue-Quill-Editor GitHub的主页：https://github.com/surmon-china/vue-quill-editor Vue-Quill-Editor是一个基于Quill的富文本编辑器：Quill的官网 使用指南 使用非常简单： 第一步：安装，使用npm命令： 1npm install vue-quill-editor --save 第二步：加载，在js中引入： 全局引入： 123456import Vue from 'vue'import VueQuillEditor from 'vue-quill-editor'const options = &#123;&#125;; /* &#123; default global options &#125; */Vue.use(VueQuillEditor, options); // options可选 局部引入： 1234567891011import 'quill/dist/quill.core.css'import 'quill/dist/quill.snow.css'import 'quill/dist/quill.bubble.css'import &#123;quillEditor&#125; from 'vue-quill-editor'var vm = new Vue(&#123; components:&#123; quillEditor &#125;&#125;) 我们这里采用局部引用： 第三步：页面使用： 1&lt;quill-editor v-model="goods.spuDetail.description" :options="editorOption"/&gt; 自定义的富文本编辑器 不过这个组件有个小问题，就是图片上传的无法直接上传到后台，因此我们对其进行了封装，支持了图片的上传。 使用也非常简单： 123&lt;v-stepper-content step="2"&gt; &lt;v-editor v-model="goods.spuDetail.description" upload-url="/upload/image"/&gt;&lt;/v-stepper-content&gt; upload-url：是图片上传的路径 v-model：双向绑定，将富文本编辑器的内容绑定到goods.spuDetail.description 效果 商品规格参数 规格参数的查询我们之前也已经编写过接口，因为商品规格参数也是与商品分类绑定，所以需要在商品分类变化后去查询，我们也是通过watch监控来实现： 可以看到这里是根据商品分类id查询规格参数：SpecParam。我们之前写过一个根据gid（分组id）来查询规格参数的接口，我们接下来完成根据分类id查询规格参数。 改造查询规格参数接口 我们在原来的根据 gid（规格组id)查询规格参数的接口上，添加一个参数：cid，即商品分类id。 等一下， 考虑到以后可能还会根据是否搜索、是否为通用属性等条件过滤，我们多添加几个过滤条件： 1234567891011121314@GetMapping("/params")public ResponseEntity&lt;List&lt;SpecParam&gt;&gt; querySpecParam( @RequestParam(value="gid", required = false) Long gid, @RequestParam(value="cid", required = false) Long cid, @RequestParam(value="searching", required = false) Boolean searching, @RequestParam(value="generic", required = false) Boolean generic )&#123; List&lt;SpecParam&gt; list = this.specificationService.querySpecParams(gid,cid,searching,generic); if(list == null || list.size() == 0)&#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(list); &#125; 改造service： 12345678public List&lt;SpecParam&gt; querySpecParams(Long gid, Long cid, Boolean searching, Boolean generic) &#123; SpecParam param = new SpecParam(); param.setGroupId(gid); param.setCid(cid); param.setSearching(searching); param.setGeneric(generic); return this.specParamMapper.select(param);&#125; 如果param中有属性为null，则不会吧属性作为查询条件，因此该方法具备通用性，即可根据gid查询，也可根据cid查询。 测试： 刷新页面测试： SKU信息 Sku属性是SPU下的每个商品的不同特征，如图： 当我们填写一些属性后，会在页面下方生成一个sku表格，大家可以计算下会生成多少个不同属性的Sku呢？ 当你选择了上图中的这些选项时： 颜色共2种：迷夜黑，勃艮第红，绚丽蓝 内存共2种：4GB，6GB 机身存储1种：64GB，128GB 此时会产生多少种SKU呢？ 应该是 3 * 2 * 2 = 12种，这其实就是在求笛卡尔积。 我们会在页面下方生成一个sku的表格： 页面表单提交 在sku列表的下方，有一个提交按钮： 并且绑定了点击事件： 点击后会组织数据并向后台提交： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465submit() &#123; // 表单校验。 if(!this.$refs.basic.validate)&#123; this.$message.error("请先完成表单内容！"); &#125; // 先处理goods，用结构表达式接收,除了categories外，都接收到goodsParams中 const &#123; categories: [&#123; id: cid1 &#125;, &#123; id: cid2 &#125;, &#123; id: cid3 &#125;], ...goodsParams &#125; = this.goods; // 处理规格参数 const specs = &#123;&#125;; this.specs.forEach((&#123; id,v &#125;) =&gt; &#123; specs[id] = v; &#125;); // 处理特有规格参数模板 const specTemplate = &#123;&#125;; this.specialSpecs.forEach((&#123; id, options &#125;) =&gt; &#123; specTemplate[id] = options; &#125;); // 处理sku const skus = this.skus .filter(s =&gt; s.enable) .map((&#123; price, stock, enable, images, indexes, ...rest &#125;) =&gt; &#123; // 标题，在spu的title基础上，拼接特有规格属性值 const title = goodsParams.title + " " + Object.values(rest).map(v =&gt; v.v).join(" "); const obj = &#123;&#125;; Object.values(rest).forEach(v =&gt; &#123; obj[v.id] = v.v; &#125;); return &#123; price: this.$format(price), // 价格需要格式化 stock, indexes, enable, title, // 基本属性 images: images ? images.join(",") : '', // 图片 ownSpec: JSON.stringify(obj) // 特有规格参数 &#125;; &#125;); Object.assign(goodsParams, &#123; cid1, cid2, cid3, // 商品分类 skus // sku列表 &#125;); goodsParams.spuDetail.genericSpec = JSON.stringify(specs); goodsParams.spuDetail.specialSpec = JSON.stringify(specTemplate); // 提交到后台 this.$http(&#123; method: this.isEdit ? "put" : "post", url: "/item/goods", data: goodsParams &#125;) .then(() =&gt; &#123; // 成功，关闭窗口 this.$emit("close"); // 提示成功 this.$message.success("保存成功了"); &#125;) .catch(() =&gt; &#123; this.$message.error("保存失败！"); &#125;);&#125; 点击提交，查看控制台提交的数据格式： 整体是一个json格式数据，包含Spu表所有数据： brandId：品牌id cid1、cid2、cid3：商品分类id subTitle：副标题 title：标题 spuDetail：是一个json对象，代表商品详情表数据 afterService：售后服务 description：商品描述 packingList：包装列表 specialSpec：sku规格属性模板 genericSpec：通用规格参数 skus：spu下的所有sku数组，元素是每个sku对象： title：标题 images：图片 price：价格 stock：库存 ownSpec：特有规格参数 indexes：特有规格参数的下标 后台实现 实体类 SPU和SpuDetail实体类已经添加过，添加Sku和Stock对象： Sku 1234567891011121314151617@Table(name = "tb_sku")public class Sku &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long spuId; private String title; private String images; private Long price; private String ownSpec;// 商品特殊规格的键值对 private String indexes;// 商品特殊规格的下标 private Boolean enable;// 是否有效，逻辑删除用 private Date createTime;// 创建时间 private Date lastUpdateTime;// 最后修改时间 @Transient private Integer stock;// 库存&#125; 注意：这里保存了一个库存字段，在数据库中是另外一张表保存的，方便查询。 Stock 12345678@Table(name = "tb_stock")public class Stock &#123; @Id private Long skuId; private Integer seckillStock;// 秒杀可用库存 private Integer seckillTotal;// 已秒杀数量 private Integer stock;// 正常库存&#125; GoodsController 请求方式：POST 请求路径：/goods 请求参数：Spu的json格式的对象，spu中包含spuDetail和Sku集合。这里我们该怎么接收？我们之前定义了一个SpuBo对象，作为业务对象。这里也可以用它，不过需要再扩展spuDetail和skus字段： 1234567891011public class SpuBo extends Spu &#123; @Transient String cname;// 商品分类名称 @Transient String bname;// 品牌名称 @Transient SpuDetail spuDetail;// 商品详情 @Transient List&lt;Sku&gt; skus;// sku列表&#125; 返回类型：无 代码： 123456789101112131415/** * 新增商品 * @param spu * @return */@PostMappingpublic ResponseEntity&lt;Void&gt; saveGoods(@RequestBody SpuBo spuBo) &#123; try &#123; this.goodsService.save(spu); return new ResponseEntity&lt;&gt;(HttpStatus.CREATED); &#125; catch (Exception e) &#123; e.printStackTrace(); return new ResponseEntity&lt;&gt;(HttpStatus.INTERNAL_SERVER_ERROR); &#125;&#125; 注意：通过@RequestBody注解来接收Json请求 GoodsService 这里的逻辑比较复杂，我们除了要对SPU新增以外，还要对SpuDetail、Sku、Stock进行保存 1234567891011121314151617181920212223242526272829303132333435@Transactionalpublic void save(SpuBo spu) &#123; // 保存spu spu.setSaleable(true); spu.setValid(true); spu.setCreateTime(new Date()); spu.setLastUpdateTime(spu.getCreateTime()); this.spuMapper.insert(spu); // 保存spu详情 spu.getSpuDetail().setSpuId(spu.getId()); this.spuDetailMapper.insert(spu.getSpuDetail()); // 保存sku和库存信息 saveSkuAndStock(spu.getSkus(), spu.getId());&#125;private void saveSkuAndStock(List&lt;Sku&gt; skus, Long spuId) &#123; for (Sku sku : skus) &#123; if (!sku.getEnable()) &#123; continue; &#125; // 保存sku sku.setSpuId(spuId); // 初始化时间 sku.setCreateTime(new Date()); sku.setLastUpdateTime(sku.getCreateTime()); this.skuMapper.insert(sku); // 保存库存信息 Stock stock = new Stock(); stock.setSkuId(sku.getId()); stock.setStock(sku.getStock()); this.stockMapper.insert(stock); &#125;&#125; Mapper 都是通用Mapper，略 目录结构： 商品修改 编辑按钮点击事件 在商品详情页，每一个商品后面，都会有一个编辑按钮： 点击这个按钮，就会打开一个商品编辑窗口，我们看下它所绑定的点击事件： 对应的方法： 可以看到这里发起了两个请求，在查询商品详情和sku信息。 因为在商品列表页面，只有spu的基本信息：id、标题、品牌、商品分类等。比较复杂的商品详情（spuDetail)和sku信息都没有，编辑页面要回显数据，就需要查询这些内容。 因此，接下来我们就编写后台接口，提供查询服务接口。 查询SpuDetail接口 GoodsController 需要分析的内容： 请求方式：GET 请求路径：/spu/detail/{id} 请求参数：id，应该是spu的id 返回结果：SpuDetail对象 12345678@GetMapping("/spu/detail/&#123;id&#125;")public ResponseEntity&lt;SpuDetail&gt; querySpuDetailById(@PathVariable("id") Long id) &#123; SpuDetail detail = this.goodsService.querySpuDetailById(id); if (detail == null) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(detail);&#125; GoodsService 123public SpuDetail querySpuDetailById(Long id) &#123; return this.spuDetailMapper.selectByPrimaryKey(id);&#125; 测试 查询sku 分析 请求方式：Get 请求路径：/sku/list 请求参数：id，应该是spu的id 返回结果：sku的集合 GoodsController 12345678@GetMapping("sku/list")public ResponseEntity&lt;List&lt;Sku&gt;&gt; querySkuBySpuId(@RequestParam("id") Long id) &#123; List&lt;Sku&gt; skus = this.goodsService.querySkuBySpuId(id); if (skus == null || skus.size() == 0) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(skus);&#125; GoodsService 需要注意的是，为了页面回显方便，我们一并把sku的库存stock也查询出来 1234567891011public List&lt;Sku&gt; querySkuBySpuId(Long spuId) &#123; // 查询sku Sku record = new Sku(); record.setSpuId(spuId); List&lt;Sku&gt; skus = this.skuMapper.select(record); for (Sku sku : skus) &#123; // 同时查询出库存 sku.setStock(this.stockMapper.selectByPrimaryKey(sku.getId()).getStock()); &#125; return skus;&#125; 测试： 页面回显 随便点击一个编辑按钮，发现数据回显完成： 页面提交 这里的保存按钮与新增其实是同一个，因此提交的逻辑也是一样的，这里不再赘述。 随便修改点数据，然后点击保存，可以看到浏览器已经发出请求： 后台实现 接下来，我们编写后台，实现修改商品接口。 Controller 请求方式：PUT 请求路径：/ 请求参数：Spu对象 返回结果：无 123456789101112131415/** * 新增商品 * @param spu * @return */@PutMappingpublic ResponseEntity&lt;Void&gt; updateGoods(@RequestBody SpuBo spu) &#123; try &#123; this.goodsService.update(spu); return new ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT); &#125; catch (Exception e) &#123; e.printStackTrace(); return new ResponseEntity&lt;&gt;(HttpStatus.INTERNAL_SERVER_ERROR); &#125;&#125; Service spu数据可以修改，但是SKU数据无法修改，因为有可能之前存在的SKU现在已经不存在了，或者以前的sku属性都不存在了。比如以前内存有4G，现在没了。 因此这里直接删除以前的SKU，然后新增即可。 代码： 12345678910111213141516171819202122232425262728293031@Transactionalpublic void update(SpuBo spu) &#123; // 查询以前sku List&lt;Sku&gt; skus = this.querySkuBySpuId(spu.getId()); // 如果以前存在，则删除 if(!CollectionUtils.isEmpty(skus)) &#123; List&lt;Long&gt; ids = skus.stream().map(s -&gt; s.getId()).collect(Collectors.toList()); // 删除以前库存 Example example = new Example(Stock.class); example.createCriteria().andIn("skuId", ids); this.stockMapper.deleteByExample(example); // 删除以前的sku Sku record = new Sku(); record.setSpuId(spu.getId()); this.skuMapper.delete(record); &#125; // 新增sku和库存 saveSkuAndStock(spu.getSkus(), spu.getId()); // 更新spu spu.setLastUpdateTime(new Date()); spu.setCreateTime(null); spu.setValid(null); spu.setSaleable(null); this.spuMapper.updateByPrimaryKeySelective(spu); // 更新spu详情 this.spuDetailMapper.updateByPrimaryKeySelective(spu.getSpuDetail());&#125; mapper 与以前一样。 其它 商品的删除、上下架大家自行实现。 搭建前台系统 后台系统的内容暂时告一段落，有了商品，接下来我们就要在页面展示商品，给用户提供浏览和购买的入口，那就是我们的门户系统。 门户系统面向的是用户，安全性很重要，而且搜索引擎对于单页应用并不友好。因此我们的门户系统不再采用与后台系统类似的SPA（单页应用）。 依然是前后端分离，不过前端的页面会使用独立的html，在每个页面中使用vue来做页面渲染。 静态资源 webpack打包多页应用配置比较繁琐，项目结构也相对复杂。这里为了简化开发（毕竟我们不是专业的前端人员），我们不再使用webpack，而是直接编写原生的静态HTML。 创建工程 创建一个新的工程： 导入静态资源 将课前资料中的leyou-portal解压，并复制到这个项目下 解压缩： 项目结构： live-server 没有webpack，我们就无法使用webpack-dev-server运行这个项目，实现热部署。 所以，这里我们使用另外一种热部署方式：live-server， 简介 地址；https://www.npmjs.com/package/live-server 这是一款带有热加载功能的小型开发服务器。用它来展示你的HTML / JavaScript / CSS，但不能用于部署最终的网站。 安装和运行参数 安装，使用npm命令即可，这里建议全局安装，以后任意位置可用 1npm install -g live-server 运行时，直接输入命令： 1live-server 另外，你可以在运行命令后，跟上一些参数以配置： --port=NUMBER - 选择要使用的端口，默认值：PORT env var或8080 --host=ADDRESS - 选择要绑定的主机地址，默认值：IP env var或0.0.0.0（“任意地址”） --no-browser - 禁止自动Web浏览器启动 --browser=BROWSER - 指定使用浏览器而不是系统默认值 --quiet | -q - 禁止记录 --verbose | -V - 更多日志记录（记录所有请求，显示所有侦听的IPv4接口等） --open=PATH - 启动浏览器到PATH而不是服务器root --watch=PATH - 用逗号分隔的路径来专门监视变化（默认值：观看所有内容） --ignore=PATH- 要忽略的逗号分隔的路径字符串（anymatch -compatible definition） --ignorePattern=RGXP-文件的正则表达式忽略（即.*\.jade）（不推荐使用赞成--ignore） --middleware=PATH - 导出要添加的中间件功能的.js文件的路径; 可以是没有路径的名称，也可以是引用middleware文件夹中捆绑的中间件的扩展名 --entry-file=PATH - 提供此文件（服务器根目录）代替丢失的文件（对单页应用程序有用） --mount=ROUTE:PATH - 在定义的路线下提供路径内容（可能有多个定义） --spa - 将请求从/ abc转换为/＃/ abc（方便单页应用） --wait=MILLISECONDS - （默认100ms）等待所有更改，然后重新加载 --htpasswd=PATH - 启用期待位于PATH的htpasswd文件的http-auth --cors - 为任何来源启用CORS（反映请求源，支持凭证的请求） --https=PATH - 到HTTPS配置模块的路径 --proxy=ROUTE:URL - 代理ROUTE到URL的所有请求 --help | -h - 显示简洁的使用提示并退出 --version | -v - 显示版本并退出 测试 我们进入leyou-portal目录，输入命令： 1live-server --port=9002 域名访问 现在我们访问只能通过：http://127.0.0.1:9002 我们希望用域名访问：http://www.leyou.com 第一步，修改hosts文件，添加一行配置： 1127.0.0.1 www.leyou.com 第二步，修改nginx配置，将www.leyou.com反向代理到127.0.0.1:9002 1234567891011121314server &#123; listen 80; server_name www.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://127.0.0.1:9002; proxy_connect_timeout 600; proxy_read_timeout 600; &#125;&#125; 重新加载nginx配置：nginx.exe -s reload common.js 为了方便后续的开发，我们在前台系统中定义了一些工具，放在了common.js中： 部分代码截图： 首先对axios进行了一些全局配置，请求超时时间，请求的基础路径，是否允许跨域操作cookie等 定义了对象 ly ，也叫leyou，包含了下面的属性： getUrlParam(key)：获取url路径中的参数 http：axios对象的别名。以后发起ajax请求，可以用ly.http.get() store：localstorage便捷操作，后面用到再详细说明 formatPrice：格式化价格，如果传入的是字符串，则扩大100被并转为数字，如果传入是数字，则缩小100倍并转为字符串 formatDate(val, pattern)：对日期对象val按照指定的pattern模板进行格式化 stringify：将对象转为参数字符串 parse：将参数字符串变为js对象]]></content>
  </entry>
  <entry>
    <title><![CDATA[day09-商品规格管理]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F27%2Fday09-%E5%95%86%E5%93%81%E8%A7%84%E6%A0%BC%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[学习目标 了解商品规格数据结构设计思路 实现商品规格查询 了解SPU和SKU数据结构设计思路 实现商品查询 了解商品新增的页面实现 独立编写商品新增后台功能 商品规格数据结构 乐优商城是一个全品类的电商网站，因此商品的种类繁多，每一件商品，其属性又有差别。为了更准确描述商品及细分差别，抽象出两个概念：SPU和SKU，了解一下： SPU和SKU SPU：Standard Product Unit （标准产品单位） ，一组具有共同属性的商品集 SKU：Stock Keeping Unit（库存量单位），SPU商品集因具体特性不同而细分的每个商品 以图为例来看： 本页的 华为Mate10 就是一个商品集（SPU） 因为颜色、内存等不同，而细分出不同的Mate10，如亮黑色128G版。（SKU） 可以看出： SPU是一个抽象的商品集概念，为了方便后台的管理。 SKU才是具体要销售的商品，每一个SKU的价格、库存可能会不一样，用户购买的是SKU而不是SPU 数据库设计分析 思考并发现问题 弄清楚了SPU和SKU的概念区分，接下来我们一起思考一下该如何设计数据库表。 首先来看SPU，大家一起思考下SPU应该有哪些字段来描述？ 123456789id:主键title：标题description：描述specification：规格packaging_list：包装after_service：售后服务comment：评价category_id：商品分类brand_id：品牌 似乎并不复杂，但是大家仔细思考一下，商品的规格字段你如何填写？ 不同商品的规格不一定相同，数据库中要如何保存？ 再看下SKU，大家觉得应该有什么字段？ 12345678id：主键spu_id：关联的spuprice：价格images：图片stock：库存颜色？内存？硬盘？ 碰到难题了，不同的商品分类，可能属性是不一样的，比如手机有内存，衣服有尺码，我们是全品类的电商网站，这些不同的商品的不同属性，如何设计到一张表中？ 分析规格参数 仔细查看每一种商品的规格你会发现： 虽然商品规格千变万化，但是同一类商品（如手机）的规格是统一的，有图为证： 华为的规格： 三星的规格： 也就是说，商品的规格参数应该是与分类绑定的。每一个分类都有统一的规格参数模板，但不同商品其参数值可能不同。 如下图所示： SKU的特有属性 SPU中会有一些特殊属性，用来区分不同的SKU，我们称为SKU特有属性。如华为META10的颜色、内存属性。 不同种类的商品，一个手机，一个衣服，其SKU属性不相同。 同一种类的商品，比如都是衣服，SKU属性基本是一样的，都是颜色、尺码等。 这样说起来，似乎SKU的特有属性也是与分类相关的？事实上，仔细观察你会发现，SKU的特有属性是商品规格参数的一部分： 也就是说，我们没必要单独对SKU的特有属性进行设计，它可以看做是规格参数中的一部分。这样规格参数中的属性可以标记成两部分： 所有sku共享的规格属性（称为全局属性） 每个sku不同的规格属性（称为特有属性） 搜索属性 打开一个搜索页，我们来看看过滤的条件： 你会发现，过滤条件中的屏幕尺寸、运行内存、网路、机身内存、电池容量、CPU核数等，在规格参数中都能找到： 也就是说，规格参数中的数据，将来会有一部分作为搜索条件来使用。我们可以在设计时，将这部分属性标记出来，将来做搜索的时候，作为过滤条件。要注意的是，无论是SPU的全局属性，还是SKU的特有属性，都有可能作为搜索过滤条件的，并不冲突，而是有一个交集： 规格参数表 表结构 先看下规格参数表： 12345CREATE TABLE `tb_specification` ( `category_id` bigint(20) NOT NULL COMMENT &apos;规格模板所属商品分类id&apos;, `specifications` varchar(3000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;规格参数模板，json格式&apos;, PRIMARY KEY (`category_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;商品规格参数模板，json格式。&apos;; 很奇怪是吧，只有两个字段。特别需要注意的是第二个字段： specificatons：规格参数模板，json格式 为什么是一个json？我们看下规格参数的格式： 如果按照传统数据库设计，这里至少需要3张表： group：代表组，与商品分类关联 param_key：属性名，与组关联，一对多 param_value：属性备选值，与属性名关联，一对多 这样程序的复杂度大大增加，但是提高了数据的复用性。 我们的解决方案是，采用json来保存整个规格参数模板，不需要额外的表，一个字符串就够了。 json结构分析 先整体看一下： 因为规格参数分为很多组，所以json最外层是一个数组。 数组中是对象类型，每个对象代表一个组的数据，对象的属性包括： group：组的名称 params：该组的所有属性 接下来是params： 以主芯片这一组为例： group：注明，这里是主芯片 params：该组的所有规格属性，因为不止一个，所以是一个数组。这里包含四个规格属性：CPU品牌，CPU型号，CPU频率，CPU核数。每个规格属性都是一个对象，包含以下信息： k：属性名称 searchable：是否作为搜索字段，将来在搜索页面使用，boolean类型 global：是否是SPU全局属性，boolean类型。true为全局属性，false为SKU的特有属性 options：属性值的可选项，数组结构。起约束作用，不允许填写可选项以外的值，比如CPU核数，有人添10000核岂不是很扯淡 numerical：是否为数值，boolean类型，true则为数值，false则不是。为空也代表非数值 unit：单位，如：克，毫米。如果是数值类型，那么就需要有单位，否则可以不填。 上面的截图中所有属性都是全局属性，我们来看看内存，应该是特有属性： 总结下： 规格参数分组，每组有多个参数 参数的 k代表属性名称，没有值，具体的SPU才能确定值 参数会有不同的属性：是否可搜索，是否是全局、是否是数值，这些都用boolean值进行标记： SPU下的多个SKU共享的参数称为全局属性，用global标记 SPU下的多个SKU特有的参数称为特有属性 如果参数是数值类型，用numerical标记，并且指定单位unit 如果参数可搜索，用searchable标记 商品规格参数管理 页面实现 页面比较复杂，这里就不带着大家去实现完整页面效果了，我们一起分析一下即可。 整体布局 打开规格参数页面，看到如下内容： 因为规格是跟商品分类绑定的，因此首先会展现商品分类树，并且提示你要选择商品分类，才能看到规格参数的模板。一起了解下页面的实现： 可以看出页面分成3个部分： v-card-title：标题部分，这里是提示信息，告诉用户要先选择分类，才能看到模板 v-tree：这里用到的是我们之前讲过的树组件，展示商品分类树，不过现在是假数据，我们只要把treeData属性删除，它就会走url属性指定的路径去查询真实的商品分类树了。 1&lt;v-tree url="/item/category/list" :isEdit="false" @handleClick="handleClick" /&gt; v-dialog：Vuetify提供的对话框组件，v-model绑定的dialog属性是boolean类型： true则显示弹窗 false则隐藏弹窗 data中定义的属性 接下来，看看Vue实例中data定义了哪些属性，对页面会产生怎样的影响： specifications：选中一个商品分类后，需要查询后台获取规格参数信息，保存在这个对象中，Vue会完成页面渲染。 oldSpec：当前页兼具了规格的增、改、查等功能，这个对象记录被修改前的规格参数，以防用户撤销修改，用来恢复数据。 dialog：是否显示对话框的标记。true则显示，false则不显示 currentNode：记录当前选中的商品分类节点 isInsert：判断接下来是新增还是修改 规格参数的查询 点击树节点后要显示规格参数，因此查询功能应该编写在点击事件中。 了解一下： 树节点的点击事件 当我们点击树节点时，要将v-dialog打开，因此必须绑定一个点击事件： 我们来看下handleClick方法： 1234567891011121314151617181920212223242526272829303132handleClick(node) &#123; // 判断点击的节点是否是父节点（只有点击到叶子节点才会弹窗） if (!node.isParent) &#123; // 如果是叶子节点，那么就发起ajax请求，去后台查询商品规格数据。 this.$http.get("/item/spec/" + node.id) .then(resp =&gt; &#123; // 查询成功后，把响应结果赋值给specifications属性，Vue会进行自动渲染。 this.specifications = resp.data; // 记录下此时的规格数据，当页面撤销修改时，用来恢复原始数据 this.oldSpec = resp.data; // 打开弹窗 this.dialog = true; // 标记此时要进行修改操作 this.isInsert = false; &#125;) .catch(() =&gt; &#123; // 如果没有查询成功，那么询问是否添加规格 this.$message.confirm('该分类还没有规格参数，是否添加?') .then(() =&gt; &#123; // 如果要添加，则将specifications初始化为空 this.specifications = [&#123; group: '', params: [] &#125;]; // 打开弹窗 this.dialog = true; // 标记为新增 this.isInsert = true; &#125;) &#125;) &#125;&#125; 因此，我们接下来要做的事情，就是编写接口，实现规格参数的查询了。 后端代码 实体类 1234567891011121314151617181920212223@Table(name = "tb_specification")public class Specification &#123; @Id private Long categoryId; private String specifications; public Long getCategoryId() &#123; return categoryId; &#125; public void setCategoryId(Long categoryId) &#123; this.categoryId = categoryId; &#125; public String getSpecifications() &#123; return specifications; &#125; public void setSpecifications(String specifications) &#123; this.specifications = specifications; &#125;&#125; mapper 12public interface SpecificationMapper extends Mapper&lt;Specification&gt; &#123;&#125; controller 先分析下需要的东西，在页面的ajax请求中可以看出： 请求方式：查询，肯定是get 请求路径：/spec/{cid} ，这里通过路径占位符传递商品分类的id 请求参数：商品分类id 返回结果：页面是直接把resp.data赋值给了specifications： 那么我们返回的应该是规格参数的字符串 代码： 12345678910111213141516@RestController@RequestMapping("spec")public class SpecificationController &#123; @Autowired private SpecificationService specificationService; @GetMapping("&#123;id&#125;") public ResponseEntity&lt;String&gt; querySpecificationByCategoryId(@PathVariable("id") Long id)&#123; Specification spec = this.specificationService.queryById(id); if (spec == null) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(spec.getSpecifications()); &#125;&#125; service: 12345678910@Servicepublic class SpecificationService &#123; @Autowired private SpecificationMapper specificationMapper; public Specification queryById(Long id) &#123; return this.specificationMapper.selectByPrimaryKey(id); &#125;&#125; 页面访问测试： 目前，我们数据库只提供了3条规格参数信息： 我们访问：http://api.leyou.com/api/item/spec/76 然后在后台系统中测试： 当我们点击一个还不存在的规格参数的商品分类： 增、删、改（作业） 增删改的作业就留给大家去完成了。页面中接口都已定义，你要做的就是实现后台接口。 SPU和SKU数据结构 规格确定以后，就可以添加商品了,先看下数据库表 SPU表 表结构 SPU表： 1234567891011121314CREATE TABLE `tb_spu` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;spu id&apos;, `title` varchar(255) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;标题&apos;, `sub_title` varchar(255) DEFAULT &apos;&apos; COMMENT &apos;子标题&apos;, `cid1` bigint(20) NOT NULL COMMENT &apos;1级类目id&apos;, `cid2` bigint(20) NOT NULL COMMENT &apos;2级类目id&apos;, `cid3` bigint(20) NOT NULL COMMENT &apos;3级类目id&apos;, `brand_id` bigint(20) NOT NULL COMMENT &apos;商品所属品牌id&apos;, `saleable` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;是否上架，0下架，1上架&apos;, `valid` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;是否有效，0已删除，1有效&apos;, `create_time` datetime DEFAULT NULL COMMENT &apos;添加时间&apos;, `last_update_time` datetime DEFAULT NULL COMMENT &apos;最后修改时间&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=208 DEFAULT CHARSET=utf8 COMMENT=&apos;spu表，该表描述的是一个抽象的商品，比如 iphone8&apos;; 与我们前面分析的基本类似，但是似乎少了一些字段，比如商品描述。 我们做了表的垂直拆分，将SPU的详情放到了另一张表：tb_spu_detail 123456789CREATE TABLE `tb_spu_detail` ( `spu_id` bigint(20) NOT NULL, `description` text COMMENT &apos;商品描述信息&apos;, `specifications` varchar(3000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;全部规格参数数据&apos;, `spec_template` varchar(1000) NOT NULL COMMENT &apos;特有规格参数及可选值信息，json格式&apos;, `packing_list` varchar(1000) DEFAULT &apos;&apos; COMMENT &apos;包装清单&apos;, `after_service` varchar(1000) DEFAULT &apos;&apos; COMMENT &apos;售后服务&apos;, PRIMARY KEY (`spu_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 这张表中的数据都比较大，为了不影响主表的查询效率我们拆分出这张表。 需要注意的是这两个字段：specifications和spec_template。 spu中的规格参数 前面讲过规格参数与商品分类绑定，一个分类下的所有SPU具有类似的规格参数。SPU下的SKU可能会有不同的规格参数，因此我们计划是这样： SPU中保存全局的规格参数信息。 SKU中保存特有规格参数。 以手机为例，品牌、操作系统等肯定是全局属性，内存、颜色等肯定是特有属性。 当你确定了一个SPU，比如小米的：红米4X 全局属性举例： 12品牌：小米型号：红米4X 特有属性举例： 123颜色：[香槟金, 樱花粉, 磨砂黑]内存：[2G, 3G]机身存储：[16GB, 32GB] 来看下我们的 表如何存储这些信息： specifications字段 首先是specifications，其中保存全部规格参数信息，因此也是一个json格式： 整体来看： 整体看上去与规格参数表中的数据一样，也是一个数组，并且分组，每组下有多个参数 展开一组来看 可以看到，与规格参数表中的模板相比，最大的区别就是，这里指定了具体的值，因为商品确定了，其参数值肯定也确定了。 特有属性 刚才看到的是全局属性，那么特有属性在这个字段中如何存储呢？ 我们发现特有属性也是有的，但是，注意看这里是不确定具体值的，因为特有属性只有在SKU中才能确定。这里只是保存了options，所有SKU属性的可选项。 在哪里会用到这个字段的值呢，商品详情页的规格参数信息中： spec_template字段 既然specifications已经包含了所有的规格参数，那么为什么又多出了一个spec_template呢？ 里面又有哪些内容呢？ 来看数据格式： 可以看出，里面只保存了规格参数中的特有属性，而且格式进行了大大的简化，只有属性的key，和待选项。 为什么要冗余保存一份？ 因为很多场景下我们只需要查询特有规格属性，如果放在一起，每次查询再去分离比较麻烦。 比如，商品详情页展示可选的规格参数时： SKU表 表结构 1234567891011121314CREATE TABLE `tb_sku` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;sku id&apos;, `spu_id` bigint(20) NOT NULL COMMENT &apos;spu id&apos;, `title` varchar(255) NOT NULL COMMENT &apos;商品标题&apos;, `images` varchar(1000) DEFAULT &apos;&apos; COMMENT &apos;商品的图片，多个图片以‘,’分割&apos;, `price` bigint(15) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;销售价格，单位为分&apos;, `indexes` varchar(100) COMMENT &apos;特有规格属性在spu属性模板中的对应下标组合&apos;, `own_spec` varchar(1000) COMMENT &apos;sku的特有规格参数，json格式，反序列化时应使用linkedHashMap，保证有序&apos;, `enable` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;是否有效，0无效，1有效&apos;, `create_time` datetime NOT NULL COMMENT &apos;添加时间&apos;, `last_update_time` datetime NOT NULL COMMENT &apos;最后修改时间&apos;, PRIMARY KEY (`id`), KEY `key_spu_id` (`spu_id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;sku表,该表表示具体的商品实体,如黑色的64GB的iphone 8&apos;; 还有一张表，代表库存： 1234567CREATE TABLE `tb_stock` ( `sku_id` bigint(20) NOT NULL COMMENT &apos;库存对应的商品sku id&apos;, `seckill_stock` int(9) DEFAULT &apos;0&apos; COMMENT &apos;可秒杀库存&apos;, `seckill_total` int(9) DEFAULT &apos;0&apos; COMMENT &apos;秒杀总数量&apos;, `stock` int(9) NOT NULL COMMENT &apos;库存数量&apos;, PRIMARY KEY (`sku_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;库存表，代表库存，秒杀库存等信息&apos;; 问题：为什么要将库存独立一张表？ 因为库存字段写频率较高，而SKU的其它字段以读为主，因此我们将两张表分离，读写不会干扰。 特别需要注意的是sku表中的indexes字段和own_spec字段。sku中应该保存特有规格参数的值，就在这两个字段中。 sku中的特有规格参数 indexes字段 在SPU表中，已经对特有规格参数及可选项进行了保存，结构如下： 123456789101112131415&#123; "机身颜色": [ "香槟金", "樱花粉", "磨砂黑" ], "内存": [ "2GB", "3GB" ], "机身存储": [ "16GB", "32GB" ]&#125; 这些特有属性如果排列组合，会产生12个不同的SKU，而不同的SKU，其属性就是上面备选项中的一个。 比如： 红米4X，香槟金，2GB内存，16GB存储 红米4X，磨砂黑，2GB内存，32GB存储 你会发现，每一个属性值，对应于SPUoptions数组的一个选项，如果我们记录下角标，就是这样： 红米4X，0,0,0 红米4X，2,0,1 既然如此，我们是不是可以将不同角标串联起来，作为SPU下不同SKU的标示。这就是我们的indexes字段。 这个设计在商品详情页会特别有用： 当用户点击选中一个特有属性，你就能根据 角标快速定位到sku。 own_spec字段 看结构： 1&#123;"机身颜色":"香槟金","内存":"2GB","机身存储":"16GB"&#125; 保存的是特有属性的键值对。 SPU中保存的是可选项，但不确定具体的值，而SKU中的保存的就是具体的键值对了。 这样，在页面展示规格参数信息时，就可以根据key来获取值，用于显示。 导入图片信息 现在商品表中虽然有数据，但是所有的图片信息都是无法访问的，我们需要把图片导入到虚拟机： 首先，把课前资料提供的数据上传到虚拟机下：/leyou/static目录： 然后，使用命令解压缩： 1unzip images.zip 修改Nginx配置，使nginx反向代理这些图片地址： 1vim /opt/nginx/config/nginx.conf 修改成如下配置： 12345678910111213141516171819server &#123; listen 80; server_name image.leyou.com; # 监听域名中带有group的，交给FastDFS模块处理 location ~/group([0-9])/ &#123; ngx_fastdfs_module; &#125; # 将其它图片代理指向本地的/leyou/static目录 location / &#123; root /leyou/static/; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; 商品查询 效果预览 接下来，我们实现商品管理的页面，先看下我们要实现的效果： 可以看出整体是一个table，然后有新增按钮。是不是跟昨天写品牌管理很像？ 模板代码在分别在Goods.vue 从0开始 接下来，我们自己来实现一下，新建两个组件：MyGoods.vue和MyGoodsForm.vue 内容先随意： 1234567891011121314151617181920&lt;template&gt; &lt;v-card&gt; MyGoods &lt;/v-card&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;my-goods&quot;, data() &#123; return &#123; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 然后修改menu.js,新建一个菜单： 修改router/index.js，添加一个路由： 预览一下： 页面实现 页面基本表格 商品列表页与品牌列表页几乎一样，我们可以直接去复制一份过来，然后进行一些修改。 首先，字段不一样，商品列表也展示的SPU信息，包含以下字段： 1234id：title：标题cname：商品分类名称bname：品牌名称 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&lt;template&gt; &lt;v-card&gt; &lt;v-card-title&gt; &lt;v-btn color="primary" @click="addGoods"&gt;新增商品&lt;/v-btn&gt; &lt;!--搜索框，与search属性关联--&gt; &lt;v-spacer/&gt; &lt;v-text-field label="输入关键字搜索" v-model.lazy="search" append-icon="search" hide-details/&gt; &lt;/v-card-title&gt; &lt;v-divider/&gt; &lt;v-data-table :headers="headers" :items="goodsList" :search="search" :pagination.sync="pagination" :total-items="totalGoods" :loading="loading" class="elevation-1" &gt; &lt;template slot="items" slot-scope="props"&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class="text-xs-center"&gt;&#123;&#123; props.item.title &#125;&#125;&lt;/td&gt; &lt;td class="text-xs-center"&gt;&#123;&#123;props.item.cname&#125;&#125;&lt;/td&gt; &lt;td class="text-xs-center"&gt;&#123;&#123; props.item.bname &#125;&#125;&lt;/td&gt; &lt;td class="justify-center layout"&gt; &lt;v-btn color="info" @click="editGoods(props.item)"&gt;编辑&lt;/v-btn&gt; &lt;v-btn color="warning"&gt;删除&lt;/v-btn&gt; &lt;v-btn &gt;下架&lt;/v-btn&gt; &lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;!--弹出的对话框--&gt; &lt;v-dialog max-width="500" v-model="show" persistent&gt; &lt;v-card&gt; &lt;!--对话框的标题--&gt; &lt;v-toolbar dense dark color="primary"&gt; &lt;v-toolbar-title&gt;&#123;&#123;isEdit ? '修改' : '新增'&#125;&#125;商品&lt;/v-toolbar-title&gt; &lt;v-spacer/&gt; &lt;!--关闭窗口的按钮--&gt; &lt;v-btn icon @click="closeWindow"&gt;&lt;v-icon&gt;close&lt;/v-icon&gt;&lt;/v-btn&gt; &lt;/v-toolbar&gt; &lt;!--对话框的内容，表单--&gt; &lt;v-card-text class="px-5"&gt; &lt;my-goods-form :oldGoods="oldGoods" /&gt; &lt;/v-card-text&gt; &lt;/v-card&gt; &lt;/v-dialog&gt; &lt;/v-card&gt;&lt;/template&gt;&lt;script&gt; // 导入自定义的表单组件 import MyGoodsForm from './MyGoodsForm' export default &#123; name: "my-goods", data() &#123; return &#123; search: '', // 搜索过滤字段 totalGoods: 0, // 总条数 goodsList: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '标题', align: 'center', sortable: false, value: 'title'&#125;, &#123;text: '商品分类', align: 'center', sortable: false, value: 'cname'&#125;, &#123;text: '品牌', align: 'center', value: 'bname', sortable: false,&#125;, &#123;text: '操作', align: 'center', sortable: false&#125; ], show: false,// 控制对话框的显示 oldGoods: &#123;&#125;, // 即将被编辑的商品信息 isEdit: false, // 是否是编辑 &#125; &#125;, mounted() &#123; // 渲染后执行 // 查询数据 this.getDataFromServer(); &#125;, watch: &#123; pagination: &#123; // 监视pagination属性的变化 deep: true, // deep为true，会监视pagination的属性及属性中的对象属性变化 handler() &#123; // 变化后的回调函数，这里我们再次调用getDataFromServer即可 this.getDataFromServer(); &#125; &#125;, search: &#123; // 监视搜索字段 handler() &#123; this.getDataFromServer(); &#125; &#125; &#125;, methods: &#123; getDataFromServer() &#123; // 从服务的加载数的方法。 // 发起请求 this.$http.get("/item/spu/page", &#123; params: &#123; key: this.search, // 搜索条件 page: this.pagination.page,// 当前页 rows: this.pagination.rowsPerPage,// 每页大小 sortBy: this.pagination.sortBy,// 排序字段 desc: this.pagination.descending// 是否降序 &#125; &#125;).then(resp =&gt; &#123; // 这里使用箭头函数 this.goodsList = resp.data.items; this.totalGoods = resp.data.total; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;) &#125;, addGoods() &#123; // 修改标记 this.isEdit = false; // 控制弹窗可见： this.show = true; // 把oldBrand变为null this.oldBrand = null; &#125;, editGoods(oldGoods)&#123; // 修改标记 this.isEdit = true; // 控制弹窗可见： this.show = true; // 获取要编辑的brand this.oldGoods = oldGoods; &#125;, closeWindow()&#123; // 重新加载数据 this.getDataFromServer(); // 关闭窗口 this.show = false; &#125; &#125;, components:&#123; MyGoodsForm &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 主要的改动点： 页面的v-data-table中的属性绑定修改。items指向goodsList，totalItems指向totalGoods 页面渲染的字段名修改：字段改成商品的SPU字段：id、title，cname(商品分类名称),bname（品牌名称） data属性修改了以下属性： goodsList：当前页商品数据 totalGoods：商品总数 headers：头信息，需要修改头显示名称 oldGoods：准备要修改的商品 加载数据的函数：getDataFromServer，请求的路径进行了修改，另外去除了跟排序相关的查询。SPU查询不排序 新增商品的事件函数：清除了一些数据查询接口，只保留弹窗 查看效果： 因为没有编写查询功能，表格一直处于loading状态。 接下来看弹窗： 上下架状态按钮 另外，似乎页面少了对上下架商品的过滤，在原始效果图中是有的： 这在Vuetify中是一组按钮，我们查看帮助文档： 查看实例得到以下信息： v-btn：一个按钮 v-btn-toggle：按钮组，内部可以有多个按钮，点击切换，有以下属性： multiple：是否支持多选，默认是false value：选中的按钮的值，如果是多选，结果是一个数组；单选，结果是点击的v-btn中的value值，因此按钮组的每个btn都需要指定value属性 改造页面： 首先在data中定义一个属性，记录按钮的值。 1234filter:&#123; saleable: false, // 上架还是下架 search: '', // 搜索过滤字段&#125; 这里我们的做法是定义一个filter属性，内部在定义search来关联过滤字段，saleable来关联上下架情况。 这样watch就必须监听filter，而不是只监听search了： 123456filter: &#123;// 监视搜索字段 handler() &#123; this.getDataFromServer(); &#125;, deep:true&#125; 另外，页面中与search有关的所有字段都需要修改成filter.search: 12&lt;!--搜索框，与search属性关联--&gt;&lt;v-text-field label="输入关键字搜索" v-model.lazy="filter.search" append-icon="search" hide-details/&gt; 然后，在页面中添加按钮组： 1234567891011121314 &lt;v-flex xs3&gt; 状态： &lt;v-btn-toggle v-model="filter.saleable"&gt; &lt;v-btn flat&gt; 全部 &lt;/v-btn&gt; &lt;v-btn flat :value="true"&gt; 上架 &lt;/v-btn&gt; &lt;v-btn flat :value="false"&gt; 下架 &lt;/v-btn&gt; &lt;/v-btn-toggle&gt;&lt;/v-flex&gt; 最后，不要忘了在查询时，将saleable携带上： 12345678910111213141516getDataFromServer() &#123; // 从服务的加载数的方法。 // 发起请求 this.$http.get("/item/spu/page", &#123; params: &#123; key: this.filter.search, // 搜索条件 saleable: this.filter.saleable, // 上下架 page: this.pagination.page,// 当前页 rows: this.pagination.rowsPerPage,// 每页大小 &#125; &#125;).then(resp =&gt; &#123; // 这里使用箭头函数 this.goodsList = resp.data.items; this.totalGoods = resp.data.total; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;)&#125; 后台提供接口 页面已经准备好，接下来在后台提供分页查询SPU的功能： 实体类 SPU 1234567891011121314151617@Table(name = "tb_spu")public class Spu &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long brandId; private Long cid1;// 1级类目 private Long cid2;// 2级类目 private Long cid3;// 3级类目 private String title;// 标题 private String subTitle;// 子标题 private Boolean saleable;// 是否上架 private Boolean valid;// 是否有效，逻辑删除用 private Date createTime;// 创建时间 private Date lastUpdateTime;// 最后修改时间 // 省略getter和setter&#125; SPU详情 1234567891011@Table(name="tb_spu_detail")public class SpuDetail &#123; @Id private Long spuId;// 对应的SPU的id private String description;// 商品描述 private String specTemplate;// 商品特殊规格的名称及可选值模板 private String specifications;// 商品的全局规格属性 private String packingList;// 包装清单 private String afterService;// 售后服务 // 省略getter和setter&#125; controller 先分析： 请求方式：GET 请求路径：/spu/page 请求参数： page：当前页 rows：每页大小 key：过滤条件 saleable：上架或下架 返回结果：商品SPU的分页信息。 要注意，页面展示的是商品分类和品牌名称，而数据库中保存的是id，怎么办？ 我们可以新建一个类，继承SPU，并且拓展cname和bname属性，写到ly-item-interface 12345678public class SpuBo extends Spu &#123; String cname;// 商品分类名称 String bname;// 品牌名称 // 略 。。&#125; 编写controller代码： 我们把与商品相关的一切业务接口都放到一起，起名为GoodsController，业务层也是这样 1234567891011121314151617181920212223242526@RestControllerpublic class GoodsController &#123; @Autowired private GoodsService goodsService; /** * 分页查询SPU * @param page * @param rows * @param key * @return */ @GetMapping("/spu/page") public ResponseEntity&lt;PageResult&lt;SpuBo&gt;&gt; querySpuByPage( @RequestParam(value = "page", defaultValue = "1") Integer page, @RequestParam(value = "rows", defaultValue = "5") Integer rows, @RequestParam(value = "key", required = false) String key) &#123; // 分页查询spu信息 PageResult&lt;SpuBo&gt; result = this.goodsService.querySpuByPageAndSort(page, rows, key); if (result == null || result.getItems().size() == 0) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(result); &#125;&#125; service 所有商品相关的业务（包括SPU和SKU）放到一个业务下：GoodsService。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Servicepublic class GoodsService &#123; @Autowired private SpuMapper spuMapper; @Autowired private CategoryService categoryService; @Autowired private BrandMapper brandMapper; public PageResult&lt;SpuBo&gt; querySpuByPageAndSort(Integer page, Integer rows, Boolean saleable, String key) &#123; // 1、查询SPU // 分页,最多允许查100条 PageHelper.startPage(page, Math.min(rows, 100)); // 创建查询条件 Example example = new Example(Spu.class); Example.Criteria criteria = example.createCriteria(); // 是否过滤上下架 if (saleable != null) &#123; criteria.orEqualTo("saleable", saleable); &#125; // 是否模糊查询 if (StringUtils.isNotBlank(key)) &#123; criteria.andLike("title", "%" + key + "%"); &#125; Page&lt;Spu&gt; pageInfo = (Page&lt;Spu&gt;) this.spuMapper.selectByExample(example); List&lt;SpuBo&gt; list = pageInfo.getResult().stream().map(spu -&gt; &#123; // 2、把spu变为 spuBo SpuBo spuBo = new SpuBo(); // 属性拷贝 BeanUtils.copyProperties(spu, spuBo); // 3、查询spu的商品分类名称,要查三级分类 List&lt;String&gt; names = this.categoryService.queryNameByIds( Arrays.asList(spu.getCid1(), spu.getCid2(), spu.getCid3())); // 将分类名称拼接后存入 spuBo.setCname(StringUtils.join(names, "/")); // 4、查询spu的品牌名称 Brand brand = this.brandMapper.selectByPrimaryKey(spu.getBrandId()); spuBo.setBname(brand.getName()); return spuBo; &#125;).collect(Collectors.toList()); return new PageResult&lt;&gt;(pageInfo.getTotal(), list); &#125;&#125; mapper 12public interface SpuMapper extends Mapper&lt;Spu&gt; &#123;&#125; Category中拓展查询名称的功能 页面需要商品的分类名称需要在这里查询，因此要额外提供查询分类名称的功能， 在CategoryService中添加功能： 123public List&lt;String&gt; queryNameByIds(List&lt;Long&gt; ids) &#123; return this.categoryMapper.selectByIdList(ids).stream().map(Category::getName).collect(Collectors.toList());&#125; mapper的selectByIDList方法是来自于通用mapper。不过需要我们在mapper上继承一个通用mapper接口： 123public interface CategoryMapper extends Mapper&lt;Category&gt;, SelectByIdListMapper&lt;Category, Long&gt; &#123; // ...coding&#125; 测试 刷新页面，查看效果： 基本与预览的效果一致，OK！ 商品新增 效果预览 新增商品窗口： 这个表单比较复杂，因为商品的信息比较多，分成了4个部分来填写： 基本信息 商品描述信息 规格参数信息 SKU信息 从0开始 我们刚刚在查询时，已经实现创建了MyGoodsForm.vue，并且已经在MyGoods中引入。 不过目前没有写代码： 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;v-card&gt; my goods form &lt;/v-card&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;my-goods-form&quot;, props: &#123; oldGoods: &#123; type: Object &#125;, isEdit: &#123; type: Boolean, default: false &#125; &#125;, data() &#123; return &#123; &#125; &#125;, methods: &#123; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 然后在MyBrand中，已经引入了MyGoodsForm组件，并且页面中也形成了对话框： 12// 导入自定义的表单组件import MyGoodsForm from './MyGoodsForm' 1234567891011121314151617&lt;v-dialog max-width="500" v-model="show" persistent&gt; &lt;v-card&gt; &lt;!--对话框的标题--&gt; &lt;v-toolbar dense dark color="primary"&gt; &lt;v-toolbar-title&gt;&#123;&#123;isEdit ? '修改' : '新增'&#125;&#125;商品&lt;/v-toolbar-title&gt; &lt;v-spacer/&gt; &lt;!--关闭窗口的按钮--&gt; &lt;v-btn icon @click="closeWindow"&gt; &lt;v-icon&gt;close&lt;/v-icon&gt; &lt;/v-btn&gt; &lt;/v-toolbar&gt; &lt;!--对话框的内容，表单--&gt; &lt;v-card-text class="px-5"&gt; &lt;my-goods-form :oldGoods="oldGoods"/&gt; &lt;/v-card-text&gt; &lt;/v-card&gt;&lt;/v-dialog&gt; 并且也已经给新增按钮绑定了点击事件： 1&lt;v-btn color="primary" @click="addGoods"&gt;新增商品&lt;/v-btn&gt; addGoods方法中，设置对话框的show属性为true： 12345678addGoods() &#123; // 修改标记 this.isEdit = false; // 控制弹窗可见： this.show = true; // 把oldBrand变为null this.oldBrand = null;&#125; 不过弹窗中没有任何数据： 新增商品页的基本框架 Steppers，步骤线 预览效果图中，分四个步骤显示商品表单的组件，叫做stepper，看下文档： 其基本结构如图： 一个步骤线（v-stepper）总的分为两部分： v-stepper-header：代表步骤的头部进度条，只能有一个 v-stepper-step：代表进度条的每一个步骤，可以有多个 v-stepper-items：代表当前步骤下的内容组，只能有一个，内部有stepper-content v-stepper-content：代表每一步骤的页面内容，可以有多个 v-stepper value：其值是当前所在的步骤索引，可以用来控制步骤切换 dark：是否使用黑暗色调，默认false non-linear：是否启用非线性步骤，用户不用按顺序切换，而是可以调到任意步骤，默认false vertical：是否垂直显示步骤线，默认是false，即水平显示 v-stepper-header的属性： 无 v-stepper-step的属性 color：颜色 complete：当前步骤是否已经完成，布尔值 editable：是否可编辑任意步骤（非线性步骤） step：步骤索引 v-stepper-items 无 v-stepper-content step：步骤索引，需要与v-stepper-step中的对应 编写页面 首先我们在data中定义一个变量，记录当前的步骤数： 12345data() &#123; return &#123; step: 1, // 当前的步骤数，默认为1 &#125;&#125;, 然后在模板页面中引入步骤线： 12345678910111213141516171819202122232425&lt;v-stepper v-model="step"&gt; &lt;v-stepper-header&gt; &lt;v-stepper-step :complete="step &gt; 1" step="1"&gt;基本信息&lt;/v-stepper-step&gt; &lt;v-divider/&gt; &lt;v-stepper-step :complete="step &gt; 2" step="2"&gt;商品描述&lt;/v-stepper-step&gt; &lt;v-divider/&gt; &lt;v-stepper-step :complete="step &gt; 3" step="3"&gt;规格参数&lt;/v-stepper-step&gt; &lt;v-divider/&gt; &lt;v-stepper-step step="4"&gt;SKU属性&lt;/v-stepper-step&gt; &lt;/v-stepper-header&gt; &lt;v-stepper-items&gt; &lt;v-stepper-content step="1"&gt; 基本信息 &lt;/v-stepper-content&gt; &lt;v-stepper-content step="2"&gt; 商品描述 &lt;/v-stepper-content&gt; &lt;v-stepper-content step="3"&gt; 规格参数 &lt;/v-stepper-content&gt; &lt;v-stepper-content step="4"&gt; SKU属性 &lt;/v-stepper-content&gt; &lt;/v-stepper-items&gt; &lt;/v-stepper&gt; 效果： 步骤线出现了！ 那么问题来了：该如何让这几个步骤切换呢？ 步骤切换按钮 分析 如果改变step的值与指定的步骤索引一致，就可以实现步骤切换了： 因此，我们需要定义两个按钮，点击后修改step的值，让步骤前进或后退。 那么这两个按钮放哪里？ 如果放在MyGoodsForm内，当表单内容过多时，按钮会被挤压到屏幕最下方，不够友好。最好是能够悬停状态。 所以，按钮必须放到MyGoods组件中，也就是父组件。 父组件的对话框是一个card，card组件提供了一个滚动效果，scrollable，如果为true，card的内容滚动时，其头部和底部是可以静止的。 现在card的头部是弹框的标题，card的中间就是表单内容。如果我们把按钮放到底部，就可以实现悬停效果。 页面添加按钮 改造MyGoods的对话框组件： 查看页面： 添加点击事件 现在这两个按钮点击后没有任何反应。我们需要给他们绑定点击事件，来修改MyGoodsForm中的step的值。 也就是说，父组件要修改子组件的属性状态。想到什么了？ props属性。 我们先在父组件定义一个step属性： 然后在点击事件中修改它： 12345678910previous()&#123; if(this.step &gt; 1)&#123; this.step-- &#125;&#125;,next()&#123; if(this.step &lt; 4)&#123; this.step++ &#125;&#125; 页面绑定事件： 1234567&lt;!--底部按钮，用来操作步骤线--&gt;&lt;v-card-actions class="elevation-10"&gt; &lt;v-flex class="xs3 mx-auto"&gt; &lt;v-btn @click="previous" color="primary" :disabled="step === 1"&gt;上一步&lt;/v-btn&gt; &lt;v-btn @click="next" color="primary" :disabled="step === 4"&gt;下一步&lt;/v-btn&gt; &lt;/v-flex&gt;&lt;/v-card-actions&gt; 然后把step属性传递给子组件： 1234&lt;!--对话框的内容，表单--&gt;&lt;v-card-text class="px-3" style="height: 600px"&gt; &lt;my-goods-form :oldGoods="oldGoods" :step="step"/&gt;&lt;/v-card-text&gt; 子组件中接收属性： 测试效果： 商品基本信息 商品基本信息，主要是一些纯文本比较简单的SPU属性，例如： 商品分类、商品品牌、商品标题、商品卖点（子标题），包装清单，售后服务 接下来，我们一一添加这些表单项。 注：这里为了简化，我们就不进行form表单校验了。之前已经讲过。 在data中定义Goods属性 首先，我们需要定义一个goods对象，包括商品的上述属性。 12345678910111213data() &#123; return &#123; goods:&#123; categories:&#123;&#125;, // 商品3级分类数组信息 brandId: 0,// 品牌id信息 title: '',// 标题 subTitle: '',// 子标题 spuDetail: &#123; packingList: '',// 包装列表 afterService: '',// 售后服务 &#125;, &#125; &#125; 注意，这里我们在goods中定义了spuDetail属性，然后把包装列表和售后服务作为它的属性，这样符合数据库的结构。 商品分类选框 商品分类选框之前我们已经做过了。是级联选框。直接拿来用： 123456&lt;v-cascader url="/item/category/list" required showAllLevels v-model="goods.categories" label="请选择商品分类"/&gt; 跟以前使用有一些区别： 一个商品只能有一个分类，所以这里去掉了multiple属性 商品SPU中要保存3级商品分类，因此我们这里需要选择showAllLevels属性，显示所有3级分类 效果： 查看goods的属性，三级类目都在： 品牌选择 select组件 品牌不分级别，使用普通下拉选框即可。我们查看官方文档的下拉选框说明： 组件名：v-select 比较重要的一些属性： item-text：选项中用来展示的字段名，默认是text item-value：选项中用来作为value值的字段名，默认是value items：待选项的对象数组 label：提示文本 multiple：是否支持多选，默认是false 其它次要属性： autocomplete：是否根据用户输入的文本进行搜索过滤（自动），默认false chips：是否以小纸片方式显示用户选中的项，默认false clearable：是否添加清空选项图标，默认是false color：颜色 dense：是否压缩选择框高度，默认false editable：是否可编辑，默认false hide-details：是否隐藏错误提示，默认false hide-selected：是否在菜单中隐藏已选择的项 hint：提示文本 其它基本与v-text-filed组件类似，不再一一列举 页面实现 备选项items需要我们去后台查询，而且必须是在用户选择商品分类后去查询。 我们定义一个属性，保存品牌的待选项信息： 然后编写一个watch，监控goods.categories的变化： 123456789101112131415watch: &#123; 'goods.categories': &#123; deep: true, handler(val) &#123; // 判断商品分类是否存在，存在才查询 if (val &amp;&amp; val.length &gt; 0) &#123; // 根据分类查询品牌 this.$http.get("/item/brand/cid/" + this.goods.categories[2].id) .then((&#123;data&#125;) =&gt; &#123; this.brandOptions = data; &#125;) &#125; &#125; &#125;&#125; 我们的品牌对象包含以下字段：id、name、letter、image。显然item-text应该对应name，item-value应该对应id 因此我们添加一个选框，指定item-text和item-value 123456789101112&lt;!--品牌--&gt;&lt;v-select :items="brandOptions" item-text="name" item-value="id" label="所属品牌" v-model="goods.brandId" required autocomplete clearable dense chips /&gt; 后台提供接口 页面需要去后台查询品牌信息，我们自然需要提供： controller 12345678910111213/** * 根据分类查询品牌 * @param cid * @return */@GetMapping("cid/&#123;cid&#125;")public ResponseEntity&lt;List&lt;Brand&gt;&gt; queryBrandByCategory(@PathVariable("cid") Long cid) &#123; List&lt;Brand&gt; list = this.brandService.queryBrandByCategory(cid); if(list == null)&#123; new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(list);&#125; service 123public List&lt;Brand&gt; queryBrandByCategory(Long cid) &#123; return this.brandMapper.queryByCategoryId(cid);&#125; mapper 根据分类查询品牌有中间表，需要自己编写Sql： 12@Select("SELECT b.* FROM tb_brand b LEFT JOIN tb_category_brand cb ON b.id = cb.brand_id WHERE cb.category_id = #&#123;cid&#125;")List&lt;Brand&gt; queryByCategoryId(Long cid); 测试效果 标题等其它字段 标题等字段都是普通文本，直接使用v-text-field即可： 1234&lt;v-text-field label="商品标题" v-model="goods.title" :counter="200" required /&gt;&lt;v-text-field label="商品卖点" v-model="goods.subTitle" :counter="200"/&gt;&lt;v-text-field label="包装清单" v-model="goods.spuDetail.packingList" :counter="1000" multi-line :rows="3"/&gt;&lt;v-text-field label="售后服务" v-model="goods.spuDetail.afterService" :counter="1000" multi-line :rows="3"/&gt; 一些新的属性： counter：计数器，记录当前用户输入的文本字数 rows：文本域的行数 multi-line：把单行文本变成文本域 商品描述信息 商品描述信息比较复杂，而且图文并茂，甚至包括视频。 这样的内容，一般都会使用富文本编辑器。 什么是富文本编辑器 百度百科： 通俗来说：富文本，就是比较丰富的文本编辑器。普通的框只能输入文字，而富文本还能给文字加颜色样式等。 富文本编辑器有很多，例如：KindEditor、Ueditor。但并不原生支持vue 但是我们今天要说的，是一款支持Vue的富文本编辑器：vue-quill-editor Vue-Quill-Editor GitHub的主页：https://github.com/surmon-china/vue-quill-editor Vue-Quill-Editor是一个基于Quill的富文本编辑器：Quill的官网 使用指南 使用非常简单： 第一步：安装，使用npm命令： 1npm install vue-quill-editor --save 第二步：加载，在js中引入： 全局使用： 123456import Vue from 'vue'import VueQuillEditor from 'vue-quill-editor'const options = &#123;&#125;; /* &#123; default global options &#125; */Vue.use(VueQuillEditor, options); // options可选 局部使用： 1234567891011import 'quill/dist/quill.core.css'import 'quill/dist/quill.snow.css'import 'quill/dist/quill.bubble.css'import &#123;quillEditor&#125; from 'vue-quill-editor'var vm = new Vue(&#123; components:&#123; quillEditor &#125;&#125;) 第三步：页面引用： 1&lt;quill-editor v-model="goods.spuDetail.description" :options="editorOption"/&gt; 自定义的富文本编辑器 不过这个组件有个小问题，就是图片上传的无法直接上传到后台，因此我们对其进行了封装，支持了图片的上传。 使用也非常简单： 123&lt;v-stepper-content step="2"&gt; &lt;v-editor v-model="goods.spuDetail.description" upload-url="/upload/image"/&gt;&lt;/v-stepper-content&gt; upload-url：是图片上传的路径 v-model：双向绑定，将富文本编辑器的内容绑定到goods.spuDetail.description 效果： 规格参数 商品规格参数与商品分类绑定，因此我们需要在用户选择商品分类后，去后台查询对应的规格参数模板。 查询商品规格 首先，我们在data中定义变量，记录查询到的规格参数模板： 然后，我们通过watch监控goods.categories的变化，然后去查询规格： 查看是否查询到： 页面展示规格属性 获取到了规格参数，还需要把它展示到页面中。 现在查询到的规格参数只有key，并没有值。值需要用户来根据SPU信息填写，因此规格参数最终需要处理为表单。 整体结构 整体来看，规格参数是数组，每个元素是一组规格的集合。我们需要分组来展示。比如每组放到一个card中。 注意事项： 规格参数中的属性有一些需要我们特殊处理： global：是否是全局属性，规格参数中一部分是SPU共享，属于全局属性，另一部是SKU特有，需要根据SKU来填写。因此，在当前版面中，只展示global为true的，即全局属性。sku特有属性放到最后一个面板 numerical：是否是数值类型，如果是，把单位补充在页面表单，不允许用户填写，并且要验证用户输入的数据格式 options：是否有可选项，如果有，则使用下拉选框来渲染。 页面代码： 123456789101112131415161718&lt;!--3、规格参数--&gt;&lt;v-stepper-content step="3"&gt; &lt;v-flex class="xs10 mx-auto px-3"&gt; &lt;!--遍历整个规格参数，获取每一组--&gt; &lt;v-card v-for="spec in specifications" :key="spec.group" class="my-2"&gt; &lt;!--组名称--&gt; &lt;v-card-title class="subheading"&gt;&#123;&#123;spec.group&#125;&#125;&lt;/v-card-title&gt; &lt;!--遍历组中的每个属性，并判断是否是全局属性，不是则不显示--&gt; &lt;v-card-text v-for="param in spec.params" :key="param.k" v-if="param.global" class="px-5"&gt; &lt;!--判断是否有可选项，如果没有，则显示文本框。还要判断是否是数值类型，如果是把unit显示到后缀--&gt; &lt;v-text-field v-if="param.options.length &lt;= 0" :label="param.k" v-model="param.v" :suffix="param.unit || ''"/&gt; &lt;!--否则，显示下拉选项--&gt; &lt;v-select v-else :label="param.k" v-model="param.v" :items="param.options"/&gt; &lt;/v-card-text&gt; &lt;/v-card&gt; &lt;/v-flex&gt;&lt;/v-stepper-content&gt; 效果： SKU特有属性 sku特有属性也存在与specifications中，但是我们现在只想展示特有属性，而不是从头遍历一次。因此，我们应该从specifications中把特有规格属性拆分出来独立保存。 筛选特有规格参数 首先：我们在data中新建一个属性，保存特有的规格参数： 然后，在查询完成规格模板后，立刻对规格参数进行处理，筛选出特有规格参数，保存到specialSpecs中： 123456789101112131415161718// 根据分类查询规格参数this.$http.get("/item/spec/" + this.goods.categories[2].id) .then((&#123;data&#125;) =&gt; &#123; // 保存全部规格 this.specifications = data; // 对特有规格进行筛选 const temp = []; data.forEach((&#123;params&#125;) =&gt; &#123; params.forEach((&#123;k, options, global&#125;) =&gt; &#123; if (!global) &#123; temp.push(&#123; k, options,selected:[] &#125;) &#125; &#125;) &#125;) this.specialSpecs = temp; &#125;) 要注意：我们添加了一个selected属性，用于保存用户填写的信息 查看数据： 页面渲染SKU属性 接下来，我们把筛选出的特有规格参数，渲染到SKU页面： 我们的目标效果是这样的： 可以看到， 每一个特有属性自成一组，都包含标题和选项。我们可以使用card达到这个效果。 无options选项的特有属性，展示一个文本框，有options选项的，展示多个checkbox，让用户选择 页面代码实现： 123456789101112131415161718192021&lt;!--4、SKU属性--&gt;&lt;v-stepper-content step="4"&gt; &lt;v-flex class="mx-auto"&gt; &lt;!--遍历特有规格参数--&gt; &lt;v-card flat v-for="spec in specialSpecs" :key="spec.k"&gt; &lt;!--特有参数的标题--&gt; &lt;v-card-title class="subheading"&gt;&#123;&#123;spec.k&#125;&#125;:&lt;/v-card-title&gt; &lt;!--特有参数的待选项，需要判断是否有options，如果没有，展示文本框，让用户自己输入--&gt; &lt;v-card-text v-if="spec.options.length &lt;= 0" class="px-5"&gt; &lt;v-text-field :label="'输入新的' + spec.k" v-model="spec.selected"/&gt; &lt;/v-card-text&gt; &lt;!--如果有options，需要展示成多个checkbox--&gt; &lt;v-card-text v-else class="container fluid grid-list-xs"&gt; &lt;v-layout row wrap class="px-5"&gt; &lt;v-checkbox color="primary" v-for="o in spec.options" :key="o" class="flex xs3" :label="o" v-model="spec.selected" :value="o"/&gt; &lt;/v-layout&gt; &lt;/v-card-text&gt; &lt;/v-card&gt; &lt;/v-flex&gt;&lt;/v-stepper-content&gt; 我们的实现效果： 测试下，勾选checkbox或填写文本会发生什么： 看下规格模板的值： 自由添加或删除文本框 刚才的实现中，普通文本项只有一个，如果用户想添加更多值就不行。我们需要让用户能够自由添加新的文本框，而且还能删除。 这里有个取巧的方法： 还记得我们初始化 特有规格参数时，新增了一个selected属性吗，用来保存用户填写的值，是一个数组。每当用户新加一个值，该数组的长度就会加1，而初始长度为0 另外，v-for指令有个特殊之处，就在于它可以遍历数字。比如 v-for=”i in 10”，你会得到1~10 因此，我们可以遍历selected的长度，每当我们输入1个文本，selected长度会加1，自然会多出一个文本框。 代码如下： 1234567891011121314151617&lt;v-card flat v-for="spec in specialSpecs" :key="spec.k"&gt; &lt;!--特有参数的标题--&gt; &lt;v-card-title class="subheading"&gt;&#123;&#123;spec.k&#125;&#125;:&lt;/v-card-title&gt; &lt;!--特有参数的待选项，需要判断是否有options，如果没有，展示文本框，让用户自己输入--&gt; &lt;v-card-text v-if="spec.options.length &lt;= 0" class="px-5"&gt; &lt;div v-for="i in spec.selected.length+1" :key="i"&gt; &lt;v-text-field :label="'输入新的' + spec.k" v-model="spec.selected[i-1]" v-bind:value="i"/&gt; &lt;/div&gt; &lt;/v-card-text&gt; &lt;!--如果有options，需要展示成多个checkbox--&gt; &lt;v-card-text v-else class="container fluid grid-list-xs"&gt; &lt;v-layout row wrap class="px-5"&gt; &lt;v-checkbox color="primary" v-for="o in spec.options" :key="o" class="flex xs3" :label="o" v-model="spec.selected" :value="o"/&gt; &lt;/v-layout&gt; &lt;/v-card-text&gt;&lt;/v-card&gt; 效果： 而删除文本框相对就比较简单了，只要在文本框末尾添加一个按钮，添加点击事件即可，代码： 添加了一些布局样式，以及一个按钮，在点击事件中删除一个值。 展示SKU列表 效果预览 当我们选定SKU的特有属性时，就会对应出不同排列组合的SKU。 举例： 当你选择了上图中的这些选项时： 颜色共2种：土豪金，绚丽红 内存共2种：2GB，4GB 机身存储1种：64GB 此时会产生多少种SKU呢？ 应该是 2 * 2 * 1 = 4种。 因此，接下来应该由用户来对这4种sku的信息进行详细填写，比如库存和价格等。而多种sku的最佳展示方式，是表格（淘宝、京东都是这么做的），如图： 而且这个表格应该随着用户选择的不同而动态变化。如何实现？ 算法：求数组笛卡尔积 大家看这个结果就能发现，这其实是在求多个数组的笛卡尔积。作为一个程序员，这应该是基本功了吧。 两个数组笛卡尔积 假如有两个数组，求笛卡尔积，其基本思路是这样的： 在遍历一个数组的同时，遍历另一个数组，然后把元素拼接，放到新数组。 示例1： 123456789101112const arr1 = ['1','2','3'];const arr2 = ['a','b','c'];const result = [];arr1.forEach(e1 =&gt; &#123; arr2.forEach(e2 =&gt; &#123; result.push(e1 + "_" + e2) &#125;)&#125;)console.log(result); 结果： 完美实现。 N个数组的笛卡尔积 如果是N个数组怎么办？ 不确定数组数量，代码没有办法写死。该如何处理？ 思路： 先拿其中两个数组求笛卡尔积 然后把前面运算的结果作为新数组，与第三个数组求笛卡尔积 把前两次运算的结果作为第三次运算的参数。大家想到什么了？ 没错，之前讲过的一个数组功能：Reduce reduce函数的声明： 1reduce(callback,initvalue) callback：是一个回调函数。这个callback可以接收2个参数：arg1,arg2 arg1代表的上次运算得到的结果 arg2是数组中正要处理的元素 initvalue，初始化值。第一次调用callback时把initvalue作为第一个参数，把数组的第一个元素作为第二个参数运算。如果未指定，则第一次运算会把数组的前两个元素作为参数。 reduce会把数组中的元素逐个用这个函数处理，然后把结果作为下一次回调函数的第一个参数，数组下个元素作为第二个参数，以此类推。 因此，我们可以把想要求笛卡尔积的多个数组先放到一个大数组中。形成二维数组。然后再来运算： 示例2： 123456789101112131415161718const arr1 = ['1', '2', '3'];const arr2 = ['a', 'b'];// 用来作为运算的二维数组const arr3 = [arr1, arr2, ['x', 'y']]const result = arr3.reduce((last, el) =&gt; &#123; const arr = []; // last：上次运算结果 // el：数组中的当前元素 last.forEach(e1 =&gt; &#123; el.forEach(e2 =&gt; &#123; arr.push(e1 + "_" + e2) &#125;) &#125;) return arr&#125;);console.log(result); 结果： 算法结合业务 来看我们的业务逻辑： 首先，我们已经有了一个特有参数的规格模板： 1234567891011121314[ &#123; "k": "机身颜色", "selected": ["红色","黑色"] &#125;, &#123; "k": "内存", "selected": ["8GB","6GB"] &#125;, &#123; "k": "机身存储", "selected": ["64GB","256GB"] &#125;] 可以看做是一个二维数组。 一维是参数对象。 二维是参数中的selected选项。 我们想要的结果： 12345678910[ &#123;"机身颜色":"红色","内存":"6GB","机身存储":"64GB"&#125;, &#123;"机身颜色":"红色","内存":"6GB","机身存储":"256GB"&#125;, &#123;"机身颜色":"红色","内存":"8GB","机身存储":"64GB"&#125;, &#123;"机身颜色":"红色","内存":"8GB","机身存储":"256GB"&#125;, &#123;"机身颜色":"黑色","内存":"6GB","机身存储":"64GB"&#125;, &#123;"机身颜色":"黑色","内存":"6GB","机身存储":"256GB"&#125;, &#123;"机身颜色":"黑色","内存":"8GB","机身存储":"64GB"&#125;, &#123;"机身颜色":"黑色","内存":"8GB","机身存储":"256GB"&#125;,] 思路是这样： 我们的启点是一个空的对象数组：[{}]， 然后先与第一个规格求笛卡尔积 然后再把结果与下一个规格求笛卡尔积，依次类推 如果： 代码： 我们在Vue中新增一个计算属性，按照上面所讲的逻辑，计算所有规格参数的笛卡尔积 12345678910111213141516171819computed: &#123; skus() &#123; // 过滤掉用户没有填写数据的规格参数 const arr = this.specialSpecs.filter(s =&gt; s.selected.length &gt; 0); // 通过reduce进行累加笛卡尔积 return arr.reduce((last, spec) =&gt; &#123; const result = []; last.forEach(o =&gt; &#123; spec.selected.forEach(option =&gt; &#123; const obj = &#123;&#125;; Object.assign(obj, o); obj[spec.k] = option; result.push(obj); &#125;) &#125;) return result &#125;, [&#123;&#125;]) &#125;&#125; 结果： 优化：这里生成的是SKU的数组。因此只包含SKU的规格参数是不够的。结合数据库知道，还需要有下面的字段： price：价格 stock：库存 enable：是否启用。虽然笛卡尔积对应了9个SKU，但用户不一定会需要所有的组合，用这个字段进行标记。 images：商品的图片 indexes：特有属性的索引拼接得到的字符串 我们需要给生成的每个sku对象添加上述字段，代码修改如下： 12345678910111213141516171819202122232425262728computed:&#123; skus()&#123; // 过滤掉用户没有填写数据的规格参数 const arr = this.specialSpecs.filter(s =&gt; s.selected.length &gt; 0); // 通过reduce进行累加笛卡尔积 return arr.reduce((last, spec, index) =&gt; &#123; const result = []; last.forEach(o =&gt; &#123; for(let i = 0; i &lt; spec.selected.length; i++)&#123; const option = spec.selected[i]; const obj = &#123;&#125;; Object.assign(obj, o); obj[spec.k] = option; // 拼接当前这个特有属性的索引 obj.indexes = (o.indexes||'') + '_'+ i if(index === arr.length - 1)&#123; // 如果发现是最后一组，则添加价格、库存等字段 Object.assign(obj, &#123; price:0, stock:0,enable:false, images:[]&#125;) // 去掉索引字符串开头的下划线 obj.indexes = obj.indexes.substring(1); &#125; result.push(obj); &#125; &#125;) return result &#125;,[&#123;&#125;]) &#125;&#125; 查看生成的数据： 页面展现 页面展现是一个表格。我们之前已经用过。表格需要以下信息： items：表格内的数据 headers：表头信息 刚才我们的计算属性skus得到的就是表格数据了。我们还差头：headers 头部信息也是动态的，用户选择了一个属性，就会多出一个表头。与skus是关联的。 既然如此，我们再次编写一个计算属性，来计算得出header数组： 123456789101112131415161718192021222324252627282930headers()&#123; if(this.skus.length &lt;= 0)&#123; return [] &#125; const headers = []; // 获取skus中的任意一个，获取key，然后遍历其属性 Object.keys(this.skus[0]).forEach(k =&gt; &#123; let value = k; if(k === 'price')&#123; // enable，表头要翻译成“价格” k = '价格' &#125;else if(k === 'stock')&#123; // enable，表头要翻译成“库存” k = '库存'; &#125;else if(k === 'enable')&#123; // enable，表头要翻译成“是否启用” k = '是否启用' &#125; else if(k === 'indexes' || k === 'images')&#123; // 图片和索引不在表格中展示 return; &#125; headers.push(&#123; text: k, align: 'center', sortable: false, value &#125;) &#125;) return headers;&#125; 接下来编写页面，实现table。 需要注意的是，price、stock字段需要用户填写数值，不能直接展示。enable要展示为checkbox，让用户选择，如图： 代码： 1234567891011121314151617181920&lt;v-card&gt; &lt;!--标题--&gt; &lt;v-card-title class="subheading"&gt;SKU列表&lt;/v-card-title&gt; &lt;!--SKU表格，hide-actions因此分页等工具条--&gt; &lt;v-data-table :items="skus" :headers="headers" hide-actions item-key="indexes"&gt; &lt;template slot="items" slot-scope="props"&gt; &lt;!--价格和库存展示为文本框--&gt; &lt;td v-for="(v,k) in props.item" :key="k" v-if="['price', 'stock'].includes(k)" class="text-xs-center"&gt; &lt;v-text-field single-line v-model.number="props.item[k]"/&gt; &lt;/td&gt; &lt;!--enable展示为checkbox--&gt; &lt;td class="text-xs-center" v-else-if="k === 'enable'"&gt; &lt;v-checkbox v-model="props.item[k]"/&gt; &lt;/td&gt; &lt;!--indexes和images不展示，其它展示为普通文本--&gt; &lt;td class="text-xs-center" v-else-if="!['indexes','images'].includes(k)"&gt;&#123;&#123;v&#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt;&lt;/v-card&gt; 效果： 图片上传列表 这个表格中只展示了基本信息，当用户需要上传图片时，该怎么做呢？ Vuetify的table有一个展开功能，可以提供额外的展示空间： 用法也非常简单，添加一个template，把其slot属性指定为expand即可： 效果： 接下来就是我们的图片上传组件：v-upload 表单提交 添加提交按钮 我们在step=4，也就是SKU属性列表页面， 添加一个提交按钮。 1234&lt;!--提交按钮--&gt;&lt;v-flex xs3 offset-xs9&gt; &lt;v-btn color="info"&gt;保存商品信息&lt;/v-btn&gt;&lt;/v-flex&gt; 效果： 点击事件 当用户点击保存，我们就需要对页面的数据进行整理，然后提交到后台服务。 现在我们页面包含了哪些信息呢？我们与数据库对比，看看少什么 goods：里面包含了SPU的几乎所有信息 title：标题 subtitle：子标题，卖点 categories：分类对象数组，需要进行整理 ** brandId：品牌id spuDetail：商品详情 packingList：包装清单 afterService：售后服务 description：商品描述 缺少全局规格属性specifications ** 缺少特有规格属性模板spec_template ** skus：包含了sku列表的几乎所有信息 price：价格，需要处理为以分为单位 stock：库存 enable：是否启用 indexes：索引 images：图片，数组，需要处理为字符串** 缺少其它特有规格，ows_spec ** 缺少标题：需要根据spu的标题结合特有属性生成 ** specifications：全局规格参数的键值对信息 specialSpec：特有规格参数信息 在页面绑定点击事件： 1234&lt;!--提交按钮--&gt;&lt;v-flex xs3 offset-xs9&gt; &lt;v-btn color="info" @click="submit"&gt;保存商品信息&lt;/v-btn&gt;&lt;/v-flex&gt; 编写代码，整理数据： 1234567891011121314151617181920212223242526272829303132333435submit()&#123; // 表单校验。 略 // 先处理goods，用结构表达式接收,除了categories外，都接收到goodsParams中 const &#123;categories: [&#123;id:cid1&#125;,&#123;id:cid2&#125;,&#123;id:cid3&#125;], ...goodsParams&#125; = this.goods; // 处理规格参数 const specs = this.specifications.map((&#123;group,params&#125;) =&gt; &#123; const newParams = params.map((&#123;options,...rest&#125;) =&gt; &#123; return rest; &#125;) return &#123;group,params:newParams&#125;; &#125;); // 处理特有规格参数模板 const specTemplate = &#123;&#125;; this.specialSpecs.forEach((&#123;k, selected&#125;) =&gt; &#123; specTemplate[k] = selected; &#125;); // 处理sku const skus = this.skus.filter(s =&gt; s.enable).map((&#123;price,stock,enable,images,indexes, ...rest&#125;) =&gt; &#123; // 标题，在spu的title基础上，拼接特有规格属性值 const title = goodsParams.title + " " + Object.values(rest).join(" "); return &#123; price: this.$format(price+""),stock,enable,indexes,title,// 基本属性 images: !images ? '' : images.join(","), // 图片 ownSpec: JSON.stringify(rest), // 特有规格参数 &#125; &#125;); Object.assign(goodsParams, &#123; cid1,cid2,cid3, // 商品分类 skus, // sku列表 &#125;) goodsParams.spuDetail.specifications= JSON.stringify(specs); goodsParams.spuDetail.specTemplate = JSON.stringify(specTemplate); console.log(goodsParams)&#125; 点击测试，看效果： 向后台发起请求，因为请求体复杂，我们直接发起Json请求： 1234567891011this.$http.post("/item/goods",goodsParams) .then(() =&gt; &#123; // 成功，关闭窗口 this.$emit('close'); // 提示成功 this.$message.success("新增成功了") &#125;) .catch(() =&gt; &#123; this.$message.error("保存失败！"); &#125;);&#125;) 后台编写接口 实体类 Spu 12345678910111213141516@Table(name = "tb_spu")public class Spu &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long brandId; private Long cid1;// 1级类目 private Long cid2;// 2级类目 private Long cid3;// 3级类目 private String title;// 标题 private String subTitle;// 子标题 private Boolean saleable;// 是否上架 private Boolean valid;// 是否有效，逻辑删除用 private Date createTime;// 创建时间 private Date lastUpdateTime;// 最后修改时间&#125; SpuDetail 12345678910@Table(name="tb_spu_detail")public class SpuDetail &#123; @Id private Long spuId;// 对应的SPU的id private String description;// 商品描述 private String specTemplate;// 商品特殊规格的名称及可选值模板 private String specifications;// 商品的全局规格属性 private String packingList;// 包装清单 private String afterService;// 售后服务&#125; Sku 1234567891011121314151617@Table(name = "tb_sku")public class Sku &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long spuId; private String title; private String images; private Long price; private String ownSpec;// 商品特殊规格的键值对 private String indexes;// 商品特殊规格的下标 private Boolean enable;// 是否有效，逻辑删除用 private Date createTime;// 创建时间 private Date lastUpdateTime;// 最后修改时间 @Transient private Long stock;// 库存&#125; 注意：这里保存了一个库存字段，在数据库中是另外一张表保存的，方便查询。 Stock 123456789@Table(name = "tb_stock")public class Stock &#123; @Id private Long skuId; private Integer seckillStock;// 秒杀可用库存 private Integer seckillTotal;// 已秒杀数量 private Integer stock;// 正常库存&#125; Controller 四个问题： 请求方式：POST 请求路径：/goods 请求参数：Spu的json格式的对象，spu中包含spuDetail和Sku集合。这里我们该怎么接收？我们之前定义了一个SpuBo对象，作为业务对象。这里也可以用它，不过需要再扩展spuDetail和skus字段： 1234567891011public class SpuBo extends Spu &#123; @Transient String cname;// 商品分类名称 @Transient String bname;// 品牌名称 @Transient SpuDetail spuDetail;// 商品详情 @Transient List&lt;Sku&gt; skus;// sku列表&#125; 返回类型：无 代码： 123456789101112131415/** * 新增商品 * @param spu * @return */@PostMappingpublic ResponseEntity&lt;Void&gt; saveGoods(@RequestBody Spu spu) &#123; try &#123; this.goodsService.save(spu); return new ResponseEntity&lt;&gt;(HttpStatus.CREATED); &#125; catch (Exception e) &#123; e.printStackTrace(); return new ResponseEntity&lt;&gt;(HttpStatus.INTERNAL_SERVER_ERROR); &#125;&#125; 注意：通过@RequestBody注解来接收Json请求 Service 这里的逻辑比较复杂，我们除了要对SPU新增以外，还要对SpuDetail、Sku、Stock进行保存 1234567891011121314151617181920212223242526272829303132333435@Transactionalpublic void save(SpuBo spu) &#123; // 保存spu spu.setSaleable(true); spu.setValid(true); spu.setCreateTime(new Date()); spu.setLastUpdateTime(spu.getCreateTime()); this.spuMapper.insert(spu); // 保存spu详情 spu.getSpuDetail().setSpuId(spu.getId()); this.spuDetailMapper.insert(spu.getSpuDetail()); // 保存sku和库存信息 saveSkuAndStock(spu.getSkus(), spu.getId());&#125;private void saveSkuAndStock(List&lt;Sku&gt; skus, Long spuId) &#123; for (Sku sku : skus) &#123; if (!sku.getEnable()) &#123; continue; &#125; // 保存sku sku.setSpuId(spuId); // 默认不参与任何促销 sku.setCreateTime(new Date()); sku.setLastUpdateTime(sku.getCreateTime()); this.skuMapper.insert(sku); // 保存库存信息 Stock stock = new Stock(); stock.setSkuId(sku.getId()); stock.setStock(sku.getStock()); this.stockMapper.insert(stock); &#125;&#125; Mapper 都是通用Mapper，略]]></content>
  </entry>
  <entry>
    <title><![CDATA[day08-品牌管理]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F27%2Fday08-%E5%93%81%E7%89%8C%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[学习目标 独立实现品牌新增 实现图片上传 了解FastDFS的安装 使用FastDFS客户端实现上传 品牌的新增 昨天我们完成了品牌的查询，接下来就是新增功能。 页面实现 初步编写弹窗 当我们点击新增按钮，应该出现一个弹窗，然后在弹窗中出现一个表格，我们就可以填写品牌信息了。 我们查看Vuetify官网，弹窗是如何实现： 另外，我们可以通过文档看到对话框的一些属性： value：控制窗口的可见性，true可见，false，不可见 max-width：控制对话框最大宽度 scrollable ：是否可滚动，要配合v-card来使用，默认是false persistent ：点击弹窗以外的地方不会关闭弹窗，默认是false 现在，我们来使用一下。 首先，我们在data中定义一个show属性，来控制对话框的显示状态： 然后，在页面添加一个v-dialog 12345678910111213&lt;!--弹出的对话框--&gt;&lt;v-dialog max-width="500" v-model="show" persistent&gt; &lt;v-card&gt; &lt;!--对话框的标题--&gt; &lt;v-toolbar dense dark color="primary"&gt; &lt;v-toolbar-title&gt;新增品牌&lt;/v-toolbar-title&gt; &lt;/v-toolbar&gt; &lt;!--对话框的内容，表单--&gt; &lt;v-card-text class="px-5"&gt; 我是表单 &lt;/v-card-text&gt; &lt;/v-card&gt;&lt;/v-dialog&gt; 说明： 我们给dialog指定了3个属性，分别是 max-width：限制宽度 v-model：value值双向绑定到show变量，用来控制窗口显示 persisitent：控制窗口不会被意外关闭 因为可滚动需要配合v-card使用，因此我们在对话框中加入了一个v-card 在v-card的头部添加了一个 v-toolbar，作为窗口的头部，并且写了标题为：新增品牌 dense：紧凑显示 dark：黑暗主题 color：颜色，primary就是整个网站的主色调，蓝色 在v-card的内容部分，暂时空置，等会写表单 class=“px-5&quot;：vuetify的内置样式，含义是padding的x轴设置为5，这样表单内容会缩进一些，而不是顶着边框 基本语法：{property}{direction}-{size} property：属性，有两种padding和margin p：对应padding m：对应margin direction：只padding和margin的作用方向， t - 对应margin-top或者padding-top属性 b - 对应margin-bottom or padding-bottom l - 对应margin-left or padding-left r - 对应margin-right or padding-right x - 同时对应*-left和*-right属性 y - 同时对应*-top和*-bottom属性 size：控制空间大小，基于$spacer进行倍增，$spacer默认是16px 0：将margin或padding的大小设置为0 1 - 将margin或者padding属性设置为$spacer * .25 2 - 将margin或者padding属性设置为$spacer * .5 3 - 将margin或者padding属性设置为$spacer 4 - 将margin或者padding属性设置为$spacer * 1.5 5 - 将margin或者padding属性设置为$spacer * 3 实现弹窗的可见和关闭 窗口可见 接下来，我们要在点击新增品牌按钮时，将窗口显示，因此要给新增按钮绑定事件。 1&lt;v-btn color="primary" @click="addBrand"&gt;新增品牌&lt;/v-btn&gt; 然后定义一个addBrand方法： 1234addBrand()&#123; // 控制弹窗可见： this.show = true;&#125; 效果： 窗口关闭 现在，悲剧发生了，因为我们设置了persistent属性，窗口无法被关闭了。除非把show属性设置为false 因此我们需要给窗口添加一个关闭按钮： 1234567&lt;!--对话框的标题--&gt;&lt;v-toolbar dense dark color="primary"&gt; &lt;v-toolbar-title&gt;新增品牌&lt;/v-toolbar-title&gt; &lt;v-spacer/&gt; &lt;!--关闭窗口的按钮--&gt; &lt;v-btn icon @click="closeWindow"&gt;&lt;v-icon&gt;close&lt;/v-icon&gt;&lt;/v-btn&gt;&lt;/v-toolbar&gt; 并且，我们还给按钮绑定了点击事件，回调函数为closeWindow。 接下来，编写closeWindow函数： 1234closeWindow()&#123; // 关闭窗口 this.show = false;&#125; 效果： 新增品牌的表单页 接下来就是写表单了。我们有两种选择： 直接在dialog对话框中编写表单代码 另外编写一个组件，组件内写表单代码。然后在对话框引用组件 选第几种？ 我们选第二种方案，优点： 表单代码独立组件，可拔插，方便后期的维护。 代码分离，可读性更好。 我们新建一个MyBrandForm.vue组件： 将MyBrandForm引入到MyBrand中，这里使用局部组件的语法： 先导入自定义组件： 12// 导入自定义的表单组件import MyBrandForm from './MyBrandForm' 然后通过components属性来指定局部组件： 123components:&#123; MyBrandForm&#125; 然后在页面中引用： 页面效果： 编写表单 表单 查看文档，找到关于表单的部分： v-form，表单组件，内部可以有许多输入项。v-form有下面的属性： value：true，代表表单验证通过；false，代表表单验证失败 v-form提供了两个方法： reset：重置表单数据 validate：校验整个表单数据，前提是你写好了校验规则。返回Boolean表示校验成功或失败 我们在data中定义一个valid属性，跟表单的value进行双向绑定，观察表单是否通过校验，同时把等会要跟表单关联的品牌brand对象声明出来： 1234567891011121314export default &#123; name: "my-brand-form", data() &#123; return &#123; valid:false, // 表单校验结果标记 brand:&#123; name:'', // 品牌名称 letter:'', // 品牌首字母 image:'',// 品牌logo categories:[], // 品牌所属的商品分类数组 &#125; &#125; &#125;&#125; 然后，在页面先写一个表单： 123&lt;v-form v-model="valid"&gt;&lt;/v-form&gt; 文本框 我们的品牌总共需要这些字段： 名称 首字母 商品分类，有很多个 LOGO 表单项主要包括文本框、密码框、多选框、单选框、文本域、下拉选框、文件上传等。思考下我们的品牌需要哪些？ 文本框：品牌名称、品牌首字母都属于文本框 文件上传：品牌需要图片，这个是文件上传框 下拉选框：商品分类提前已经定义好，这里需要通过下拉选框展示，提供给用户选择。 先看文本框，昨天已经用过的，叫做v-text-field： 查看文档，v-text-field有以下关键属性： append-icon：文本框后追加图标，需要填写图标名称。无默认值 clearable：是否添加一个清空图标，点击会清空文本框。默认是false color：颜色 counter：是否添加一个文本计数器，在角落显示文本长度，指定true或允许的组大长度。无默认值 dark：是否应用黑暗色调，默认是false disable：是否禁用，默认是false flat：是否移除默认的动画效果，默认是false full-width：指定宽度为全屏，默认是false hide-details：是否因此错误提示，默认是false hint：输入框的提示文本 label：输入框的标签 multi-line：是否转为文本域，默认是false。文本框和文本域可以自由切换 placeholder：输入框占位符文本，focus后消失 required：是否为必填项，如果是，会在label后加*，不具备校验功能。默认是false rows：文本域的行数，multi-line为true时才有效 rules：指定校验规则及错误提示信息，数组结构。默认[] single-line：是否单行文本显示，默认是false suffix：显示后缀 接下来，我们先添加两个字段：品牌名称、品牌的首字母，校验规则暂时不写： 1234&lt;v-form v-model="valid"&gt; &lt;v-text-field v-model="brand.name" label="请输入品牌名称" required /&gt; &lt;v-text-field v-model="brand.letter" label="请输入品牌首字母" required /&gt;&lt;/v-form&gt; 千万不要忘了通过v-model把表单项与brand的属性关联起来。 效果： 级联下拉选框 接下来就是商品分类了，按照刚才的分析，商品分类应该是下拉选框。 但是大家仔细思考，商品分类包含三级。在展示的时候，应该是先由用户选中1级，才显示2级；选择了2级，才显示3级。形成一个多级分类的三级联动效果。 这个时候，就不是普通的下拉选框，而是三级联动的下拉选框！ 这样的选框，在Vuetify中并没有提供（它提供的是基本的下拉框）。因此我已经给大家编写了一个无限级联动的下拉选框，能够满足我们的需求。 具体请参考课前资料的《自定义组件用法指南.md》 我们在代码中使用： 123456&lt;v-cascader url="/item/category/list" multiple required v-model="brand.categories" label="请选择商品分类"/&gt; url：加载商品分类选项的接口路径 multiple：是否多选，这里设置为true，因为一个品牌可能有多个分类 requried：是否是必须的，这里为true，会在提示上加*，提醒用户 v-model：关联我们brand对象的categories属性 label：文字说明 效果： data中获取的结果： 文件上传项 在Vuetify中，也没有文件上传的组件。 还好，我已经给大家写好了一个文件上传的组件： 详细用法，参考《自定义组件使用指南.md》 我们添加上传的组件： 1234567891011121314&lt;v-layout row&gt; &lt;v-flex xs3&gt; &lt;span style="font-size: 16px; color: #444"&gt;品牌LOGO：&lt;/span&gt; &lt;/v-flex&gt; &lt;v-flex&gt; &lt;v-upload v-model="brand.image" url="/upload" :multiple="false" :pic-width="250" :pic-height="90" /&gt; &lt;/v-flex&gt;&lt;/v-layout&gt; 注意： 文件上传组件本身没有提供文字提示。因此我们需要自己添加一段文字说明 我们要实现文字和图片组件左右放置，因此这里使用了v-layout布局组件： layout添加了row属性，代表这是一行，如果是column，代表是多行 layout下面有v-flex组件，是这一行的单元，我们有2个单元 &lt;v-flex xs3&gt; ：显示文字说明，xs3是响应式布局，代表占12格中的3格 剩下的部分就是图片上传组件了 v-upload：图片上传组件，包含以下属性： v-model：将上传的结果绑定到brand的image属性 url：上传的路径，我们先随便写一个。 multiple：是否运行多图片上传，这里是false。因为品牌LOGO只有一个 pic-width和pic-height：可以控制l图片上传后展示的宽高 最终结果： 按钮 上面已经把所有的表单项写完。最后就差提交和清空的按钮了。 在表单的最下面添加两个按钮： 12345&lt;v-layout class="my-4" row&gt; &lt;v-spacer/&gt; &lt;v-btn @click="submit" color="primary"&gt;提交&lt;/v-btn&gt; &lt;v-btn @click="clear" &gt;重置&lt;/v-btn&gt;&lt;/v-layout&gt; 通过layout来进行布局，my-4增大上下边距 v-spacer占用一定空间，将按钮都排挤到页面右侧 两个按钮分别绑定了submit和clear事件 我们先将方法定义出来： 12345678methods:&#123; submit()&#123; // 提交表单 &#125;, clear()&#123; // 重置表单 &#125;&#125; 重置表单相对简单，因为v-form组件已经提供了reset方法，用来清空表单数据。只要我们拿到表单组件对象，就可以调用方法了。 我们可以通过$refs内置对象来获取表单组件。 首先，在表单上定义ref属性： 然后，在页面查看this.$refs属性： 看到this.$refs中只有一个属性，就是myBrandForm 我们在clear中来获取表单对象并调用reset方法： 123456789101112methods:&#123; submit()&#123; // 提交表单 console.log(this); &#125;, clear()&#123; // 重置表单 this.$refs.myBrandForm.reset(); // 需要手动清空商品分类 this.categories = []; &#125;&#125; 要注意的是，这里我们还手动把this.categories清空了，因为我写的级联选择组件并没有跟表单结合起来。需要手动清空。 表单校验 校验规则 Vuetify的表单校验，是通过rules属性来指定的： 校验规则的写法： 说明： 规则是一个数组 数组中的元素是一个函数，该函数接收表单项的值作为参数，函数返回值两种情况： 返回true，代表成功， 返回错误提示信息，代表失败 项目中代码 我们有四个字段： name：做非空校验和长度校验，长度必须大于1 letter：首字母，校验长度为1，非空。 image：图片，不做校验，图片可以为空 categories：非空校验，自定义组件已经帮我们完成，不用写了 首先，我们定义规则： 12345678nameRules:[ v =&gt; !!v || "品牌名称不能为空", v =&gt; v.length &gt; 1 || "品牌名称至少2位"],letterRules:[ v =&gt; !!v || "首字母不能为空", v =&gt; /^[A-Z]&#123;1&#125;$/.test(v) || "品牌字母只能是A~Z的大写字母"] 然后，在页面标签中指定： 12&lt;v-text-field v-model="brand.name" label="请输入品牌名称" required :rules="nameRules" /&gt;&lt;v-text-field v-model="brand.letter" label="请输入品牌首字母" required :rules="letterRules" /&gt; 效果： 表单提交 在submit方法中添加表单提交的逻辑： 1234567891011121314151617181920submit() &#123; // 1、表单校验 if (this.$refs.myBrandForm.validate()) &#123; // 2、定义一个请求参数对象，通过解构表达式来获取brand中的属性 const &#123;categories ,letter ,...params&#125; = this.brand; // 3、数据库中只要保存分类的id即可，因此我们对categories的值进行处理,只保留id，并转为字符串 params.cids = categories.map(c =&gt; c.id).join(","); // 4、将字母都处理为大写 params.letter = letter.toUpperCase(); // 5、将数据提交到后台 this.$http.post('/item/brand', params) .then(() =&gt; &#123; // 6、弹出提示 this.$message.success("保存成功！"); &#125;) .catch(() =&gt; &#123; this.$message.error("保存失败！"); &#125;); &#125;&#125; 1、通过this.$refs.myBrandForm选中表单，然后调用表单的validate方法，进行表单校验。返回boolean值，true代表校验通过 2、通过解构表达式来获取brand中的值，categories和letter需要处理，单独获取。其它的存入params对象中 3、品牌和商品分类的中间表只保存两者的id，而brand.categories中保存的数对象数组，里面有id和name属性，因此这里通过数组的map功能转为id数组，然后通过join方法拼接为字符串 4、首字母都处理为大写保存 5、发起请求 6、弹窗提示成功还是失败，这里用到的是我们的自定义组件功能message组件： 这个插件把$message对象绑定到了Vue的原型上，因此我们可以通过this.$message来直接调用。 包含以下常用方法： info、error、success、warning等，弹出一个带有提示信息的窗口，色调与为普通（灰）、错误（红色）、成功（绿色）和警告（黄色）。使用方法：this.$message.info(“msg”) confirm：确认框。用法：this.$message.confirm(&quot;确认框的提示信息&quot;)，返回一个Promise 后台实现新增 controller 还是一样，先分析四个内容： 请求方式：刚才看到了是POST 请求路径：/brand 请求参数：brand对象，外加商品分类的id数组cids 返回值：无 代码： 12345678910/** * 新增品牌 * @param brand * @return */@PostMappingpublic ResponseEntity&lt;Void&gt; saveBrand(Brand brand, @RequestParam("cids") List&lt;Long&gt; cids) &#123; this.brandService.saveBrand(brand, cids); return new ResponseEntity&lt;&gt;(HttpStatus.CREATED);&#125; Service 这里要注意，我们不仅要新增品牌，还要维护品牌和商品分类的中间表。 123456789@Transactionalpublic void saveBrand(Brand brand, List&lt;Long&gt; cids) &#123; // 新增品牌信息 this.brandMapper.insertSelective(brand); // 新增品牌和分类中间表 for (Long cid : cids) &#123; this.brandMapper.insertCategoryBrand(cid, brand.getId()); &#125;&#125; 这里调用了brandMapper中的一个自定义方法，来实现中间表的数据新增 Mapper 通用Mapper只能处理单表，也就是Brand的数据，因此我们手动编写一个方法及sql，实现中间表的新增： 12345678910public interface BrandMapper extends Mapper&lt;Brand&gt; &#123; /** * 新增商品分类和品牌中间表数据 * @param cid 商品分类id * @param bid 品牌id * @return */ @Insert("INSERT INTO tb_category_brand (category_id, brand_id) VALUES (#&#123;cid&#125;,#&#123;bid&#125;)") int insertCategoryBrand(@Param("cid") Long cid, @Param("bid") Long bid);&#125; 请求参数格式错误 原因分析 我们填写表单并提交，发现报错了： 查看控制台的请求详情： 发现请求的数据格式是JSON格式。 原因分析： axios处理请求体的原则会根据请求数据的格式来定： 如果请求体是对象：会转为json发送 如果请求体是String：会作为普通表单请求发送，但需要我们自己保证String的格式是键值对。 如：name=jack&amp;age=12 QS工具 QS是一个第三方库，我们可以用npm install qs --save来安装。不过我们在项目中已经集成了，大家无需安装： 这个工具的名字：QS，即Query String，请求参数字符串。 什么是请求参数字符串？例如： name=jack&amp;age=21 QS工具可以便捷的实现 JS的Object与QueryString的转换。 在我们的项目中，将QS注入到了Vue的原型对象中，我们可以通过this.$qs来获取这个工具： 我们将this.$qs对象打印到控制台： 123created()&#123; console.log(this.$qs);&#125; 发现其中有3个方法： 这里我们要使用的方法是stringify，它可以把Object转为QueryString。 测试一下，使用浏览器工具，把qs对象保存为一个临时变量： 然后调用stringify方法： 成功将person对象变成了 name=jack&amp;age=21的字符串了 解决问题 修改页面，对参数处理后发送： 然后再次发起请求： 发现请求成功： 参数格式： 数据库： 新增完成后关闭窗口 我们发现有一个问题：新增不管成功还是失败，窗口都一致在这里，不会关闭。 这样很不友好，我们希望如果新增失败，窗口保持；但是新增成功，窗口关闭才对。 因此，我们需要在新增的ajax请求完成以后，关闭窗口 但问题在于，控制窗口是否显示的标记在父组件：MyBrand.vue中。子组件如何才能操作父组件的属性？或者告诉父组件该关闭窗口了？ 之前我们讲过一个父子组件的通信，有印象吗？ 第一步，在父组件中定义一个函数，用来关闭窗口，不过之前已经定义过了，我们优化一下，关闭的同时重新加载数据： 123456closeWindow()&#123; // 关闭窗口 this.show = false; // 重新加载数据 this.getDataFromServer();&#125; 第二步，父组件在使用子组件时，绑定事件，关联到这个函数： 1234&lt;!--对话框的内容，表单--&gt;&lt;v-card-text class="px-5"&gt; &lt;my-brand-form @close="closeWindow"/&gt;&lt;/v-card-text&gt; 第三步，子组件通过this.$emit调用父组件的函数： 测试一下 实现图片上传 刚才的新增实现中，我们并没有上传图片，接下来我们一起完成图片上传逻辑。 文件的上传并不只是在品牌管理中有需求，以后的其它服务也可能需要，因此我们创建一个独立的微服务，专门处理各种上传。 搭建项目 创建module 依赖 我们需要EurekaClient和web依赖： 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-upload&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 编写配置 12345678910111213141516171819server: port: 8082spring: application: name: upload-service servlet: multipart: max-file-size: 5MB # 限制文件上传的大小# Eurekaeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 需要注意的是，我们应该添加了限制文件大小的配置 启动类 1234567@SpringBootApplication@EnableDiscoveryClientpublic class LyUploadService &#123; public static void main(String[] args) &#123; SpringApplication.run(LyUploadService.class, args); &#125;&#125; 结构： 编写上传功能 controller 编写controller需要知道4个内容： 请求方式：上传肯定是POST 请求路径：/upload/image 请求参数：文件，参数名是file，SpringMVC会封装为一个接口：MultipleFile 返回结果：上传成功后得到的文件的url路径 代码如下： 1234567891011121314151617181920212223@RestController@RequestMapping("upload")public class UploadController &#123; @Autowired private UploadService uploadService; /** * 上传图片功能 * @param file * @return */ @PostMapping("image") public ResponseEntity&lt;String&gt; uploadImage(@RequestParam("file") MultipartFile file) &#123; String url = this.uploadService.upload(file); if (StringUtils.isBlank(url)) &#123; // url为空，证明上传失败 return new ResponseEntity&lt;&gt;(HttpStatus.BAD_REQUEST); &#125; // 返回200，并且携带url路径 return ResponseEntity.ok(url); &#125;&#125; service 在上传文件过程中，我们需要对上传的内容进行校验： 校验文件大小 校验文件的媒体类型 校验文件的内容 文件大小在Spring的配置文件中设置，因此已经会被校验，我们不用管。 具体代码： 1234567891011121314151617181920212223242526272829303132333435363738394041@Servicepublic class UploadService &#123; private static final Logger logger = LoggerFactory.getLogger(UploadController.class); // 支持的文件类型 private static final List&lt;String&gt; suffixes = Arrays.asList("image/png", "image/jpeg"); public String upload(MultipartFile file) &#123; try &#123; // 1、图片信息校验 // 1)校验文件类型 String type = file.getContentType(); if (!suffixes.contains(type)) &#123; logger.info("上传失败，文件类型不匹配：&#123;&#125;", type); return null; &#125; // 2)校验图片内容 BufferedImage image = ImageIO.read(file.getInputStream()); if (image == null) &#123; logger.info("上传失败，文件内容不符合要求"); return null; &#125; // 2、保存图片 // 2.1、生成保存目录 File dir = new File("D:\\heima\\upload"); if (!dir.exists()) &#123; dir.mkdirs(); &#125; // 2.2、保存图片 file.transferTo(new File(dir, file.getOriginalFilename())); // 2.3、拼接图片地址 String url = "http://image.leyou.com/upload/" + file.getOriginalFilename(); return url; &#125; catch (Exception e) &#123; return null; &#125; &#125;&#125; 这里有一个问题：为什么图片地址需要使用另外的url？ 图片不能保存在服务器内部，这样会对服务器产生额外的加载负担 一般静态资源都应该使用独立域名，这样访问静态资源时不会携带一些不必要的cookie，减小请求的数据量 测试上传 我们通过RestClient工具来测试： 结果： 去目录下查看： 上传成功！ 绕过网关 图片上传是文件的传输，如果也经过Zuul网关的代理，文件就会经过多次网路传输，造成不必要的网络负担。在高并发时，可能导致网络阻塞，Zuul网关不可用。这样我们的整个系统就瘫痪了。 所以，我们上传文件的请求就不经过网关来处理了。 Zuul的路由过滤 Zuul中提供了一个ignored-patterns属性，用来忽略不希望路由的URL路径，示例： 1zuul.ignored-patterns: /upload/** 路径过滤会对一切微服务进行判定。 Zuul还提供了ignored-services属性，进行服务过滤： 1zuul.ignored-services: upload-servie 我们这里采用忽略服务： 123zuul: ignored-services: - upload-service # 忽略upload-service服务 上面的配置采用了集合语法，代表可以配置多个 Nginx的rewrite指令 现在，我们修改页面的访问路径： 123456&lt;v-upload v-model="brand.image" url="/upload/image" :multiple="false" :pic-width="250" :pic-height="90" /&gt; 查看页面的请求路径： 可以看到这个地址不对，依然是去找Zuul网关，因为我们的系统全局配置了URL地址。怎么办？ 有同学会想：修改页面请求地址不就好了。 注意：原则上，我们是不能把除了网关以外的服务对外暴露的，不安全。 既然不能修改页面请求，那么就只能在Nginx反向代理上做文章了。 我们修改nginx配置，将以/api/upload开头的请求拦截下来，转交到真实的服务地址: 12345location /api/upload &#123; proxy_pass http://127.0.0.1:8082; proxy_connect_timeout 600; proxy_read_timeout 600;&#125; 这样写大家觉得对不对呢？ 显然是不对的，因为ip和端口虽然对了，但是路径没变，依然是：http://127.0.0.1:8002/api/upload/image 前面多了一个/api Nginx提供了rewrite指令，用于对地址进行重写，语法规则： 1rewrite &quot;用来匹配路径的正则&quot; 重写后的路径 [指令]; 我们的案例： 1234567891011121314151617181920212223server &#123; listen 80; server_name api.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 上传路径的映射 location /api/upload &#123; proxy_pass http://127.0.0.1:8082; proxy_connect_timeout 600; proxy_read_timeout 600; rewrite "^/api/(.*)$" /$1 break; &#125; location / &#123; proxy_pass http://127.0.0.1:10010; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125; 首先，我们映射路径是/api/upload，而下面一个映射路径是 / ，根据最长路径匹配原则，/api/upload优先级更高。也就是说，凡是以/api/upload开头的路径，都会被第一个配置处理 proxy_pass：反向代理，这次我们代理到8082端口，也就是upload-service服务 rewrite &quot;^/api/(.*)$&quot; /$1 break，路径重写： &quot;^/api/(.*)$&quot;：匹配路径的正则表达式，用了分组语法，把/api/以后的所有部分当做1组 /$1：重写的目标路径，这里用$1引用前面正则表达式匹配到的分组（组编号从1开始），即/api/后面的所有。这样新的路径就是除去/api/以外的所有，就达到了去除/api前缀的目的 break：指令，常用的有2个，分别是：last、break last：重写路径结束后，将得到的路径重新进行一次路径匹配 break：重写路径结束后，不再重新匹配路径。 我们这里不能选择last，否则以新的路径/upload/image来匹配，就不会被正确的匹配到8082端口了 修改完成，输入nginx -s reload命令重新加载配置。然后再次上传试试。 跨域问题 重启nginx，再次上传，发现报错了： 不过庆幸的是，这个错误已经不是第一次见了，跨域问题。 我们在upload-service中添加一个CorsFilter即可： 1234567891011121314151617181920212223@Configurationpublic class GlobalCorsConfig &#123; @Bean public CorsFilter corsFilter() &#123; //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 config.addAllowedOrigin("http://manage.leyou.com"); //2) 是否发送Cookie信息 config.setAllowCredentials(false); //3) 允许的请求方式 config.addAllowedMethod("OPTIONS"); config.addAllowedMethod("POST"); config.addAllowedHeader("*"); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration("/**", config); //3.返回新的CorsFilter. return new CorsFilter(configSource); &#125;&#125; 再次测试： 不过，非常遗憾的是，访问图片地址，却没有响应。 这是因为我们并没有任何服务器对应image.leyou.com这个域名。。 这个问题，我们暂时放下，回头再来解决。 之前上传的缺陷 先思考一下，之前上传的功能，有没有什么问题？ 上传本身没有任何问题，问题出在保存文件的方式，我们是保存在服务器机器，就会有下面的问题： 单机器存储，存储能力有限 无法进行水平扩展，因为多台机器的文件无法共享,会出现访问不到的情况 数据没有备份，有单点故障风险 并发能力差 这个时候，最好使用分布式文件存储来代替本地文件存储。 FastDFS 什么是分布式文件系统 分布式文件系统（Distributed File System）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连。 通俗来讲： 传统文件系统管理的文件就存储在本机。 分布式文件系统管理的文件存储在很多机器，这些机器通过网络连接，要被统一管理。无论是上传或者访问文件，都需要通过管理中心来访问 什么是FastDFS FastDFS是由淘宝的余庆先生所开发的一个轻量级、高性能的开源分布式文件系统。用纯C语言开发，功能丰富： 文件存储 文件同步 文件访问（上传、下载） 存取负载均衡 在线扩容 适合有大容量存储需求的应用或系统。同类的分布式文件系统有谷歌的GFS、HDFS（Hadoop）、TFS（淘宝）等。 FastDFS的架构 架构图 先上图： FastDFS两个主要的角色：Tracker Server 和 Storage Server 。 Tracker Server：跟踪服务器，主要负责调度storage节点与client通信，在访问上起负载均衡的作用，和记录storage节点的运行状态，是连接client和storage节点的枢纽。 Storage Server：存储服务器，保存文件和文件的meta data（元数据），每个storage server会启动一个单独的线程主动向Tracker cluster中每个tracker server报告其状态信息，包括磁盘使用情况，文件同步情况及文件上传下载次数统计等信息 Group：文件组，多台Storage Server的集群。上传一个文件到同组内的一台机器上后，FastDFS会将该文件即时同步到同组内的其它所有机器上，起到备份的作用。不同组的服务器，保存的数据不同，而且相互独立，不进行通信。 Tracker Cluster：跟踪服务器的集群，有一组Tracker Server（跟踪服务器）组成。 Storage Cluster ：存储集群，有多个Group组成。 上传和下载流程 上传 Client通过Tracker server查找可用的Storage server。 Tracker server向Client返回一台可用的Storage server的IP地址和端口号。 Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并进行文件上传。 上传完成，Storage server返回Client一个文件ID，文件上传结束。 下载 Client通过Tracker server查找要下载文件所在的的Storage server。 Tracker server向Client返回包含指定文件的某个Storage server的IP地址和端口号。 Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并指定要下载文件。 下载文件成功。 安装和使用 参考课前资料的：《centos安装FastDFS.md》 java客户端 余庆先生提供了一个Java客户端，但是作为一个C程序员，写的java代码可想而知。而且已经很久不维护了。 这里推荐一个开源的FastDFS客户端，支持最新的SpringBoot2.0。 配置使用极为简单，支持连接池，支持自动生成缩略图，狂拽酷炫吊炸天啊，有木有。 地址：tobato/FastDFS_client 引入依赖 在父工程中，我们已经管理了依赖，版本为： 1&lt;fastDFS.client.version&gt;1.26.2&lt;/fastDFS.client.version&gt; 因此，这里我们直接引入坐标即可： 1234&lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt;&lt;/dependency&gt; 引入配置类 纯java配置： 123456@Configuration@Import(FdfsClientConfig.class)// 解决jmx重复注册bean的问题@EnableMBeanExport(registration = RegistrationPolicy.IGNORE_EXISTING)public class FastClientImporter &#123;&#125; 编写FastDFS属性 12345678fdfs: so-timeout: 1501 connect-timeout: 601 thumb-image: # 缩略图 width: 60 height: 60 tracker-list: # tracker地址 - 192.168.56.101:22122 测试 12345678910111213141516171819202122232425262728293031323334353637@RunWith(SpringRunner.class)@SpringBootTest(classes = LyUploadService.class)public class FdfsTest &#123; @Autowired private FastFileStorageClient storageClient; @Autowired private ThumbImageConfig thumbImageConfig; @Test public void testUpload() throws FileNotFoundException &#123; File file = new File("D:\\test\\baby.png"); // 上传并且生成缩略图 StorePath storePath = this.storageClient.uploadFile( new FileInputStream(file), file.length(), "png", null); // 带分组的路径 System.out.println(storePath.getFullPath()); // 不带分组的路径 System.out.println(storePath.getPath()); &#125; @Test public void testUploadAndCreateThumb() throws FileNotFoundException &#123; File file = new File("D:\\test\\baby.png"); // 上传并且生成缩略图 StorePath storePath = this.storageClient.uploadImageAndCrtThumbImage( new FileInputStream(file), file.length(), "png", null); // 带分组的路径 System.out.println(storePath.getFullPath()); // 不带分组的路径 System.out.println(storePath.getPath()); // 获取缩略图路径 String path = thumbImageConfig.getThumbImagePath(storePath.getPath()); System.out.println(path); &#125;&#125; 结果： 123group1/M00/00/00/wKg4ZVro5eCAZEMVABfYcN8vzII630.pngM00/00/00/wKg4ZVro5eCAZEMVABfYcN8vzII630.pngM00/00/00/wKg4ZVro5eCAZEMVABfYcN8vzII630_60x60.png 访问第一个路径： 访问最后一个路径（缩略图路径），注意加组名： 改造上传逻辑 12345678910111213141516171819202122232425262728293031323334353637383940@Servicepublic class UploadService &#123; private static final Logger logger = LoggerFactory.getLogger(UploadController.class); // 支持的文件类型 private static final List&lt;String&gt; suffixes = Arrays.asList("image/png", "image/jpeg"); @Autowired FastFileStorageClient storageClient; public String upload(MultipartFile file) &#123; try &#123; // 1、图片信息校验 // 1)校验文件类型 String type = file.getContentType(); if (!suffixes.contains(type)) &#123; logger.info("上传失败，文件类型不匹配：&#123;&#125;", type); return null; &#125; // 2)校验图片内容 BufferedImage image = ImageIO.read(file.getInputStream()); if (image == null) &#123; logger.info("上传失败，文件内容不符合要求"); return null; &#125; // 2、将图片上传到FastDFS // 2.1、获取文件后缀名 String extension = StringUtils.substringAfterLast(file.getOriginalFilename(), "."); // 2.2、上传 StorePath storePath = this.storageClient.uploadFile( file.getInputStream(), file.getSize(), extension, null); // 2.3、返回完整路径 return "http://image.leyou.com/" + storePath.getFullPath(); &#125; catch (Exception e) &#123; return null; &#125; &#125;&#125; 只需要把原来保存文件的逻辑去掉，然后上传到FastDFS即可。 测试 通过RestClient测试： 页面测试上传 发现上传成功： 不过，当我们访问页面时： 这是因为我们图片是上传到虚拟机的，ip为：192.168.56.101 因此，我们需要将image.leyou.com映射到192.168.56.101 修改我们的hosts： 再次上传： 修改品牌（作业） 修改的难点在于回显。 当我们点击编辑按钮，希望弹出窗口的同时，看到原来的数据： 点击编辑出现弹窗 这个比较简单，修改show属性为true即可实现，我们绑定一个点击事件： 1&lt;v-btn color="info" @click="editBrand"&gt;编辑&lt;/v-btn&gt; 然后编写事件，改变show 的状态： 如果仅仅是这样，编辑按钮与新增按钮将没有任何区别，关键在于，如何回显呢？ 回显数据 回显数据，就是把当前点击的品牌数据传递到子组件（MyBrandForm）。而父组件给子组件传递数据，通过props属性。 第一步：在编辑时获取当前选中的品牌信息，并且记录到data中 先在data中定义属性，用来接收用来编辑的brand数据： 我们在页面触发编辑事件时，把当前的brand传递给editBrand方法： 1&lt;v-btn color="info" @click="editBrand(props.item)"&gt;编辑&lt;/v-btn&gt; 然后在editBrand中接收数据，赋值给oldBrand： 123456editBrand(oldBrand)&#123; // 控制弹窗可见： this.show = true; // 获取要编辑的brand this.oldBrand = oldBrand;&#125;, 第二步：把获取的brand数据 传递给子组件 1234&lt;!--对话框的内容，表单--&gt;&lt;v-card-text class="px-5"&gt; &lt;my-brand-form @close="closeWindow" :oldBrand="oldBrand"/&gt;&lt;/v-card-text&gt; 第三步：在子组件中通过props接收要编辑的brand数据，Vue会自动完成回显 接收数据： 通过watch函数监控oldBrand的变化，把值copy到本地的brand： 12345678910111213141516171819watch: &#123; oldBrand: &#123;// 监控oldBrand的变化 handler(val) &#123; if(val)&#123; // 注意不要直接复制，否则这边的修改会影响到父组件的数据，copy属性即可 this.brand = Object.deepCopy(val) &#125;else&#123; // 为空，初始化brand this.brand = &#123; name: '', letter: '', image: '', categories: [], &#125; &#125; &#125;, deep: true &#125;&#125; Object.deepCopy 自定义的对对象进行深度复制的方法。 需要判断监听到的是否为空，如果为空，应该进行初始化 测试：发现数据回显了，除了商品分类以外： 商品分类回显 为什么商品分类没有回显？ 因为品牌中并没有商品分类数据。我们需要在进入编辑页面之前，查询商品分类信息： 后台提供接口 controller 12345678910111213/** * 通过品牌id查询商品分类 * @param bid * @return */@GetMapping("bid/&#123;bid&#125;")public ResponseEntity&lt;List&lt;Category&gt;&gt; queryByBrandId(@PathVariable("bid") Long bid) &#123; List&lt;Category&gt; list = this.categoryService.queryByBrandId(bid); if (list == null || list.size() &lt; 1) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(list);&#125; Service 123public List&lt;Category&gt; queryByBrandId(Long bid) &#123; return this.categoryMapper.queryByBrandId(bid);&#125; mapper 因为需要通过中间表进行子查询，所以这里要手写Sql： 1234567/** * 根据品牌id查询商品分类 * @param bid * @return */@Select("SELECT * FROM tb_category WHERE id IN (SELECT category_id FROM tb_category_brand WHERE brand_id = #&#123;bid&#125;)")List&lt;Category&gt; queryByBrandId(Long bid); 前台查询分类并渲染 我们在编辑页面打开之前，先把数据查询完毕： 123456789101112editBrand(oldBrand)&#123; // 根据品牌信息查询商品分类 this.$http.get("/item/category/bid/" + oldBrand.id) .then((&#123;data&#125;) =&gt; &#123; // 控制弹窗可见： this.show = true; // 获取要编辑的brand this.oldBrand = oldBrand // 回显商品分类 this.oldBrand.categories = data; &#125;)&#125; 再次测试：数据成功回显了 新增窗口数据干扰 但是，此时却产生了新问题：新增窗口竟然也有数据？ 原因： ​ 如果之前打开过编辑，那么在父组件中记录的oldBrand会保留。下次再打开窗口，如果是编辑窗口到没问题，但是新增的话，就会再次显示上次打开的品牌信息了。 解决： ​ 新增窗口打开前，把数据置空。 123456addBrand() &#123; // 控制弹窗可见： this.show = true; // 把oldBrand变为null this.oldBrand = null;&#125; 提交表单时判断是新增还是修改 新增和修改是同一个页面，我们该如何判断？ 父组件中点击按钮弹出新增或修改的窗口，因此父组件非常清楚接下来是新增还是修改。 因此，最简单的方案就是，在父组件中定义变量，记录新增或修改状态，当弹出页面时，把这个状态也传递给子组件。 第一步：在父组件中记录状态： 第二步：在新增和修改前，更改状态： 第三步：传递给子组件 第四步，子组件接收标记： 标题的动态化： 表单提交动态： axios除了除了get和post外，还有一个通用的请求方式： 1234567891011121314// 将数据提交到后台// this.$http.post('/item/brand', this.$qs.stringify(params))this.$http(&#123; method: this.isEdit ? 'put' : 'post', // 动态判断是POST还是PUT url: '/item/brand', data: this.$qs.stringify(this.brand)&#125;).then(() =&gt; &#123; // 关闭窗口 this.$emit("close"); this.$message.success("保存成功！");&#125;) .catch(() =&gt; &#123; this.$message.error("保存失败！");&#125;); 删除（作业）]]></content>
  </entry>
  <entry>
    <title><![CDATA[day07-商品分类及品牌]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F27%2Fday07-%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB%E5%8F%8A%E5%93%81%E7%89%8C%2F</url>
    <content type="text"><![CDATA[学习目标 使用资料搭建后台系统 会使用nginx进行反向代理 实现商品分类查询功能 掌握cors解决跨域 实现品牌查询功能 使用域名访问本地项目 统一环境 我们现在访问页面使用的是：http://localhost:9001 有没有什么问题？ 实际开发中，会有不同的环境： 开发环境：自己的电脑 测试环境：提供给测试人员使用的环境 预发布环境：数据是和生成环境的数据一致，运行最新的项目代码进去测试 生产环境：项目最终发布上线的环境 如果不同环境使用不同的ip去访问，可能会出现一些问题。为了保证所有环境的一致，我们会在各种环境下都使用域名来访问。 我们将使用以下域名： 主域名是：www.leyou.com， 管理系统域名：manage.leyou.com 网关域名：api.leyou.com … 但是最终，我们希望这些域名指向的还是我们本机的某个端口。 那么，当我们在浏览器输入一个域名时，浏览器是如何找到对应服务的ip和端口的呢？ 域名解析 一个域名一定会被解析为一个或多个ip。这一般会包含两步： 本地域名解析 浏览器会首先在本机的hosts文件中查找域名映射的IP地址，如果查找到就返回IP ，没找到则进行域名服务器解析，一般本地解析都会失败，因为默认这个文件是空的。 Windows下的hosts文件地址：C:/Windows/System32/drivers/etc/hosts Linux下的hosts文件所在路径： /etc/hosts 样式： 1234# My hosts127.0.0.1 localhost0.0.0.0 account.jetbrains.com127.0.0.1 www.xmind.net 域名服务器解析 本地解析失败，才会进行域名服务器解析，域名服务器就是网络中的一台计算机，里面记录了所有注册备案的域名和ip映射关系，一般只要域名是正确的，并且备案通过，一定能找到。 解决域名解析问题 我们不可能去购买一个域名，因此我们可以伪造本地的hosts文件，实现对域名的解析。修改本地的host为： 12127.0.0.1 api.leyou.com127.0.0.1 manage.leyou.com 这样就实现了域名的关系映射了。 每次在C盘寻找hosts文件并修改是非常麻烦的，给大家推荐一个快捷修改host的工具，在课前资料中可以找到： 效果： 我们添加了两个映射关系： 127.0.0.1 api.leyou.com ：我们的网关Zuul 127.0.0.1 manage.leyou.com：我们的后台系统地址 现在，ping一下域名试试是否畅通： OK！ nginx解决端口问题 虽然域名解决了，但是现在如果我们要访问，还得自己加上端口：http://manage.taotao.com:9001。 这就不够优雅了。我们希望的是直接域名访问：http://manage.taotao.com。这种情况下端口默认是80，如何才能把请求转移到9001端口呢？ 这里就要用到反向代理工具：Nginx 什么是Nginx NIO：not-blocking-io 非阻塞IO BIO：blocking-IO 阻塞IO nginx可以作为web服务器，但更多的时候，我们把它作为网关，因为它具备网关必备的功能： 反向代理 负载均衡 动态路由 请求过滤 nginx作为web服务器 Web服务器分2类： web应用服务器，如： tomcat resin jetty web服务器，如： Apache 服务器 Nginx IIS 区分：web服务器不能解析jsp等页面，只能处理js、css、html等静态资源。并发：web服务器的并发能力远高于web应用服务器。 Nginx + tomcat nginx作为反向代理 什么是反向代理？ 代理：通过客户机的配置，实现让一台服务器代理客户机，客户的所有请求都交给代理服务器处理。 反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。 nginx可以当做反向代理服务器来使用： 我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理 当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能 利用反向代理，就可以解决我们前面所说的端口问题，如图 安装和使用 安装 安装非常简单，把课前资料提供的nginx直接解压即可，绿色免安装，舒服！ 我们在本地安装一台nginx： 目录结构： 使用 nginx可以通过命令行来启动，操作命令： 启动：start nginx.exe 停止：nginx.exe -s stop 重新加载：nginx.exe -s reload 反向代理配置 示例： nginx中的每个server就是一个反向代理配置，可以有多个server 完整配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#user nobody;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; server &#123; listen 80; server_name manage.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://127.0.0.1:9001; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125; server &#123; listen 80; server_name api.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://127.0.0.1:10010; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125;&#125; 测试 启动nginx，然后用域名访问后台管理系统： 现在实现了域名访问网站了，中间的流程是怎样的呢？ 浏览器准备发起请求，访问http://mamage.leyou.com，但需要进行域名解析 优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：127.0.0.1 请求被发往解析得到的ip，并且默认使用80端口：http://127.0.0.1:80 本机的nginx一直监听80端口，因此捕获这个请求 nginx中配置了反向代理规则，将manage.leyou.com代理到127.0.0.1:9001，因此请求被转发 后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx nginx将得到的结果返回到浏览器 实现商品分类查询 商城的核心自然是商品，而商品多了以后，肯定要进行分类，并且不同的商品会有不同的品牌信息，其关系如图所示： 一个商品分类下有很多商品 一个商品分类下有很多品牌 而一个品牌，可能属于不同的分类 一个品牌下也会有很多商品 因此，我们需要依次去完成：商品分类、品牌、商品的开发。 导入数据 首先导入课前资料提供的sql： 我们先看商品分类表： 123456789CREATE TABLE `tb_category` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;类目id&apos;, `name` varchar(20) NOT NULL COMMENT &apos;类目名称&apos;, `parent_id` bigint(20) NOT NULL COMMENT &apos;父类目id,顶级类目填0&apos;, `is_parent` tinyint(1) NOT NULL COMMENT &apos;是否为父节点，0为否，1为是&apos;, `sort` int(4) NOT NULL COMMENT &apos;排序指数，越小越靠前&apos;, PRIMARY KEY (`id`), KEY `key_parent_id` (`parent_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1424 DEFAULT CHARSET=utf8 COMMENT=&apos;商品类目表，类目和商品(spu)是一对多关系，类目与品牌是多对多关系&apos;; 因为商品分类会有层级关系，因此这里我们加入了parent_id字段，对本表中的其它分类进行自关联。 页面实现 页面分析 首先我们看下要实现的效果： 商品分类之间是会有层级关系的，采用树结构去展示是最直观的方式。 一起来看页面，对应的是/pages/item/Category.vue： 页面模板： 123456789101112&lt;v-card&gt; &lt;v-flex xs12 sm10&gt; &lt;v-tree url="/item/category/list" :treeData="treeData" :isEdit="isEdit" @handleAdd="handleAdd" @handleEdit="handleEdit" @handleDelete="handleDelete" @handleClick="handleClick" /&gt; &lt;/v-flex&gt;&lt;/v-card&gt; v-card：卡片，是vuetify中提供的组件，提供一个悬浮效果的面板，一般用来展示一组数据。 v-flex：布局容器，用来控制响应式布局。与BootStrap的栅格系统类似，整个屏幕被分为12格。我们可以控制所占的格数来控制宽度： 本例中，我们用sm10控制在小屏幕及以上时，显示宽度为10格 v-tree：树组件。Vuetify并没有提供树组件，这个是我们自己编写的自定义组件： 里面涉及一些vue的高级用法，大家暂时不要关注其源码，会用即可。 树组件的用法 也可参考课前资料中的：《自定义Vue组件的用法.md》 这里我贴出树组件的用法指南。 属性列表： 属性名称 说明 数据类型 默认值 url 用来加载数据的地址，即延迟加载 String - isEdit 是否开启树的编辑功能 boolean false treeData 整颗树数据，这样就不用远程加载了 Array - 这里推荐使用url进行延迟加载，每当点击父节点时，就会发起请求，根据父节点id查询子节点信息。 当有treeData属性时，就不会触发url加载 远程请求返回的结果格式： 12345678910111213141516[ &#123; "id": 74, "name": "手机", "parentId": 0, "isParent": true, "sort": 2 &#125;, &#123; "id": 75, "name": "家用电器", "parentId": 0, "isParent": true, "sort": 3 &#125;] 事件： 事件名称 说明 回调参数 handleAdd 新增节点时触发，isEdit为true时有效 新增节点node对象，包含属性：name、parentId和sort handleEdit 当某个节点被编辑后触发，isEdit为true时有效 被编辑节点的id和name handleDelete 当删除节点时触发，isEdit为true时有效 被删除节点的id handleClick 点击某节点时触发 被点击节点的node对象,包含全部信息 完整node的信息 回调函数中返回完整的node节点会包含以下数据： 12345678&#123; "id": 76, // 节点id "name": "手机", // 节点名称 "parentId": 75, // 父节点id "isParent": false, // 是否是父节点 "sort": 1, // 顺序 "path": ["手机", "手机通讯", "手机"] // 所有父节点的名称数组&#125; 实现功能 url异步请求 给大家的页面中，treeData是假数据，我们删除数据treeData属性，只保留url看看会发生什么： 1234567&lt;v-tree url="/item/category/list" :isEdit="isEdit" @handleAdd="handleAdd" @handleEdit="handleEdit" @handleDelete="handleDelete" @handleClick="handleClick" /&gt; 刷新页面，可以看到： 页面中的树没有了，并且发起了一条请求：http://localhost/api/item/category/list?pid=0 大家可能会觉得很奇怪，我们明明是使用的相对路径，讲道理发起的请求地址应该是： http://manage.leyou.com/item/category/list 但实际却是： http://localhost/api/item/category/list?pid=0 这是因为，我们有一个全局的配置文件，对所有的请求路径进行了约定： 路径是localhost，并且默认加上了/api的前缀，这恰好与我们的网关设置匹配，我们只需要把地址改成网关的地址即可,因为我们使用了nginx反向代理，这里可以写域名： 再次查看页面，发现地址已经变成了正确的地址了： 接下来，我们要做的事情就是编写后台接口，返回对应的数据即可。 实体类 在ly-item-interface中添加category实体类： 123456789101112@Table(name="tb_category")public class Category &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id; private String name; private Long parentId; private Boolean isParent; private Integer sort; // getter和setter略 // 注意isParent的get和set方法&#125; 需要注意的是，这里要用到jpa的注解，因此我们在ly-item-iterface中添加jpa依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;persistence-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 结构： controller 编写一个controller一般需要知道四个内容： 请求方式：决定我们用GetMapping还是PostMapping 请求路径：决定映射路径 请求参数：决定方法的参数 返回值结果：决定方法的返回值 在刚才页面发起的请求中，我们就能得到绝大多数信息： 请求方式：Get 请求路径：/api/item/category/list。其中/api是网关前缀，/item是网关的路由映射，真实的路径应该是/category/list 请求参数：pid=0，根据tree组件的说明，应该是父节点的id，第一次查询为0，那就是查询一级类目 返回结果：？？ 根据前面tree组件的用法我们知道，返回的应该是json数组： 12345678910111213141516[ &#123; "id": 74, "name": "手机", "parentId": 0, "isParent": true, "sort": 2 &#125;, &#123; "id": 75, "name": "家用电器", "parentId": 0, "isParent": true, "sort": 3 &#125;] 对应的java类型可以是List集合，里面的元素就是类目对象了。 controller代码： 12345678910111213141516171819202122@RestController@RequestMapping("category")public class CategoryController &#123; @Autowired private CategoryService categoryService; /** * 根据父节点查询商品类目 * @param pid * @return */ @GetMapping("list") public ResponseEntity&lt;List&lt;Category&gt;&gt; queryByParentId( @RequestParam(value = "pid", defaultValue = "0") Long pid) &#123; List&lt;Category&gt; list = this.categoryService.queryListByParent(pid); if (list == null || list.size() &lt; 1) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(list); &#125;&#125; service 一般service层我们会定义接口和实现类，不过这里我们就偷懒一下，直接写实现类了： 123456789101112@Servicepublic class CategoryService &#123; @Autowired private CategoryMapper categoryMapper; public List&lt;Category&gt; queryListByParent(Long pid) &#123; Category category = new Category(); category.setParentId(pid); return this.categoryMapper.select(category); &#125;&#125; mapper 我们使用通用mapper来简化开发： 12public interface CategoryMapper extends Mapper&lt;Category&gt; &#123;&#125; 要注意，我们并没有在mapper接口上声明@Mapper注解，那么mybatis如何才能找到接口呢？ 我们在启动类上添加一个扫描包功能： 12345678@SpringBootApplication@EnableDiscoveryClient@MapperScan("com.leyou.item.mapper") // 扫描mapper包public class LyItemService &#123; public static void main(String[] args) &#123; SpringApplication.run(LyItemService.class, args); &#125;&#125; 项目结构： 启动并测试 我们不经过网关，直接访问： 然后试试网关是否畅通： 一切OK！ 然后刷新页面查看： 发现报错了！ 浏览器直接访问没事，但是这里却报错，什么原因？ 跨域问题 什么是跨域 跨域是指跨域名的访问，以下情况都属于跨域： 跨域原因说明 示例 域名不同 www.jd.com 与 www.taobao.com 域名相同，端口不同 www.jd.com:8080 与 www.jd.com:8081 二级域名不同 item.jd.com 与 miaosha.jd.com 如果域名和端口都相同，但是请求路径不同，不属于跨域，如： www.jd.com/item www.jd.com/goods 而我们刚才是从manage.leyou.com去访问api.leyou.com，这属于二级域名不同，跨域了。 为什么有跨域问题？ 跨域不一定会有跨域问题。 因为跨域问题是浏览器对于ajax请求的一种安全限制：一个页面发起的ajax请求，只能是于当前页同域名的路径，这能有效的阻止跨站攻击。 因此：跨域问题 是针对ajax的一种限制。 但是这却给我们的开发带来了不变，而且在实际生成环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？ 解决跨域问题的方案 目前比较常用的跨域解决方案有3种： Jsonp 最早的解决方案，利用script标签可以跨域的原理实现。 限制： 需要服务的支持 只能发起GET请求 nginx反向代理 思路是：利用nginx反向代理把跨域为不跨域，支持各种请求方式 缺点：需要在nginx进行额外配置，语义不清晰 CORS 规范化的跨域请求解决方案，安全可靠。 优势： 在服务端进行控制是否允许跨域，可自定义规则 支持各种请求方式 缺点： 会产生额外的请求 我们这里会采用cors的跨域方案。 cors解决跨域 什么是cors CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 浏览器端： 目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。 服务端： CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否运行其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。 原理有点复杂 浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。 简单请求 只要同时满足以下两大条件，就属于简单请求。： （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 当浏览器发现发现的ajax请求是简单请求时，会在请求头中携带一个字段：Origin. Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。 如果服务器允许跨域，需要在返回的响应头中携带下面信息： 123Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*，代表任意 Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true 注意： 如果跨域请求要想操作cookie，需要满足3个条件： 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。 浏览器发起ajax需要指定withCredentials 为true 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名 特殊请求 不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。 预检请求 特殊请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 一个“预检”请求的样板： 12345678OPTIONS /cors HTTP/1.1Origin: http://manage.leyou.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.leyou.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 与简单请求相比，除了Origin以外，多了两个头： Access-Control-Request-Method：接下来会用到的请求方式，比如PUT Access-Control-Request-Headers：会额外用到的头信息 预检请求的响应 服务的收到预检请求，如果许可跨域，会发出响应： 1234567891011121314HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Max-Age: 1728000Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 除了Access-Control-Allow-Origin和Access-Control-Allow-Credentials以外，这里又额外多出3个头： Access-Control-Allow-Methods：允许访问的方式 Access-Control-Allow-Headers：允许携带的头 Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次进行预检了 如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。 实现非常简单 虽然原理比较复杂，但是前面说过： 浏览器端都有浏览器自动完成，我们无需操心 服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。 事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。 在ly-api-gateway中编写一个配置类，并且注册CorsFilter： 1234567891011121314151617181920212223242526272829303132333435import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class GlobalCorsConfig &#123; @Bean public CorsFilter corsFilter() &#123; //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 config.addAllowedOrigin("http://manage.leyou.com"); //2) 是否发送Cookie信息 config.setAllowCredentials(true); //3) 允许的请求方式 config.addAllowedMethod("OPTIONS"); config.addAllowedMethod("HEAD"); config.addAllowedMethod("GET"); config.addAllowedMethod("PUT"); config.addAllowedMethod("POST"); config.addAllowedMethod("DELETE"); config.addAllowedMethod("PATCH"); // 4）允许的头信息 config.addAllowedHeader("*"); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration("/**", config); //3.返回新的CorsFilter. return new CorsFilter(configSource); &#125;&#125; 结构： 4.5.4.重启测试： 访问正常： 页面也OK了： 分类的增删改功能暂时就不做了，页面已经预留好了事件接口，有兴趣的同学可以完成一下。 品牌的查询 商品分类完成以后，自然轮到了品牌功能了。 先看看我们要实现的效果： 接下来，我们从0开始，实现下从前端到后端的完整开发。 从0开始 为了方便看到效果，我们新建一个MyBrand.vue（注意先停掉服务器），从0开始搭建。 内容初始化一下： 123456789101112131415&lt;template&gt; &lt;span&gt; hello &lt;/span&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;my-brand&quot; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 改变router新的index.js，将路由地址指向MyBrand.vue 打开服务器，再次查看页面： 干干净净了。 品牌查询页面 data-tables组件 大家看到这个原型页面肯定能看出，其主体就是一个table。我们去Vuetify查看有关table的文档： 仔细阅读，发现v-data-table中有以下核心属性： dark：是否使用黑暗色彩主题，默认是false expand：表格的行是否可以展开，默认是false headers：定义表头的数组，数组的每个元素就是一个表头信息对象，结构： 12345678&#123; text: string, // 表头的显示文本 value: string, // 表头对应的每行数据的key align: 'left' | 'center' | 'right', // 位置 sortable: boolean, // 是否可排序 class: string[] | string,// 样式 width: string,// 宽度&#125; items：表格的数据的数组，数组的每个元素是一行数据的对象，对象的key要与表头的value一致 loading：是否显示加载数据的进度条，默认是false no-data-text：当没有查询到数据时显示的提示信息，string类型，无默认值 pagination.sync：包含分页和排序信息的对象，将其与vue实例中的属性关联，表格的分页或排序按钮被触发时，会自动将最新的分页和排序信息更新。对象结构： 123456&#123; page: 1, // 当前页 rowsPerPage: 5, // 每页大小 sortBy: '', // 排序字段 descending:false, // 是否降序&#125; total-items：分页的总条数信息，number类型，无默认值 select-all ：是否显示每一行的复选框，Boolean类型，无默认值 value：当表格可选的时候，返回选中的行 我们向下翻，找找有没有看起来牛逼的案例。 找到这样一条： 其它的案例都是由Vuetify帮我们对查询到的当前页数据进行排序和分页，这显然不是我们想要的。我们希望能在服务端完成对整体品牌数据的排序和分页，而这个案例恰好合适。 点击按钮，我们直接查看源码，然后直接复制到MyBrand.vue中 模板： 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;desserts&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalDesserts&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.calories &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.fat &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.carbs &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.protein &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.iron &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/div&gt;&lt;/template&gt; 分析 接下来，就分析一下案例中每一部分是什么意思，搞清楚了，我们也可以自己玩了。 先看模板中table上的一些属性： 12345678910&lt;v-data-table :headers=&quot;headers&quot; :items=&quot;desserts&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalDesserts&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt;&lt;/v-data-table&gt; headers：表头信息，是一个数组 items：要在表格中展示的数据，数组结构，每一个元素是一行 search：搜索过滤字段，用不到，暂时不管 pagination.sync：分页信息，包含了当前页，每页大小，排序字段，排序方式等。加上.sync代表服务端排序，当用户点击分页条时，该对象的值会跟着变化。监控这个值，并在这个值变化时去服务端查询，即可实现页面数据动态加载了。 total-items：总条数 loading：boolean类型，true：代表数据正在加载，会有进度条。false：数据加载完毕。 另外，在v-data-tables中，我们还看到另一段代码： 12345678&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.calories &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.fat &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.carbs &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.protein &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.iron &#125;&#125;&lt;/td&gt;&lt;/template&gt; 这段就是在渲染每一行的数据。Vue会自动遍历上面传递的items属性，并把得到的对象传递给这段template中的props.item属性。我们从中得到数据，渲染在页面即可。 我们需要做的事情，主要有两件： 给items和totalItems赋值 当pagination变化时，重新获取数据，再次给items和totalItems赋值 初步实现 我们先弄点假品牌数据： 1234567891011121314151617181920212223242526272829303132[ &#123; "id": 2032, "name": "OPPO", "image": "http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg", "letter": "O" &#125;, &#123; "id": 2033, "name": "飞利浦（PHILIPS）", "image": "http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg", "letter": "F" &#125;, &#123; "id": 2034, "name": "华为（HUAWEI）", "image": "http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg", "letter": "H" &#125;, &#123; "id": 2036, "name": "酷派（Coolpad）", "image": "http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg", "letter": "K" &#125;, &#123; "id": 2037, "name": "魅族（MEIZU）", "image": "http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg", "letter": "M" &#125;] 品牌中有id,name,image,letter字段。 修改模板 123456789101112131415161718192021&lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt; &lt;img v-if=&quot;props.item.image&quot; :src=&quot;props.item.image&quot; width=&quot;130&quot; height=&quot;40&quot;&gt; &lt;span v-else&gt;无&lt;/span&gt; &lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt;&lt;/div&gt; 我们修改了以下部分： items：指向一个brands变量，等下在js代码中定义 total-items：指向了totalBrands变量，等下在js代码中定义 template模板中，渲染了四个字段： id： name image，注意，我们不是以文本渲染，而是赋值到一个img标签的src属性中，并且做了非空判断 letter 编写数据 接下来编写要用到的数据： 1234567891011121314151617&#123; data() &#123; return &#123; search: '', // 搜索过滤字段 totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ // 头信息 &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '名称', align: 'center', sortable: false, value: 'name'&#125;, &#123;text: 'LOGO', align: 'center', sortable: false, value: 'image'&#125;, &#123;text: '首字母', align: 'center', value: 'letter', sortable: true,&#125; ] &#125; &#125;&#125; 编写函数，初始化数据 接下来就是对brands和totalBrands完成赋值动作了。 我们编写一个函数来完成赋值，提高复用性： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950methods:&#123; getDataFromServer()&#123; // 从服务的加载数据的方法。 // 伪造假数据 const brands = [ &#123; "id": 2032, "name": "OPPO", "image": "http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg", "letter": "O", "categories": null &#125;, &#123; "id": 2033, "name": "飞利浦（PHILIPS）", "image": "http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg", "letter": "F", "categories": null &#125;, &#123; "id": 2034, "name": "华为（HUAWEI）", "image": "http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg", "letter": "H", "categories": null &#125;, &#123; "id": 2036, "name": "酷派（Coolpad）", "image": "http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg", "letter": "K", "categories": null &#125;, &#123; "id": 2037, "name": "魅族（MEIZU）", "image": "http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg", "letter": "M", "categories": null &#125; ]; // 模拟延迟一段时间，随后进行赋值 setTimeout(() =&gt; &#123; // 然后赋值给brands this.brands = brands; this.totalBrands = brands.length; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;,400) &#125;&#125; 然后使用钩子函数，在Vue实例初始化完毕后调用这个方法，这里使用mounted（渲染后）函数： 1234mounted()&#123; // 渲染后执行 // 查询数据 this.getDataFromServer();&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;template&gt; &lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;my-brand&quot;, data() &#123; return &#123; search: &apos;&apos;, // 搜索过滤字段 totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ &#123;text: &apos;id&apos;, align: &apos;center&apos;, value: &apos;id&apos;&#125;, &#123;text: &apos;名称&apos;, align: &apos;center&apos;, sortable: false, value: &apos;name&apos;&#125;, &#123;text: &apos;LOGO&apos;, align: &apos;center&apos;, sortable: false, value: &apos;image&apos;&#125;, &#123;text: &apos;首字母&apos;, align: &apos;center&apos;, value: &apos;letter&apos;, sortable: true,&#125; ] &#125; &#125;, mounted()&#123; // 渲染后执行 // 查询数据 this.getDataFromServer(); &#125;, methods:&#123; getDataFromServer()&#123; // 从服务的加载数的方法。 // 伪造假数据 const brands = [ &#123; &quot;id&quot;: 2032, &quot;name&quot;: &quot;OPPO&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg&quot;, &quot;letter&quot;: &quot;O&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2033, &quot;name&quot;: &quot;飞利浦（PHILIPS）&quot;, &quot;image&quot;: &quot;http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg&quot;, &quot;letter&quot;: &quot;F&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2034, &quot;name&quot;: &quot;华为（HUAWEI）&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg&quot;, &quot;letter&quot;: &quot;H&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2036, &quot;name&quot;: &quot;酷派（Coolpad）&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg&quot;, &quot;letter&quot;: &quot;K&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2037, &quot;name&quot;: &quot;魅族（MEIZU）&quot;, &quot;image&quot;: &quot;http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg&quot;, &quot;letter&quot;: &quot;M&quot;, &quot;categories&quot;: null &#125; ]; // 模拟延迟一段时间，随后进行赋值 setTimeout(() =&gt; &#123; // 然后赋值给brands this.brands = brands; this.totalBrands = brands.length; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;,400) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 刷新页面查看： 优化页面 编辑和删除按钮 我们将来要对品牌进行增删改，需要给每一行数据添加 修改删除的按钮，一般放到改行的最后一列： 其实就是多了一列，只是这一列没有数据，而是两个按钮而已。 我们先在头（headers）中添加一列： 1234567headers: [ &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '名称', align: 'center', sortable: false, value: 'name'&#125;, &#123;text: 'LOGO', align: 'center', sortable: false, value: 'image'&#125;, &#123;text: '首字母', align: 'center', value: 'letter', sortable: true,&#125;, &#123;text: '操作', align: 'center', value: 'id', sortable: false&#125;] 然后在模板中添加按钮： 123456789&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;justify-center&quot;&gt; 编辑/删除 &lt;/td&gt;&lt;/template&gt; 因为不知道按钮怎么写，先放个普通文本看看： 然后在官方文档中找到按钮的用法： 修改我们的模板： 12345678910&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;justify-center layout&quot;&gt; &lt;v-btn color=&quot;info&quot;&gt;编辑&lt;/v-btn&gt; &lt;v-btn color=&quot;warning&quot;&gt;删除&lt;/v-btn&gt; &lt;/td&gt;&lt;/template&gt; 新增按钮 因为新增根某个品牌无关，是独立的，因此我们可以放到表格的外面： 效果： 卡片（card） 为了不让按钮显得过于孤立，我们可以将按新增按钮和表格放到一张卡片（card）中。 我们去官网查看卡片的用法： 卡片v-card包含四个基本组件： v-card-media：一般放图片或视频 v-card-title：卡片的标题，一般位于卡片顶部 v-card-text：卡片的文本（主体内容），一般位于卡片正中 v-card-action：卡片的按钮，一般位于卡片底部 我们可以把新增的按钮放到v-card-title位置，把table放到下面，这样就成一个上下关系。 1234567891011121314151617181920212223242526272829&lt;v-card&gt; &lt;!-- 卡片的头部 --&gt; &lt;v-card-title&gt; &lt;v-btn color=&quot;primary&quot;&gt;新增&lt;/v-btn&gt; &lt;/v-card-title&gt; &lt;!-- 分割线 --&gt; &lt;v-divider/&gt; &lt;!--卡片的中部--&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;justify-center layout&quot;&gt; &lt;v-btn color=&quot;info&quot;&gt;编辑&lt;/v-btn&gt; &lt;v-btn color=&quot;warning&quot;&gt;删除&lt;/v-btn&gt; &lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt;&lt;/v-card&gt; 效果： 添加搜索框 我们还可以在卡片头部添加一个搜索框，其实就是一个文本输入框。 查看官网中，文本框的用法： name：字段名，表单中会用到 label：提示文字 value：值。可以用v-model代替，实现双向绑定 修改模板，添加输入框： 12345&lt;v-card-title&gt; &lt;v-btn color="primary"&gt;新增品牌&lt;/v-btn&gt; &lt;!--搜索框，与search属性关联--&gt; &lt;v-text-field label="输入关键字搜索" v-model="search"/&gt;&lt;/v-card-title&gt; 效果： 发现输入框变的超级长！！！ 这个时候，我们可以使用Vuetify提供的一个空间隔离工具： 修改代码： 1234567&lt;v-card-title&gt; &lt;v-btn color="primary"&gt;新增品牌&lt;/v-btn&gt; &lt;!--空间隔离组件--&gt; &lt;v-spacer /&gt; &lt;!--搜索框，与search属性关联--&gt; &lt;v-text-field label="输入关键字搜索" v-model="search"/&gt;&lt;/v-card-title&gt; 给搜索框添加搜索图标 查看textfiled的文档，发现： 通过append-icon属性可以为 输入框添加后置图标，所有可用图标名称可以到 material-icons官网去查看。 修改我们的代码： 1&lt;v-text-field label="输入关键字搜索" v-model="search" append-icon="search"/&gt; 把文本框变紧凑 搜索框看起来高度比较高，页面不够紧凑。这其实是因为默认在文本框下面预留有错误提示空间。通过下面的属性可以取消提示： 修改代码： 1&lt;v-text-field label="输入关键字搜索" v-model="search" append-icon="search" hide-details/&gt; 效果： 几乎已经达到了原来一样的效果了吧！ 后台提供查询接口 前台页面已经准备好，接下来就是后台提供数据接口了。 数据库表 1234567CREATE TABLE `tb_brand` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;品牌id&apos;, `name` varchar(50) NOT NULL COMMENT &apos;品牌名称&apos;, `image` varchar(200) DEFAULT &apos;&apos; COMMENT &apos;品牌图片地址&apos;, `letter` char(1) DEFAULT &apos;&apos; COMMENT &apos;品牌的首字母&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=325400 DEFAULT CHARSET=utf8 COMMENT=&apos;品牌表，一个品牌下有多个商品（spu），一对多关系&apos;; 简单的四个字段，不多解释。 这里需要注意的是，品牌和商品分类之间是多对多关系。因此我们有一张中间表，来维护两者间关系： 12345CREATE TABLE `tb_category_brand` ( `category_id` bigint(20) NOT NULL COMMENT &apos;商品类目id&apos;, `brand_id` bigint(20) NOT NULL COMMENT &apos;品牌id&apos;, PRIMARY KEY (`category_id`,`brand_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;商品分类和品牌的中间表，两者是多对多关系&apos;; 但是，你可能会发现，这张表中并没有设置外键约束，似乎与数据库的设计范式不符。为什么这么做？ 外键会严重影响数据库读写的效率 数据删除时会比较麻烦 在电商行业，性能是非常重要的。我们宁可在代码中通过逻辑来维护表关系，也不设置外键。 实体类 12345678910@Table(name = "tb_brand")public class Brand &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name;// 品牌名称 private String image;// 品牌图片 private Character letter; // getter setter 略&#125; mapper 通用mapper来简化开发： 12public interface BrandMapper extends Mapper&lt;Brand&gt; &#123;&#125; controller 编写controller先思考四个问题，这次没有前端代码，需要我们自己来设定 请求方式：查询，肯定是Get 请求路径：分页查询，/brand/page 请求参数：根据我们刚才编写的页面，有分页功能，有排序功能，有搜索过滤功能，因此至少要有5个参数： page：当前页，int rows：每页大小，int sortBy：排序字段，String desc：是否为降序，boolean key：搜索关键词，String 响应结果：分页结果一般至少需要两个数据 total：总条数 items：当前页数据 totalPage：有些还需要总页数 这里我们封装一个类，来表示分页结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class PageResult&lt;T&gt; &#123; private Long total;// 总条数 private Long totalPage;// 总页数 private List&lt;T&gt; items;// 当前页数据 public PageResult() &#123; &#125; public PageResult(Long total, List&lt;T&gt; items) &#123; this.total = total; this.items = items; &#125; public PageResult(Long total, Long totalPage, List&lt;T&gt; items) &#123; this.total = total; this.totalPage = totalPage; this.items = items; &#125; public Long getTotal() &#123; return total; &#125; public void setTotal(Long total) &#123; this.total = total; &#125; public List&lt;T&gt; getItems() &#123; return items; &#125; public void setItems(List&lt;T&gt; items) &#123; this.items = items; &#125; public Long getTotalPage() &#123; return totalPage; &#125; public void setTotalPage(Long totalPage) &#123; this.totalPage = totalPage; &#125;&#125; 另外，这个PageResult以后可能在其它项目中也有需求，因此我们将其抽取到ly-common中，提高复用性： 接下来，我们编写Controller 123456789101112131415161718192021@RestController@RequestMapping("brand")public class BrandController &#123; @Autowired private BrandService brandService; @GetMapping("page") public ResponseEntity&lt;PageResult&lt;Brand&gt;&gt; queryBrandByPage( @RequestParam(value = "page", defaultValue = "1") Integer page, @RequestParam(value = "rows", defaultValue = "5") Integer rows, @RequestParam(value = "sortBy", required = false) String sortBy, @RequestParam(value = "desc", defaultValue = "false") Boolean desc, @RequestParam(value = "key", required = false) String key) &#123; PageResult&lt;Brand&gt; result = this.brandService.queryBrandByPageAndSort(page,rows,sortBy,desc, key); if (result == null || result.getItems().size() == 0) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(result); &#125;&#125; Service 123456789101112131415161718192021222324252627@Servicepublic class BrandService &#123; @Autowired private BrandMapper brandMapper; public PageResult&lt;Brand&gt; queryBrandByPageAndSort( Integer page, Integer rows, String sortBy, Boolean desc, String key) &#123; // 开始分页 PageHelper.startPage(page, rows); // 过滤 Example example = new Example(Brand.class); if (StringUtils.isNotBlank(key)) &#123; example.createCriteria().andLike("name", "%" + key + "%") .orEqualTo("letter", key); &#125; if (StringUtils.isNotBlank(sortBy)) &#123; // 排序 String orderByClause = sortBy + (desc ? " DESC" : " ASC"); example.setOrderByClause(orderByClause); &#125; // 查询 Page&lt;Brand&gt; pageInfo = (Page&lt;Brand&gt;) brandMapper.selectByExample(example); // 返回结果 return new PageResult&lt;&gt;(pageInfo.getTotal(), pageInfo); &#125;&#125; 完整结构： 测试 通过浏览器访问试试：http://api.leyou.com/api/item/brand/page 接下来，去页面请求数据并渲染 异步查询工具axios 异步查询数据，自然是通过ajax查询，大家首先想起的肯定是jQuery。但jQuery与MVVM的思想不吻合，而且ajax只是jQuery的一小部分。因此不可能为了发起ajax请求而去引用这么大的一个库。 axios入门 Vue官方推荐的ajax请求框架叫做：axios，看下demo： axios的Get请求语法： 123456789101112131415axios.get("/item/category/list?pid=0") // 请求路径和请求参数拼接 .then(function(resp)&#123; // 成功回调函数 &#125;) .catch(function()&#123; // 失败回调函数 &#125;)// 参数较多时，可以通过params来传递参数axios.get("/item/category/list", &#123; params:&#123; pid:0 &#125; &#125;) .then(function(resp)&#123;&#125;)// 成功时的回调 .catch(function(error)&#123;&#125;)// 失败时的回调 axios的POST请求语法： 比如新增一个用户 123456axios.post("/user",&#123; name:"Jack", age:21 &#125;) .then(function(resp)&#123;&#125;) .catch(function(error)&#123;&#125;) 注意，POST请求传参，不需要像GET请求那样定义一个对象，在对象的params参数中传参。post()方法的第二个参数对象，就是将来要传递的参数 PUT和DELETE请求与POST请求类似 axios的全局配置 而在我们的项目中，已经引入了axios，并且进行了简单的封装，在src下的http.js中： http.js中对axios进行了一些默认配置： 12345678import Vue from 'vue'import axios from 'axios'import config from './config'// config中定义的基础路径是：http://api.leyou.com/apiaxios.defaults.baseURL = config.api; // 设置axios的基础请求路径axios.defaults.timeout = 2000; // 设置axios的请求时间Vue.prototype.$http = axios;// 将axios赋值给Vue原型的$http属性，这样所有vue实例都可使用该对象 http.js中导入了config的配置，还记得吗？ ![1526041205846](day07-商品分类及品牌/1526041205846.png) http.js对axios进行了全局配置：baseURL=config.api，即http://api.leyou.com/api。因此以后所有用axios发起的请求，都会以这个地址作为前缀。 通过Vue.property.$http = axios，将axios赋值给了 Vue原型中的$http。这样以后所有的Vue实例都可以访问到$http，也就是访问到了axios了。 测试一下： 我们在组件MyBrand.vue的getDataFromServer方法，通过$http发起get请求，测试查询品牌的接口，看是否能获取到数据： 网络监视： 控制台结果： 可以看到，在请求成功的返回结果response中，有一个data属性，里面就是真正的响应数据。 响应结果中与我们设计的一致，包含3个内容： total：总条数，目前是165 items：当前页数据 totalPage：总页数，我们没有返回 异步加载品牌数据 虽然已经通过ajax请求获取了品牌数据，但是刚才的请求没有携带任何参数，这样显然不对。我们后端接口需要5个参数： page：当前页，int rows：每页大小，int sortBy：排序字段，String desc：是否为降序，boolean key：搜索关键词，String 而页面中分页信息应该是在pagination对象中，我们通过浏览器工具，查看pagination中有哪些属性： 分别是： descending：是否是降序，对应请求参数的desc page：当前页，对应参数的page rowsPerpage：每页大小，对应参数中的rows sortBy：排序字段，对应参数的sortBy 缺少一个搜索关键词，这个应该是通过v-model与输入框绑定的属性：search。这样，所有参数就都有了。 另外，不要忘了把查询的结果赋值给brands和totalBrands属性，Vuetify会帮我们渲染页面。 接下来，我们在getDataFromServer方法中完善请求参数： 12345678910111213141516// 发起请求this.$http.get("/item/brand/page",&#123; params:&#123; key: this.search, // 搜索条件 page: this.pagination.page,// 当前页 rows: this.pagination.rowsPerPage,// 每页大小 sortBy: this.pagination.sortBy,// 排序字段 desc: this.pagination.descending// 是否降序 &#125; &#125;).then(resp =&gt; &#123; // 这里使用箭头函数 // 将得到的数据赋值给本地属性 this.brands = resp.data.items; this.totalBrands = resp.data.total; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;) 查看网络请求： 效果： 完成分页和过滤 分页 现在我们实现了页面加载时的第一次查询，你会发现你点击分页或搜索不会发起新的请求，怎么办？ 虽然点击分页，不会发起请求，但是通过浏览器工具查看，会发现pagination对象的属性一直在变化： 我们可以利用Vue的监视功能：watch，当pagination发生改变时，会调用我们的回调函数，我们在回调函数中进行数据的查询即可！ 具体实现： 成功实现分页功能： 过滤 分页实现了，过滤也很好实现了。过滤字段对应的是search属性，我们只要监视这个属性即可: 查看网络请求： 页面结果： 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;template&gt; &lt;v-card&gt; &lt;v-card-title&gt; &lt;v-btn color=&quot;primary&quot; @click=&quot;addBrand&quot;&gt;新增品牌&lt;/v-btn&gt; &lt;!--搜索框，与search属性关联--&gt; &lt;v-spacer/&gt; &lt;v-text-field label=&quot;输入关键字搜索&quot; v-model.lazy=&quot;search&quot; append-icon=&quot;search&quot; hide-details/&gt; &lt;/v-card-title&gt; &lt;v-divider/&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;justify-center layout&quot;&gt; &lt;v-btn color=&quot;info&quot;&gt;编辑&lt;/v-btn&gt; &lt;v-btn color=&quot;warning&quot;&gt;删除&lt;/v-btn&gt; &lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/v-card&gt;&lt;/template&gt;&lt;script&gt; import MyBrandForm from &apos;./MyBrandForm&apos; export default &#123; name: &quot;my-brand&quot;, data() &#123; return &#123; search: &apos;&apos;, // 搜索过滤字段 totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ &#123;text: &apos;id&apos;, align: &apos;center&apos;, value: &apos;id&apos;&#125;, &#123;text: &apos;名称&apos;, align: &apos;center&apos;, sortable: false, value: &apos;name&apos;&#125;, &#123;text: &apos;LOGO&apos;, align: &apos;center&apos;, sortable: false, value: &apos;image&apos;&#125;, &#123;text: &apos;首字母&apos;, align: &apos;center&apos;, value: &apos;letter&apos;, sortable: true,&#125;, &#123;text: &apos;操作&apos;, align: &apos;center&apos;, value: &apos;id&apos;, sortable: false&#125; ] &#125; &#125;, mounted() &#123; // 渲染后执行 // 查询数据 this.getDataFromServer(); &#125;, watch: &#123; pagination: &#123; // 监视pagination属性的变化 deep: true, // deep为true，会监视pagination的属性及属性中的对象属性变化 handler() &#123; // 变化后的回调函数，这里我们再次调用getDataFromServer即可 this.getDataFromServer(); &#125; &#125;, search: &#123; // 监视搜索字段 handler() &#123; this.getDataFromServer(); &#125; &#125; &#125;, methods: &#123; getDataFromServer() &#123; // 从服务的加载数的方法。 // 发起请求 this.$http.get(&quot;/item/brand/page&quot;, &#123; params: &#123; key: this.search, // 搜索条件 page: this.pagination.page,// 当前页 rows: this.pagination.rowsPerPage,// 每页大小 sortBy: this.pagination.sortBy,// 排序字段 desc: this.pagination.descending// 是否降序 &#125; &#125;).then(resp =&gt; &#123; // 这里使用箭头函数 this.brands = resp.data.items; this.totalBrands = resp.data.total; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[day07-搭建管理系统页面]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F27%2Fday07-%E6%90%AD%E5%BB%BA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[学习目标 使用资料搭建后台系统 会使用nginx进行反向代理 实现商品分类查询功能 掌握cors解决跨域 实现品牌查询功能 使用域名访问本地项目 统一环境 我们现在访问页面使用的是：http://localhost:9001 有没有什么问题？ 实际开发中，会有不同的环境： 开发环境：自己的电脑 测试环境：提供给测试人员使用的环境 预发布环境：数据是和生成环境的数据一致，运行最新的项目代码进去测试 生产环境：项目最终发布上线的环境 如果不同环境使用不同的ip去访问，可能会出现一些问题。为了保证所有环境的一致，我们会在各种环境下都使用域名来访问。 我们将使用以下域名： 主域名是：www.leyou.com， 管理系统域名：manage.leyou.com 网关域名：api.leyou.com … 但是最终，我们希望这些域名指向的还是我们本机的某个端口。 那么，当我们在浏览器输入一个域名时，浏览器是如何找到对应服务的ip和端口的呢？ 域名解析 一个域名一定会被解析为一个或多个ip。这一般会包含两步： 本地域名解析 浏览器会首先在本机的hosts文件中查找域名映射的IP地址，如果查找到就返回IP ，没找到则进行域名服务器解析，一般本地解析都会失败，因为默认这个文件是空的。 Windows下的hosts文件地址：C:/Windows/System32/drivers/etc/hosts Linux下的hosts文件所在路径： /etc/hosts 样式： 1234# My hosts127.0.0.1 localhost0.0.0.0 account.jetbrains.com127.0.0.1 www.xmind.net 域名服务器解析 本地解析失败，才会进行域名服务器解析，域名服务器就是网络中的一台计算机，里面记录了所有注册备案的域名和ip映射关系，一般只要域名是正确的，并且备案通过，一定能找到。 解决域名解析问题 我们不可能去购买一个域名，因此我们可以伪造本地的hosts文件，实现对域名的解析。修改本地的host为： 12127.0.0.1 api.leyou.com127.0.0.1 manage.leyou.com 这样就实现了域名的关系映射了。 每次在C盘寻找hosts文件并修改是非常麻烦的，给大家推荐一个快捷修改host的工具，在课前资料中可以找到： 效果： 我们添加了两个映射关系： 127.0.0.1 api.leyou.com ：我们的网关Zuul 127.0.0.1 manage.leyou.com：我们的后台系统地址 现在，ping一下域名试试是否畅通： OK！ nginx解决端口问题 虽然域名解决了，但是现在如果我们要访问，还得自己加上端口：http://manage.taotao.com:9001。 这就不够优雅了。我们希望的是直接域名访问：http://manage.taotao.com。这种情况下端口默认是80，如何才能把请求转移到9001端口呢？ 这里就要用到反向代理工具：Nginx 什么是Nginx NIO：not-blocking-io 非阻塞IO BIO：blocking-IO 阻塞IO nginx可以作为web服务器，但更多的时候，我们把它作为网关，因为它具备网关必备的功能： 反向代理 负载均衡 动态路由 请求过滤 nginx作为web服务器 Web服务器分2类： web应用服务器，如： tomcat resin jetty web服务器，如： Apache 服务器 Nginx IIS 区分：web服务器不能解析jsp等页面，只能处理js、css、html等静态资源。并发：web服务器的并发能力远高于web应用服务器。 Nginx + tomcat nginx作为反向代理 什么是反向代理？ 代理：通过客户机的配置，实现让一台服务器代理客户机，客户的所有请求都交给代理服务器处理。 反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。 nginx可以当做反向代理服务器来使用： 我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理 当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能 利用反向代理，就可以解决我们前面所说的端口问题，如图 安装和使用 安装 安装非常简单，把课前资料提供的nginx直接解压即可，绿色免安装，舒服！ 我们在本地安装一台nginx： 目录结构： 使用 nginx可以通过命令行来启动，操作命令： 启动：start nginx.exe 停止：nginx.exe -s stop 重新加载：nginx.exe -s reload 反向代理配置 示例： nginx中的每个server就是一个反向代理配置，可以有多个server 完整配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#user nobody;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; server &#123; listen 80; server_name manage.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://127.0.0.1:9001; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125; server &#123; listen 80; server_name api.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://127.0.0.1:10010; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125;&#125; 测试 启动nginx，然后用域名访问后台管理系统： 现在实现了域名访问网站了，中间的流程是怎样的呢？ 浏览器准备发起请求，访问http://mamage.leyou.com，但需要进行域名解析 优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：127.0.0.1 请求被发往解析得到的ip，并且默认使用80端口：http://127.0.0.1:80 本机的nginx一直监听80端口，因此捕获这个请求 nginx中配置了反向代理规则，将manage.leyou.com代理到127.0.0.1:9001，因此请求被转发 后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx nginx将得到的结果返回到浏览器 实现商品分类查询 商城的核心自然是商品，而商品多了以后，肯定要进行分类，并且不同的商品会有不同的品牌信息，其关系如图所示： 一个商品分类下有很多商品 一个商品分类下有很多品牌 而一个品牌，可能属于不同的分类 一个品牌下也会有很多商品 因此，我们需要依次去完成：商品分类、品牌、商品的开发。 导入数据 首先导入课前资料提供的sql： 我们先看商品分类表： 123456789CREATE TABLE `tb_category` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;类目id&apos;, `name` varchar(20) NOT NULL COMMENT &apos;类目名称&apos;, `parent_id` bigint(20) NOT NULL COMMENT &apos;父类目id,顶级类目填0&apos;, `is_parent` tinyint(1) NOT NULL COMMENT &apos;是否为父节点，0为否，1为是&apos;, `sort` int(4) NOT NULL COMMENT &apos;排序指数，越小越靠前&apos;, PRIMARY KEY (`id`), KEY `key_parent_id` (`parent_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1424 DEFAULT CHARSET=utf8 COMMENT=&apos;商品类目表，类目和商品(spu)是一对多关系，类目与品牌是多对多关系&apos;; 因为商品分类会有层级关系，因此这里我们加入了parent_id字段，对本表中的其它分类进行自关联。 页面实现 页面分析 首先我们看下要实现的效果： 商品分类之间是会有层级关系的，采用树结构去展示是最直观的方式。 一起来看页面，对应的是/pages/item/Category.vue： 页面模板： 123456789101112&lt;v-card&gt; &lt;v-flex xs12 sm10&gt; &lt;v-tree url="/item/category/list" :treeData="treeData" :isEdit="isEdit" @handleAdd="handleAdd" @handleEdit="handleEdit" @handleDelete="handleDelete" @handleClick="handleClick" /&gt; &lt;/v-flex&gt;&lt;/v-card&gt; v-card：卡片，是vuetify中提供的组件，提供一个悬浮效果的面板，一般用来展示一组数据。 v-flex：布局容器，用来控制响应式布局。与BootStrap的栅格系统类似，整个屏幕被分为12格。我们可以控制所占的格数来控制宽度： 本例中，我们用sm10控制在小屏幕及以上时，显示宽度为10格 v-tree：树组件。Vuetify并没有提供树组件，这个是我们自己编写的自定义组件： 里面涉及一些vue的高级用法，大家暂时不要关注其源码，会用即可。 树组件的用法 也可参考课前资料中的：《自定义Vue组件的用法.md》 这里我贴出树组件的用法指南。 属性列表： 属性名称 说明 数据类型 默认值 url 用来加载数据的地址，即延迟加载 String - isEdit 是否开启树的编辑功能 boolean false treeData 整颗树数据，这样就不用远程加载了 Array - 这里推荐使用url进行延迟加载，每当点击父节点时，就会发起请求，根据父节点id查询子节点信息。 当有treeData属性时，就不会触发url加载 远程请求返回的结果格式： 12345678910111213141516[ &#123; "id": 74, "name": "手机", "parentId": 0, "isParent": true, "sort": 2 &#125;, &#123; "id": 75, "name": "家用电器", "parentId": 0, "isParent": true, "sort": 3 &#125;] 事件： 事件名称 说明 回调参数 handleAdd 新增节点时触发，isEdit为true时有效 新增节点node对象，包含属性：name、parentId和sort handleEdit 当某个节点被编辑后触发，isEdit为true时有效 被编辑节点的id和name handleDelete 当删除节点时触发，isEdit为true时有效 被删除节点的id handleClick 点击某节点时触发 被点击节点的node对象,包含全部信息 完整node的信息 回调函数中返回完整的node节点会包含以下数据： 12345678&#123; "id": 76, // 节点id "name": "手机", // 节点名称 "parentId": 75, // 父节点id "isParent": false, // 是否是父节点 "sort": 1, // 顺序 "path": ["手机", "手机通讯", "手机"] // 所有父节点的名称数组&#125; 实现功能 url异步请求 给大家的页面中，treeData是假数据，我们删除数据treeData属性，只保留url看看会发生什么： 1234567&lt;v-tree url="/item/category/list" :isEdit="isEdit" @handleAdd="handleAdd" @handleEdit="handleEdit" @handleDelete="handleDelete" @handleClick="handleClick" /&gt; 刷新页面，可以看到： 页面中的树没有了，并且发起了一条请求：http://localhost/api/item/category/list?pid=0 大家可能会觉得很奇怪，我们明明是使用的相对路径，讲道理发起的请求地址应该是： http://manage.leyou.com/item/category/list 但实际却是： http://localhost/api/item/category/list?pid=0 这是因为，我们有一个全局的配置文件，对所有的请求路径进行了约定： 路径是localhost，并且默认加上了/api的前缀，这恰好与我们的网关设置匹配，我们只需要把地址改成网关的地址即可,因为我们使用了nginx反向代理，这里可以写域名： 再次查看页面，发现地址已经变成了正确的地址了： 接下来，我们要做的事情就是编写后台接口，返回对应的数据即可。 实体类 在ly-item-interface中添加category实体类： 123456789101112@Table(name="tb_category")public class Category &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id; private String name; private Long parentId; private Boolean isParent; private Integer sort; // getter和setter略 // 注意isParent的get和set方法&#125; 需要注意的是，这里要用到jpa的注解，因此我们在ly-item-iterface中添加jpa依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;persistence-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 结构： controller 编写一个controller一般需要知道四个内容： 请求方式：决定我们用GetMapping还是PostMapping 请求路径：决定映射路径 请求参数：决定方法的参数 返回值结果：决定方法的返回值 在刚才页面发起的请求中，我们就能得到绝大多数信息： 请求方式：Get 请求路径：/api/item/category/list。其中/api是网关前缀，/item是网关的路由映射，真实的路径应该是/category/list 请求参数：pid=0，根据tree组件的说明，应该是父节点的id，第一次查询为0，那就是查询一级类目 返回结果：？？ 根据前面tree组件的用法我们知道，返回的应该是json数组： 12345678910111213141516[ &#123; "id": 74, "name": "手机", "parentId": 0, "isParent": true, "sort": 2 &#125;, &#123; "id": 75, "name": "家用电器", "parentId": 0, "isParent": true, "sort": 3 &#125;] 对应的java类型可以是List集合，里面的元素就是类目对象了。 controller代码： 12345678910111213141516171819202122@RestController@RequestMapping("category")public class CategoryController &#123; @Autowired private CategoryService categoryService; /** * 根据父节点查询商品类目 * @param pid * @return */ @GetMapping("list") public ResponseEntity&lt;List&lt;Category&gt;&gt; queryByParentId( @RequestParam(value = "pid", defaultValue = "0") Long pid) &#123; List&lt;Category&gt; list = this.categoryService.queryListByParent(pid); if (list == null || list.size() &lt; 1) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(list); &#125;&#125; service 一般service层我们会定义接口和实现类，不过这里我们就偷懒一下，直接写实现类了： 123456789101112@Servicepublic class CategoryService &#123; @Autowired private CategoryMapper categoryMapper; public List&lt;Category&gt; queryListByParent(Long pid) &#123; Category category = new Category(); category.setParentId(pid); return this.categoryMapper.select(category); &#125;&#125; mapper 我们使用通用mapper来简化开发： 12public interface CategoryMapper extends Mapper&lt;Category&gt; &#123;&#125; 要注意，我们并没有在mapper接口上声明@Mapper注解，那么mybatis如何才能找到接口呢？ 我们在启动类上添加一个扫描包功能： 12345678@SpringBootApplication@EnableDiscoveryClient@MapperScan("com.leyou.item.mapper") // 扫描mapper包public class LyItemService &#123; public static void main(String[] args) &#123; SpringApplication.run(LyItemService.class, args); &#125;&#125; 启动并测试 我们不经过网关，直接访问： 然后试试网关是否畅通： 一切OK！ 然后刷新页面查看： 发现报错了！ 浏览器直接访问没事，但是这里却报错，什么原因？ 跨域问题 什么是跨域 跨域是指跨域名的访问，以下情况都属于跨域： 跨域原因说明 示例 域名不同 www.jd.com 与 www.taobao.com 域名相同，端口不同 www.jd.com:8080 与 www.jd.com:8081 二级域名不同 item.jd.com 与 miaosha.jd.com 如果域名和端口都相同，但是请求路径不同，不属于跨域，如： www.jd.com/item www.jd.com/goods 而我们刚才是从manage.leyou.com去访问api.leyou.com，这属于二级域名不同，跨域了。 为什么有跨域问题？ 跨域不一定会有跨域问题。 因为跨域问题是浏览器对于ajax请求的一种安全限制：一个页面发起的ajax请求，只能是于当前页同域名的路径，这能有效的阻止跨站攻击。 因此：跨域问题 是针对ajax的一种限制。 但是这却给我们的开发带来了不变，而且在实际生成环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？ 解决跨域问题的方案 目前比较常用的跨域解决方案有3种： Jsonp 最早的解决方案，利用script标签可以跨域的原理实现。 限制： 需要服务的支持 只能发起GET请求 nginx反向代理 思路是：利用nginx反向代理把跨域为不跨域，支持各种请求方式 缺点：需要在nginx进行额外配置，语义不清晰 CORS 规范化的跨域请求解决方案，安全可靠。 优势： 在服务端进行控制是否允许跨域，可自定义规则 支持各种请求方式 缺点： 会产生额外的请求 我们这里会采用cors的跨域方案。 cors解决跨域 什么是cors CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 浏览器端： 目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。 服务端： CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否运行其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。 原理有点复杂 浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。 简单请求 只要同时满足以下两大条件，就属于简单请求。： （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 当浏览器发现发现的ajax请求是简单请求时，会在请求头中携带一个字段：Origin. Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。 如果服务器允许跨域，需要在返回的响应头中携带下面信息： 123Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*，代表任意 Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true 注意： 如果跨域请求要想操作cookie，需要满足3个条件： 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。 浏览器发起ajax需要指定withCredentials 为true 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名 特殊请求 不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。 预检请求 特殊请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 一个“预检”请求的样板： 12345678OPTIONS /cors HTTP/1.1Origin: http://manage.leyou.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.leyou.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 与简单请求相比，除了Origin以外，多了两个头： Access-Control-Request-Method：接下来会用到的请求方式，比如PUT Access-Control-Request-Headers：会额外用到的头信息 预检请求的响应 服务的收到预检请求，如果许可跨域，会发出响应： 1234567891011121314HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Max-Age: 1728000Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 除了Access-Control-Allow-Origin和Access-Control-Allow-Credentials以外，这里又额外多出3个头： Access-Control-Allow-Methods：允许访问的方式 Access-Control-Allow-Headers：允许携带的头 Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次进行预检了 如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。 实现非常简单 虽然原理比较复杂，但是前面说过： 浏览器端都有浏览器自动完成，我们无需操心 服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。 事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。 在ly-api-gateway中编写一个配置类，并且注册CorsFilter： 1234567891011121314151617181920212223242526272829303132333435import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class GlobalCorsConfig &#123; @Bean public CorsFilter corsFilter() &#123; //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 config.addAllowedOrigin("http://manage.leyou.com"); //2) 是否发送Cookie信息 config.setAllowCredentials(true); //3) 允许的请求方式 config.addAllowedMethod("OPTIONS"); config.addAllowedMethod("HEAD"); config.addAllowedMethod("GET"); config.addAllowedMethod("PUT"); config.addAllowedMethod("POST"); config.addAllowedMethod("DELETE"); config.addAllowedMethod("PATCH"); // 4）允许的头信息 config.addAllowedHeader("*"); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration("/**", config); //3.返回新的CorsFilter. return new CorsFilter(configSource); &#125;&#125; 结构： 4.5.4.重启测试： 访问正常： 页面也OK了： 分类的增删改功能暂时就不做了，页面已经预留好了事件接口，有兴趣的同学可以完成一下。 品牌的查询 商品分类完成以后，自然轮到了品牌功能了。 先看看我们要实现的效果： 接下来，我们从0开始，实现下从前端到后端的完整开发。 从0开始 为了方便看到效果，我们新建一个MyBrand.vue（注意先停掉服务器），从0开始搭建。 内容初始化一下： 123456789101112131415&lt;template&gt; &lt;span&gt; hello &lt;/span&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;my-brand&quot; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 改变router新的index.js，将路由地址指向MyBrand.vue 打开服务器，再次查看页面： 干干净净了。 品牌查询页面 data-tables组件 大家看到这个原型页面肯定能看出，其主体就是一个table。我们去Vuetify查看有关table的文档： 仔细阅读，发现v-data-table中有以下核心属性： dark：是否使用黑暗色彩主题，默认是false expand：表格的行是否可以展开，默认是false headers：定义表头的数组，数组的每个元素就是一个表头信息对象，结构： 12345678&#123; text: string, // 表头的显示文本 value: string, // 表头对应的每行数据的key align: 'left' | 'center' | 'right', // 位置 sortable: boolean, // 是否可排序 class: string[] | string,// 样式 width: string,// 宽度&#125; items：表格的数据的数组，数组的每个元素是一行数据的对象，对象的key要与表头的value一致 loading：是否显示加载数据的进度条，默认是false no-data-text：当没有查询到数据时显示的提示信息，string类型，无默认值 pagination.sync：包含分页和排序信息的对象，将其与vue实例中的属性关联，表格的分页或排序按钮被触发时，会自动将最新的分页和排序信息更新。对象结构： 123456&#123; page: 1, // 当前页 rowsPerPage: 5, // 每页大小 sortBy: '', // 排序字段 descending:false, // 是否降序&#125; total-items：分页的总条数信息，number类型，无默认值 select-all ：是否显示每一行的复选框，Boolean类型，无默认值 value：当表格可选的时候，返回选中的行 我们向下翻，找找有没有看起来牛逼的案例。 找到这样一条： 其它的案例都是由Vuetify帮我们对查询到的当前页数据进行排序和分页，这显然不是我们想要的。我们希望能在服务端完成对整体品牌数据的排序和分页，而这个案例恰好合适。 点击按钮，我们直接查看源码，然后直接复制到MyBrand.vue中 模板： 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;desserts&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalDesserts&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.calories &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.fat &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.carbs &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.protein &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.iron &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/div&gt;&lt;/template&gt; 分析 接下来，就分析一下案例中每一部分是什么意思，搞清楚了，我们也可以自己玩了。 先看模板中table上的一些属性： 12345678910&lt;v-data-table :headers=&quot;headers&quot; :items=&quot;desserts&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalDesserts&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt;&lt;/v-data-table&gt; headers：表头信息，是一个数组 items：要在表格中展示的数据，数组结构，每一个元素是一行 search：搜索过滤字段，用不到，暂时不管 pagination.sync：分页信息，包含了当前页，每页大小，排序字段，排序方式等。加上.sync代表服务端排序，当用户点击分页条时，该对象的值会跟着变化。监控这个值，并在这个值变化时去服务端查询，即可实现页面数据动态加载了。 total-items：总条数 loading：boolean类型，true：代表数据正在加载，会有进度条。false：数据加载完毕。 另外，在v-data-tables中，我们还看到另一段代码： 12345678&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.calories &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.fat &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.carbs &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.protein &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.iron &#125;&#125;&lt;/td&gt;&lt;/template&gt; 这段就是在渲染每一行的数据。Vue会自动遍历上面传递的items属性，并把得到的对象传递给这段template中的props.item属性。我们从中得到数据，渲染在页面即可。 我们需要做的事情，主要有两件： 给items和totalItems赋值 当pagination变化时，重新获取数据，再次给items和totalItems赋值 初步实现 我们先弄点假品牌数据： 1234567891011121314151617181920212223242526272829303132[ &#123; "id": 2032, "name": "OPPO", "image": "http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg", "letter": "O" &#125;, &#123; "id": 2033, "name": "飞利浦（PHILIPS）", "image": "http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg", "letter": "F" &#125;, &#123; "id": 2034, "name": "华为（HUAWEI）", "image": "http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg", "letter": "H" &#125;, &#123; "id": 2036, "name": "酷派（Coolpad）", "image": "http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg", "letter": "K" &#125;, &#123; "id": 2037, "name": "魅族（MEIZU）", "image": "http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg", "letter": "M" &#125;] 品牌中有id,name,image,letter字段。 修改模板 123456789101112131415161718192021&lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt; &lt;img v-if=&quot;props.item.image&quot; :src=&quot;props.item.image&quot; width=&quot;130&quot; height=&quot;40&quot;&gt; &lt;span v-else&gt;无&lt;/span&gt; &lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt;&lt;/div&gt; 我们修改了以下部分： items：指向一个brands变量，等下在js代码中定义 total-items：指向了totalBrands变量，等下在js代码中定义 template模板中，渲染了四个字段： id： name image，注意，我们不是以文本渲染，而是赋值到一个img标签的src属性中，并且做了非空判断 letter 编写数据 接下来编写要用到的数据： 1234567891011121314151617&#123; data() &#123; return &#123; search: '', // 搜索过滤字段 totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ // 头信息 &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '名称', align: 'center', sortable: false, value: 'name'&#125;, &#123;text: 'LOGO', align: 'center', sortable: false, value: 'image'&#125;, &#123;text: '首字母', align: 'center', value: 'letter', sortable: true,&#125; ] &#125; &#125;&#125; 编写函数，初始化数据 接下来就是对brands和totalBrands完成赋值动作了。 我们编写一个函数来完成赋值，提高复用性： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950methods:&#123; getDataFromServer()&#123; // 从服务的加载数据的方法。 // 伪造假数据 const brands = [ &#123; "id": 2032, "name": "OPPO", "image": "http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg", "letter": "O", "categories": null &#125;, &#123; "id": 2033, "name": "飞利浦（PHILIPS）", "image": "http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg", "letter": "F", "categories": null &#125;, &#123; "id": 2034, "name": "华为（HUAWEI）", "image": "http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg", "letter": "H", "categories": null &#125;, &#123; "id": 2036, "name": "酷派（Coolpad）", "image": "http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg", "letter": "K", "categories": null &#125;, &#123; "id": 2037, "name": "魅族（MEIZU）", "image": "http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg", "letter": "M", "categories": null &#125; ]; // 模拟延迟一段时间，随后进行赋值 setTimeout(() =&gt; &#123; // 然后赋值给brands this.brands = brands; this.totalBrands = brands.length; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;,400) &#125;&#125; 然后使用钩子函数，在Vue实例初始化完毕后调用这个方法，这里使用mounted（渲染后）函数： 1234mounted()&#123; // 渲染后执行 // 查询数据 this.getDataFromServer();&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;template&gt; &lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;my-brand&quot;, data() &#123; return &#123; search: &apos;&apos;, // 搜索过滤字段 totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ &#123;text: &apos;id&apos;, align: &apos;center&apos;, value: &apos;id&apos;&#125;, &#123;text: &apos;名称&apos;, align: &apos;center&apos;, sortable: false, value: &apos;name&apos;&#125;, &#123;text: &apos;LOGO&apos;, align: &apos;center&apos;, sortable: false, value: &apos;image&apos;&#125;, &#123;text: &apos;首字母&apos;, align: &apos;center&apos;, value: &apos;letter&apos;, sortable: true,&#125; ] &#125; &#125;, mounted()&#123; // 渲染后执行 // 查询数据 this.getDataFromServer(); &#125;, methods:&#123; getDataFromServer()&#123; // 从服务的加载数的方法。 // 伪造假数据 const brands = [ &#123; &quot;id&quot;: 2032, &quot;name&quot;: &quot;OPPO&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg&quot;, &quot;letter&quot;: &quot;O&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2033, &quot;name&quot;: &quot;飞利浦（PHILIPS）&quot;, &quot;image&quot;: &quot;http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg&quot;, &quot;letter&quot;: &quot;F&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2034, &quot;name&quot;: &quot;华为（HUAWEI）&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg&quot;, &quot;letter&quot;: &quot;H&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2036, &quot;name&quot;: &quot;酷派（Coolpad）&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg&quot;, &quot;letter&quot;: &quot;K&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2037, &quot;name&quot;: &quot;魅族（MEIZU）&quot;, &quot;image&quot;: &quot;http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg&quot;, &quot;letter&quot;: &quot;M&quot;, &quot;categories&quot;: null &#125; ]; // 模拟延迟一段时间，随后进行赋值 setTimeout(() =&gt; &#123; // 然后赋值给brands this.brands = brands; this.totalBrands = brands.length; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;,400) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 刷新页面查看： 优化页面 编辑和删除按钮 我们将来要对品牌进行增删改，需要给每一行数据添加 修改删除的按钮，一般放到改行的最后一列： 其实就是多了一列，只是这一列没有数据，而是两个按钮而已。 我们先在头（headers）中添加一列： 1234567headers: [ &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '名称', align: 'center', sortable: false, value: 'name'&#125;, &#123;text: 'LOGO', align: 'center', sortable: false, value: 'image'&#125;, &#123;text: '首字母', align: 'center', value: 'letter', sortable: true,&#125;, &#123;text: '操作', align: 'center', value: 'id', sortable: false&#125;] 然后在模板中添加按钮： 123456789&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;justify-center&quot;&gt; 编辑/删除 &lt;/td&gt;&lt;/template&gt; 因为不知道按钮怎么写，先放个普通文本看看： 然后在官方文档中找到按钮的用法： 修改我们的模板： 12345678910&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;justify-center layout&quot;&gt; &lt;v-btn color=&quot;info&quot;&gt;编辑&lt;/v-btn&gt; &lt;v-btn color=&quot;warning&quot;&gt;删除&lt;/v-btn&gt; &lt;/td&gt;&lt;/template&gt; 新增按钮 因为新增根某个品牌无关，是独立的，因此我们可以放到表格的外面： 效果： 卡片（card） 为了不让按钮显得过于孤立，我们可以将按新增按钮和表格放到一张卡片（card）中。 我们去官网查看卡片的用法： 卡片v-card包含四个基本组件： v-card-media：一般放图片或视频 v-card-title：卡片的标题，一般位于卡片顶部 v-card-text：卡片的文本（主体内容），一般位于卡片正中 v-card-action：卡片的按钮，一般位于卡片底部 我们可以把新增的按钮放到v-card-title位置，把table放到下面，这样就成一个上下关系。 1234567891011121314151617181920212223242526272829&lt;v-card&gt; &lt;!-- 卡片的头部 --&gt; &lt;v-card-title&gt; &lt;v-btn color=&quot;primary&quot;&gt;新增&lt;/v-btn&gt; &lt;/v-card-title&gt; &lt;!-- 分割线 --&gt; &lt;v-divider/&gt; &lt;!--卡片的中部--&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;justify-center layout&quot;&gt; &lt;v-btn color=&quot;info&quot;&gt;编辑&lt;/v-btn&gt; &lt;v-btn color=&quot;warning&quot;&gt;删除&lt;/v-btn&gt; &lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt;&lt;/v-card&gt; 效果： 添加搜索框 我们还可以在卡片头部添加一个搜索框，其实就是一个文本输入框。 查看官网中，文本框的用法： name：字段名，表单中会用到 label：提示文字 value：值。可以用v-model代替，实现双向绑定 修改模板，添加输入框： 12345&lt;v-card-title&gt; &lt;v-btn color="primary"&gt;新增品牌&lt;/v-btn&gt; &lt;!--搜索框，与search属性关联--&gt; &lt;v-text-field label="输入关键字搜索" v-model="search"/&gt;&lt;/v-card-title&gt; 效果： 发现输入框变的超级长！！！ 这个时候，我们可以使用Vuetify提供的一个空间隔离工具： 修改代码： 1234567&lt;v-card-title&gt; &lt;v-btn color="primary"&gt;新增品牌&lt;/v-btn&gt; &lt;!--空间隔离组件--&gt; &lt;v-spacer /&gt; &lt;!--搜索框，与search属性关联--&gt; &lt;v-text-field label="输入关键字搜索" v-model="search"/&gt;&lt;/v-card-title&gt; 给搜索框添加搜索图标 查看textfiled的文档，发现： 通过append-icon属性可以为 输入框添加后置图标，所有可用图标名称可以到 material-icons官网去查看。 修改我们的代码： 1&lt;v-text-field label="输入关键字搜索" v-model="search" append-icon="search"/&gt; 把文本框变紧凑 搜索框看起来高度比较高，页面不够紧凑。这其实是因为默认在文本框下面预留有错误提示空间。通过下面的属性可以取消提示： 修改代码： 1&lt;v-text-field label="输入关键字搜索" v-model="search" append-icon="search" hide-details/&gt; 效果： 几乎已经达到了原来一样的效果了吧！ 后台提供查询接口 前台页面已经准备好，接下来就是后台提供数据接口了。 数据库表 1234567CREATE TABLE `tb_brand` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;品牌id&apos;, `name` varchar(50) NOT NULL COMMENT &apos;品牌名称&apos;, `image` varchar(200) DEFAULT &apos;&apos; COMMENT &apos;品牌图片地址&apos;, `letter` char(1) DEFAULT &apos;&apos; COMMENT &apos;品牌的首字母&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=325400 DEFAULT CHARSET=utf8 COMMENT=&apos;品牌表，一个品牌下有多个商品（spu），一对多关系&apos;; 简单的四个字段，不多解释。 这里需要注意的是，品牌和商品分类之间是多对多关系。因此我们有一张中间表，来维护两者间关系： 12345CREATE TABLE `tb_category_brand` ( `category_id` bigint(20) NOT NULL COMMENT &apos;商品类目id&apos;, `brand_id` bigint(20) NOT NULL COMMENT &apos;品牌id&apos;, PRIMARY KEY (`category_id`,`brand_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;商品分类和品牌的中间表，两者是多对多关系&apos;; 但是，你可能会发现，这张表中并没有设置外键约束，似乎与数据库的设计范式不符。为什么这么做？ 外键会严重影响数据库读写的效率 数据删除时会比较麻烦 在电商行业，性能是非常重要的。我们宁可在代码中通过逻辑来维护表关系，也不设置外键。 实体类 12345678910@Table(name = "tb_brand")public class Brand &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name;// 品牌名称 private String image;// 品牌图片 private Character letter; // getter setter 略&#125; mapper 通用mapper来简化开发： 12public interface BrandMapper extends Mapper&lt;Brand&gt; &#123;&#125; controller 编写controller先思考四个问题，这次没有前端代码，需要我们自己来设定 请求方式：查询，肯定是Get 请求路径：分页查询，/brand/page 请求参数：根据我们刚才编写的页面，有分页功能，有排序功能，有搜索过滤功能，因此至少要有5个参数： page：当前页，int rows：每页大小，int sortBy：排序字段，String desc：是否为降序，boolean key：搜索关键词，String 响应结果：分页结果一般至少需要两个数据 total：总条数 items：当前页数据 totalPage：有些还需要总页数 这里我们封装一个类，来表示分页结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class PageResult&lt;T&gt; &#123; private Long total;// 总条数 private Long totalPage;// 总页数 private List&lt;T&gt; items;// 当前页数据 public PageResult() &#123; &#125; public PageResult(Long total, List&lt;T&gt; items) &#123; this.total = total; this.items = items; &#125; public PageResult(Long total, Long totalPage, List&lt;T&gt; items) &#123; this.total = total; this.totalPage = totalPage; this.items = items; &#125; public Long getTotal() &#123; return total; &#125; public void setTotal(Long total) &#123; this.total = total; &#125; public List&lt;T&gt; getItems() &#123; return items; &#125; public void setItems(List&lt;T&gt; items) &#123; this.items = items; &#125; public Long getTotalPage() &#123; return totalPage; &#125; public void setTotalPage(Long totalPage) &#123; this.totalPage = totalPage; &#125;&#125; 另外，这个PageResult以后可能在其它项目中也有需求，因此我们将其抽取到ly-common中，提高复用性： 接下来，我们编写Controller 123456789101112131415161718192021@RestController@RequestMapping("brand")public class BrandController &#123; @Autowired private BrandService brandService; @GetMapping("page") public ResponseEntity&lt;PageResult&lt;Brand&gt;&gt; queryBrandByPage( @RequestParam(value = "page", defaultValue = "1") Integer page, @RequestParam(value = "rows", defaultValue = "5") Integer rows, @RequestParam(value = "sortBy", required = false) String sortBy, @RequestParam(value = "desc", defaultValue = "false") Boolean desc, @RequestParam(value = "key", required = false) String key) &#123; PageResult&lt;Brand&gt; result = this.brandService.queryBrandByPageAndSort(page,rows,sortBy,desc, key); if (result == null || result.getItems().size() == 0) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(result); &#125;&#125; Service 123456789101112131415161718192021222324252627@Servicepublic class BrandService &#123; @Autowired private BrandMapper brandMapper; public PageResult&lt;Brand&gt; queryBrandByPageAndSort( Integer page, Integer rows, String sortBy, Boolean desc, String key) &#123; // 开始分页 PageHelper.startPage(page, rows); // 过滤 Example example = new Example(Brand.class); if (StringUtils.isNotBlank(key)) &#123; example.createCriteria().andLike("name", "%" + key + "%") .orEqualTo("letter", key); &#125; if (StringUtils.isNotBlank(sortBy)) &#123; // 排序 String orderByClause = sortBy + (desc ? " DESC" : " ASC"); example.setOrderByClause(orderByClause); &#125; // 查询 Page&lt;Brand&gt; pageInfo = (Page&lt;Brand&gt;) brandMapper.selectByExample(example); // 返回结果 return new PageResult&lt;&gt;(pageInfo.getTotal(), pageInfo); &#125;&#125; 测试 通过浏览器访问试试：http://api.leyou.com/api/item/brand/page 接下来，去页面请求数据并渲染 异步查询工具axios 异步查询数据，自然是通过ajax查询，大家首先想起的肯定是jQuery。但jQuery与MVVM的思想不吻合，而且ajax只是jQuery的一小部分。因此不可能为了发起ajax请求而去引用这么大的一个库。 axios入门 Vue官方推荐的ajax请求框架叫做：axios，看下demo： axios的Get请求语法： 123456789101112131415axios.get("/item/category/list?pid=0") // 请求路径和请求参数拼接 .then(function(resp)&#123; // 成功回调函数 &#125;) .catch(function()&#123; // 失败回调函数 &#125;)// 参数较多时，可以通过params来传递参数axios.get("/item/category/list", &#123; params:&#123; pid:0 &#125; &#125;) .then(function(resp)&#123;&#125;)// 成功时的回调 .catch(function(error)&#123;&#125;)// 失败时的回调 axios的POST请求语法： 比如新增一个用户 123456axios.post("/user",&#123; name:"Jack", age:21 &#125;) .then(function(resp)&#123;&#125;) .catch(function(error)&#123;&#125;) 注意，POST请求传参，不需要像GET请求那样定义一个对象，在对象的params参数中传参。post()方法的第二个参数对象，就是将来要传递的参数 PUT和DELETE请求与POST请求类似 axios的全局配置 而在我们的项目中，已经引入了axios，并且进行了简单的封装，在src下的http.js中： http.js中对axios进行了一些默认配置： 12345678import Vue from 'vue'import axios from 'axios'import config from './config'// config中定义的基础路径是：http://api.leyou.com/apiaxios.defaults.baseURL = config.api; // 设置axios的基础请求路径axios.defaults.timeout = 2000; // 设置axios的请求时间Vue.prototype.$http = axios;// 将axios赋值给Vue原型的$http属性，这样所有vue实例都可使用该对象 http.js中导入了config的配置，还记得吗？ http.js对axios进行了全局配置：baseURL=config.api，即http://api.leyou.com/api。因此以后所有用axios发起的请求，都会以这个地址作为前缀。 通过Vue.property.$http = axios，将axios赋值给了 Vue原型中的$http。这样以后所有的Vue实例都可以访问到$http，也就是访问到了axios了。 测试一下： 我们在组件MyBrand.vue的getDataFromServer方法，通过$http发起get请求，测试查询品牌的接口，看是否能获取到数据： 网络监视： 控制台结果： 可以看到，在请求成功的返回结果response中，有一个data属性，里面就是真正的响应数据。 响应结果中与我们设计的一致，包含3个内容： total：总条数，目前是165 items：当前页数据 totalPage：总页数，我们没有返回 异步加载品牌数据 虽然已经通过ajax请求获取了品牌数据，但是刚才的请求没有携带任何参数，这样显然不对。我们后端接口需要5个参数： page：当前页，int rows：每页大小，int sortBy：排序字段，String desc：是否为降序，boolean key：搜索关键词，String 而页面中分页信息应该是在pagination对象中，我们通过浏览器工具，查看pagination中有哪些属性： 分别是： descending：是否是降序，对应请求参数的desc page：当前页，对应参数的page rowsPerpage：每页大小，对应参数中的rows sortBy：排序字段，对应参数的sortBy 缺少一个搜索关键词，这个应该是通过v-model与输入框绑定的属性：search。这样，所有参数就都有了。 另外，不要忘了把查询的结果赋值给brands和totalBrands属性，Vuetify会帮我们渲染页面。 接下来，我们在getDataFromServer方法中完善请求参数： 12345678910111213141516// 发起请求this.$http.get("/item/brand/page",&#123; params:&#123; key: this.search, // 搜索条件 page: this.pagination.page,// 当前页 rows: this.pagination.rowsPerPage,// 每页大小 sortBy: this.pagination.sortBy,// 排序字段 desc: this.pagination.descending// 是否降序 &#125; &#125;).then(resp =&gt; &#123; // 这里使用箭头函数 // 将得到的数据赋值给本地属性 this.brands = resp.data.items; this.totalBrands = resp.data.total; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;) 查看网络请求： 效果： 完成分页和过滤 分页 现在我们实现了页面加载时的第一次查询，你会发现你点击分页或搜索不会发起新的请求，怎么办？ 虽然点击分页，不会发起请求，但是通过浏览器工具查看，会发现pagination对象的属性一直在变化： 我们可以利用Vue的监视功能：watch，当pagination发生改变时，会调用我们的回调函数，我们在回调函数中进行数据的查询即可！ 具体实现： 成功实现分页功能： 过滤 分页实现了，过滤也很好实现了。过滤字段对应的是search属性，我们只要监视这个属性即可: 查看网络请求： 页面结果： 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;template&gt; &lt;v-card&gt; &lt;v-card-title&gt; &lt;v-btn color=&quot;primary&quot; @click=&quot;addBrand&quot;&gt;新增品牌&lt;/v-btn&gt; &lt;!--搜索框，与search属性关联--&gt; &lt;v-spacer/&gt; &lt;v-text-field label=&quot;输入关键字搜索&quot; v-model.lazy=&quot;search&quot; append-icon=&quot;search&quot; hide-details/&gt; &lt;/v-card-title&gt; &lt;v-divider/&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;justify-center layout&quot;&gt; &lt;v-btn color=&quot;info&quot;&gt;编辑&lt;/v-btn&gt; &lt;v-btn color=&quot;warning&quot;&gt;删除&lt;/v-btn&gt; &lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/v-card&gt;&lt;/template&gt;&lt;script&gt; import MyBrandForm from &apos;./MyBrandForm&apos; export default &#123; name: &quot;my-brand&quot;, data() &#123; return &#123; search: &apos;&apos;, // 搜索过滤字段 totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ &#123;text: &apos;id&apos;, align: &apos;center&apos;, value: &apos;id&apos;&#125;, &#123;text: &apos;名称&apos;, align: &apos;center&apos;, sortable: false, value: &apos;name&apos;&#125;, &#123;text: &apos;LOGO&apos;, align: &apos;center&apos;, sortable: false, value: &apos;image&apos;&#125;, &#123;text: &apos;首字母&apos;, align: &apos;center&apos;, value: &apos;letter&apos;, sortable: true,&#125;, &#123;text: &apos;操作&apos;, align: &apos;center&apos;, value: &apos;id&apos;, sortable: false&#125; ] &#125; &#125;, mounted() &#123; // 渲染后执行 // 查询数据 this.getDataFromServer(); &#125;, watch: &#123; pagination: &#123; // 监视pagination属性的变化 deep: true, // deep为true，会监视pagination的属性及属性中的对象属性变化 handler() &#123; // 变化后的回调函数，这里我们再次调用getDataFromServer即可 this.getDataFromServer(); &#125; &#125;, search: &#123; // 监视搜索字段 handler() &#123; this.getDataFromServer(); &#125; &#125; &#125;, methods: &#123; getDataFromServer() &#123; // 从服务的加载数的方法。 // 发起请求 this.$http.get(&quot;/item/brand/page&quot;, &#123; params: &#123; key: this.search, // 搜索条件 page: this.pagination.page,// 当前页 rows: this.pagination.rowsPerPage,// 每页大小 sortBy: this.pagination.sortBy,// 排序字段 desc: this.pagination.descending// 是否降序 &#125; &#125;).then(resp =&gt; &#123; // 这里使用箭头函数 this.brands = resp.data.items; this.totalBrands = resp.data.total; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[day06-webpack]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F27%2Fday06-webpack%2F</url>
    <content type="text"><![CDATA[学习目标 了解vue-router使用 了解webpack使用 会使用vue-cli搭建项目 独立搭建后台管理系统 了解系统基本结构 路由vue-router 场景模拟 现在我们来实现这样一个功能： 一个页面，包含登录和注册，点击不同按钮，实现登录和注册页切换： 编写父组件 为了让接下来的功能比较清晰，我们先新建一个文件夹：src: 然后新建一个HTML文件，作为入口：index.html 然后编写页面的基本结构： 1234567891011121314&lt;div id="app"&gt; &lt;span&gt;登录&lt;/span&gt; &lt;span&gt;注册&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; 登录页/注册页 &lt;/div&gt;&lt;/div&gt;&lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app" &#125;)&lt;/script&gt; 样式： 编写登录组件 接下来我们来实现登录组件，以前我们都是写在一个文件中，但是为了复用性，开发中都会把组件放如独立的JS文件中，我们新建一个login.js 编写组件，这里我们只写模板，不写功能： 123456789const loginForm = &#123; template:'\ &lt;div&gt;\ &lt;h2&gt;登录页&lt;/h2&gt; \ 用户名：&lt;input type="text"&gt;&lt;br/&gt;\ 密码：&lt;input type="password"&gt;&lt;br/&gt;\ &lt;/div&gt;\ '&#125; 编写注册组件 新建单文件组件：register.js 编写模板： 12345678910const registerForm = &#123; template:'\ &lt;div&gt;\ &lt;h2&gt;注册页&lt;/h2&gt; \ 用户名：&lt;input type="text"&gt;&lt;br/&gt;\ 密码：&lt;input type="password"&gt;&lt;br/&gt;\ 确认密码：&lt;input type="password"&gt;&lt;br/&gt;\ &lt;/div&gt;\ '&#125; 在父组件中引用 在index.html中使用刚刚编写的两个组件 123456789101112131415161718192021&lt;div id="app"&gt; &lt;span&gt;登录&lt;/span&gt; &lt;span&gt;注册&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;login-form&gt;&lt;/login-form&gt; &lt;register-form&gt;&lt;/register-form&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="js/login.js"&gt;&lt;/script&gt;&lt;script src="js/register.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app", components:&#123;// 引用登录和注册组件 loginForm, registerForm &#125; &#125;)&lt;/script&gt; 效果： 问题 我们期待的是，当点击登录或注册按钮，分别显示登录页或注册页，而不是一起显示。 但是，如何才能动态加载组件，实现组件切换呢？ 虽然使用原生的Html5和JS也能实现，但是官方推荐我们使用vue-router模块。 vue-router简介和安装 使用vue-router和vue可以非常方便的实现 复杂单页应用的动态路由功能。 官网：https://router.vuejs.org/zh-cn/ 使用npm安装：npm install vue-router --save 在index.html中引入依赖： 1&lt;script src="../node_modules/vue-router/dist/vue-router.js"&gt;&lt;/script&gt; 快速入门 新建vue-router对象，并且指定路由规则： 12345678910// 创建VueRouter对象const router = new VueRouter(&#123; routes:[ // 编写多个路由规则 &#123; path:"/login", // 请求路径 component:loginForm // 组件名称 &#125;, &#123;path:"/register",component:registerForm&#125;, ]&#125;) 创建VueRouter对象，并指定路由参数 routes：路由规则的数组，可以指定多个对象，每个对象是一条路由规则，包含以下属性： path：路由的路径 component：组件名称 在父组件中引入router对象： 12345678var vm = new Vue(&#123; el:"#app", components:&#123;// 引用登录和注册组件 loginForm, registerForm &#125;, router // 引用上面定义的router对象&#125;) 页面跳转控制： 12345678910&lt;div id="app"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 通过&lt;router-view&gt;来指定一个锚点，当路由的路径匹配时，vue-router会自动把对应组件放到锚点位置进行渲染 通过&lt;router-link&gt;指定一个跳转链接，当点击时，会触发vue-router的路由功能，路径中的hash值会随之改变 效果： 注意：单页应用中，页面的切换并不是页面的跳转。仅仅是地址最后的hash值变化。 事实上，我们总共就一个HTML：index.html 父子组件 webpack 认识webpack Webpack 是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。 中文官方网站：https://www.webpackjs.com/ 官网给出的解释： 为什么需要打包？ 将许多碎小文件打包成一个整体，减少单页面内的衍生请求次数，提高网站效率。 将ES6的高级语法进行转换编译，以兼容老版本的浏览器。 将代码打包的同时进行混淆，提高代码的安全性。 四个核心概念 学习Webpack，你需要先理解四个核心概念： 入口(entry) webpack打包的启点，可以有一个或多个，一般是js文件。webpack会从启点文件开始，寻找启点直接或间接依赖的其它所有的依赖，包括JS、CSS、图片资源等，作为将来打包的原始数据 输出(output) 出口一般包含两个属性：path和filename。用来告诉webpack打包的目标文件夹，以及文件的名称。目的地也可以有多个。 加载器（loader） webpack本身只识别Js文件，如果要加载非JS文件，必须指定一些额外的加载器（loader），例如css-loader。然后将这些文件转为webpack能处理的有效模块，最后利用webpack的打包能力去处理。 插件(plugins) 插件可以扩展webpack的功能，让webpack不仅仅是完成打包，甚至各种更复杂的功能，或者是对打包功能进行优化、压缩，提高效率。 安装 webpack支持全局安装和本地安装，官方推荐是本地安装，我们按照官方的来。 输入命令：npm install webpack webpack-cli --save-dev 此时，我们注意下项目中文件夹下，会有一个package.json文件。（其实早就有了） 打开文件，可以看到我们之前用npm安装过的文件都会出现在这里： 编写webpack配置 接下来，我们编写一个webpack的配置，来指定一些打包的配置项。配置文件的名称，默认就是webpack.config.js，我们放到hello-vue的根目录： 配置文件中就是要指定上面说的四个核心概念，入口、出口、加载器、插件。 不过，加载器和插件是可选的。我们先编写入口和出口 入口entry webpack打包的启点，可以有一个或多个，一般是js文件。现在思考一下我们有没有一个入口？貌似没有，我们所有的东西都集中在index.html，不是一个js，那怎么办？ 我们新建一个js，把index.html中的部分内容进行集中，然后在index.html中引用这个js不就OK了！ 然后把原来index.html中的js代码全部移动到main.js中 1234567891011121314151617181920212223242526// 使用es6的语法导入js模块import Vue from '../node_modules/vue/dist/vue';import VueRouter from '../node_modules/vue-router/dist/vue-router'import loginForm from './js/login'import registerForm from './js/register'Vue.use(VueRouter)// 创建VueRouter对象const router = new VueRouter(&#123; routes:[ // 编写多个路由规则 &#123; path:"/login", // 请求路径 component:loginForm // 组件名称 &#125;, &#123;path:"/register",component:registerForm&#125;, ]&#125;)var vm = new Vue(&#123; el:"#app", components:&#123;// 引用登录和注册组件 loginForm, registerForm &#125;, router&#125;) 原来的index.html中引入了很多其它js，在这里我们使用es6的import语法进行导入。 注意，要使用import，就需要在login.js和register.js中添加export导出语句： 12345678910const loginForm = &#123; template:` &lt;div&gt; &lt;h2&gt;登录页&lt;/h2&gt; 用户名：&lt;input type="text"&gt;&lt;br/&gt; 密码：&lt;input type="password"&gt;&lt;br/&gt; &lt;/div&gt; `&#125;export default loginForm; register.js: 1234567891011const registerForm = &#123; template:` &lt;div&gt; &lt;h2&gt;注册页&lt;/h2&gt; 用户名：&lt;input type="text"&gt;&lt;br/&gt; 密码：&lt;input type="password"&gt;&lt;br/&gt; 确认密码：&lt;input type="password"&gt;&lt;br/&gt; &lt;/div&gt; `&#125;export default registerForm; vue-router使用模块话加载后，必须增加一句：Vue.use(VueRouter) 这样，main.js就成了我们整个配置的入口了。 我们在webpack.config.js中添加以下内容： 123module.exports=&#123; entry:'./src/main.js', //指定打包的入口文件&#125; 出口output 出口，就是输出的目的地。一般我们会用一个dist目录，作为打包输出的文件夹： 然后，编写webpack.config.js，添加出口配置： 12345678module.exports=&#123; entry:'./src/main.js', //指定打包的入口文件 output:&#123; // path: 输出的目录，__dirname是相对于webpack.config.js配置文件的绝对路径 path : __dirname+'/dist', filename:'build.js' //输出的js文件名 &#125;&#125; 执行打包 在控制台输入以下命令： 1npx webpack --config webpack.config.js 随后，查看dist目录： 尝试打开build.js，你根本看不懂： 所有的js合并为1个，并且对变量名进行了随机打乱，这样就起到了 压缩、混淆的作用。 测试运行 在index.html中引入刚刚生成的build.js文件， 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="../dist/build.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后运行： 打包CSS 编写css文件 我们来编写一段CSS代码，对index的样式做一些美化： 内容： 123456789101112131415161718192021#app a&#123; display: inline-block; width: 150px; line-height: 30px; background-color: dodgerblue; color: white; font-size: 16px; text-decoration: none;&#125;#app a:hover&#123; background-color: whitesmoke; color: dodgerblue;&#125;#app div&#123; width: 300px; height: 150px;&#125;#app&#123; width: 305px; border: 1px solid dodgerblue;&#125; 安装加载器 前面说过，webpack默认只支持js加载。要加载CSS文件，必须安装加载器： 命令： 1npm install style-loader css-loader --save-dev 此时，在package.json中能看到新安装的： 在main.js引入css文件 因为入口在main.js，因此css文件也要在这里引入。依然使用ES6 的模块语法： 1import './css/main.css' 在webpack.config.js添加加载器 123456789101112131415161718module.exports = &#123; entry: './src/main.js', //指定打包的入口文件 output: &#123; path: __dirname + '/dist', // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename: 'build.js' //输出文件 &#125;, module: &#123; rules: [ &#123; test: /\.css$/, // 通过正则表达式匹配所有以.css后缀的文件 use: [ // 要使用的加载器，这两个顺序一定不要乱 'style-loader', 'css-loader' ] &#125; ] &#125;&#125; 重新打包 再次输入打包指令：npx webpack --config webpack.config.js 效果： script脚本 我们每次使用npm安装，都会在package.json中留下痕迹，事实上，package.json中不仅可以记录安装的内容，还可编写脚本，让我们运行命令更加快捷。 我们可以把webpack的命令编入其中： 以后，如果要打包，就可以直接输入：npm run build即可。 npm run ：执行npm脚本，后面跟的是脚本的名称build 打包HTML 之前的打包过程中，除了HTML文件外的其它文件都被打包了，当在线上部署时，我们还得自己复制HTML到dist，然后手动添加生成的js到HTML中，这非常不友好。 webpack中的一个插件：html-webpack-plugin，可以解决这个问题。 1）安装插件：npm install --save-dev html-webpack-plugin 需要在webpack.config.js中添加插件： 123456789101112131415161718192021222324252627const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: './src/main.js', //指定打包的入口文件 output: &#123; path: __dirname + '/dist', // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename: 'build.js' //输出文件 &#125;, module: &#123; rules: [ &#123; test: /\.css$/, // 通过正则表达式匹配所有以.css后缀的文件 use: [ // 要使用的加载器，这两个顺序一定不要乱 'style-loader', 'css-loader' ] &#125; ] &#125;, plugins:[ new HtmlWebpackPlugin(&#123; title: '首页', //生成的页面标题&lt;head&gt;&lt;title&gt;首页&lt;/title&gt;&lt;/head&gt; filename: 'index.html', // dist目录下生成的文件名 template: './src/index.html' // 我们原来的index.html，作为模板 &#125;) ]&#125; 2）将原来HTML中的引入js代码删除： 3）再次打包：npm run build 4）查看dist目录： 打开index.html，发现已经自动添加了当前目录下的build.js 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;script type="text/javascript" src="build.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 热更新的web服务 刚才的案例中，每次修改任何js或css内容，都必须重新打包，非常麻烦。 webpack给我们提供了一个插件，可以帮我们运行一个web服务，加载页面内容，并且修改js后不需要重新加载就能看到最新结果： 1）安装插件： 1npm install webpack-dev-server --save-dev 2）添加启动脚本 在package.json中配置script 123"scripts": &#123; "dev": "webpack-dev-server --inline --hot --open --port 8080 --host 127.0.0.1"&#125;, –inline：自动刷新 –hot：热加载 –port：指定端口 –open：自动在默认浏览器打开 –host：可以指定服务器的 ip，不指定则为127.0.0.1 3）运行脚本： 1npm run dev 4）效果： vue-cli 介绍和安装 在开发中，需要打包的东西不止是js、css、html。还有更多的东西要处理，这些插件和加载器如果我们一一去添加就会比较麻烦。 幸好，vue官方提供了一个快速搭建vue项目的脚手架：vue-cli 使用它能快速的构建一个web工程模板。 官网：https://github.com/vuejs/vue-cli 安装命令： 1npm install -g vue-cli 快速上手 我们新建一个module： 打开终端并进入目录： 用vue-cli命令，快速搭建一个webpack的项目：vue init webpack 前面几项都走默认或yes 下面这些我们选no 最后，再选yes，使用 npm安装 项目结构 安装好的项目结构： 入口文件： 单文件组件 需要注意的是，我们看到有一类后缀名为.vue的文件，我们称为单文件组件 每一个.vue文件，就是一个独立的vue组件。类似于我们刚才写的loginForm.js和registerForm.js 只不过，我们在js中编写 html模板和样式非常的不友好，而且没有语法提示和高亮。 而单文件组件中包含三部分内容： template：模板，支持html语法高亮和提示 script：js脚本，这里编写的就是vue的组件对象，看到上面的data(){}了吧 style：样式，支持CSS语法高亮和提示 每个组件都有自己独立的html、JS、CSS，互不干扰，真正做到可独立复用。 运行 看看生成的package.json： 可以看到这引入了非常多的依赖，绝大多数都是开发期依赖，比如大量的加载器。 运行时依赖只有vue和vue-router 脚本有三个： dev：使用了webpack-dev-server命令，开发时热部署使用 start：使用了npm run dev命令，与上面的dev效果完全一样 build：等同于webpack的打包功能，会打包到dist目录下。 我们执行npm run dev 或者 npm start 都可以启动项目： 页面： 搭建后台管理前端 导入已有资源 后台项目相对复杂，为了有利于教学，我们不再从0搭建项目，而是直接使用课前资料中给大家准备好的源码： 我们解压缩，放到工作目录中： 然后在eclipse中导入新的工程： 选中我们的工程： 这正是一个用vue-cli构建的webpack工程，是不是与昨天的一样： 安装依赖 你应该注意到，这里并没有node_modules文件夹，方便给大家下发，已经把依赖都删除了。不过package.json中依然定义了我们所需的一切依赖： 我们只需要通过命令来安装所需依赖即可。打开终端，进入项目目录，输入：npm install 大概需要1分钟。 运行一下看看 输入命令： 1npm run dev 发现默认的端口是9001。访问：http://localhost:9001 会自动进行跳转： Vuetify框架 为什么要学习UI框架 Vue负责的是虽然会帮我们进行视图的渲染，但是样式是有我们自己来完成。这显然不是我们的强项，因此后端开发人员一般都喜欢使用一些现成的UI组件，拿来即用，常见的例如： BootStrap LayUI EasyUI ZUI 然而这些UI组件的基因天生与Vue不合，因为他们更多的是利用DOM操作，借助于jQuery实现，而不是MVVM的思想。 而目前与Vue吻合的UI框架也非常的多，国内比较知名的如： element-ui：饿了么出品 i-view：某公司出品 然而我们都不用，我们今天推荐的是一款国外的框架：Vuetify 官方网站：https://vuetifyjs.com/zh-Hans/ 为什么是Vuetify 有中国的为什么还要用外国的？原因如下： Vuetify几乎不需要任何CSS代码，而element-ui许多布局样式需要我们来编写 Vuetify从底层构建起来的语义化组件。简单易学，容易记住。 Vuetify基于Material Design（谷歌推出的多平台设计规范），更加美观，动画效果酷炫，且风格统一 这是官网的说明： 缺陷： 目前官网虽然有中文文档，但因为翻译问题，几乎不太能看。 怎么用？ 基于官方网站的文档进行学习： 我们重点关注UI components即可，里面有大量的UI组件，我们要用的时候再查看，不用现在学习，先看下有什么： 以后用到什么组件，就来查询即可。 项目结构 开始编码前，我们先了解下项目的结构： 目录结构 首先是目录结构图： 调用关系 我们最主要理清index.html、main.js、App.vue之间的关系： 理一下： index.html中定义了空的div，其id为app。 main.js中定义了Vue对象，并且绑定通过id选择器，绑定到index.html的div中，因此main.js的内容都将在index.html的div中显示。 而main.js中只有一行内容：&lt;App/&gt;,这是使用了App组件，即App.vue，也就是说index.html中最终展现的是App.vue中的内容。 App.vue中也没有内容，而是定义了vue-router的锚点：&lt;router-view&gt;,我们之前讲过，vue-router路由后的组件将会在锚点展示。 最终的结论是：一切路由后的内容都将通过App.vue在index.html中显示。 页面布局 接下来我们一起看下页面布局： Layout组件是我们的整个页面的布局组件： 一个典型的三块布局。包含左，上，中三部分： 里面使用了Vuetify中的2个组件和一个布局元素： v-navigation-drawer ：导航抽屉，主要用于容纳应用程序中的页面的导航链接。 v-toolbar：工具栏通常是网站导航的主要途径。可以与导航抽屉一起很好地工作，动态选择是否打开导航抽屉，实现可伸缩的侧边栏。 v-content：并不是一个组件，而是标记页面布局的元素。可以根据您指定的app组件的结构动态调整大小，使得您可以创建高度可定制的组件。 那么问题来了：v-content中的内容来自哪里？ Layout映射的路径是/ 除了Login以为的所有组件，都是定义在Layout的children属性，并且路径都是/的下面 因此当路由到子组件时，会在Layout中定义的锚点中显示。 并且Layout中的其它部分不会变化，这就实现了布局的共享。]]></content>
  </entry>
  <entry>
    <title><![CDATA[day06]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F27%2Fday06%2F</url>
    <content type="text"><![CDATA[学习目标 使用资料搭建后台系统 会使用nginx进行反向代理 实现商品分类查询功能 掌握cors解决跨域 实现品牌查询功能 搭建后台管理前端 导入已有资源 后台项目相对复杂，为了有利于教学，我们不再从0搭建项目，而是直接使用课前资料中给大家准备好的源码： 我们解压缩，放到工作目录中： 然后在Intellij idea中导入新的工程： 选中我们的工程： 这正是一个用vue-cli构建的webpack工程，是不是与昨天的一样： 安装依赖 你应该注意到，这里并没有node_modules文件夹，方便给大家下发，已经把依赖都删除了。不过package.json中依然定义了我们所需的一切依赖： 我们只需要打开终端，进入项目目录，输入：npm install命令，即可安装这些依赖。 大概需要几分钟。 如果安装过程出现以下问题： 建议删除node_modules目录，重新安装。 运行一下看看 输入命令：npm run dev 发现默认的端口是9001。访问：http://localhost:9001 会自动进行跳转： Vuetify框架 为什么要学习UI框架 Vue虽然会帮我们进行视图的渲染，但样式还是由我们自己来完成。这显然不是我们的强项，因此后端开发人员一般都喜欢使用一些现成的UI组件，拿来即用，常见的例如： BootStrap LayUI EasyUI ZUI 然而这些UI组件的基因天生与Vue不合，因为他们更多的是利用DOM操作，借助于jQuery实现，而不是MVVM的思想。 而目前与Vue吻合的UI框架也非常的多，国内比较知名的如： element-ui：饿了么出品 i-view：某公司出品 然而我们都不用，我们今天推荐的是一款国外的框架：Vuetify 官方网站：https://vuetifyjs.com/zh-Hans/ 为什么是Vuetify 有中国的为什么还要用外国的？原因如下： Vuetify几乎不需要任何CSS代码，而element-ui许多布局样式需要我们来编写 Vuetify从底层构建起来的语义化组件。简单易学，容易记住。 Vuetify基于Material Design（谷歌推出的多平台设计规范），更加美观，动画效果酷炫，且风格统一 这是官网的说明： 缺陷： 目前官网虽然有中文文档，但因为翻译问题，几乎不太能看。 怎么用？ 基于官方网站的文档进行学习： 我们重点关注UI components即可，里面有大量的UI组件，我们要用的时候再查看，不用现在学习，先看下有什么： 以后用到什么组件，就来查询即可。 项目结构 开始编码前，我们先了解下项目的结构。 目录结构 首先是目录结构图： 调用关系 我们最主要理清index.html、main.js、App.vue之间的关系： 理一下： index.html：html模板文件。定义了空的div，其id为app。 main.js：实例化vue对象，并且绑定通过id选择器，绑定到index.html的div中，因此main.js的内容都将在index.html的div中显示。main.js中使用了App组件，即App.vue，也就是说index.html中最终展现的是App.vue中的内容。index.html引用它之后，就拥有了vue的内容（包括组件、样式等），所以，main.js也是webpack打包的入口。 index.js：定义请求路径和组件的映射关系。相当于之前的&lt;vue-router&gt; App.vue中也没有内容，而是定义了vue-router的锚点：&lt;router-view&gt;,我们之前讲过，vue-router路由后的组件将会在锚点展示。 最终结论：一切路由后的内容都将通过App.vue在index.html中显示。 访问流程：用户在浏览器输入路径，例如：http://localhost:9001/#/item/brand –&gt; index.js(/item/brand路径对应pages/item/Brand.vue组件) –&gt; 该组件显示在App.vue的锚点位置 –&gt; main.js使用了App.vue组件，并把该组件渲染在index.html文件中（id为“app”的div中） 页面布局 接下来我们一起看下页面布局。 Layout组件是我们的整个页面的布局组件： 一个典型的三块布局。包含左，上，中三部分： 里面使用了Vuetify中的2个组件和一个布局元素： v-navigation-drawer ：导航抽屉，主要用于容纳应用程序中的页面的导航链接。 ![1530380237867](day06/1530380237867.png) v-toolbar：工具栏通常是网站导航的主要途径。可以与导航抽屉一起很好地工作，动态选择是否打开导航抽屉，实现可伸缩的侧边栏。 v-content：并不是一个组件，而是标记页面布局的元素。可以根据您指定的app组件的结构动态调整大小，使得您可以创建高度可定制的组件。 那么问题来了：v-content中的内容来自哪里？ Layout映射的路径是/ 除了Login以为的所有组件，都是定义在Layout的children属性，并且路径都是/的下面 因此当路由到子组件时，会在Layout中定义的锚点中显示。 并且Layout中的其它部分不会变化，这就实现了布局的共享。 使用域名访问本地项目 统一环境 我们现在访问页面使用的是：http://localhost:9001 有没有什么问题？ 实际开发中，会有不同的环境： 开发环境：自己的电脑 测试环境：提供给测试人员使用的环境 预发布环境：数据是和生成环境的数据一致，运行最新的项目代码进去测试 生产环境：项目最终发布上线的环境 如果不同环境使用不同的ip去访问，可能会出现一些问题。为了保证所有环境的一致，我们会在各种环境下都使用域名来访问。 我们将使用以下域名： 主域名是：www.leyou.com， 管理系统域名：manage.leyou.com 网关域名：api.leyou.com … 但是最终，我们希望这些域名指向的还是我们本机的某个端口。 那么，当我们在浏览器输入一个域名时，浏览器是如何找到对应服务的ip和端口的呢？ 域名解析 一个域名一定会被解析为一个或多个ip。这一般会包含两步： 本地域名解析 浏览器会首先在本机的hosts文件中查找域名映射的IP地址，如果查找到就返回IP ，没找到则进行域名服务器解析，一般本地解析都会失败，因为默认这个文件是空的。 Windows下的hosts文件地址：C:/Windows/System32/drivers/etc/hosts Linux下的hosts文件所在路径： /etc/hosts 样式： 1234# My hosts127.0.0.1 localhost0.0.0.0 account.jetbrains.com127.0.0.1 www.xmind.net 域名服务器解析 本地解析失败，才会进行域名服务器解析，域名服务器就是网络中的一台计算机，里面记录了所有注册备案的域名和ip映射关系，一般只要域名是正确的，并且备案通过，一定能找到。 解决域名解析问题 我们不可能去购买一个域名，因此我们可以伪造本地的hosts文件，实现对域名的解析。修改本地的host为： 12127.0.0.1 api.leyou.com127.0.0.1 manage.leyou.com 这样就实现了域名的关系映射了。 每次在C盘寻找hosts文件并修改是非常麻烦的，给大家推荐一个快捷修改host的工具，在课前资料中可以找到： 解压，运行exe文件，效果： 我们添加了两个映射关系（中间用空格隔开）： 127.0.0.1 api.leyou.com ：我们的网关Zuul 127.0.0.1 manage.leyou.com：我们的后台系统地址 现在，ping一下域名试试是否畅通： OK！ 通过域名访问： 原因：我们配置了项目访问的路径，虽然manage.leyou.com映射的ip也是127.0.0.1，但是webpack会验证host是否符合配置。 在webpack.dev.conf.js中取消host验证： 重新执行npm run dev，刷新浏览器： OK！ nginx解决端口问题 域名问题解决了，但是现在要访问后台页面，还得自己加上端口：http://manage.taotao.com:9001。 这就不够优雅了。我们希望的是直接域名访问：http://manage.taotao.com。这种情况下端口默认是80，如何才能把请求转移到9001端口呢？ 这里就要用到反向代理工具：Nginx 什么是Nginx nginx可以作为web服务器，但更多的时候，我们把它作为网关，因为它具备网关必备的功能： 反向代理 负载均衡 动态路由 请求过滤 nginx作为web服务器 Web服务器分2类： web应用服务器，如： tomcat resin jetty web服务器，如： Apache 服务器 Nginx IIS 区分：web服务器不能解析jsp等页面，只能处理js、css、html等静态资源。并发：web服务器的并发能力远高于web应用服务器。 nginx作为反向代理 什么是反向代理？ 代理：通过客户机的配置，实现让一台服务器(代理服务器)代理客户机，客户的所有请求都交给代理服务器处理。 反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。 nginx可以当做反向代理服务器来使用： 我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理 当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能 利用反向代理，就可以解决我们前面所说的端口问题，如图 安装和使用 安装 安装非常简单，把课前资料提供的nginx直接解压即可，绿色免安装，舒服！ 我们在本地安装一台nginx： 解压后，目录结构： conf：配置目录 contrib：第三方依赖 html：默认的静态资源目录，类似于tomcat的webapps logs：日志目录 nginx.exe：启动程序。可双击运行，但不建议这么做。 反向代理配置 示例： nginx中的每个server就是一个反向代理配置，可以有多个server 完整配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#user nobody;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; server &#123; listen 80; server_name manage.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://127.0.0.1:9001; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125; server &#123; listen 80; server_name api.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://127.0.0.1:10010; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125;&#125; 使用 nginx可以通过命令行来启动，操作命令： 启动：start nginx.exe 停止：nginx.exe -s stop 重新加载：nginx.exe -s reload 启动过程会闪烁一下，启动成功后，任务管理器中会有两个nginx进程： 测试 启动nginx，然后用域名访问后台管理系统： 现在实现了域名访问网站了，中间的流程是怎样的呢？ 浏览器准备发起请求，访问http://mamage.leyou.com，但需要进行域名解析 优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：127.0.0.1 请求被发往解析得到的ip，并且默认使用80端口：http://127.0.0.1:80 本机的nginx一直监听80端口，因此捕获这个请求 nginx中配置了反向代理规则，将manage.leyou.com代理到127.0.0.1:9001，因此请求被转发 后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx nginx将得到的结果返回到浏览器 实现商品分类查询 商城的核心自然是商品，而商品多了以后，肯定要进行分类，并且不同的商品会有不同的品牌信息，其关系如图所示： 一个商品分类下有很多商品 一个商品分类下有很多品牌 而一个品牌，可能属于不同的分类 一个品牌下也会有很多商品 因此，我们需要依次去完成：商品分类、品牌、商品的开发。 导入数据 首先导入课前资料提供的sql： 我们先看商品分类表： 123456789CREATE TABLE `tb_category` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;类目id&apos;, `name` varchar(20) NOT NULL COMMENT &apos;类目名称&apos;, `parent_id` bigint(20) NOT NULL COMMENT &apos;父类目id,顶级类目填0&apos;, `is_parent` tinyint(1) NOT NULL COMMENT &apos;是否为父节点，0为否，1为是&apos;, `sort` int(4) NOT NULL COMMENT &apos;排序指数，越小越靠前&apos;, PRIMARY KEY (`id`), KEY `key_parent_id` (`parent_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1424 DEFAULT CHARSET=utf8 COMMENT=&apos;商品类目表，类目和商品(spu)是一对多关系，类目与品牌是多对多关系&apos;; 因为商品分类会有层级关系，因此这里我们加入了parent_id字段，对本表中的其它分类进行自关联。 页面实现 页面分析 首先我们看下要实现的效果： 商品分类之间是会有层级关系的，采用树结构去展示是最直观的方式。 一起来看页面，对应的是/pages/item/Category.vue： 页面模板： 1234567891011121314&lt;template&gt; &lt;v-card&gt; &lt;v-flex xs12 sm10&gt; &lt;v-tree url="/item/category/list" :treeData="treeData" :isEdit="isEdit" @handleAdd="handleAdd" @handleEdit="handleEdit" @handleDelete="handleDelete" @handleClick="handleClick" /&gt; &lt;/v-flex&gt; &lt;/v-card&gt;&lt;/template&gt; v-card：卡片，是vuetify中提供的组件，提供一个悬浮效果的面板，一般用来展示一组数据。 v-flex：布局容器，用来控制响应式布局。与BootStrap的栅格系统类似，整个屏幕被分为12格。我们可以控制所占的格数来控制宽度： 本例中，我们用sm10控制在小屏幕及以上时，显示宽度为10格 v-tree：树组件。Vuetify并没有提供树组件，这个是我们自己编写的自定义组件： 里面涉及一些vue的高级用法，大家暂时不要关注其源码，会用即可。 树组件的用法 也可参考课前资料中的：《自定义Vue组件的用法.md》 这里我贴出树组件的用法指南。 属性列表： 属性名称 说明 数据类型 默认值 url 用来加载数据的地址，即延迟加载 String - isEdit 是否开启树的编辑功能 boolean false treeData 整颗树数据，这样就不用远程加载了 Array - 这里推荐使用url进行延迟加载，每当点击父节点时，就会发起请求，根据父节点id查询子节点信息。 当有treeData属性时，就不会触发url加载 远程请求返回的结果格式： 12345678910111213141516[ &#123; "id": 74, "name": "手机", "parentId": 0, "isParent": true, "sort": 2 &#125;, &#123; "id": 75, "name": "家用电器", "parentId": 0, "isParent": true, "sort": 3 &#125;] 事件： 事件名称 说明 回调参数 handleAdd 新增节点时触发，isEdit为true时有效 新增节点node对象，包含属性：name、parentId和sort handleEdit 当某个节点被编辑后触发，isEdit为true时有效 被编辑节点的id和name handleDelete 当删除节点时触发，isEdit为true时有效 被删除节点的id handleClick 点击某节点时触发 被点击节点的node对象,包含完整的node信息 完整node的信息 回调函数中返回完整的node节点会包含以下数据： 12345678&#123; "id": 76, // 节点id "name": "手机", // 节点名称 "parentId": 75, // 父节点id "isParent": false, // 是否是父节点 "sort": 1, // 顺序 "path": ["手机", "手机通讯", "手机"] // 所有父节点的名称数组&#125; 实现功能 url异步请求 给大家的页面中，treeData是假数据，我们删除数据treeData属性，只保留url看看会发生什么： 1234567&lt;v-tree url="/item/category/list" :isEdit="isEdit" @handleAdd="handleAdd" @handleEdit="handleEdit" @handleDelete="handleDelete" @handleClick="handleClick" /&gt; 刷新页面，可以看到： 页面中的树没有了，并且发起了一条请求：http://localhost/api/item/category/list?pid=0 大家可能会觉得很奇怪，我们明明是使用的相对路径，讲道理发起的请求地址应该是： http://manage.leyou.com/item/category/list 但实际却是： http://localhost/api/item/category/list?pid=0 这是因为，我们有一个全局的配置文件，对所有的请求路径进行了约定： 路径是localhost，并且默认加上了/api的前缀，这恰好与我们的网关设置匹配，我们只需要把地址改成网关的地址即可,因为我们使用了nginx反向代理，这里可以写域名。 接下来，我们要做的事情就是编写后台接口，返回对应的数据即可。 实体类 在ly-item-interface中添加category实体类： 内容： 1234567891011@Table(name="tb_category")public class Category &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id; private String name; private Long parentId; private Boolean isParent; // 注意isParent生成的getter和setter方法需要手动加上Is private Integer sort; // getter和setter略&#125; 需要注意的是，这里要用到jpa的注解，因此我们在ly-item-iterface中添加jpa依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;persistence-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; controller 编写一个controller一般需要知道四个内容： 请求方式：决定我们用GetMapping还是PostMapping 请求路径：决定映射路径 请求参数：决定方法的参数 返回值结果：决定方法的返回值 在刚才页面发起的请求中，我们就能得到绝大多数信息： 请求方式：Get 请求路径：/api/item/category/list。其中/api是网关前缀，/item是网关的路由映射，真实的路径应该是/category/list 请求参数：pid=0，根据tree组件的说明，应该是父节点的id，第一次查询为0，那就是查询一级类目 返回结果：？？ 根据前面tree组件的用法我们知道，返回的应该是json数组： 12345678910111213141516[ &#123; "id": 74, "name": "手机", "parentId": 0, "isParent": true, "sort": 2 &#125;, &#123; "id": 75, "name": "家用电器", "parentId": 0, "isParent": true, "sort": 3 &#125;] 对应的java类型可以是List集合，里面的元素就是类目对象了。也就是List&lt;Category&gt; 添加Controller： controller代码： 12345678910111213141516171819202122232425262728293031323334@Controller@RequestMapping("category")public class CategoryController &#123; @Autowired private CategoryService categoryService; /** * 根据parentId查询类目 * @param pid * @return */ @RequestMapping("list") public ResponseEntity&lt;List&lt;Category&gt;&gt; queryCategoryListByParentId(@RequestParam(value = "pid", defaultValue = "0") Long pid) &#123; try &#123; if (pid == null || pid.longValue() &lt; 0)&#123; // pid为null或者小于等于0，响应400 return ResponseEntity.badRequest().build(); &#125; // 执行查询操作 List&lt;Category&gt; categoryList = this.categoryService.queryCategoryListByParentId(pid); if (CollectionUtils.isEmpty(categoryList))&#123; // 返回结果集为空，响应404 return ResponseEntity.notFound().build(); &#125; // 响应200 return ResponseEntity.ok(categoryList); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 响应500 return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); &#125;&#125; service 一般service层我们会定义接口和实现类，不过这里我们就偷懒一下，直接写实现类了： 1234567891011121314151617@Servicepublic class CategoryService &#123; @Autowired private CategoryMapper categoryMapper; /** * 根据parentId查询子类目 * @param pid * @return */ public List&lt;Category&gt; queryCategoryListByParentId(Long pid) &#123; Category record = new Category(); record.setParentId(pid); return this.categoryMapper.select(record); &#125;&#125; mapper 我们使用通用mapper来简化开发： 12public interface CategoryMapper extends Mapper&lt;Category&gt; &#123;&#125; 要注意，我们并没有在mapper接口上声明@Mapper注解，那么mybatis如何才能找到接口呢？ 我们在启动类上添加一个扫描包功能： 123456789@SpringBootApplication@EnableDiscoveryClient@MapperScan("com.leyou.item.mapper") // mapper接口的包扫描public class LeyouItemServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LeyouItemServiceApplication.class, args); &#125;&#125; 启动并测试 我们不经过网关，直接访问：http://localhost:8081/category/list 然后试试网关是否畅通：http://api.leyou.com/api/item/category/list 一切OK！ 然后刷新后台管理页面查看： 发现报错了！ 浏览器直接访问没事，但是这里却报错，什么原因？ 跨域问题 跨域：浏览器对于javascript的同源策略的限制 。 以下情况都属于跨域： 跨域原因说明 示例 域名不同 www.jd.com 与 www.taobao.com 域名相同，端口不同 www.jd.com:8080 与 www.jd.com:8081 二级域名不同 item.jd.com 与 miaosha.jd.com 如果域名和端口都相同，但是请求路径不同，不属于跨域，如： www.jd.com/item www.jd.com/goods 而我们刚才是从manage.leyou.com去访问api.leyou.com，这属于二级域名不同，跨域了。 为什么有跨域问题？ 跨域不一定会有跨域问题。 因为跨域问题是浏览器对于ajax请求的一种安全限制：一个页面发起的ajax请求，只能是与当前页域名相同的路径，这能有效的阻止跨站攻击。 因此：跨域问题 是针对ajax的一种限制。 但是这却给我们的开发带来了不便，而且在实际生产环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？ 解决跨域问题的方案 目前比较常用的跨域解决方案有3种： Jsonp 最早的解决方案，利用script标签可以跨域的原理实现。 限制： 需要服务的支持 只能发起GET请求 nginx反向代理 思路是：利用nginx把跨域反向代理为不跨域，支持各种请求方式 缺点：需要在nginx进行额外配置，语义不清晰 CORS 规范化的跨域请求解决方案，安全可靠。 优势： 在服务端进行控制是否允许跨域，可自定义规则 支持各种请求方式 缺点： 会产生额外的请求 我们这里会采用cors的跨域方案。 cors解决跨域 什么是cors CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 浏览器端： 目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。 服务端： CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否允许其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。 原理有点复杂 浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。 简单请求 只要同时满足以下两大条件，就属于简单请求。： （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 当浏览器发现发起的ajax请求是简单请求时，会在请求头中携带一个字段：Origin. Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。 如果服务器允许跨域，需要在返回的响应头中携带下面信息： 123Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*（代表任意域名） Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true 有关cookie： 要想操作cookie，需要满足3个条件： 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。 浏览器发起ajax需要指定withCredentials 为true 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名 特殊请求 不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。 预检请求 特殊请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 一个“预检”请求的样板： 12345678OPTIONS /cors HTTP/1.1Origin: http://manage.leyou.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.leyou.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 与简单请求相比，除了Origin以外，多了两个头： Access-Control-Request-Method：接下来会用到的请求方式，比如PUT Access-Control-Request-Headers：会额外用到的头信息 预检请求的响应 服务的收到预检请求，如果许可跨域，会发出响应： 1234567891011121314HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Max-Age: 1728000Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 除了Access-Control-Allow-Origin和Access-Control-Allow-Credentials以外，这里又额外多出3个头： Access-Control-Allow-Methods：允许访问的方式 Access-Control-Allow-Headers：允许携带的头 Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次进行预检了 如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。 实现非常简单 虽然原理比较复杂，但是前面说过： 浏览器端都有浏览器自动完成，我们无需操心 服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。 事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。 在leyou-gateway中编写一个配置类，并且注册CorsFilter： 1234567891011121314151617181920212223242526272829303132333435import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class GlobalCorsConfig &#123; @Bean public CorsFilter corsFilter() &#123; //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 config.addAllowedOrigin("http://manage.leyou.com"); //2) 是否发送Cookie信息 config.setAllowCredentials(true); //3) 允许的请求方式 config.addAllowedMethod("OPTIONS"); config.addAllowedMethod("HEAD"); config.addAllowedMethod("GET"); config.addAllowedMethod("PUT"); config.addAllowedMethod("POST"); config.addAllowedMethod("DELETE"); config.addAllowedMethod("PATCH"); // 4）允许的头信息 config.addAllowedHeader("*"); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration("/**", config); //3.返回新的CorsFilter. return new CorsFilter(configSource); &#125;&#125; 结构： 重启测试，访问正常： 分类的增删改功能暂时就不做了，页面已经预留好了事件接口，有兴趣的同学可以完成一下。 从0开始品牌的查询 商品分类完成以后，自然轮到了品牌功能了。 先看看我们要实现的效果： 接下来，我们从0开始，实现下从前端到后端的完整开发。 设计前端页面 为了方便看到效果，我们新建一个MyBrand.vue（注意先停掉服务器），从0开始搭建。 内容初始化一下： 12345678910111213141516&lt;template&gt; &lt;span&gt; hello &lt;/span&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;myBrand&quot; &#125;&lt;/script&gt;&lt;!-- scoped:当前样式只作用于当前组件的节点 --&gt;&lt;style scoped&gt;&lt;/style&gt; 改变router新的index.js，将路由地址指向MyBrand.vue 打开服务器，再次查看页面： 干干净净了。只剩hello 查询表格 大家看到这个原型页面肯定能看出，其主体就是一个table。我们去Vuetify查看有关table的文档： 仔细阅读，发现v-data-table中有以下核心属性： dark：是否使用黑暗色彩主题，默认是false expand：表格的行是否可以展开，默认是false headers：定义表头的数组，数组的每个元素就是一个表头信息对象，结构： 12345678&#123; text: string, // 表头的显示文本 value: string, // 表头对应的每行数据的key align: 'left' | 'center' | 'right', // 位置 sortable: boolean, // 是否可排序 class: string[] | string,// 样式 width: string,// 宽度&#125; items：表格的数据的数组，数组的每个元素是一行数据的对象，对象的key要与表头的value一致 loading：是否显示加载数据的进度条，默认是false no-data-text：当没有查询到数据时显示的提示信息，string类型，无默认值 pagination.sync：包含分页和排序信息的对象，将其与vue实例中的属性关联，表格的分页或排序按钮被触发时，会自动将最新的分页和排序信息更新。对象结构： 123456&#123; page: 1, // 当前页 rowsPerPage: 5, // 每页大小 sortBy: '', // 排序字段 descending:false, // 是否降序&#125; total-items：分页的总条数信息，number类型，无默认值 select-all ：是否显示每一行的复选框，Boolean类型，无默认值 value：当表格可选的时候，返回选中的行 我们向下翻，找找有没有看起来牛逼的案例。 找到这样一条： 其它的案例都是由Vuetify帮我们对查询到的当前页数据进行排序和分页，这显然不是我们想要的。我们希望能在服务端完成对整体品牌数据的排序和分页，而这个案例恰好合适。 点击按钮，我们直接查看源码，然后直接复制到MyBrand.vue中 模板： 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;desserts&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalDesserts&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.calories &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.fat &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.carbs &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.protein &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.iron &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/div&gt;&lt;/template&gt; 表格分析 接下来，就分析一下案例中每一部分是什么意思，搞清楚了，我们也可以自己玩了。 先看模板中table上的一些属性： 123456789&lt;v-data-table :headers=&quot;headers&quot; :items=&quot;desserts&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalDesserts&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt;&lt;/v-data-table&gt; headers：表头信息，是一个数组 items：要在表格中展示的数据，数组结构，每一个元素是一行。在这里应该是品牌集合 pagination.sync：分页信息，包含了当前页，每页大小，排序字段，排序方式等。加上.sync代表服务端排序，当用户点击分页条时，该对象的值会跟着变化。监控这个值，并在这个值变化时去服务端查询，即可实现页面数据动态加载了。 total-items：总条数，在这里是品牌的总记录数 loading：boolean类型，true：代表数据正在加载，会有进度条。false：数据加载完毕。 另外，在v-data-tables中，我们还看到另一段代码： 12345678&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.calories &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.fat &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.carbs &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.protein &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.iron &#125;&#125;&lt;/td&gt;&lt;/template&gt; 这段就是在渲染每一行的数据。Vue会自动遍历上面传递的items属性，并把得到的对象传递给这段template中的props.item属性。我们从中得到数据，渲染在页面即可。 我们需要做的事情，主要有两件： 给items和totalItems赋值 当pagination变化时，重新获取数据，再次给items和totalItems赋值 动手实现 表格中具体有哪些列呢？参照品牌表： 品牌中有id,name,image,letter字段。 修改模板 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img v-if=&quot;props.item.image&quot; :src=&quot;props.item.image&quot; width=&quot;130&quot; height=&quot;40&quot;/&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/div&gt;&lt;/template&gt; 我们修改了以下部分： items：指向一个brands变量，等下在js代码中定义 total-items：指向了totalBrands变量，等下在js代码中定义 template模板中，渲染了四个字段： id： name image，注意，我们不是以文本渲染，而是赋值到一个img标签的src属性中，并且做了非空判断 letter 编写数据模型 接下来编写要用到的数据： 1234567891011121314data () &#123; return &#123; totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ // 头信息 &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '名称', align: 'center', value: 'name', sortable: false&#125;, &#123;text: 'LOGO', align: 'center', value: 'image', sortable: false&#125;, &#123;text: '首字母', align: 'center', value: 'letter'&#125;, ] &#125;&#125; 数据初始化 接下来就是对brands和totalBrands完成赋值动作了。 我们编写一个函数来完成赋值，提高复用性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748methods: &#123; getDataFromServer()&#123; // 从服务端加载数据的函数 // 伪造演示数据 const brands = [ &#123; "id": 2032, "name": "OPPO", "image": "http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg", "letter": "O", "categories": null &#125;, &#123; "id": 2033, "name": "飞利浦（PHILIPS）", "image": "http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg", "letter": "F", "categories": null &#125;, &#123; "id": 2034, "name": "华为（HUAWEI）", "image": "http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg", "letter": "H", "categories": null &#125;, &#123; "id": 2036, "name": "酷派（Coolpad）", "image": "http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg", "letter": "K", "categories": null &#125;, &#123; "id": 2037, "name": "魅族（MEIZU）", "image": "http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg", "letter": "M", "categories": null &#125; ]; // 延迟一段时间，模拟数据请求时间 setTimeout(()=&gt;&#123; this.brands = brands; // 赋值给品牌数组 this.totalBrands = brands.length; // 赋值数据总条数 this.loading = false; // 数据加载完成 &#125;, 1000); &#125;&#125; 然后使用钩子函数，在Vue实例初始化完毕后调用这个方法，这里使用mounted（渲染后）函数： 1234// 渲染后执行mounted()&#123; this.getDataFromServer() // 调用数据初始化函数&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;template&gt; &lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img v-if=&quot;props.item.image&quot; :src=&quot;props.item.image&quot; width=&quot;130&quot; height=&quot;40&quot;/&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;myBrand&quot;, data () &#123; return &#123; totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ // 头信息 &#123;text: &apos;id&apos;, align: &apos;center&apos;, value: &apos;id&apos;&#125;, &#123;text: &apos;名称&apos;, align: &apos;center&apos;, value: &apos;name&apos;, sortable: false&#125;, &#123;text: &apos;LOGO&apos;, align: &apos;center&apos;, value: &apos;image&apos;, sortable: false&#125;, &#123;text: &apos;首字母&apos;, align: &apos;center&apos;, value: &apos;letter&apos;&#125;, ] &#125; &#125;, methods: &#123; getDataFromServer()&#123; // 从服务端加载数据的函数 // 伪造演示数据 const brands = [ &#123; &quot;id&quot;: 2032, &quot;name&quot;: &quot;OPPO&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg&quot;, &quot;letter&quot;: &quot;O&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2033, &quot;name&quot;: &quot;飞利浦（PHILIPS）&quot;, &quot;image&quot;: &quot;http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg&quot;, &quot;letter&quot;: &quot;F&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2034, &quot;name&quot;: &quot;华为（HUAWEI）&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg&quot;, &quot;letter&quot;: &quot;H&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2036, &quot;name&quot;: &quot;酷派（Coolpad）&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg&quot;, &quot;letter&quot;: &quot;K&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2037, &quot;name&quot;: &quot;魅族（MEIZU）&quot;, &quot;image&quot;: &quot;http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg&quot;, &quot;letter&quot;: &quot;M&quot;, &quot;categories&quot;: null &#125; ]; // 延迟一段时间，模拟数据请求时间 setTimeout(()=&gt;&#123; this.brands = brands; // 赋值给品牌数组 this.totalBrands = brands.length; // 赋值数据总条数 this.loading = false; // 数据加载完成 &#125;, 1000); &#125; &#125;, // 渲染后执行 mounted()&#123; this.getDataFromServer() // 调用数据初始化函数 &#125; &#125;&lt;/script&gt;&lt;!-- scoped:当前样式只作用于当前组件的节点 --&gt;&lt;style scoped&gt;&lt;/style&gt; 刷新页面查看： 优化页面 编辑和删除按钮 我们将来要对品牌进行增删改，需要给每一行数据添加 修改删除的按钮，一般放到改行的最后一列。 其实就是多了一列，只是这一列没有数据，而是两个按钮而已。可以在官方文档中找一个带有操作按钮的表格，作为参考。 我们先在头（headers）中添加一列： 1234567headers: [ // 头信息 &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '名称', align: 'center', value: 'name', sortable: false&#125;, &#123;text: 'LOGO', align: 'center', value: 'image', sortable: false&#125;, &#123;text: '首字母', align: 'center', value: 'letter'&#125;, &#123;text: '操作', align: 'center', value: 'id', sortable: false &#125;] 然后在模板中添加按钮： 1234567891011121314&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img v-if=&quot;props.item.image&quot; :src=&quot;props.item.image&quot; width=&quot;130&quot; height=&quot;40&quot;/&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt; &lt;v-icon small class=&quot;mr-2&quot; @click=&quot;editItem(props.item)&quot;&gt; edit &lt;/v-icon&gt; &lt;v-icon small @click=&quot;deleteItem(props.item)&quot;&gt; delete &lt;/v-icon&gt; &lt;/td&gt;&lt;/template&gt; 效果： 新增按钮 在官方文档中找到按钮的用法： 因为新增跟某个品牌无关，是独立的，因此我们可以放到表格的外面。 效果： 卡片（card） 为了不让按钮显得过于孤立，我们可以将按新增按钮和表格放到一张卡片（card）中。 我们去官网查看卡片的用法： 卡片v-card包含四个基本组件： v-card-media：一般放图片或视频 v-card-title：卡片的标题，一般位于卡片顶部 v-card-text：卡片的文本（主体内容），一般位于卡片正中 v-card-action：卡片的按钮，一般位于卡片底部 我们可以把新增的按钮放到v-card-title位置，把table放到下面，这样就成一个上下关系。 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;v-card&gt; &lt;v-card-title flat color=&quot;white&quot;&gt; &lt;v-btn color=&quot;primary&quot;&gt;新增&lt;/v-btn&gt; &lt;/v-card-title&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img v-if=&quot;props.item.image&quot; :src=&quot;props.item.image&quot; width=&quot;130&quot; height=&quot;40&quot;/&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt; &lt;v-icon small class=&quot;mr-2&quot; @click=&quot;editItem(props.item)&quot;&gt; edit &lt;/v-icon&gt; &lt;v-icon small @click=&quot;deleteItem(props.item)&quot;&gt; delete &lt;/v-icon&gt; &lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/v-card&gt;&lt;/template&gt; 效果： 添加搜索框 我们还可以在卡片头部添加一个搜索框，其实就是一个文本输入框。 查看官网中，文本框的用法： name：字段名，表单中会用到 label/placeholder：提示文字 value：值。可以用v-model代替，实现双向绑定 修改模板，添加输入框： 12345&lt;v-card-title&gt; &lt;v-btn color="primary"&gt;新增品牌&lt;/v-btn&gt; &lt;!--搜索框，与search属性关联--&gt; &lt;v-text-field label="输入关键字搜索" v-model="search"/&gt;&lt;/v-card-title&gt; 注意：要在数据模型中，添加search字段： 12345678910111213141516data() &#123; return &#123; totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 search: "", // 查询关键字 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ // 头信息 &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '名称', align: 'center', value: 'name', sortable: false&#125;, &#123;text: 'LOGO', align: 'center', value: 'image', sortable: false&#125;, &#123;text: '首字母', align: 'center', value: 'letter'&#125;, &#123;text: '操作', align: 'center', value: 'id', sortable: false&#125; ] &#125;&#125; 效果： 发现输入框超级长！！！ 这个时候，我们可以使用Vuetify提供的一个空间隔离工具： 修改代码： 1234567&lt;v-card-title&gt; &lt;v-btn color="primary"&gt;新增品牌&lt;/v-btn&gt; &lt;!--空间隔离组件--&gt; &lt;v-spacer /&gt; &lt;!--搜索框，与search属性关联--&gt; &lt;v-text-field label="输入关键字搜索" v-model="search"/&gt;&lt;/v-card-title&gt; 添加搜索图标 查看textfiled的文档，发现： 通过append-icon属性可以为 输入框添加后置图标，所有可用图标名称可以到 material-icons官网去查看。 修改我们的代码： 1&lt;v-text-field label="输入关键字搜索" v-model="search" append-icon="search"/&gt; 把文本框变紧凑 搜索框看起来高度比较高，页面不够紧凑。这其实是因为默认在文本框下面预留有错误提示空间。通过下面的属性可以取消提示： 修改代码： 1&lt;v-text-field label="输入关键字搜索" v-model="search" append-icon="search" hide-details/&gt; 效果： 几乎已经达到了原来一样的效果了吧！ 后台提供查询接口 前台页面已经准备好，接下来就是后台提供数据接口了。 数据库表 1234567CREATE TABLE `tb_brand` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;品牌id&apos;, `name` varchar(50) NOT NULL COMMENT &apos;品牌名称&apos;, `image` varchar(200) DEFAULT &apos;&apos; COMMENT &apos;品牌图片地址&apos;, `letter` char(1) DEFAULT &apos;&apos; COMMENT &apos;品牌的首字母&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=325400 DEFAULT CHARSET=utf8 COMMENT=&apos;品牌表，一个品牌下有多个商品（spu），一对多关系&apos;; 简单的四个字段，不多解释。 这里需要注意的是，品牌和商品分类之间是多对多关系。因此我们有一张中间表，来维护两者间关系： 12345CREATE TABLE `tb_category_brand` ( `category_id` bigint(20) NOT NULL COMMENT &apos;商品类目id&apos;, `brand_id` bigint(20) NOT NULL COMMENT &apos;品牌id&apos;, PRIMARY KEY (`category_id`,`brand_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;商品分类和品牌的中间表，两者是多对多关系&apos;; 但是，你可能会发现，这张表中并没有设置外键约束，似乎与数据库的设计范式不符。为什么这么做？ 外键会严重影响数据库读写的效率 数据删除时会比较麻烦 在电商行业，性能是非常重要的。我们宁可在代码中通过逻辑来维护表关系，也不设置外键。 实体类 12345678910@Table(name = "tb_brand")public class Brand &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name;// 品牌名称 private String image;// 品牌图片 private Character letter; // getter setter 略&#125; mapper 通用mapper来简化开发： 12public interface BrandMapper extends Mapper&lt;Brand&gt; &#123;&#125; controller 编写controller先思考四个问题，这次没有前端代码，需要我们自己来设定 请求方式：查询，肯定是Get 请求路径：分页查询，/brand/page 请求参数：根据我们刚才编写的页面，有分页功能，有排序功能，有搜索过滤功能，因此至少要有5个参数： page：当前页，int rows：每页大小，int sortBy：排序字段，String desc：是否为降序，boolean key：搜索关键词，String 响应结果：分页结果一般至少需要两个数据 total：总条数 items：当前页数据 totalPage：有些还需要总页数 这里我们封装一个类，来表示分页结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class PageResult&lt;T&gt; &#123; private Long total;// 总条数 private Long totalPage;// 总页数 private List&lt;T&gt; items;// 当前页数据 public PageResult() &#123; &#125; public PageResult(Long total, List&lt;T&gt; items) &#123; this.total = total; this.items = items; &#125; public PageResult(Long total, Long totalPage, List&lt;T&gt; items) &#123; this.total = total; this.totalPage = totalPage; this.items = items; &#125; public Long getTotal() &#123; return total; &#125; public void setTotal(Long total) &#123; this.total = total; &#125; public List&lt;T&gt; getItems() &#123; return items; &#125; public void setItems(List&lt;T&gt; items) &#123; this.items = items; &#125; public Long getTotalPage() &#123; return totalPage; &#125; public void setTotalPage(Long totalPage) &#123; this.totalPage = totalPage; &#125;&#125; 另外，这个PageResult以后可能在其它项目中也有需求，因此我们将其抽取到leyou-common中，提高复用性： 不要忘记在leyou-item-service工程的pom.xml中引入leyou-common的依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;leyou-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 接下来，我们编写Controller 123456789101112131415161718192021@RestController@RequestMapping("brand")public class BrandController &#123; @Autowired private BrandService brandService; @GetMapping("page") public ResponseEntity&lt;PageResult&lt;Brand&gt;&gt; queryBrandByPage( @RequestParam(value = "page", defaultValue = "1") Integer page, @RequestParam(value = "rows", defaultValue = "5") Integer rows, @RequestParam(value = "sortBy", required = false) String sortBy, @RequestParam(value = "desc", defaultValue = "false") Boolean desc, @RequestParam(value = "key", required = false) String key) &#123; PageResult&lt;Brand&gt; result = this.brandService.queryBrandByPageAndSort(page,rows,sortBy,desc, key); if (result == null || result.getItems().size() == 0) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(result); &#125;&#125; Service 123456789101112131415161718192021222324252627@Servicepublic class BrandService &#123; @Autowired private BrandMapper brandMapper; public PageResult&lt;Brand&gt; queryBrandByPageAndSort( Integer page, Integer rows, String sortBy, Boolean desc, String key) &#123; // 开始分页 PageHelper.startPage(page, rows); // 过滤 Example example = new Example(Brand.class); if (StringUtils.isNotBlank(key)) &#123; example.createCriteria().andLike("name", "%" + key + "%") .orEqualTo("letter", key); &#125; if (StringUtils.isNotBlank(sortBy)) &#123; // 排序 String orderByClause = sortBy + (desc ? " DESC" : " ASC"); example.setOrderByClause(orderByClause); &#125; // 查询 Page&lt;Brand&gt; pageInfo = (Page&lt;Brand&gt;) brandMapper.selectByExample(example); // 返回结果 return new PageResult&lt;&gt;(pageInfo.getTotal(), pageInfo); &#125;&#125; 测试 通过浏览器访问试试：http://api.leyou.com/api/item/brand/page 接下来，去页面请求数据并渲染 异步查询工具axios 异步查询数据，自然是通过ajax查询，大家首先想起的肯定是jQuery。但jQuery与MVVM的思想不吻合，而且ajax只是jQuery的一小部分。因此不可能为了发起ajax请求而去引用这么大的一个库。 axios入门 Vue官方推荐的ajax请求框架叫做：axios，看下demo： axios的Get请求语法： 123456789101112131415axios.get("/item/category/list?pid=0") // 请求路径和请求参数拼接 .then(function(resp)&#123; // 成功回调函数 &#125;) .catch(function()&#123; // 失败回调函数 &#125;)// 参数较多时，可以通过params来传递参数axios.get("/item/category/list", &#123; params:&#123; pid:0 &#125; &#125;) .then(function(resp)&#123;&#125;)// 成功时的回调 .catch(function(error)&#123;&#125;)// 失败时的回调 axios的POST请求语法： 比如新增一个用户 123456axios.post("/user",&#123; name:"Jack", age:21 &#125;) .then(function(resp)&#123;&#125;) .catch(function(error)&#123;&#125;) 注意，POST请求传参，不需要像GET请求那样定义一个对象，在对象的params参数中传参。post()方法的第二个参数对象，就是将来要传递的参数 PUT和DELETE请求与POST请求类似 axios的全局配置 而在我们的项目中，已经引入了axios，并且进行了简单的封装，在src下的http.js中： http.js中对axios进行了一些默认配置： 12345678import Vue from 'vue'import axios from 'axios'import config from './config'// config中定义的基础路径是：http://api.leyou.com/apiaxios.defaults.baseURL = config.api; // 设置axios的基础请求路径axios.defaults.timeout = 2000; // 设置axios的请求时间Vue.prototype.$http = axios;// 将axios赋值给Vue原型的$http属性，这样所有vue实例都可使用该对象 http.js中导入了config的配置，还记得吗？ http.js对axios进行了全局配置：baseURL=config.api，即http://api.leyou.com/api。因此以后所有用axios发起的请求，都会以这个地址作为前缀。 通过Vue.property.$http = axios，将axios赋值给了 Vue原型中的$http。这样以后所有的Vue实例都可以访问到$http，也就是访问到了axios了。 小试一下 我们在组件MyBrand.vue的getDataFromServer方法，通过$http发起get请求，测试查询品牌的接口，看是否能获取到数据： 网络监视： resp到底都有那些数据，查看控制台结果： 可以看到，在请求成功的返回结果response中，有一个data属性，里面就是真正的响应数据。 响应结果中与我们设计的一致，包含3个内容： total：总条数，目前是165 items：当前页数据 totalPage：总页数，我们没有返回 异步加载品牌数据 虽然已经通过ajax请求获取了品牌数据，但是刚才的请求没有携带任何参数，这样显然不对。我们后端接口需要5个参数： page：当前页，int rows：每页大小，int sortBy：排序字段，String desc：是否为降序，boolean key：搜索关键词，String 而页面中分页信息应该是在pagination对象中，我们通过浏览器工具，查看pagination中有哪些属性： 分别是： descending：是否是降序，对应请求参数的desc page：当前页，对应参数的page rowsPerpage：每页大小，对应参数中的rows sortBy：排序字段，对应参数的sortBy 缺少一个搜索关键词，这个应该是通过v-model与输入框绑定的属性：search。这样，所有参数就都有了。 另外，不要忘了把查询的结果赋值给brands和totalBrands属性，Vuetify会帮我们渲染页面。 接下来，我们完善请求参数： 12345678910111213141516171819methods: &#123; getDataFromServer() &#123; // 从服务端加载数据的函数 this.loading = true; // 加载数据 // 通过axios获取数据 this.$http.get("/item/brand/page", &#123; params: &#123; page: this.pagination.page, // 当前页 rows: this.pagination.rowsPerPage, // 每页条数 sortBy: this.pagination.sortBy, // 排序字段 desc: this.pagination.descending, // 是否降序 key: this.search // 查询字段 &#125; &#125;).then(resp =&gt; &#123; // 获取响应结果对象 this.totalBrands = resp.data.total; // 总条数 this.brands = resp.data.items; // 品牌数据 this.loading = false; // 加载完成 &#125;); &#125;&#125; 查看网络请求： 效果： 完成分页和过滤 分页 现在我们实现了页面加载时的第一次查询，你会发现你点击分页或搜索不会发起新的请求，怎么办？ 虽然点击分页，不会发起请求，但是通过浏览器工具查看，会发现pagination对象的属性一直在变化： 我们可以利用Vue的监视功能：watch，当pagination发生改变时，会调用我们的回调函数，我们在回调函数中进行数据的查询即可！ 具体实现： 成功实现分页功能： 过滤 分页实现了，过滤也很好实现了。过滤字段对应的是search属性，我们只要监视这个属性即可: 查看网络请求： 页面结果： 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;template&gt; &lt;v-card&gt; &lt;v-card-title flat color=&quot;white&quot;&gt; &lt;v-btn color=&quot;primary&quot;&gt;新增&lt;/v-btn&gt; &lt;!--空间隔离组件--&gt; &lt;v-spacer /&gt; &lt;!--搜索框，与search属性关联--&gt; &lt;v-text-field label=&quot;输入关键字搜索&quot; append-icon=&quot;search&quot; v-model=&quot;search&quot; hide-details/&gt; &lt;/v-card-title&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img v-if=&quot;props.item.image&quot; :src=&quot;props.item.image&quot; width=&quot;130&quot; height=&quot;40&quot;/&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt; &lt;v-icon small class=&quot;mr-2&quot; @click=&quot;editItem(props.item)&quot;&gt; edit &lt;/v-icon&gt; &lt;v-icon small @click=&quot;deleteItem(props.item)&quot;&gt; delete &lt;/v-icon&gt; &lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/v-card&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;myBrand&quot;, data() &#123; return &#123; totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 search: &quot;&quot;, // 查询关键字 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ // 头信息 &#123;text: &apos;id&apos;, align: &apos;center&apos;, value: &apos;id&apos;&#125;, &#123;text: &apos;名称&apos;, align: &apos;center&apos;, value: &apos;name&apos;, sortable: false&#125;, &#123;text: &apos;LOGO&apos;, align: &apos;center&apos;, value: &apos;image&apos;, sortable: false&#125;, &#123;text: &apos;首字母&apos;, align: &apos;center&apos;, value: &apos;letter&apos;&#125;, &#123;text: &apos;操作&apos;, align: &apos;center&apos;, value: &apos;id&apos;, sortable: false&#125; ] &#125; &#125;, watch: &#123; pagination:&#123; deep: true, // 深度监视 handler()&#123; this.getDataFromServer(); &#125; &#125;, search()&#123; this.pagination.page = 1; this.getDataFromServer(); &#125; &#125;, methods: &#123; getDataFromServer() &#123; // 从服务端加载数据的函数 this.loading = true; // 加载数据 // 通过axios获取数据 this.$http.get(&quot;/item/brand/page&quot;, &#123; params: &#123; page: this.pagination.page, // 当前页 rows: this.pagination.rowsPerPage, // 每页条数 sortBy: this.pagination.sortBy, // 排序字段 desc: this.pagination.descending, // 是否降序 key: this.search // 查询字段 &#125; &#125;).then(resp =&gt; &#123; // 获取响应结果对象 this.totalBrands = resp.data.total; // 总条数 this.brands = resp.data.items; // 品牌数据 this.loading = false; // 加载完成 &#125;); &#125; &#125;, // 渲染后执行 mounted() &#123; this.getDataFromServer() // 调用数据初始化函数 &#125; &#125;&lt;/script&gt;&lt;!-- scoped:当前样式只作用于当前组件的节点 --&gt;&lt;style scoped&gt;&lt;/style&gt; 大家下去可以尝试实现品牌的增删改功能]]></content>
  </entry>
  <entry>
    <title><![CDATA[day05-vue入门]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F27%2Fday05-vue%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学习目标 会创建Vue实例，知道Vue的常见属性 会使用Vue的生命周期的钩子函数 会使用vue常见指令 会使用vue计算属性和watch监控 会编写Vue组件 掌握组件间通信 了解vue-router使用 了解webpack使用 会使用vue-cli搭建项目 前言 前几天我们已经对后端的技术栈有了初步的了解、并且已经搭建了整个后端微服务的平台。接下来要做的事情就是功能开发了。但是没有前端页面，我们肯定无从下手，因此今天我们就要来了解一下前端的一些技术，完成前端页面搭建。 先聊一下前端开发模式的发展。 静态页面 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务端到客户端单向流通。开发人员也只关心页面的样式和内容即可。 异步刷新，操作DOM 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言. 随着JavaScript的诞生，我们可以操作页面的DOM元素及样式，页面有了一些动态的效果，但是依然是以静态为主。 ajax盛行： 2005年开始，ajax逐渐被前端开发人员所重视，因为不用刷新页面就可以更新页面的数据和渲染效果。 此时的开发人员不仅仅要编写HTML样式，还要懂ajax与后端交互，然后通过JS操作Dom元素来实现页面动态效果。比较流行的框架如Jquery就是典型代表。 MVVM，关注模型和视图 2008年，google的Chrome发布，随后就以极快的速度占领市场，超过IE成为浏览器市场的主导者。 2009年，Ryan Dahl在谷歌的Chrome V8引擎基础上，打造了基于事件循环的异步IO框架：Node.js。 基于事件循环的异步IO 单线程运行，避免多线程的变量同步问题 JS可以编写后台代码，前后台统一编程语言 node.js的伟大之处不在于让JS迈向了后端开发，而是构建了一个庞大的生态系统。 2010年，NPM作为node.js的包管理系统首次发布，开发人员可以遵循Common.js规范来编写Node.js模块，然后发布到NPM上供其他开发人员使用。目前已经是世界最大的包模块管理系统。 随后，在node的基础上，涌现出了一大批的前端框架： MVVM模式 M：即Model，模型，包括数据和一些基本操作 V：即View，视图，页面渲染结果 VM：即View-Model，模型与视图间的双向操作（无需开发人员干涉） 在MVVM之前，开发人员从后端获取需要的数据模型，然后要通过DOM操作Model渲染到View中。而后当用户操作视图，我们还需要通过DOM获取View中的数据，然后同步到Model中。 而MVVM中的VM要做的事情就是把DOM操作完全封装起来，开发人员不用再关心Model和View之间是如何互相影响的： 只要我们Model发生了改变，View上自然就会表现出来。 当用户修改了View，Model中的数据也会跟着改变。 把开发人员从繁琐的DOM操作中解放出来，把关注点放在如何操作Model上。 而我们今天要学习的，就是一款MVVM模式的框架：Vue 认识Vue Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 ​ 前端框架三巨头：Vue.js、React.js、AngularJS，vue.js以其轻量易用著称，vue.js和React.js发展速度最快，AngularJS还是老大。 官网：https://cn.vuejs.org/ 参考：https://cn.vuejs.org/v2/guide/ Git地址：https://github.com/vuejs 尤雨溪，Vue.js 创作者，Vue Technology创始人，致力于Vue的研究开发。 Node和NPM 前面说过，NPM是Node提供的模块管理工具，可以非常方便的下载安装很多前端框架，包括Jquery、AngularJS、VueJs都有。为了后面学习方便，我们先安装node及NPM工具。 下载Node.js 下载地址：https://nodejs.org/en/ 推荐下载LTS版本。 课程中采用的是8.11.3版本。也是目前最新的。大家自行下载或者使用课前资料中提供的安装包。然后下一步安装即可。 完成以后，在控制台输入： 1node -v 看到版本信息： NPM Node自带了NPM了，在控制台输入npm -v查看： npm默认的仓库地址是在国外网站，速度较慢，建议大家设置到淘宝镜像。但是切换镜像是比较麻烦的。推荐一款切换镜像的工具：nrm 我们首先安装nrm，这里-g代表全局安装。可能需要一点儿时间 1npm install nrm -g 然后通过nrm ls命令查看npm的仓库列表,带*的就是当前选中的镜像仓库： 通过nrm use taobao来指定要使用的镜像源： 然后通过nrm test npm来测试速度： 注意： 有教程推荐大家使用cnpm命令，但是使用发现cnpm有时会有bug，不推荐。 安装完成请一定要重启下电脑！！！ 安装完成请一定要重启下电脑！！！ 安装完成请一定要重启下电脑！！！ 快速入门 接下来，我们快速领略下vue的魅力 创建工程 创建一个新的空工程： 然后新建一个module： 选中static web，静态web项目： 位置信息： 安装vue 下载安装 下载地址：https://github.com/vuejs/vue 可以下载2.5.16版本https://github.com/vuejs/vue/archive/v2.5.16.zip 下载解压，得到vue.js文件。 使用CDN 或者也可以直接使用公共的CDN服务： 12&lt;!-- 开发环境版本，包含了用帮助的命令行警告 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; 或者： 12&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt; 推荐npm安装 在idea的左下角，有个Terminal按钮，点击打开控制台： 进入hello-vue目录，先输入：npm init -y 进行初始化 安装Vue，输入命令：npm install vue --save 然后就会在hello-vue目录发现一个node_modules目录，并且在下面有一个vue目录。 node_modules是通过npm安装的所有模块的默认位置。 vue入门案例 HTML模板 在hello-vue目录新建一个HTML 在hello.html中，我们编写一段简单的代码： h2中要输出一句话：xx 非常帅。前面的xx是要渲染的数据。 vue声明式渲染 然后我们通过Vue进行渲染： 12345678910111213141516&lt;body&gt; &lt;div id="app"&gt; &lt;h2&gt;&#123;&#123;name&#125;&#125;，非常帅！！！&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="node_modules/vue/dist/vue.js" &gt;&lt;/script&gt;&lt;script&gt; // 创建vue实例 var app = new Vue(&#123; el:"#app", // el即element，该vue实例要渲染的页面元素 data:&#123; // 渲染页面需要的数据 name: "峰哥" &#125; &#125;);&lt;/script&gt; 首先通过 new Vue()来创建Vue实例 然后构造函数接收一个对象，对象中有一些属性： el：是element的缩写，通过id选中要渲染的页面元素，本例中是一个div data：数据，数据是一个对象，里面有很多属性，都可以渲染到视图中 name：这里我们指定了一个name属性 页面中的h2元素中，我们通过的方式，来渲染刚刚定义的name属性。 打开页面查看效果： 更神奇的在于，当你修改name属性时，页面会跟着变化： 双向绑定 我们对刚才的案例进行简单修改： 1234567891011121314151617181920&lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-model="num"&gt; &lt;h2&gt; &#123;&#123;name&#125;&#125;，非常帅！！！有&#123;&#123;num&#125;&#125;位女神为他着迷。 &lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="node_modules/vue/dist/vue.js" &gt;&lt;/script&gt;&lt;script&gt; // 创建vue实例 var app = new Vue(&#123; el: "#app", // el即element，该vue实例要渲染的页面元素 data: &#123; // 渲染页面需要的数据 name: "峰哥", num: 5 &#125; &#125;);&lt;/script&gt; 我们在data添加了新的属性：num 在页面中有一个input元素，通过v-model与num进行绑定。 同时通过在页面输出 效果： 我们可以观察到，输入框的变化引起了data中的num的变化，同时页面输出也跟着变化。 input与num绑定，input的value值变化，影响到了data中的num值 页面与数据num绑定，因此num值变化，引起了页面效果变化。 没有任何dom操作，这就是双向绑定的魅力。 事件处理 我们在页面添加一个按钮： 1&lt;button v-on:click="num++"&gt;点我&lt;/button&gt; 这里用v-on指令绑定点击事件，而不是普通的onclick，然后直接操作num 普通click是无法直接操作num的。 效果： Vue实例 创建Vue实例 每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的： 123var vm = new Vue(&#123; // 选项&#125;) 在构造函数中传入一个对象，并且在对象中声明各种Vue需要的数据和方法，包括： el data methods 等等 接下来我们一 一介绍。 模板或元素 每个Vue实例都需要关联一段Html模板，Vue会基于此模板进行视图渲染。 我们可以通过el属性来指定。 例如一段html模板： 123&lt;div id="app"&gt; &lt;/div&gt; 然后创建Vue实例，关联这个div 123var vm = new Vue(&#123; el:"#app"&#125;) 这样，Vue就可以基于id为app的div元素作为模板进行渲染了。在这个div范围以外的部分是无法使用vue特性的。 数据 当Vue实例被创建时，它会尝试获取在data中定义的所有属性，用于视图的渲染，并且监视data中的属性变化，当data发生改变，所有相关的视图都将重新渲染，这就是“响应式“系统。 html： 123&lt;div id="app"&gt; &lt;input type="text" v-model="name"/&gt;&lt;/div&gt; js: 123456var vm = new Vue(&#123; el:"#app", data:&#123; name:"刘德华" &#125;&#125;) name的变化会影响到input的值 input中输入的值，也会导致vm中的name发生改变 方法 Vue实例中除了可以定义data属性，也可以定义方法，并且在Vue实例的作用范围内使用。 html: 1234&lt;div id="app"&gt; &#123;&#123;num&#125;&#125; &lt;button v-on:click="add"&gt;加&lt;/button&gt;&lt;/div&gt; js: 123456789101112var vm = new Vue(&#123; el:"#app", data:&#123; num: 0 &#125;, methods:&#123; add:function()&#123; // this代表的当前vue实例 this.num++; &#125; &#125;&#125;) 生命周期钩子 生命周期 每个 Vue 实例在被创建时都要经过一系列的初始化过程 ：创建实例，装载模板，渲染模板等等。Vue为生命周期中的每个状态都设置了钩子函数（监听函数）。每当Vue实例处于不同的生命周期时，对应的函数就会被触发调用。 生命周期： 钩子函数 beforeCreated：我们在用Vue时都要进行实例化，因此，该函数就是在Vue实例化是调用，也可以将他理解为初始化函数比较方便一点，在Vue1.0时，这个函数的名字就是init。 created：在创建实例之后进行调用。 beforeMount：页面加载完成，没有渲染。如：此时页面还是 mounted：我们可以将他理解为原生js中的window.onload=function({.,.}),或许大家也在用jquery，所以也可以理解为jquery中的$(document).ready(function(){….})，他的功能就是：在dom文档渲染完毕之后将要执行的函数，该函数在Vue1.0版本中名字为compiled。 此时页面中的已被渲染成峰哥 beforeDestroy：该函数将在销毁实例前进行调用 。 destroyed：改函数将在销毁实例时进行调用。 beforeUpdate：组件更新之前。 updated：组件更新之后。 例如：created代表在vue实例创建后； 我们可以在Vue中定义一个created函数，代表这个时期的钩子函数： 12345678910111213141516// 创建vue实例var app = new Vue(&#123; el: "#app", // el即element，该vue实例要渲染的页面元素 data: &#123; // 渲染页面需要的数据 name: "峰哥", num: 5 &#125;, methods: &#123; add: function()&#123; this.num--; &#125; &#125;, created: function () &#123; this.num = 100; &#125;&#125;); 结果： this 我们可以看下在vue内部的this变量是谁，我们在created的时候，打印this 123456methods: &#123; add: function()&#123; this.num--; console.log(this); &#125;&#125;, 控制台的输出： 指令 什么是指令？ 指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的预期值是：单个 JavaScript 表达式。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 例如我们在入门案例中的v-on，代表绑定事件。 插值表达式 花括号 格式： 1&#123;&#123;表达式&#125;&#125; 说明： 该表达式支持JS语法，可以调用js内置函数（必须有返回值） 表达式必须有返回结果。例如 1 + 1，没有结果的表达式不允许使用，如：var a = 1 + 1; 可以直接获取Vue实例中定义的数据或函数 示例： HTML： 1&lt;div id="app"&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; JS: 123456var app = new Vue(&#123; el:"#app", data:&#123; name:"Jack" &#125;&#125;) 插值闪烁 使用{{ }}方式在网速较慢时会出现问题。在数据未加载完成时，页面会显示出原始的{{ }}，加载完毕后才显示正确数据，我们称为插值闪烁。 我们将网速调慢一些，然后试试看刚才的案例： 刷新页面： v-text和v-html 使用v-text和v-html指令来替代{{ }} 说明： v-text：将数据输出到元素内部，如果输出的数据有HTML代码，会作为普通文本输出 v-html：将数据输出到元素内部，如果输出的数据有HTML代码，会被渲染 示例： HTML: 1234&lt;div id="app"&gt; v-text:&lt;span v-text="hello"&gt;&lt;/span&gt; &lt;br/&gt; v-html:&lt;span v-html="hello"&gt;&lt;/span&gt;&lt;/div&gt; JS: 123456var vm = new Vue(&#123; el:"#app", data:&#123; hello: "&lt;h1&gt;大家好，我是峰哥&lt;/h1&gt;" &#125;&#125;) 效果： 并且不会出现插值闪烁，当没有数据时，会显示空白。 v-model 刚才的v-text和v-html可以看做是单向绑定，数据影响了视图渲染，但是反过来就不行。接下来学习的v-model是双向绑定，视图（View）和模型（Model）之间会互相影响。 既然是双向绑定，一定是在视图中可以修改数据，这样就限定了视图的元素类型。目前v-model的可使用元素有： input select textarea checkbox radio components（Vue中的自定义组件） 基本上除了最后一项，其它都是表单的输入项。 举例： html： 1234567891011121314151617&lt;div id="app"&gt; &lt;input type="checkbox" v-model="language" value="Java" /&gt;Java&lt;br/&gt; &lt;input type="checkbox" v-model="language" value="PHP" /&gt;PHP&lt;br/&gt; &lt;input type="checkbox" v-model="language" value="Swift" /&gt;Swift&lt;br/&gt; &lt;h1&gt; 你选择了：&#123;&#123;language.join(',')&#125;&#125; &lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app", data:&#123; language: [] &#125; &#125;)&lt;/script&gt; 多个CheckBox对应一个model时，model的类型是一个数组，单个checkbox值默认是boolean类型 radio对应的值是input的value值 input 和textarea 默认对应的model是字符串 select单选对应字符串，多选对应也是数组 效果： v-on 基本用法 v-on指令用于给页面元素绑定事件。 语法： 1v-on:事件名=&quot;js片段或函数名&quot; 示例： 123456789101112131415161718192021&lt;div id="app"&gt; &lt;!--事件中直接写js片段--&gt; &lt;button v-on:click="num++"&gt;增加一个&lt;/button&gt;&lt;br/&gt; &lt;!--事件指定一个回调函数，必须是Vue实例中定义的函数--&gt; &lt;button v-on:click="decrement"&gt;减少一个&lt;/button&gt;&lt;br/&gt; &lt;h1&gt;有&#123;&#123;num&#125;&#125;个女神迷恋峰哥&lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el:"#app", data:&#123; num:100 &#125;, methods:&#123; decrement()&#123; this.num--; &#125; &#125; &#125;)&lt;/script&gt; 效果： 另外，事件绑定可以简写，例如v-on:click=&#39;add&#39;可以简写为@click=&#39;add&#39; 事件修饰符 在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。修饰符是由点开头的指令后缀来表示的。 .stop ：阻止事件冒泡到父元素 .prevent：阻止默认事件发生 .capture：使用事件捕获模式 .self：只有元素自身触发事件才执行。（冒泡或捕获的都不执行） .once：只执行一次 阻止默认事件 123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;!--右击事件，并阻止默认事件发生--&gt; &lt;button v-on:contextmenu.prevent="num++"&gt;增加一个&lt;/button&gt; &lt;br/&gt; &lt;!--右击事件，不阻止默认事件发生--&gt; &lt;button v-on:contextmenu="decrement($event)"&gt;减少一个&lt;/button&gt; &lt;br/&gt; &lt;h1&gt;有&#123;&#123;num&#125;&#125;个女神迷恋峰哥&lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; num: 100 &#125;, methods: &#123; decrement(ev) &#123; // ev.preventDefault(); this.num--; &#125; &#125; &#125;)&lt;/script&gt; 效果：（右键“增加一个”，不会触发默认的浏览器右击事件；右键“减少一个”，会触发默认的浏览器右击事件） 按键修饰符 在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符： 12&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.13="submit"&gt; 记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名： 12345&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter="submit"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter="submit"&gt; 全部的按键别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 组合按钮 可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift 例如： 12345&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67="clear"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl="doSomething"&gt;Do something&lt;/div&gt; v-for 遍历数据渲染页面是非常常用的需求，Vue中通过v-for指令来实现。 遍历数组 语法： 1v-for=&quot;item in items&quot; items：要遍历的数组，需要在vue的data中定义好。 item：迭代得到的数组元素的别名 示例 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="user in users"&gt; &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.gender&#125;&#125; - &#123;&#123;user.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; users:[ &#123;name:'柳岩', gender:'女', age: 21&#125;, &#123;name:'峰哥', gender:'男', age: 18&#125;, &#123;name:'范冰冰', gender:'女', age: 24&#125;, &#123;name:'刘亦菲', gender:'女', age: 18&#125;, &#123;name:'古力娜扎', gender:'女', age: 25&#125; ] &#125;, &#125;)&lt;/script&gt; 效果： 数组角标 在遍历的过程中，如果我们需要知道数组角标，可以指定第二个参数： 语法 1v-for=&quot;(item,index) in items&quot; items：要迭代的数组 item：迭代得到的数组元素别名 index：迭代到的当前元素索引，从0开始。 示例 12345&lt;ul&gt; &lt;li v-for="(user, index) in users"&gt; &#123;&#123;index + 1&#125;&#125;. &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.gender&#125;&#125; - &#123;&#123;user.age&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 效果： 遍历对象 v-for除了可以迭代数组，也可以迭代对象。语法基本类似 语法： 123v-for="value in object"v-for="(value,key) in object"v-for="(value,key,index) in object" 1个参数时，得到的是对象的属性 2个参数时，第一个是属性，第二个是键 3个参数时，第三个是索引，从0开始 示例： 12345678910111213141516&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="(value, key, index) in user"&gt; &#123;&#123;index + 1&#125;&#125;. &#123;&#123;key&#125;&#125; - &#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app", data:&#123; user:&#123;name:'峰哥', gender:'男', age: 18&#125; &#125; &#125;)&lt;/script&gt; 效果： key 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 这个功能可以有效的提高渲染的效率。 但是要实现这个功能，你需要给Vue一些提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id。 示例： 123&lt;ul&gt; &lt;li v-for="(item,index) in items" :key=index&gt;&lt;/li&gt;&lt;/ul&gt; 这里使用了一个特殊语法：:key=&quot;&quot; 我们后面会讲到，它可以让你读取vue中的属性，并赋值给key属性 这里我们绑定的key是数组的索引，应该是唯一的 v-if和v-show 基本使用 v-if，顾名思义，条件判断。当得到结果为true时，所在的元素才会被渲染。 语法： 1v-if=&quot;布尔表达式&quot; 示例： 12345678910111213141516171819&lt;div id="app"&gt; &lt;button v-on:click="show = !show"&gt;点我呀&lt;/button&gt; &lt;br&gt; &lt;h1 v-if="show"&gt; 看到我啦？！ &lt;/h1&gt; &lt;h1 v-show="show"&gt; 看到我啦？！show &lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; show: true &#125; &#125;)&lt;/script&gt; 效果： 与v-for结合 当v-if和v-for出现在一起时，v-for优先级更高。也就是说，会先遍历，再判断条件。 修改v-for中的案例，添加v-if： 12345&lt;ul&gt; &lt;li v-for="(user, index) in users" v-if="user.gender == '女'"&gt; &#123;&#123;index + 1&#125;&#125;. &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.gender&#125;&#125; - &#123;&#123;user.age&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 效果： 只显示女性用户信息 v-else 你可以使用 v-else 指令来表示 v-if 的“else 块”： 12345678&lt;div id="app"&gt; &lt;h1 v-if="Math.random() &gt; 0.5"&gt; 看到我啦？！if &lt;/h1&gt; &lt;h1 v-else&gt; 看到我啦？！else &lt;/h1&gt;&lt;/div&gt; v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。 v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用： 123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;button v-on:click="random=Math.random()"&gt;点我呀&lt;/button&gt;&lt;span&gt;&#123;&#123;random&#125;&#125;&lt;/span&gt; &lt;h1 v-if="random &gt;= 0.75"&gt; 看到我啦？！if &lt;/h1&gt; &lt;h1 v-else-if="random &gt; 0.5"&gt; 看到我啦？！if 0.5 &lt;/h1&gt; &lt;h1 v-else-if="random &gt; 0.25"&gt; 看到我啦？！if 0.25 &lt;/h1&gt; &lt;h1 v-else&gt; 看到我啦？！else &lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; random: 1 &#125; &#125;)&lt;/script&gt; 类似于 v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后。 演示： v-show 另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样： 1&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt; 不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。 示例： 12345678910111213141516&lt;div id="app"&gt; &lt;!--事件中直接写js片段--&gt; &lt;button v-on:click="show = !show"&gt;点击切换&lt;/button&gt;&lt;br/&gt; &lt;h1 v-if="show"&gt; 你好 &lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el:"#app", data:&#123; show:true &#125; &#125;)&lt;/script&gt; 代码： v-bind html属性不能使用双大括号形式绑定，只能使用v-bind指令。 在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 12345678910111213&lt;div id="app"&gt; &lt;!--可以是数据模型，可以是具有返回值的js代码块或者函数--&gt; &lt;div v-bind:title="title" style="border: 1px solid red; width: 50px; height: 50px;"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; title: "title", &#125; &#125;)&lt;/script&gt; 效果： 在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 绑定class样式 数组语法 我们可以借助于v-bind指令来实现： HTML： 123456789101112131415&lt;div id="app"&gt; &lt;div v-bind:class="activeClass"&gt;&lt;/div&gt; &lt;div v-bind:class="errorClass"&gt;&lt;/div&gt; &lt;div v-bind:class="[activeClass, errorClass]"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; activeClass: 'active', errorClass: ['text-danger', 'text-error'] &#125; &#125;)&lt;/script&gt; 渲染后的效果：（具有active和hasError的样式） 对象语法 我们可以传给 v-bind:class 一个对象，以动态地切换 class： 1&lt;div v-bind:class="&#123; active: isActive &#125;"&gt;&lt;/div&gt; 上面的语法表示 active 这个 class 存在与否将取决于数据属性 isActive 的 truthiness（所有的值都是真实的，除了false,0,“”,null,undefined和NaN）。 你可以在对象中传入更多属性来动态切换多个 class。此外，v-bind:class 指令也可以与普通的 class 属性共存。如下模板: 123&lt;div class="static" v-bind:class="&#123; active: isActive, 'text-danger': hasError &#125;"&gt;&lt;/div&gt; 和如下 data： 1234data: &#123; isActive: true, hasError: false&#125; 结果渲染为： 1&lt;div class="static active"&gt;&lt;/div&gt; active样式和text-danger样式的存在与否，取决于isActive和hasError的值。本例中isActive为true，hasError为false，所以active样式存在，text-danger不存在。 通常情况下，绑定的数据对象不必内联定义在模板里： 1&lt;div class="static" v-bind:class="classObject"&gt;&lt;/div&gt; 数据： 123456data: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125; 效果和之前一样： 1&lt;div class="static active"&gt;&lt;/div&gt; 绑定style样式 数组语法 数组语法可以将多个样式对象应用到同一个元素上： 1&lt;div v-bind:style="[baseStyles, overridingStyles]"&gt;&lt;/div&gt; 数据： 1234data: &#123; baseStyles: &#123;'background-color': 'red'&#125;, overridingStyles: &#123;border: '1px solid black'&#125;&#125; 渲染后的结果： 1&lt;div style="background-color: red; border: 1px solid black;"&gt;&lt;/div&gt; 对象语法 v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名： 1&lt;div v-bind:style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;&lt;/div&gt; 数据： 1234data: &#123; activeColor: 'red', fontSize: 30&#125; 效果： 1&lt;div style="color: red; font-size: 30px;"&gt;&lt;/div&gt; 直接绑定到一个样式对象通常更好，这会让模板更清晰： 1&lt;div v-bind:style="styleObject"&gt;&lt;/div&gt; 123456data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;&#125; 效果同上。 简写 v-bind:class可以简写为:class 计算属性 在插值表达式中使用js表达式是非常方便的，而且也经常被用到。 但是如果表达式的内容很长，就会显得不够优雅，而且后期维护起来也不方便，例如下面的场景，我们有一个日期的数据，但是是毫秒值： 123data:&#123; birthday:1529032123201 // 毫秒值&#125; 我们在页面渲染，希望得到yyyy-MM-dd的样式： 1234&lt;h1&gt;您的生日是：&#123;&#123; new Date(birthday).getFullYear() + '-'+ new Date(birthday).getMonth()+ '-' + new Date(birthday).getDay() &#125;&#125;&lt;/h1&gt; 虽然能得到结果，但是非常麻烦。 Vue中提供了计算属性，来替代复杂的表达式： 123456789101112var vm = new Vue(&#123; el:"#app", data:&#123; birthday:1429032123201 // 毫秒值 &#125;, computed:&#123; birth()&#123;// 计算属性本质是一个方法，但是必须返回结果 const d = new Date(this.birthday); return d.getFullYear() + "-" + d.getMonth() + "-" + d.getDay(); &#125; &#125;&#125;) 计算属性本质就是方法，但是一定要返回数据。然后页面渲染时，可以把这个方法当成一个变量来使用。 页面使用： 123&lt;div id="app"&gt; &lt;h1&gt;您的生日是：&#123;&#123;birth&#125;&#125; &lt;/h1&gt;&lt;/div&gt; 效果： 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要birthday还没有发生改变，多次访问 birthday 计算属性会立即返回之前的计算结果，而不必再次执行函数。 watch watch可以让我们监控一个值的变化。从而做出相应的反应。 示例： 1234567891011121314151617&lt;div id="app"&gt; &lt;input type="text" v-model="message"&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app", data:&#123; message:"" &#125;, watch:&#123; message(newVal, oldVal)&#123; console.log(newVal, oldVal); &#125; &#125; &#125;)&lt;/script&gt; 效果： 组件化 在大型应用开发的时候，页面可以划分成很多部分。往往不同的页面，也会有相同的部分。例如可能会有相同的头部导航。 但是如果每个页面都独自开发，这无疑增加了我们开发的成本。所以我们会把页面的不同部分拆分成独立的组件，然后在不同页面就可以共享这些组件，避免重复开发。 全局组件 我们通过Vue的component方法来定义一个全局组件。 12345678910111213141516171819&lt;div id="app"&gt; &lt;!--使用定义好的全局组件--&gt; &lt;counter&gt;&lt;/counter&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; // 定义全局组件，两个参数：1，组件名称。2，组件参数 Vue.component("counter",&#123; template:'&lt;button v-on:click="count++"&gt;你点了我 &#123;&#123; count &#125;&#125; 次，我记住了.&lt;/button&gt;', data()&#123; return &#123; count:0 &#125; &#125; &#125;) var app = new Vue(&#123; el:"#app" &#125;)&lt;/script&gt; 组件其实也是一个Vue实例，因此它在定义时也会接收：data、methods、生命周期函数等 不同的是组件不会与页面的元素绑定，否则就无法复用了，因此没有el属性。 但是组件渲染需要html模板，所以增加了template属性，值就是HTML模板 全局组件定义完毕，任何vue实例都可以直接在HTML中通过组件名称来使用组件了。 data必须是一个函数，不再是一个对象。 效果： 组件的复用 定义好的组件，可以任意复用多次： 123456&lt;div id="app"&gt; &lt;!--使用定义好的全局组件--&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt;&lt;/div&gt; 效果： 你会发现每个组件互不干扰，都有自己的count值。怎么实现的？ 组件的data属性必须是函数！ 当我们定义这个 &lt;counter&gt; 组件时，它的data 并不是像这样直接提供一个对象： 123data: &#123; count: 0&#125; 取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝： 12345data: function () &#123; return &#123; count: 0 &#125;&#125; 如果 Vue 没有这条规则，点击一个按钮就会影响到其它所有实例！ 局部注册 一旦全局注册，就意味着即便以后你不再使用这个组件，它依然会随着Vue的加载而加载。 因此，对于一些并不频繁使用的组件，我们会采用局部注册。 我们先在外部定义一个对象，结构与创建组件时传递的第二个参数一致： 12345678const counter = &#123; template:'&lt;button v-on:click="count++"&gt;你点了我 &#123;&#123; count &#125;&#125; 次，我记住了.&lt;/button&gt;', data()&#123; return &#123; count:0 &#125; &#125;&#125;; 然后在Vue中使用它： 123456var app = new Vue(&#123; el:"#app", components:&#123; counter:counter // 将定义的对象注册为组件 &#125;&#125;) components就是当前vue对象子组件集合。 其key就是子组件名称 其值就是组件对象的属性 效果与刚才的全局注册是类似的，不同的是，这个counter组件只能在当前的Vue实例中使用 组件通信 通常一个单页应用会以一棵嵌套的组件树的形式来组织： 页面首先分成了顶部导航、左侧内容区、右侧边栏三部分 左侧内容区又分为上下两个组件 右侧边栏中又包含了3个子组件 各个组件之间以嵌套的关系组合在一起，那么这个时候不可避免的会有组件间通信的需求。 props（父向子传递） 父组件使用子组件时，自定义属性（属性名任意，属性值为要传递的数据） 子组件通过props接收父组件属性 父组件使用子组件，并自定义了title属性： 12345678910111213141516&lt;div id="app"&gt; &lt;h1&gt;打个招呼：&lt;/h1&gt; &lt;!--使用子组件，同时传递title属性--&gt; &lt;introduce title="大家好，我是锋哥"/&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; Vue.component("introduce",&#123; // 直接使用props接收到的属性来渲染页面 template:'&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;', props:['title'] // 通过props来接收一个父组件传递的属性 &#125;) var app = new Vue(&#123; el:"#app" &#125;)&lt;/script&gt; 效果： props验证 我们定义一个子组件，并接受复杂数据： 1234567891011121314const myList = &#123; template: '\ &lt;ul&gt;\ &lt;li v-for="item in items" :key="item.id"&gt;&#123;&#123;item.id&#125;&#125; : &#123;&#123;item.name&#125;&#125;&lt;/li&gt;\ &lt;/ul&gt;\ ', props: &#123; items: &#123; type: Array, default: [], required: true &#125; &#125;&#125;; 这个子组件可以对 items 进行迭代，并输出到页面。 props：定义需要从父组件中接收的属性 items：是要接收的属性名称 type：限定父组件传递来的必须是数组 default：默认值 required：是否必须 当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。 我们在父组件中使用它： 12345&lt;div id="app"&gt; &lt;h2&gt;传智播客已开设如下课程：&lt;/h2&gt; &lt;!-- 使用子组件的同时，传递属性，这里使用了v-bind，指向了父组件自己的属性lessons --&gt; &lt;my-list :items="lessons"/&gt;&lt;/div&gt; 12345678910111213var app = new Vue(&#123; el:"#app", components:&#123; myList // 当key和value一样时，可以只写一个 &#125;, data:&#123; lessons:[ &#123;id:1, name: 'java'&#125;, &#123;id:2, name: 'php'&#125;, &#123;id:3, name: 'ios'&#125;, ] &#125;&#125;) 效果： type类型，可以有： 动态静态传递 给 prop 传入一个静态的值： 1&lt;introduce title="大家好，我是锋哥"/&gt; 给 prop 传入一个动态的值： （通过v-bind从数据模型中，获取title的值） 1&lt;introduce :title="title"/&gt; 静态传递时，我们传入的值都是字符串类型的，但实际上任何类型的值都可以传给一个 props。 123456&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个JavaScript表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:likes="42"&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:likes="post.likes"&gt;&lt;/blog-post&gt; 子向父的通信 来看这样的一个案例： 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;h2&gt;num: &#123;&#123;num&#125;&#125;&lt;/h2&gt; &lt;!--使用子组件的时候，传递num到子组件中--&gt; &lt;counter :num="num"&gt;&lt;/counter&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; Vue.component("counter", &#123;// 子组件，定义了两个按钮，点击数字num会加或减 template:'\ &lt;div&gt;\ &lt;button @click="num++"&gt;加&lt;/button&gt; \ &lt;button @click="num--"&gt;减&lt;/button&gt; \ &lt;/div&gt;', props:['num']// count是从父组件获取的。 &#125;) var app = new Vue(&#123; el:"#app", data:&#123; num:0 &#125; &#125;)&lt;/script&gt; 子组件接收父组件的num属性 子组件定义点击按钮，点击后对num进行加或减操作 我们尝试运行，好像没问题，点击按钮试试： 子组件接收到父组件属性后，默认是不允许修改的。怎么办？ 既然只有父组件能修改，那么加和减的操作一定是放在父组件： 1234567891011121314var app = new Vue(&#123; el:"#app", data:&#123; num:0 &#125;, methods:&#123; // 父组件中定义操作num的方法 increment()&#123; this.num++; &#125;, decrement()&#123; this.num--; &#125; &#125;&#125;) 但是，点击按钮是在子组件中，那就是说需要子组件来调用父组件的函数，怎么做？ 我们可以通过v-on指令将父组件的函数绑定到子组件上： 1234&lt;div id="app"&gt; &lt;h2&gt;num: &#123;&#123;num&#125;&#125;&lt;/h2&gt; &lt;counter :count="num" @inc="increment" @dec="decrement"&gt;&lt;/counter&gt;&lt;/div&gt; 在子组件中定义函数，函数的具体实现调用父组件的实现，并在子组件中调用这些函数。当子组件中按钮被点击时，调用绑定的函数： 12345678910111213141516Vue.component("counter", &#123; template:'\ &lt;div&gt;\ &lt;button @click="plus"&gt;加&lt;/button&gt; \ &lt;button @click="reduce"&gt;减&lt;/button&gt; \ &lt;/div&gt;', props:['count'], methods:&#123; plus()&#123; this.$emit("inc"); &#125;, reduce()&#123; this.$emit("dec"); &#125; &#125;&#125;) vue提供了一个内置的this.$emit()函数，用来调用父组件绑定的函数 效果： 路由vue-router 场景模拟 现在我们来实现这样一个功能： 一个页面，包含登录和注册，点击不同按钮，实现登录和注册页切换： 编写父组件 为了让接下来的功能比较清晰，我们先新建一个文件夹：src 然后新建一个HTML文件，作为入口：index.html 然后编写页面的基本结构： 1234567891011121314&lt;div id="app"&gt; &lt;span&gt;登录&lt;/span&gt; &lt;span&gt;注册&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; 登录页/注册页 &lt;/div&gt;&lt;/div&gt;&lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app" &#125;)&lt;/script&gt; 样式： 编写登录及注册组件 接下来我们来实现登录组件，以前我们都是写在一个文件中，但是为了复用性，开发中都会把组件放入独立的JS文件中，我们新建一个user目录以及login.js及register.js： 编写组件，这里我们只写模板，不写功能。 login.js内容如下： 123456789const loginForm = &#123; template:'\ &lt;div&gt;\ &lt;h2&gt;登录页&lt;/h2&gt; \ 用户名：&lt;input type="text"&gt;&lt;br/&gt;\ 密码：&lt;input type="password"&gt;&lt;br/&gt;\ &lt;/div&gt;\ '&#125; register.js内容： 12345678910const registerForm = &#123; template:'\ &lt;div&gt;\ &lt;h2&gt;注册页&lt;/h2&gt; \ 用&amp;ensp;户&amp;ensp;名：&lt;input type="text"&gt;&lt;br/&gt;\ 密&amp;emsp;&amp;emsp;码：&lt;input type="password"&gt;&lt;br/&gt;\ 确认密码：&lt;input type="password"&gt;&lt;br/&gt;\ &lt;/div&gt;\ '&#125; 在父组件中引用 123456789101112131415161718192021222324252627&lt;div id="app"&gt; &lt;span&gt;登录&lt;/span&gt; &lt;span&gt;注册&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--&lt;loginForm&gt;&lt;/loginForm&gt;--&gt; &lt;!-- 疑问：为什么不采用上面的写法？ 由于html是大小写不敏感的，如果采用上面的写法，则被认为是&lt;loginform&gt;&lt;/loginform&gt; 所以，如果是驼峰形式的组件，需要把驼峰转化为“-”的形式 --&gt; &lt;login-form&gt;&lt;/login-form&gt; &lt;register-form&gt;&lt;/register-form&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="user/login.js"&gt;&lt;/script&gt;&lt;script src="user/register.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: "#app", components: &#123; loginForm, registerForm &#125; &#125;)&lt;/script&gt; 效果： 问题 我们期待的是，当点击登录或注册按钮，分别显示登录页或注册页，而不是一起显示。 但是，如何才能动态加载组件，实现组件切换呢？ 虽然使用原生的Html5和JS也能实现，但是官方推荐我们使用vue-router模块。 vue-router简介和安装 使用vue-router和vue可以非常方便的实现 复杂单页应用的动态路由功能。 官网：https://router.vuejs.org/zh-cn/ 使用npm安装：npm install vue-router --save 在index.html中引入依赖： 1&lt;script src="../node_modules/vue-router/dist/vue-router.js"&gt;&lt;/script&gt; 快速入门 新建vue-router对象，并且指定路由规则： 12345678910// 创建VueRouter对象const router = new VueRouter(&#123; routes:[ // 编写路由规则 &#123; path:"/login", // 请求路径 component:loginForm // 组件名称 &#125;, &#123;path:"/register",component:registerForm&#125;, ]&#125;) 创建VueRouter对象，并指定路由参数 routes：路由规则的数组，可以指定多个对象，每个对象是一条路由规则，包含以下属性： path：路由的路径 component：组件名称 在父组件中引入router对象： 12345678var vm = new Vue(&#123; el:"#app", components:&#123;// 引用登录和注册组件 loginForm, registerForm &#125;, router // 引用上面定义的router对象&#125;) 页面跳转控制： 12345678910&lt;div id="app"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 通过&lt;router-view&gt;来指定一个锚点，当路由的路径匹配时，vue-router会自动把对应组件放到锚点位置进行渲染 通过&lt;router-link&gt;指定一个跳转链接，当点击时，会触发vue-router的路由功能，路径中的hash值会随之改变 效果： 注意：单页应用中，页面的切换并不是页面的跳转。仅仅是地址最后的hash值变化。 事实上，我们总共就一个HTML：index.html webpack Webpack 是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。 中文官方网站：https://www.webpackjs.com/ 官网给出的解释： 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 为什么需要打包？ 将许多碎小文件打包成一个整体，减少单页面内的衍生请求次数，提高网站效率。 将ES6的高级语法进行转换编译，以兼容老版本的浏览器。 将代码打包的同时进行混淆，提高代码的安全性。 安装 webpack支持全局安装和本地安装，官方推荐是本地安装，我们按照官方的来。 安装最新版本webpack，输入命令：npm install --save-dev webpack webpack 4+ 版本，你还需要安装 CLI ，输入命令：npm install webpack webpack-cli --save-dev 此时，我们注意下项目中文件夹下，会有一个package.json文件。（其实早就有了） 打开文件，可以看到我们之前用npm安装过的文件都会出现在这里： 核心概念 学习Webpack，你需要先理解四个核心概念： 入口(entry) webpack打包的起点，可以有一个或多个，一般是js文件。webpack会从启点文件开始，寻找启点直接或间接依赖的其它所有的依赖，包括JS、CSS、图片资源等，作为将来打包的原始数据 输出(output) 出口一般包含两个属性：path和filename。用来告诉webpack打包的目标文件夹，以及文件的名称。目的地也可以有多个。 加载器（loader） webpack本身只识别Js文件，如果要加载非JS文件，必须指定一些额外的加载器（loader），例如css-loader。然后将这些文件转为webpack能处理的有效模块，最后利用webpack的打包能力去处理。 插件(plugins) 插件可以扩展webpack的功能，让webpack不仅仅是完成打包，甚至各种更复杂的功能，或者是对打包功能进行优化、压缩，提高效率。 编写webpack配置 接下来，我们编写一个webpack的配置，来指定一些打包的配置项。配置文件的名称，默认就是webpack.config.js，我们放到hello-vue的根目录： 配置文件中就是要指定上面说的四个核心概念，入口、出口、加载器、插件。 不过，加载器和插件是可选的。我们先编写入口和出口 入口entry webpack打包的启点，可以有一个或多个，一般是js文件。现在思考一下我们有没有一个入口？貌似没有，我们所有的东西都集中在index.html，不是一个js，那怎么办？ 我们新建一个js，把index.html中的部分内容进行集中，然后在index.html中引用这个js不就OK了！ 然后把原来index.html中的js代码全部移动到index.js中 123456789101112131415161718192021222324// 使用es6的语法导入js模块import Vue from '../node_modules/vue/dist/vue';import VueRouter from '../node_modules/vue-router/dist/vue-router';import loginForm from './user/login';import registerForm from './user/register';Vue.use(VueRouter);// 创建vue对象const router = new VueRouter(&#123; routes: [ // 编写路由规则 // path: 路由请求路径；component：组件名称 &#123;path: "/login", component: loginForm&#125;, &#123;path: "/register", component: registerForm&#125; ]&#125;);var vm = new Vue(&#123; el: "#app", components: &#123; loginForm, registerForm &#125;, router&#125;); 原来的index.html中引入了很多其它js，在这里我们使用es6的import语法进行导入。 ​ 注意，要使用import，就需要在login.js和register.js中添加export导出语句： 123456789const loginForm=&#123; template: '\ &lt;div&gt;\ &lt;h2&gt;登陆页&lt;/h2&gt;\ 用户名：&lt;input type="text"&gt;&lt;br&gt;\ 密&amp;emsp;码：&lt;input type="password"&gt;\ &lt;/div&gt;',&#125;export default loginForm; register.js: 1234567891011const registerForm = &#123; template:'\ &lt;div&gt;\ &lt;h2&gt;注册页&lt;/h2&gt; \ 用&amp;ensp;户&amp;ensp;名：&lt;input type="text"&gt;&lt;br/&gt;\ 密&amp;emsp;&amp;emsp;码：&lt;input type="password"&gt;&lt;br/&gt;\ 确认密码：&lt;input type="password"&gt;&lt;br/&gt;\ &lt;/div&gt;\ '&#125;export default registerForm; vue-router使用模块化加载后，必须增加一句：Vue.use(VueRouter) 这样，index.js就成了我们整个配置的入口了。 我们在webpack.config.js中添加以下内容： 123module.exports=&#123; entry:'./src/index.js', //指定打包的入口文件&#125; 出口output 出口，就是输出的目的地。一般我们会用一个dist目录，作为打包输出的文件夹： 然后，编写webpack.config.js，添加出口配置： 12345678module.exports=&#123; entry:'./src/main.js', //指定打包的入口文件 output:&#123; // path: 输出的目录，__dirname是相对于webpack.config.js配置文件的绝对路径 path : __dirname+'/dist', filename:'build.js' //输出的js文件名 &#125;&#125; 执行打包 在控制台输入以下命令： 1npx webpack --config webpack.config.js 随后，查看dist目录： 尝试打开build.js，你根本看不懂： 所有的js合并为1个，并且对变量名进行了随机打乱，这样就起到了 压缩、混淆的作用。 测试运行 在index.html中引入刚刚生成的build.js文件， 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="../dist/build.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后运行： 打包CSS 我们来编写一段CSS代码，对index的样式做一些美化： 内容： 123456789101112131415161718192021#app a&#123; display: inline-block; width: 150px; line-height: 30px; background-color: dodgerblue; color: white; font-size: 16px; text-decoration: none;&#125;#app a:hover&#123; background-color: whitesmoke; color: dodgerblue;&#125;#app div&#123; width: 300px; height: 150px;&#125;#app&#123; width: 305px; border: 1px solid dodgerblue;&#125; 安装加载器 前面说过，webpack默认只支持js加载。要加载CSS文件，必须安装加载器： 命令：npm install style-loader css-loader --save-dev 此时，在package.json中能看到新安装的： index.js引入css文件 因为入口在index.js，因此css文件也要在这里引入。依然使用ES6 的模块语法： 1import './css/main.css' 配置加载器 在webpack.config.js配置文件中配置css的加载器 123456789101112131415161718module.exports = &#123; entry: './src/main.js', //指定打包的入口文件 output: &#123; path: __dirname + '/dist', // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename: 'build.js' //输出文件 &#125;, module: &#123; rules: [ &#123; test: /\.css$/, // 通过正则表达式匹配所有以.css后缀的文件 use: [ // 要使用的加载器，这两个顺序一定不要乱 'style-loader', 'css-loader' ] &#125; ] &#125;&#125; 重新打包 再次输入打包指令：npx webpack --config webpack.config.js 效果： script脚本 我们每次使用npm安装，都会在package.json中留下痕迹，事实上，package.json中不仅可以记录安装的内容，还可编写脚本，让我们运行命令更加快捷。 我们可以把webpack的命令编入其中： 以后，如果要打包，就可以直接输入：npm run build即可。 npm run ：执行npm脚本，后面跟的是配置脚本的名称build 打包HTML 之前的打包过程中，除了HTML文件外的其它文件都被打包了，当在线上部署时，我们还得自己复制HTML到dist，然后手动添加生成的js到HTML中，这非常不友好。 webpack中的一个插件：html-webpack-plugin，可以解决这个问题。 1）安装插件：npm install --save-dev html-webpack-plugin 需要在webpack.config.js中添加插件： 123456789101112131415161718192021222324252627const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: './src/main.js', //指定打包的入口文件 output: &#123; path: __dirname + '/dist', // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename: 'build.js' //输出文件 &#125;, module: &#123; rules: [ &#123; test: /\.css$/, // 通过正则表达式匹配所有以.css后缀的文件 use: [ // 要使用的加载器，这两个顺序一定不要乱 'style-loader', 'css-loader' ] &#125; ] &#125;, plugins:[ new HtmlWebpackPlugin(&#123; title: '首页', //生成的页面标题&lt;head&gt;&lt;title&gt;首页&lt;/title&gt;&lt;/head&gt; filename: 'index.html', // dist目录下生成的文件名 template: './src/index.html' // 我们原来的index.html，作为模板 &#125;) ]&#125; 2）将原来HTML中的引入js代码删除： 3）再次打包：npm run build 4）查看dist目录： 打开index.html，发现已经自动添加了当前目录下的build.js 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;script type="text/javascript" src="build.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 热更新的web服务 刚才的案例中，每次修改任何js或css内容，都必须重新打包，非常麻烦。 webpack给我们提供了一个插件，可以帮我们运行一个web服务，加载页面内容，并且修改js后不需要重新加载就能看到最新结果： 1）安装插件：npm install webpack-dev-server --save-dev 2）添加启动脚本 在package.json中配置script 123"scripts": &#123; "dev": "webpack-dev-server --inline --hot --open --port 8080 --host 127.0.0.1"&#125;, –inline：自动刷新 –hot：热加载 –port：指定端口 –open：自动在默认浏览器打开 –host：可以指定服务器的 ip，不指定则为127.0.0.1 3）运行脚本：npm run dev 4）效果： vue-cli 介绍和安装 在开发中，需要打包的东西不止是js、css、html。还有更多的东西要处理，这些插件和加载器如果我们一一去添加就会比较麻烦。 幸好，vue官方提供了一个快速搭建vue项目的脚手架：vue-cli 使用它能快速的构建一个web工程模板。 官网：https://github.com/vuejs/vue-cli 安装命令：npm install -g vue-cli 快速上手 我们新建一个module： 切换到该目录： 用vue-cli命令，快速搭建一个webpack的项目：vue init webpack 前面几项都走默认或yes 下面这些我们选no 最后，再选yes，使用 npm安装 开始初始化项目，并安装依赖，可能需要 安装成功！ 可以使用npm run dev命令启动。 项目结构 安装好的项目结构： 入口文件：main.js 单文件组件 需要注意的是，我们看到有一类后缀名为.vue的文件，我们称为单文件组件 每一个.vue文件，就是一个独立的vue组件。类似于我们刚才写的login.js和register.js 只不过，我们在js中编写 html模板和样式非常的不友好，而且没有语法提示和高亮。 而单文件组件中包含三部分内容： template：模板，支持html语法高亮和提示 script：js脚本，这里编写的就是vue的组件对象，还可以有data(){}等 style：样式，支持CSS语法高亮和提示 每个组件都有自己独立的html、JS、CSS，互不干扰，真正做到可独立复用。 运行 看看生成的package.json： 可以看到这引入了非常多的依赖，绝大多数都是开发期依赖，比如大量的加载器。 运行时依赖只有vue和vue-router 脚本有三个： dev：使用了webpack-dev-server命令，开发时热部署使用 start：使用了npm run dev命令，与上面的dev效果完全一样，当脚本名为“start”时，可以省略“run”。 build：等同于webpack的打包功能，会打包到dist目录下。 我们执行npm run dev 或者 npm start 都可以启动项目： 页面：]]></content>
  </entry>
  <entry>
    <title><![CDATA[day04-乐优商城项目搭建]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F24%2Fday04-%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[学习目标 了解电商行业 了解乐优商城项目结构 能独立搭建项目基本框架 能参考使用ES6的新语法 了解电商行业 学习电商项目，自然要先了解这个行业，所以我们首先来聊聊电商行业 项目分类 主要从需求方、盈利模式、技术侧重点这三个方面来看它们的不同 传统项目 各种企业里面用的管理系统（ERP、HR、OA、CRM、物流管理系统。。。。。。。） 需求方：公司、企业内部 盈利模式：项目本身卖钱 技术侧重点：业务功能 互联网项目 门户网站、电商网站：baidu.com、qq.com、taobao.com、jd.com …… 需求方：广大用户群体 盈利模式：虚拟币、增值服务、广告收益…… 技术侧重点：网站性能、业务功能 而我们今天要聊的就是互联网项目中的重要角色：电商 电商行业的发展 钱景 近年来，中国的电子商务快速发展，交易额连创新高，电子商务在各领域的应用不断拓展和深化、相关服务业蓬勃发展、支撑体系不断健全完善、创新的动力和能力不断增强。电子商务正在与实体经济深度融合，进入规模性发展阶段，对经济社会生活的影响不断增大，正成为我国经济发展的新引擎。 中国电子商务研究中心数据显示，截止到 2012 年底，中国电子商务市场交易规模达 7.85万亿人民币，同比增长 30.83%。其中，B2B 电子商务交易额达 6.25 万亿，同比增长 27%。而 2011 年全年，中国电子商务市场交易额达 6 万亿人民币，同比增长 33%，占 GDP 比重上升到 13%；2012 年，电子商务占 GDP 的比重已经高达 15%。 ![1525686041466](day04-乐优商城项目搭建/1525686041466.png) 数据 来看看双十一的成交数据： 2016双11开场30分钟，创造每秒交易峰值17.5万笔，每秒支付峰值12万笔的新纪录。菜鸟单日物流订单量超过4.67亿，创历史新高。 技术特点 从上面的数据我们不仅要看到钱，更要看到背后的技术实力。正是得益于电商行业的高强度并发压力，促使了BAT等巨头们的技术进步。电商行业有些什么特点呢？ 技术范围广 技术新 高并发（分布式、静态化技术、缓存技术、异步并发、池化、队列） 高可用（集群、负载均衡、限流、降级、熔断） 数据量大 业务复杂 数据安全 常见电商模式 电商行业的一些常见模式： B2C：商家对个人，如：亚马逊、当当等 C2C平台：个人对个人，如：咸鱼、拍拍网、ebay B2B平台：商家对商家，如：阿里巴巴、八方资源网等 O2O：线上和线下结合，如：饿了么、电影票、团购等 P2P：在线金融，贷款，如：网贷之家、人人聚财等。 B2C平台：天猫、京东、一号店等 一些专业术语 SaaS：软件即服务 SOA：面向服务 RPC：远程过程调用 RMI：远程方法调用 PV：(page view)，即页面浏览量； 用户每1次对网站中的每个网页访问均被记录1次。用户对同一页面的多次访问，访问量累计 UV：(unique visitor)，独立访客 指访问某个站点或点击某条新闻的不同IP地址的人数。在同一天内，uv只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。 PV与带宽： 计算带宽大小需要关注两个指标：峰值流量和页面的平均大小。 计算公式是：网站带宽= ( PV * 平均页面大小（单位MB）* 8 )/统计时间（换算到秒） 为什么要乘以8？ 网站大小为单位是字节(Byte)，而计算带宽的单位是bit，1Byte=8bit 这个计算的是平均带宽，高峰期还需要扩大一定倍数 PV、QPS、并发 QPS：每秒处理的请求数量。8000/s 比如你的程序处理一个请求平均需要0.1S，那么1秒就可以处理10个请求。QPS自然就是10，多线程情况下，这个数字可能就会有所增加。 由PV和QPS如何需要部署的服务器数量？ 根据二八原则，80%的请求集中在20%的时间来计算峰值压力： （每日PV * 80%） / （3600s * 24 * 20%） * 每个页面的请求数 = 每个页面每秒的请求数量 然后除以服务器的QPS值，即可计算得出需要部署的服务器数量 项目开发流程 项目经理：管人 产品经理：设计需求原型 测试： 前端：大前端。node 后端： 移动端： 项目开发流程图： ​ 公司现状： ​ 乐优商城介绍 项目介绍 乐优商城是一个全品类的电商购物网站（B2C）。 用户可以在线购买商品、加入购物车、下单、秒杀商品 可以品论已购买商品 管理员可以在后台管理商品的上下架、促销活动 管理员可以监控商品销售状况 客服可以在后台处理退款操作 希望未来3到5年可以支持千万用户的使用 系统架构 架构图 乐优商城架构缩略图，大图请参考课前资料： 系统架构解读 整个乐优商城可以分为两部分：后台管理系统、前台门户系统。 后台管理： 后台系统主要包含以下功能： 商品管理，包括商品分类、品牌、商品规格等信息的管理 销售管理，包括订单统计、订单退款处理、促销活动生成等 用户管理，包括用户控制、冻结、解锁等 权限管理，整个网站的权限控制，采用JWT鉴权方案，对用户及API进行权限控制 统计，各种数据的统计分析展示 后台系统会采用前后端分离开发，而且整个后台管理系统会使用Vue.js框架搭建出单页应用（SPA）。 预览图： 前台门户 前台门户面向的是客户，包含与客户交互的一切功能。例如： 搜索商品 加入购物车 下单 评价商品等等 前台系统我们会使用Thymeleaf模板引擎技术来完成页面开发。出于SEO优化的考虑，我们将不采用单页应用。 无论是前台还是后台系统，都共享相同的微服务集群，包括： 商品微服务：商品及商品分类、品牌、库存等的服务 搜索微服务：实现搜索功能 订单微服务：实现订单相关 购物车微服务：实现购物车相关功能 用户中心：用户的登录注册等功能 Eureka注册中心 Zuul网关服务 Spring Cloud Config配置中心 … 项目搭建 技术选型 前端技术： 基础的HTML、CSS、JavaScript（基于ES6标准） JQuery Vue.js 2.0以及基于Vue的框架：Vuetify 前端构建工具：WebPack 前端安装包工具：NPM Vue脚手架：Vue-cli Vue路由：vue-router ajax框架：axios 基于Vue的富文本框架：quill-editor 后端技术： 基础的SpringMVC、Spring 5.0和MyBatis3 Spring Boot 2.0.1版本 Spring Cloud 最新版 Finchley.RC1 Redis-4.0 RabbitMQ-3.4 Elasticsearch-5.6.8 nginx-1.10.2： FastDFS - 5.0.8 MyCat Thymeleaf 开发环境 为了保证开发环境的统一，希望每个人都按照我的环境来配置： IDE：我们使用Idea 2017.3 版本 JDK：统一使用JDK1.8 项目构建：maven3.3.9以上版本即可 版本控制工具：git idea大家可以在我的课前资料中找到。另外，使用帮助大家可以参考课前资料的《idea使用指南.md》 域名 我们在开发的过程中，为了保证以后的生产、测试环境统一。尽量都采用域名来访问项目。 一级域名：www.leyou.com 二级域名：manage.leyou.com , api.leyou.com 我们可以通过switchhost工具来修改自己的host对应的地址，只要把这些域名指向127.0.0.1，那么跟你用localhost的效果是完全一样的。 switchhost可以去课前资料寻找。 创建父工程 创建统一的父工程：leyou，用来管理依赖及其版本，注意是创建project，而不是moudle 填写项目信息： 注意： 父工程不需要代码，只是管理依赖，因此我们不选择任何SpringCloud的依赖 跳过依赖选择。 填写保存的位置信息： 然后将pom文件修改成我这个样子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;leyou&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt; &lt;mybatis.starter.version&gt;1.3.2&lt;/mybatis.starter.version&gt; &lt;mapper.starter.version&gt;2.0.2&lt;/mapper.starter.version&gt; &lt;druid.starter.version&gt;1.1.9&lt;/druid.starter.version&gt; &lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt; &lt;pageHelper.starter.version&gt;1.2.3&lt;/pageHelper.starter.version&gt; &lt;leyou.latest.version&gt;1.0.0-SNAPSHOT&lt;/leyou.latest.version&gt; &lt;fastDFS.client.version&gt;1.26.1-RELEASE&lt;/fastDFS.client.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- springCloud --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mybatis启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mapper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分页助手启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;pageHelper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--FastDFS客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt; &lt;version&gt;$&#123;fastDFS.client.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 可以发现，我们在父工程中引入了SpringCloud等很多以后需要用到的依赖，以后创建的子工程就不需要自己引入了。 最后，删除自动生成的LeyouApplication启动类、测试类以及application.properties文件，我们不需要。 创建EurekaServer 创建工程 这个大家应该比较熟悉了。 我们的注册中心，起名为：ly-registry 这次我们就不Spring使用提供的脚手架了。直接创建maven项目，自然会继承父类的依赖： 选择新建module： ​ 选择maven安装，但是不要选择骨架： 然后填写项目坐标，我们的项目名称为ly-registry: 选择安装目录，因为是聚合项目，目录应该是在父工程leyou的下面： 添加依赖 添加EurekaServer的依赖： 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-registry&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 编写启动类 1234567@SpringBootApplication@EnableEurekaServerpublic class LyRegistry &#123; public static void main(String[] args) &#123; SpringApplication.run(LyRegistry.class, args); &#125;&#125; 配置文件 1234567891011121314server: port: 10086spring: application: name: ly-registryeureka: client: fetch-registry: false register-with-eureka: false service-url: defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka server: enable-self-preservation: false # 关闭自我保护 eviction-interval-timer-in-ms: 5000 # 每隔5秒进行一次服务列表清理 项目的结构： 目前，整个项目的结构如图： 创建Zuul网关 创建工程 与上面类似，选择maven方式创建Module，然后填写项目名称，我们命名为：ly-api-gateway 填写保存的目录： 添加依赖 这里我们需要添加Zuul和EurekaClient的依赖： 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-api-gateway&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--是springboot提供的微服务检测接口，默认对外提供几个接口：/info--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 编写启动类 12345678@SpringBootApplication@EnableDiscoveryClient@EnableZuulProxypublic class LyApiGateway &#123; public static void main(String[] args) &#123; SpringApplication.run(LyApiGateway.class, args); &#125;&#125; 配置文件 123456789101112131415161718192021222324252627282930server: port: 10010spring: application: name: api-gatewayeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka registry-fetch-interval-seconds: 5 instance: prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125;zuul: prefix: /api # 添加路由前缀 retryable: trueribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 2000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 10000 # 熔断超时时长：10000ms 项目结构 目前，leyou下有两个子模块： ly-registry：服务的注册中心（EurekaServer） ly-api-gateway：服务网关（Zuul） 目前，服务的结构如图所示： 截止到这里，我们已经把基础服务搭建完毕，为了便于开发，统一配置中心（ConfigServer）我们留待以后添加。 创建商品微服务 既然是一个全品类的电商购物平台，那么核心自然就是商品。因此我们要搭建的第一个服务，就是商品微服务。其中会包含对于商品相关的一系列内容的管理，包括： 商品分类管理 品牌管理 商品规格参数管理 商品管理 库存管理 我们先完成项目的搭建： 微服务的结构 因为与商品的品类相关，我们的工程命名为ly-item. 需要注意的是，我们的ly-item是一个微服务，那么将来肯定会有其它系统需要来调用服务中提供的接口，因此肯定也会使用到接口中关联的实体类。 因此这里我们需要使用聚合工程，将要提供的接口及相关实体类放到独立子工程中，以后别人引用的时候，只需要知道坐标即可。 我们会在ly-item中创建两个子工程： ly-item-interface：主要是对外暴露的接口及相关实体类 ly-item-service：所有业务逻辑及内部使用接口 调用关系如图所示： 创建父工程ly-item 依然是使用maven构建： 保存的位置： 不需要任何依赖，我们可以把项目打包方式设置为pom 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- 打包方式为pom --&gt; &lt;packaging&gt;pom&lt;/packaging&gt;&lt;/project&gt; 创建ly-item-interface 在ly-item工程上点击右键，选择new &gt; module: 依然是使用maven构建，注意父工程是ly-item： 注意：接下来填写的目录结构需要自己手动完成，保存到ly-item下的ly-item-interface目录中： 点击Finish完成。 此时的项目结构： ​ 创建ly-item-service 与ly-item-interface类似，我们选择在ly-item上右键，新建module，然后填写项目信息： 填写存储位置，是在/ly-item/ly-item-service目录 点击Finish完成。 整个微服务结构 如图所示： ​ 我们打开ly-item的pom查看，会发现ly-item-interface和ly-item-service都已经称为module了： ​ 添加依赖 接下来我们给ly-item-service中添加依赖： 思考一下我们需要什么？ Eureka客户端 web启动器 mybatis启动器 通用mapper启动器 分页助手启动器 连接池，我们用默认的Hykira mysql驱动 千万不能忘了，我们自己也需要ly-item-interface中的实体类 这些依赖，我们在顶级父工程：leyou中已经添加好了。所以直接引入即可： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;ly-item&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-service&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!--Eureka客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--web启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mapper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分页助手启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;pageHelper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-interface&lt;/artifactId&gt; &lt;version&gt;$&#123;leyou.latest.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ly-item-interface中需要什么我们暂时不清楚，所以先不管。 整个结构： 编写启动和配置 在整个ly-item工程中，只有ly-item-service是需要启动的。因此在其中编写启动类即可： 1234567@SpringBootApplication@EnableDiscoveryClientpublic class LyItemService &#123; public static void main(String[] args) &#123; SpringApplication.run(LyItemService.class, args); &#125;&#125; 然后是全局属性文件： 12345678910111213141516171819202122server: port: 8081spring: application: name: item-service datasource: url: jdbc:mysql://localhost:3306/heima username: root password: 123 hikari: maximum-pool-size: 30 minimum-idle: 10eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 添加商品微服务的路由规则 既然商品微服务已经创建，接下来肯定要添加路由规则到Zuul中，我们不使用默认的路由规则。 12345zuul: prefix: /api # 添加路由前缀 retryable: true routes: item-service: /item/** # 将商品微服务映射到/item/** 启动测试 我们分别启动：ly-registry，ly-api-gateway，ly-item-service 查看Eureka面板： 测试路由规则 为了测试路由规则是否畅通，我们是不是需要在item-service中编写一个controller接口呢？ 其实不需要，Spring提供了一个依赖：actuator 只要我们添加了actuator的依赖，它就会为我们生成一系列的访问接口： /info /health /refresh … 添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 重启后访问Eureka控制台： 鼠标悬停在item-service上，会显示一个地址： 这就是actuator提供的接口，我们点击访问： 因为我们没有添加信息，所以是一个空的json，但是可以肯定的是：我们能够访问到item-service了。 接下来我们通过路由访问试试，根据路由规则，我们需要访问的地址是： http://127.0.0.1:10010/api/item/actuator/info 通用工具模块 有些工具或通用的约定内容，我们希望各个服务共享，因此需要创建一个工具模块：ly-common 使用maven来构建module： 位置信息： 结构： 目前还不需要编码。 ES6 语法指南 后端项目搭建完毕，接下来就是前端页面了。不过在这之前需要一些准备工作。我们需要学习ES6的语法标准。 什么是ES6？就是ECMAScript第6版标准。 什么是ECMAScript？ 来看下前端的发展历程： web1.0时代： 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。开发人员也只关心页面的样式和内容即可。 web2.0时代： 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。 1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。 1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了ECMAscript标准规范。JavaScript和JScript都是ECMAScript的标准实现者，随后各大浏览器厂商纷纷实现了ECMAScript标准。 所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。 ECMAScript的快速发展 而后，ECMAScript就进入了快速发展期。 1998年6月，ECMAScript 2.0 发布。 1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。 2007年10月。。。。ECMAScript 4.0 草案发布。 这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。 一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。 一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。 ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中 2009年12月，ECMAScript 5 发布。 2011年6月，ECMAScript 5.1 发布。 2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 ES5和6的一些新特性 我们这里只把一些常用的进行学习，更详细的大家参考：阮一峰的ES6教程 let 和 const 命令 var 之前，js定义变量只有一个关键字：var var有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。 例如这样的一段代码： 1234for(var i = 0; i &lt; 5; i++)&#123; console.log(i);&#125;console.log("循环外：" + i) 你猜下打印的结果是什么？ let let所声明的变量，只在let命令所在的代码块内有效。 我们把刚才的var改成let试试： 1234for(let i = 0; i &lt; 5; i++)&#123; console.log(i);&#125;console.log("循环外：" + i) 结果： const const声明的变量是常量，不能被修改 字符串扩展 新的API ES6为字符串扩展了几个新的API： includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 实验一下： 字符串模板 ES6中提供了`来作为字符串模板标记。我们可以这么玩： 在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本 键盘是的1的左侧，tab的上侧，esc的正下方 解构表达式 数组解构 比如有一个数组： 1let arr = [1,2,3] 我想获取其中的值，只能通过角标。ES6可以这样： 123const [x,y,z] = arr;// x，y，z将与arr中的每个位置对应来取值// 然后打印console.log(x,y,z); 结果： 对象解构 例如有个person对象： 12345const person = &#123; name:"jack", age:21, language: ['java','js','css']&#125; 我们可以这么做： 123456// 解构表达式获取值const &#123;name,age,language&#125; = person;// 打印console.log(name);console.log(age);console.log(language); 结果： 如过想要用其它变量接收，需要额外指定别名： {name:n}：name是person中的属性名，冒号后面的n是解构后要赋值给的变量。 函数优化 函数参数默认值 在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法： 1234567function add(a , b) &#123; // 判断b是否为空，为空就给默认值1 b = b || 1; return a + b;&#125;// 传一个参数console.log(add(10)); 现在可以这么写： 12345function add(a , b = 1) &#123; return a + b;&#125;// 传一个参数console.log(add(10)); 箭头函数 ES6中定义函数的简写方式： 一个参数时： 12345var print = function (obj) &#123; console.log(obj);&#125;// 简写为：var print2 = obj =&gt; console.log(obj); 多个参数： 123456// 两个参数的情况：var sum = function (a , b) &#123; return a + b;&#125;// 简写为：var sum2 = (a,b) =&gt; a+b; 代码不止一行，可以用{}括起来 123var sum3 = (a,b) =&gt; &#123; return a + b;&#125; 对象的函数属性简写 比如一个Person对象，里面有eat方法： 12345678910111213let person = &#123; name: "jack", // 以前： eat: function (food) &#123; console.log(this.name + "在吃" + food); &#125;, // 箭头函数版： eat2: food =&gt; console.log(person.name + "在吃" + food),// 这里拿不到this // 简写版： eat3(food)&#123; console.log(this.name + "在吃" + food); &#125;&#125; 箭头函数结合解构表达式 比如有一个函数： 123456789const person = &#123; name:"jack", age:21, language: ['java','js','css']&#125;function hello(person) &#123; console.log("hello," + person.name)&#125; 如果用箭头函数和解构表达式 1var hi = (&#123;name&#125;) =&gt; console.log("hello," + name); map和reduce 数组中新增了map和reduce方法。 map map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。 举例：有一个字符串数组，我们希望转为int数组 123456let arr = ['1','20','-5','3'];console.log(arr)arr = arr.map(s =&gt; parseInt(s));console.log(arr) reduce reduce()：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数： 第一个参数是上一次reduce处理的结果 第二个参数是数组中要处理的下一个元素 reduce()会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数 举例： 1const arr = [1,20,-5,3] 没有初始值： 指定初始值： promise 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 感觉跟java的Future类很像啊，有木有！ 我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。 语法： 123456789const promise = new Promise(function(resolve, reject) &#123; // ... 执行异步操作 if (/* 异步操作成功 */)&#123; resolve(value);// 调用resolve，代表Promise将返回成功的结果 &#125; else &#123; reject(error);// 调用reject，代表Promise会返回失败结果 &#125;&#125;); 这样，在promise中就封装了一段异步执行的结果。 如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现,语法： 123promise.then(function(value)&#123; // 异步执行成功后的回调&#125;); 如果想要处理promise异步执行失败的事件，还可以跟上catch： 12345promise.then(function(value)&#123; // 异步执行成功后的回调&#125;).catch(function(error)&#123; // 异步执行失败后的回调&#125;) 示例： 12345678910111213141516171819const p = new Promise(function (resolve, reject) &#123; // 这里我们用定时任务模拟异步 setTimeout(() =&gt; &#123; const num = Math.random(); // 随机返回成功或失败 if (num &lt; 0.5) &#123; resolve(&quot;成功！num:&quot; + num) &#125; else &#123; reject(&quot;出错了！num:&quot; + num) &#125; &#125;, 300)&#125;)// 调用promisep.then(function (msg) &#123; console.log(msg);&#125;).catch(function (msg) &#123; console.log(msg);&#125;) 结果： set和map（了解） ES6提供了Set和Map的数据结构。 Set，本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。跟java很像吧。 构造函数： 12345// Set构造函数可以接收一个数组或空let set = new Set();set.add(1);// [1]// 接收数组let set2 = new Set([2,3,4,5,5]);// 得到[2,3,4,5] 普通方法： 123456789set.add(1);// 添加set.clear();// 清空set.delete(2);// 删除指定元素set.has(2); // 判断是否存在set.keys();// 返回所有keyset.values();// 返回所有值set.entries();// 返回键值对集合// 因为set没有键值对，所有其keys、values、entries方法返回值一样的。set.size; // 元素个数。是属性，不是方法。 map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即： object是 &lt;string,object&gt;集合 map是&lt;object,object&gt;集合 构造函数： 12345678910111213// map接收一个数组，数组中的元素是键值对数组const map = new Map([ ['key1','value1'], ['key2','value2'],])// 或者接收一个setconst set = new Set([ ['key1','value1'], ['key2','value2'],])const map2 = new Map(set)// 或者其它mapconst map3 = new Map(map); 方法： 模块化 什么是模块化 模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。 而JS中没有包的概念，换来的是 模块。 模块功能主要由两个命令构成：export和import。 export命令用于规定模块的对外接口， import命令用于导入其他模块提供的功能。 export 比如我定义一个js文件:hello.js，里面有一个对象： 12345const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125; 我可以使用export将这个对象导出： 123456const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125;export util; 当然，也可以简写为： 12345export const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125; export不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。 当要导出多个值时，还可以简写。比如我有一个文件：user.js： 123var name = "jack"var age = 21export &#123;name,age&#125; 省略名称 上面的导出代码中，都明确指定了导出的变量名，这样其它人在导入使用时就必须准确写出变量名，否则就会出错。 因此js提供了default关键字，可以对导出的变量名进行省略 例如： 123456// 无需声明对象的名字export default &#123; sum(a,b)&#123; return a + b; &#125;&#125; 这样，当使用者导入时，可以任意起名字 import 使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 例如我要使用上面导出的util： 1234// 导入utilimport util from 'hello.js'// 调用util中的属性util.sum(1,2) 要批量导入前面导出的name和age： 123import &#123;name, age&#125; from 'user.js'console.log(name + " , 今年"+ age +"岁了") 但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。除非借助于工具，把ES6 的语法进行编译降级到ES5，比如Babel-cli工具 我们暂时不做测试，大家了解即可。 对象扩展 ES6给Object拓展了许多新的方法，如： keys(obj)：获取对象的所有key形成的数组 values(obj)：获取对象的所有value形成的数组 entries(obj)：获取对象的所有key和value形成的二维数组。格式：[[k1,v1],[k2,v2],...] assian(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。 数组扩展 ES6给数组新增了许多方法： find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素 findIndex(callback)：与find类似，不过返回的是品牌到的元素的索引 includes（callback）：与find类似，如果匹配到元素，则返回true，代表找到了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[day03-认识微服务2]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F24%2Fday03-%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A12%2F</url>
    <content type="text"><![CDATA[学习目标 会配置Hystix熔断 会使用Feign进行远程调用 能独立搭建Zuul网关 能编写Zuul的拦截器 Hystix 简介 Hystix，即熔断器。 主页：https://github.com/Netflix/Hystrix/ Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。 熔断器的工作机制： 正常工作的情况下，客户端请求调用服务API接口： 当有服务出现异常时，直接进行失败回滚，服务降级处理： 当服务繁忙时，如果服务出现异常，不是粗暴的直接报错，而是返回一个友好的提示，虽然拒绝了用户的访问，但是会返回一个结果。 这就好比去买鱼，平常超市买鱼会额外赠送杀鱼的服务。等到逢年过节，超时繁忙时，可能就不提供杀鱼服务了，这就是服务的降级。 系统特别繁忙时，一些次要服务暂时中断，优先保证主要服务的畅通，一切资源优先让给主要服务来使用，在双十一、618时，京东天猫都会采用这样的策略。 动手实践 引入依赖 首先在user-consumer中引入Hystix依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 开启熔断 改造消费者 我们改造user-consumer，添加一个用来访问的user服务的DAO，并且声明一个失败时的回滚处理函数： 1234567891011121314151617181920212223242526@Componentpublic class UserDao &#123; @Autowired private RestTemplate restTemplate; private static final Logger logger = LoggerFactory.getLogger(UserDao.class); @HystrixCommand(fallbackMethod = "queryUserByIdFallback") public User queryUserById(Long id)&#123; long begin = System.currentTimeMillis(); String url = "http://user-service/user/" + id; User user = this.restTemplate.getForObject(url, User.class); long end = System.currentTimeMillis(); // 记录访问用时： logger.info("访问用时：&#123;&#125;", end - begin); return user; &#125; public User queryUserByIdFallback(Long id)&#123; User user = new User(); user.setId(id); user.setName("用户信息查询出现异常！"); return user; &#125;&#125; @HystrixCommand(fallbackMethod=&quot;queryUserByIdFallback&quot;)：声明一个失败回滚处理函数queryUserByIdFallback，当queryUserById执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。 为了方便查看熔断的触发时机，我们记录请求访问时间。 在原来的业务逻辑中调用这个DAO： 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserDao userDao; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.userDao.queryUserById(id)); &#125;); return users; &#125;&#125; 改造服务提供者 改造服务提供者，随机休眠一段时间，以触发熔断： 123456789101112@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id) throws InterruptedException &#123; // 为了演示超时现象，我们在这里然线程休眠,时间随机 0~2000毫秒 Thread.sleep(new Random().nextInt(2000)); return this.userMapper.selectByPrimaryKey(id); &#125;&#125; 启动测试 然后运行并查看日志： id为9、10、11的访问时间分别是： id为12的访问时间： 因此，只有12是正常访问，其它都会触发熔断，我们来查看结果： 优化 虽然熔断实现了，但是我们的重试机制似乎没有生效，是这样吗？ 其实这里是因为我们的Ribbon超时时间设置的是1000ms: ​ 而Hystix的超时时间默认也是1000ms，因此重试机制没有被触发，而是先触发了熔断。 所以，Ribbon的超时时间一定要小于Hystix的超时时间。 我们可以通过hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds来设置Hystrix超时时间。 1234567hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 6000 # 设置hystrix的超时时间为6000ms Feign 在前面的学习中，我们使用了Ribbon的负载均衡功能，大大简化了远程调用时的代码： 12String baseUrl = "http://user-service/user/";User user = this.restTemplate.getForObject(baseUrl + id, User.class) 如果就学到这里，你可能以后需要编写类似的大量重复代码，格式基本相同，无非参数不一样。有没有更优雅的方式，来对这些代码再次优化呢？ 这就是我们接下来要学的Feign的功能了。 简介 有道词典的英文解释： ​ 为什么叫伪装？ Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。 项目主页：https://github.com/OpenFeign/feign 快速入门 导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; Feign的客户端 123456@FeignClient("user-service")public interface UserFeignClient &#123; @GetMapping("/user/&#123;id&#125;") User queryUserById(@PathVariable("id") Long id);&#125; 首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像 @FeignClient，声明这是一个Feign客户端，类似@Mapper注解。同时通过value属性指定服务名称 接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果 改造原来的调用逻辑，不再调用UserDao： 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserFeignClient userFeignClient; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.userFeignClient.queryUserById(id)); &#125;); return users; &#125;&#125; 开启Feign功能 我们在启动类上，添加注解，开启Feign功能 123456789@SpringBootApplication@EnableDiscoveryClient@EnableHystrix@EnableFeignClients // 开启Feign功能public class UserConsumerDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserConsumerDemoApplication.class, args); &#125;&#125; 你会发现RestTemplate的注册被我删除了。Feign中已经自动集成了Ribbon负载均衡，因此我们不需要自己定义RestTemplate了 启动测试： 访问接口： 正常获取到了结果。 负载均衡 Feign中本身已经集成了Ribbon依赖和自动配置： ​ 因此我们不需要额外引入依赖，也不需要再注册RestTemplate对象。 另外，我们可以像上节课中讲的那样去配置Ribbon，可以通过ribbon.xx来进行全局配置。也可以通过服务名.ribbon.xx来对指定服务配置： 1234567user-service: ribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 1000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数 Hystix支持 Feign默认也有对Hystix的集成： ​ 只不过，默认情况下是关闭的。我们需要通过下面的参数来开启： 123feign: hystrix: enabled: true # 开启Feign的熔断功能 但是，Feign中的Fallback配置不像Ribbon中那样简单了。 1）首先，我们要定义一个类，实现刚才编写的UserFeignClient，作为fallback的处理类 12345678910@Componentpublic class UserFeignClientFallback implements UserFeignClient &#123; @Override public User queryUserById(Long id) &#123; User user = new User(); user.setId(id); user.setName("用户查询出现异常！"); return user; &#125;&#125; 2）然后在UserFeignClient中，指定刚才编写的实现类 123456@FeignClient(value = "user-service", fallback = UserFeignClientFallback.class)public interface UserFeignClient &#123; @GetMapping("/user/&#123;id&#125;") User queryUserById(@PathVariable("id") Long id);&#125; 3）重启测试： 我们关闭user-service服务，然后在页面访问： 请求压缩(了解) Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能： 123456feign: compression: request: enabled: true # 开启请求压缩 response: enabled: true # 开启响应压缩 同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置： 123456feign: compression: request: enabled: true # 开启请求压缩 mime-types: text/html,application/xml,application/json # 设置压缩的数据类型 min-request-size: 2048 # 设置触发压缩的大小下限 注：上面的数据类型、压缩大小下限均为默认值。 日志级别(了解) 前面讲过，通过logging.level.xx=debug来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为@FeignClient注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。 1）设置com.leyou包下的日志级别都为debug 123logging: level: com.leyou: debug 2）编写配置类，定义日志级别 1234567@Configurationpublic class FeignConfig &#123; @Bean Logger.Level feignLoggerLevel()&#123; return Logger.Level.FULL; &#125;&#125; 这里指定的Level级别是FULL，Feign支持4种级别： ​ NONE：不记录任何日志信息，这是默认值。 BASIC：仅记录请求的方法，URL以及响应状态码和执行时间 HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息 FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。 3）在FeignClient中指定配置类： 12345@FeignClient(value = "user-service", fallback = UserFeignClientFallback.class, configuration = FeignConfig.class)public interface UserFeignClient &#123; @GetMapping("/user/&#123;id&#125;") User queryUserById(@PathVariable("id") Long id);&#125; 4）重启项目，即可看到每次访问的日志： Zuul网关 通过前面的学习，使用Spring Cloud实现微服务的架构基本成型，大致是这样的： 我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。 在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？ 先来说说这样架构需要做的一些事儿以及存在的不足： 首先，破坏了服务无状态特点。 为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。 从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。 其次，无法直接复用既有接口。 当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。 面对类似上面的问题，我们要如何解决呢？答案是：服务网关！ 为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器的 服务网关。 服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。 简介 官网：https://github.com/Netflix/zuul ​ Zuul：维基百科： 电影《捉鬼敢死队》中的怪兽，Zuul，在纽约引发了巨大骚乱。 事实上，在微服务架构中，Zuul就是守门的大Boss！一夫当关，万夫莫开！ Zuul加入后的架构 不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。 快速入门 新建工程 填写基本信息： 添加Zuul依赖： 编写启动类 通过@EnableZuulProxy注解开启Zuul的功能： 12345678@SpringBootApplication@EnableZuulProxy // 开启Zuul的网关功能public class ZuulDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125; 编写配置 12345server: port: 10010 #服务端口spring: application: name: api-gateway #指定服务名 编写路由规则 我们需要用Zuul来代理user-service服务，先看一下控制面板中的服务状态： ip为：127.0.0.1 端口为：8081 映射规则： 12345zuul: routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 url: http://127.0.0.1:8081 # 映射路径对应的实际url地址 我们将符合path 规则的一切请求，都代理到 url参数指定的地址 本例中，我们将 /user-service/**开头的请求，代理到http://127.0.0.1:8081 启动测试： 访问的路径中需要加上配置规则的映射路径，我们访问：http://127.0.0.1:8081/user-service/user/10 ​ 面向服务的路由 在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。 我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！ 添加Eureka客户端依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 开启Eureka客户端发现功能 123456789@SpringBootApplication@EnableZuulProxy // 开启Zuul的网关功能@EnableDiscoveryClientpublic class ZuulDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125; 添加Eureka配置，获取服务信息 12345678eureka: client: registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true ip-address: 127.0.0.1 修改映射配置，通过服务名称获取 因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。 12345zuul: routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 serviceId: user-service # 指定服务名称 启动测试 再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问： ​ 日志中可以看到使用了负载均衡器： 简化的路由配置 在刚才的配置中，我们的规则是这样的： zuul.routes.&lt;route&gt;.path=/xxx/**： 来指定映射路径。&lt;route&gt;是自定义的路由名 zuul.routes.&lt;route&gt;.serviceId=/user-service：来指定服务名。 而大多数情况下，我们的&lt;route&gt;路由名称往往和 服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：zuul.routes.&lt;serviceId&gt;=&lt;path&gt; 比方说上面我们关于user-service的配置可以简化为一条： 123zuul: routes: user-service: /user-service/** # 这里是映射路径 省去了对服务名称的配置。 默认的路由规则 在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则： 默认情况下，一切服务的映射路径就是服务名本身。 例如服务名为：user-service，则默认的映射路径就是：/user-service/** 也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。 路由前缀 配置示例： 123456zuul: prefix: /api # 添加路由前缀 routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 service-id: user-service # 指定服务名称 我们通过zuul.prefix=/api来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。 路径/api/user-service/user/1将会被代理到/user-service/user/1 过滤器 Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。 ZuulFilter ZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法： 12345678910public abstract ZuulFilter implements IZuulFilter&#123; abstract public String filterType(); abstract public int filterOrder(); boolean shouldFilter();// 来自IZuulFilter Object run() throws ZuulException;// IZuulFilter&#125; shouldFilter：返回一个Boolean值，判断该过滤器是否需要执行。返回true执行，返回false不执行。 run：过滤器的具体业务逻辑。 filterType：返回字符串，代表过滤器的类型。包含以下4种： pre：请求在被路由之前执行 routing：在路由请求时调用 post：在routing和errror过滤器之后调用 error：处理请求时发生错误调用 filterOrder：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。 过滤器执行生命周期： 这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。 ​ 正常流程： 请求到达首先会经过pre类型过滤器，而后到达routing类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。 异常流程： 整个过程中，pre或者routing过滤器出现异常，都会直接进入error过滤器，再error处理完毕后，会将请求交给POST过滤器，最后返回给用户。 如果是error过滤器自己出现异常，最终也会进入POST过滤器，而后返回。 如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和routing不同的时，请求不会再到达POST过滤器了。 所有内置过滤器列表： ​ 使用场景 场景非常多： 请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了 异常处理：一般会在error类型和post类型过滤器中结合来处理。 服务调用时长统计：pre和post结合使用。 自定义过滤器 接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。 定义过滤器类 12345678910111213141516171819202122232425262728293031323334353637383940@Componentpublic class LoginFilter extends ZuulFilter&#123; @Override public String filterType() &#123; // 登录校验，肯定是在前置拦截 return "pre"; &#125; @Override public int filterOrder() &#123; // 顺序设置为1 return 1; &#125; @Override public boolean shouldFilter() &#123; // 返回true，代表过滤器生效。 return true; &#125; @Override public Object run() throws ZuulException &#123; // 登录校验逻辑。 // 1）获取Zuul提供的请求上下文对象 RequestContext ctx = RequestContext.getCurrentContext(); // 2) 从上下文中获取request对象 HttpServletRequest req = ctx.getRequest(); // 3) 从请求中获取token String token = req.getParameter("access-token"); // 4) 判断 if(token == null || "".equals(token.trim()))&#123; // 没有token，登录校验失败，拦截 ctx.setSendZuulResponse(false); // 返回401状态码。也可以考虑重定向到登录页。 ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value()); &#125; // 校验通过，可以考虑把用户信息放入上下文，继续向后执行 return null; &#125;&#125; 测试 没有token参数时，访问失败： ​ 添加token参数后： ​ 负载均衡和熔断 Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置： 123456789101112131415zuul: retryable: trueribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 2000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 2 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 6000 # 熔断超时时长：6000ms]]></content>
  </entry>
  <entry>
    <title><![CDATA[day02-认识微服务]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F24%2Fday02-%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[学习目标 了解系统架构的演变 了解RPC与Http的区别 掌握HttpClient的简单使用 知道什么是SpringCloud 独立搭建Eureka注册中心 独立配置Robbin负载均衡 -Xms128m -Xmx128m 系统架构演变 随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。我们到底是该乘坐微服务的船只驶向远方，还是偏安一隅得过且过？ 其实生活不止眼前的苟且，还有诗和远方。所以我们今天就回顾历史，看一看系统架构演变的历程；把握现在，学习现在最火的技术架构；展望未来，争取成为一名优秀的Java工程师。 集中式架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。 存在的问题： 代码耦合，开发维护困难 无法针对不同模块进行针对性优化 无法水平扩展 单点容错率低，并发能力差 垂直拆分 当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分： 优点： 系统拆分实现了流量分担，解决了并发问题 可以针对不同模块进行优化 方便水平扩展，负载均衡，容错率提高 缺点： 系统间相互独立，会有很多重复开发工作，影响开发效率 分布式服务 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。 优点： 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率 缺点： 系统间耦合度变高，调用关系错综复杂，难以维护 服务治理（SOA） 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键 以前出现了什么问题？ 服务越来越多，需要管理每个服务的地址 调用关系错综复杂，难以理清依赖关系 服务过多，服务状态难以管理，无法根据服务情况动态管理 服务治理要做什么？ 服务注册中心，实现服务自动注册和发现，无需人为记录服务地址 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系 动态监控服务状态监控报告，人为控制服务状态 缺点： 服务间会有依赖关系，一旦某个环节出错会影响较大 服务关系复杂，运维、测试部署困难，不符合DevOps思想 微服务 前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实缺有一些差别： 微服务的特点： 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 面向服务：面向服务是说每个服务都要对外暴露服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。 自治：自治是说服务间互相独立，互不干扰 团队独立：每个服务都是一个独立的开发团队，人数不能过多。 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口 数据库分离：每个服务都使用自己的数据源 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护 微服务结构图： 远程调用方式 无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？ 常见的远程调用方式有以下几种： RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型 Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。 现在热门的Rest风格，就可以通过http协议来实现。 认识RPC RPC，即 Remote Procedure Call（远程过程调用），是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。说得通俗一点就是：A计算机提供一个服务，B计算机可以像调用本地服务那样调用A计算机的服务。 通过上面的概念，我们可以知道，实现RPC主要是做到两点： 实现远程调用其他计算机的服务 要实现远程调用，肯定是通过网络传输数据。A程序提供服务，B程序通过网络将请求参数传递给A，A本地执行后得到结果，再将结果返回给B程序。这里需要关注的有两点： 1）采用何种网络通讯协议？ 现在比较流行的RPC框架，都会采用TCP作为底层传输协议 2）数据传输的格式怎样？ 两个程序进行通讯，必须约定好数据传输格式。就好比两个人聊天，要用同一种语言，否则无法沟通。所以，我们必须定义好请求和响应的格式。另外，数据在网路中传输需要进行序列化，所以还需要约定统一的序列化的方式。 像调用本地服务一样调用远程服务 如果仅仅是远程调用，还不算是RPC，因为RPC强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装 RPC调用流程图： 想要了解详细的RPC实现，给大家推荐一篇文章：自己动手实现RPC 认识Http Http协议：超文本传输协议，是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。说到这里，大家可能觉得，Http与RPC的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求，有响应。没错，在这点来看，两者非常相似，但是还是有一些细微差别。 RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。 Http中还定义了资源定位的路径，RPC中并不需要 最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。 优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台 缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境。 例如我们通过浏览器访问网站，就是通过Http协议。只不过浏览器把请求封装，发起请求以及接收响应，解析响应的事情都帮我们做了。如果是不通过浏览器，那么这些事情都需要自己去完成。 如何选择？ 既然两种方式都可以实现远程调用，我们该如何选择呢？ 速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩。 难度来看，RPC实现较为复杂，http相对比较简单 灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。 因此，两者都有不同的使用场景： 如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。 如果需要更加灵活，跨语言、跨平台，显然http更合适 那么我们该怎么选择呢？ 微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。 Http客户端工具 既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如： HttpClient OKHttp URLConnection 接下来，我们就一起了解一款比较流行的客户端工具：HttpClient HttpClient 介绍 HttpClient是Apache公司的产品，是Http Components下的一个组件。 官网地址：http://hc.apache.org/index.html 特点： 基于标准、纯净的Java语言。实现了Http1.0和Http1.1 以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE） 支持HTTPS协议。 通过Http代理建立透明的连接。 自动处理Set-Cookie中的Cookie。 使用 我们导入课前资料提供的demo工程：《http-demo》 发起get请求： 123456@Testpublic void testGet() throws IOException &#123; HttpGet request = new HttpGet("http://www.baidu.com"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response);&#125; 发起Post请求： 12345678@Testpublic void testPost() throws IOException &#123; HttpPost request = new HttpPost("http://www.oschina.net/"); request.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response);&#125; 尝试访问昨天编写的接口：http://localhost/hello 这个接口返回一个User对象 123456@Testpublic void testGetPojo() throws IOException &#123; HttpGet request = new HttpGet("http://localhost/hello"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response);&#125; 我们实际得到的是一个json字符串： 123456789101112&#123; "id": 8, "userName": "liuyan", "password": "123456", "name": "柳岩", "age": 21, "sex": 2, "birthday": "1995-08-07T16:00:00.000+0000", "created": "2014-09-20T03:41:15.000+0000", "updated": "2014-09-20T03:41:15.000+0000", "note": "柳岩同学在传智播客学表演"&#125; 如果想要得到对象，我们还需要手动进行Json反序列化，这一点比较麻烦。 Json转换工具 HttpClient请求数据后是json字符串，需要我们自己把Json字符串反序列化为对象，我们会使用JacksonJson工具来实现。 JacksonJson是SpringMVC内置的json处理工具，其中有一个ObjectMapper类，可以方便的实现对json的处理： 对象转json 12345678910111213// json处理工具 private ObjectMapper mapper = new ObjectMapper(); @Test public void testJson() throws JsonProcessingException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化 String json = mapper.writeValueAsString(user); System.out.println("json = " + json); &#125; 结果： json转普通对象 12345678910111213141516// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化 String json = mapper.writeValueAsString(user); // 反序列化，接收两个参数：json数据，反序列化的目标类字节码 User result = mapper.readValue(json, User.class); System.out.println("result = " + result);&#125; 结果： json转集合 json转集合比较麻烦，因为你无法同时把集合的class和元素的class同时传递到一个参数。 因此Jackson做了一个类型工厂，用来解决这个问题： 12345678910111213141516171819// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化,得到对象集合的json字符串 String json = mapper.writeValueAsString(Arrays.asList(user, user)); // 反序列化，接收两个参数：json数据，反序列化的目标类字节码 List&lt;User&gt; users = mapper.readValue(json, mapper.getTypeFactory().constructCollectionType(List.class, User.class)); for (User u : users) &#123; System.out.println("u = " + u); &#125;&#125; 结果： json转任意复杂类型 当对象泛型关系复杂时，类型工厂也不好使了。这个时候Jackson提供了TypeReference来接收类型泛型，然后底层通过反射来获取泛型上的具体类型。实现数据转换。 12345678910111213141516171819// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化,得到对象集合的json字符串 String json = mapper.writeValueAsString(Arrays.asList(user, user)); // 反序列化，接收两个参数：json数据，反序列化的目标类字节码 List&lt;User&gt; users = mapper.readValue(json, new TypeReference&lt;List&lt;User&gt;&gt;()&#123;&#125;); for (User u : users) &#123; System.out.println("u = " + u); &#125;&#125; 结果： Spring的RestTemplate Spring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持： HttpClient OkHttp JDK原生的URLConnection（默认的） 首先在项目中注册一个RestTemplate对象，可以在启动类位置注册： 12345678910111213@SpringBootApplicationpublic class HttpDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HttpDemoApplication.class, args); &#125; @Bean public RestTemplate restTemplate() &#123; // 默认的RestTemplate，底层是走JDK的URLConnection方式。 return new RestTemplate(); &#125;&#125; 在测试类中直接@Autowired注入： 12345678910111213@RunWith(SpringRunner.class)@SpringBootTest(classes = HttpDemoApplication.class)public class HttpDemoApplicationTests &#123; @Autowired private RestTemplate restTemplate; @Test public void httpGet() &#123; User user = this.restTemplate.getForObject("http://localhost/hello", User.class); System.out.println(user); &#125;&#125; 通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。 学习完了Http客户端工具，接下来就可以正式学习微服务了。 初始SpringCloud 微服务是一种架构方式，最终肯定需要技术架构去实施。 微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？ 后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。 技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了 群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？SpringCloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。 使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建 简介 SpringCloud是Spring旗下的项目之一，官网地址：http://projects.spring.io/spring-cloud/ Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。 SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括： netflix Eureka：注册中心 Zuul：服务网关 Ribbon：负载均衡 Feign：服务调用 Hystix：熔断器 以上只是其中一部分，架构图： 版本 SpringCloud的版本命名比较特殊，因为它不是一个组件，而是许多组件的集合，它的命名是以A到Z的为首字母的一些单词组成： 我们在项目中，会是以Finchley的版本。 其中包含的组件，也都有各自的版本，如下表： Component Edgware.SR3 Finchley.RC1 Finchley.BUILD-SNAPSHOT spring-cloud-aws 1.2.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-bus 1.3.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-cli 1.4.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-commons 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-contract 1.2.4.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-config 1.4.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-netflix 1.4.4.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-security 1.2.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-cloudfoundry 1.1.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-consul 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-sleuth 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-stream Ditmars.SR3 Elmhurst.RELEASE Elmhurst.BUILD-SNAPSHOT spring-cloud-zookeeper 1.2.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-boot 1.5.10.RELEASE 2.0.1.RELEASE 2.0.0.BUILD-SNAPSHOT spring-cloud-task 1.2.2.RELEASE 2.0.0.RC1 2.0.0.RELEASE spring-cloud-vault 1.1.0.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-gateway 1.0.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-openfeign 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT 接下来，我们就一一学习SpringCloud中的重要组件。 微服务场景模拟 首先，我们需要模拟一个服务调用的场景。方便后面学习微服务架构 服务提供者 我们新建一个项目，对外提供查询用户的服务。 Spring脚手架创建工程 借助于Spring提供的快速搭建工具： 填写项目信息： 添加web依赖： 添加mybatis依赖： 填写项目位置： 生成的项目结构： 依赖也已经全部自动引入： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;user-service-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-service-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 当然，因为要使用通用mapper，所以我们需要手动加一条依赖： 12345&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 非常快捷啊！ 编写代码 添加一个对外查询的接口： 123456789101112@RestController@RequestMapping("user")public class UserController &#123; @Autowired private UserService userService; @GetMapping("/&#123;id&#125;") public User queryById(@PathVariable("id") Long id) &#123; return this.userService.queryById(id); &#125;&#125; Service： 12345678910@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id) &#123; return this.userMapper.selectByPrimaryKey(id); &#125;&#125; mapper: 123@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125; 实体类： 1234567891011121314151617181920212223242526272829303132333435363738@Table(name = "tb_user")public class User implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; // 用户名 private String userName; // 密码 private String password; // 姓名 private String name; // 年龄 private Integer age; // 性别，1男性，2女性 private Integer sex; // 出生日期 private Date birthday; // 创建时间 private Date created; // 更新时间 private Date updated; // 备注 private String note; // 。。。省略getters和setters&#125; 属性文件,这里我们采用了yaml语法，而不是properties： 123456789101112server: port: 8081spring: datasource: url: jdbc:mysql://localhost:3306/mydb01 username: root password: 123 hikari: maximum-pool-size: 20 minimum-idle: 10mybatis: type-aliases-package: com.leyou.userservice.pojo 项目结构： 启动并测试： 启动项目，访问接口：http://localhost:8081/user/7 服务调用者 创建工程 与上面类似，这里不再赘述，需要注意的是，我们调用user-service的功能，因此不需要mybatis相关依赖了。 pom： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;user-consumer-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-consumer-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 添加OkHttp支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 编写代码 首先在启动类中注册RestTemplate： 12345678910111213@SpringBootApplicationpublic class UserConsumerDemoApplication &#123; @Bean public RestTemplate restTemplate() &#123; // 这次我们使用了OkHttp客户端,只需要注入工厂即可 return new RestTemplate(new OkHttp3ClientHttpRequestFactory()); &#125; public static void main(String[] args) &#123; SpringApplication.run(UserConsumerDemoApplication.class, args); &#125;&#125; 然后编写UserDao，注意，这里不是调用mapper查数据库，而是通过RestTemplate远程查询user-service-demo中的接口： 1234567891011@Componentpublic class UserDao &#123; @Autowired private RestTemplate restTemplate; public User queryUserById(Long id)&#123; String url = "http://localhost:8081/user/" + id; return this.restTemplate.getForObject(url, User.class); &#125;&#125; 然后编写user-service，循环查询UserDAO信息： 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserDao userDao; public List&lt;User&gt; querUserByIds(List&lt;Long&gt; ids)&#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); for (Long id : ids) &#123; User user = this.userDao.queryUserById(id); users.add(user); &#125; return users; &#125;&#125; 编写controller： 123456789101112@RestController@RequestMapping("consume")public class ConsumerController &#123; @Autowired private UserService userService; @GetMapping public List&lt;User&gt; consume(@RequestParam("ids") List&lt;Long&gt; ids) &#123; return this.userService.queryUserByIds(ids); &#125;&#125; 启动测试： 因为我们没有配置端口，那么默认就是8080，我们访问：http://localhost:8080/consume?ids=6,7,8 一个简单的远程服务调用案例就实现了。 有没有问题？ 简单回顾一下，刚才我们写了什么： use-service-demo：一个提供根据id查询用户的微服务 consumer-demo：一个服务调用者，通过RestTemplate远程调用user-service-demo 流程如下： 存在什么问题？ 在consumer中，我们把url地址硬编码到了代码中，不方便后期维护 consumer需要记忆user-service的地址，如果出现变更，可能得不到通知，地址将失效 consumer不清楚user-service的状态，服务宕机也不知道 user-service只有1台服务，不具备高可用性 即便user-service形成集群，consumer还需自己实现负载均衡 其实上面说的问题，概括一下就是分布式服务必然要面临的问题： 服务管理 如何自动注册和发现 如何实现状态监管 如何实现动态路由 服务如何实现负载均衡 服务如何解决容灾问题 服务如何实现统一配置 以上的问题，我们都将在SpringCloud中得到答案。 Eureka注册中心 认识Eureka 首先我们来解决第一问题，服务的管理。 问题分析 在刚才的案例中，user-service对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。这在服务较少的时候并不觉得有什么，但是在现在日益复杂的互联网环境，一个项目肯定会拆分出十几，甚至数十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。 网约车 这就好比是 网约车出现以前，人们出门叫车只能叫出租车。一些私家车想做出租却没有资格，被称为黑车。而很多人想要约车，但是无奈出租车太少，不方便。私家车很多却不敢拦，而且满大街的车，谁知道哪个才是愿意载人的。一个想要，一个愿意给，就是缺少引子，缺乏管理啊。 此时滴滴这样的网约车平台出现了，所有想载客的私家车全部到滴滴注册，记录你的车型（服务类型），身份信息（联系方式）。这样提供服务的私家车，在滴滴那里都能找到，一目了然。 此时要叫车的人，只需要打开APP，输入你的目的地，选择车型（服务类型），滴滴自动安排一个符合需求的车到你面前，为你服务，完美！ Eureka做什么？ Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。 同时，服务提供方与Eureka之间通过“心跳”机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。 这就实现了服务的自动注册、发现、状态监控。 原理图 基本架构： Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址 提供者：启动后向Eureka注册自己信息（地址，提供什么服务） 消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态 入门案例 编写EurekaServer 接下来我们创建一个项目，启动一个EurekaServer： 依然使用spring提供的快速搭建工具： 选择依赖： 完整的Pom文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;eureka-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eureka-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!-- SpringCloud版本，是最新的F系列 --&gt; &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Eureka服务端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringCloud依赖，一定要放到dependencyManagement中，起到管理版本的作用即可 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 编写启动类： 12345678@SpringBootApplication@EnableEurekaServer // 声明这个应用是一个EurekaServerpublic class EurekaDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaDemoApplication.class, args); &#125;&#125; 编写配置： 1234567891011server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: register-with-eureka: false # 是否注册自己的信息到EurekaServer，默认是true fetch-registry: false # 是否拉取其它服务的信息，默认是true service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。 defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka 启动服务，并访问：http://127.0.0.1:10086/eureka 将user-service注册到Eureka 注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。 我们在user-service-demo中添加Eureka客户端依赖： 先添加SpringCloud依赖： 1234567891011121314151617181920212223&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.RC1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- Spring的仓库地址 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 然后是Eureka客户端： 12345&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类上开启Eureka客户端功能 通过添加@EnableDiscoveryClient来开启Eureka客户端功能 1234567@SpringBootApplication@EnableDiscoveryClient // 开启EurekaClient功能public class UserServiceDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserServiceDemoApplication.class, args); &#125;&#125; 编写配置 123456789101112131415161718192021server: port: 8081spring: datasource: url: jdbc:mysql://localhost:3306/mydb01 username: root password: 123 hikari: maximum-pool-size: 20 minimum-idle: 10 application: name: user-service # 应用名称mybatis: type-aliases-package: com.leyou.userservice.pojoeureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true # 当调用getHostname获取实例的hostname时，返回ip而不是host名称 ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找 注意： 这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。 不用指定register-with-eureka和fetch-registry，因为默认是true 重启项目，访问Eureka监控页面查看 我们发现user-service服务已经注册成功了 消费者从Eureka获取服务 接下来我们修改consumer-demo，尝试从EurekaServer获取服务。 方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！ 1）添加依赖： 先添加SpringCloud依赖： 1234567891011121314151617181920212223&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.RC1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- Spring的仓库地址 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 然后是Eureka客户端： 12345&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 2）在启动类开启Eureka客户端 1234567891011@SpringBootApplication@EnableDiscoveryClient // 开启Eureka客户端public class UserConsumerDemoApplication &#123; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(new OkHttp3ClientHttpRequestFactory()); &#125; public static void main(String[] args) &#123; SpringApplication.run(UserConsumerDemoApplication.class, args); &#125;&#125; 3）修改配置： 123456789101112server: port: 8080spring: application: name: consumer # 应用名称eureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true # 当其它服务获取地址时提供ip而不是hostname ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找 4）修改代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例： 12345678910111213141516171819202122232425262728293031@Servicepublic class UserService &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient;// Eureka客户端，可以获取到服务实例信息 public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); // String baseUrl = "http://localhost:8081/user/"; // 根据服务名称，获取服务实例 List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances("user-service"); // 因为只有一个UserService,因此我们直接get(0)获取 ServiceInstance instance = instances.get(0); // 获取ip和端口信息 String baseUrl = "http://"+instance.getHost() + ":" + instance.getPort()+"/user/"; ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.restTemplate.getForObject(baseUrl + id, User.class)); // 每次间隔500毫秒 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); return users; &#125;&#125; 5）Debug跟踪运行： 生成的URL： 访问结果： Eureka详解 接下来我们详细讲解Eureka的原理及配置。 基础架构 Eureka架构中的三个核心角色： 服务注册中心 Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的eureka-demo 服务提供者 提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的user-service-demo 服务消费者 消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的consumer-demo 高可用的Eureka Server Eureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。 服务同步 多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现数据同步。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。 动手搭建高可用的EurekaServer 我们假设要搭建两条EurekaServer的集群，端口分别为：10086和10087 1）我们修改原来的EurekaServer配置： 123456789server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10087/eureka 所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改： 删除了register-with-eureka=false和fetch-registry=false两个配置。因为默认值是true，这样就会吧自己注册到注册中心了。 把service-url的值改成了另外一台EurekaServer的地址，而不是自己 2）另外一台配置恰好相反： 123456789server: port: 10087 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10086/eureka 注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器： 然后启动即可。 3）启动测试： 4）客户端注册服务到集群 因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化： 1234eureka: client: service-url: # EurekaServer地址,多个地址以','隔开 defaultZone: http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka 服务提供者 服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。 服务注册 服务提供者在启动时，会检测配置属性中的：eureka.client.register-with-erueka=true参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。第一层Map的Key就是服务名称，第二层Map的key是服务的实例id。 服务续约 在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）； 有两个重要参数可以修改服务续约的行为： 1234eureka: instance: lease-expiration-duration-in-seconds: 90 lease-renewal-interval-in-seconds: 30 lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒 lease-expiration-duration-in-seconds：服务失效时间，默认值90秒 也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。 但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。 1234eureka: instance: lease-expiration-duration-in-seconds: 10 # 10秒即过期 lease-renewal-interval-in-seconds: 5 # 5秒一次心跳 实例id 先来看一下服务状态信息： 在Eureka监控页面，查看服务注册信息： 在status一列中，显示以下信息： UP(1)：代表现在是启动了1个示例，没有集群 DESKTOP-2MVEC12:user-service:8081：是示例的名称（instance-id）， 默认格式是：${hostname} + ${spring.application.name} + ${server.port} instance-id是区分同一服务的不同实例的唯一标准，因此不能重复。 我们可以通过instance-id属性来修改它的构成： 123eureka: instance: instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 重启服务再试试看： 服务消费者 获取服务列表 当服务消费者启动是，会检测eureka.client.fetch-registry=true参数的值，如果为true，则会从Eureka Server服务的列表只读备份，然后缓存在本地。并且每隔30秒会重新获取并更新数据。我们可以通过下面的参数来修改： 123eureka: client: registry-fetch-interval-seconds: 5 生产环境中，我们不需要修改这个值。 但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。 失效剔除和自我保护 失效剔除 有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。 可以通过eureka.server.eviction-interval-timer-in-ms参数对其进行修改，单位是毫秒，生成环境不要修改。 这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如10S 自我保护 我们关停一个服务，就会在Eureka面板看到一条警告： 这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。 但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式： 1234eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms） 负载均衡Robbin 在刚才的案例中，我们启动了一个user-service，然后通过DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。 但是实际环境中，我们往往会开启很多个user-service的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？ 一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。 不过Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。 什么是Ribbon： 接下来，我们就来使用Ribbon实现负载均衡。 启动两个服务实例 首先我们启动两个user-service实例，一个8081，一个8082。 Eureka监控面板： 开启负载均衡 因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖。直接修改代码： 在RestTemplate的配置方法上添加@LoadBalanced注解： 12345@Bean@LoadBalancedpublic RestTemplate restTemplate() &#123; return new RestTemplate(new OkHttp3ClientHttpRequestFactory());&#125; 修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用： 1234567891011121314151617181920212223242526@Servicepublic class UserService &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); // 地址直接写服务名称即可 String baseUrl = "http://user-service/user/"; ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.restTemplate.getForObject(baseUrl + id, User.class)); // 每次间隔500毫秒 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); return users; &#125;&#125; 访问页面，查看结果： 完美！ 源码跟踪 为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。 显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor 我们进行源码跟踪： 继续跟入execute方法：发现获取了8082端口的服务 再跟下一次，发现获取的是8081： 负载均衡策略 Ribbon默认的负载均衡策略是简单的轮询，我们可以测试一下： 编写测试类，在刚才的源码中我们看到拦截中是使用RibbonLoadBalanceClient来进行负载均衡的，其中有一个choose方法，是这样介绍的： 现在这个就是负载均衡获取实例的方法。 我们对注入这个类的对象，然后对其测试： 123456789101112131415@RunWith(SpringRunner.class)@SpringBootTest(classes = UserConsumerDemoApplication.class)public class LoadBalanceTest &#123; @Autowired RibbonLoadBalancerClient client; @Test public void test()&#123; for (int i = 0; i &lt; 100; i++) &#123; ServiceInstance instance = this.client.choose("user-service"); System.out.println(instance.getHost() + ":" + instance.getPort()); &#125; &#125;&#125; 结果： 符合了我们的预期推测，确实是轮询方式。 我们是否可以修改负载均衡的策略呢？ 继续跟踪源码，发现这么一段代码： 我们看看这个rule是谁： 这里的rule默认值是一个RoundRobinRule，看类的介绍： 这不就是轮询的意思嘛。 我们注意到，这个类其实是实现了接口IRule的，查看一下： 定义负载均衡的规则接口。 它有以下实现： SpringBoot也帮我们提供了修改负载均衡规则的配置入口： 123user-service: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 格式是：{服务名称}.ribbon.NFLoadBalancerRuleClassName，值就是IRule的实现类。 再次测试，发现结果变成了随机： 重试机制 Eureka的服务治理强调了CAP原则中的AP，即可用性和可靠性。它与Zookeeper这一类强调CP（一致性，可靠性）的服务治理框架最大的区别在于：Eureka为了实现更高的服务可用性，牺牲了一定的一致性，极端情况下它宁愿接收故障实例也不愿丢掉健康实例，正如我们上面所说的自我保护机制。 但是，此时如果我们调用了这些不正常的服务，调用就会失败，从而导致其它服务不能正常工作！这显然不是我们愿意看到的。 我们现在关闭一个user-service实例： 因为服务剔除的延迟，consumer并不会立即得到最新的服务列表，此时再次访问你会得到错误提示： 但是此时，8081服务其实是正常的。 因此Spring Cloud 整合了Spring Retry 来增强RestTemplate的重试能力，当一次服务调用失败后，不会立即抛出一次，而是再次重试另一个服务。 只需要简单配置即可实现Ribbon的重试： 123456789101112spring: cloud: loadbalancer: retry: enabled: true # 开启Spring Cloud的重试功能user-service: ribbon: ConnectTimeout: 250 # Ribbon的连接超时时间 ReadTimeout: 1000 # Ribbon的数据读取超时时间 OkToRetryOnAllOperations: true # 是否对所有操作都进行重试 MaxAutoRetriesNextServer: 1 # 切换实例的重试次数 MaxAutoRetries: 1 # 对当前实例的重试次数 根据如上配置，当访问到某个服务超时后，它会再次尝试访问下一个服务实例，如果不行就再换一个实例，如果不行，则返回失败。切换次数取决于MaxAutoRetriesNextServer参数的值 引入spring-retry依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt; &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;&lt;/dependency&gt; 我们重启user-consumer-demo，测试，发现即使user-service2宕机，也能通过另一台服务实例获取到结果！]]></content>
  </entry>
  <entry>
    <title><![CDATA[day01-springboot]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F24%2Fday01-springboot%2F</url>
    <content type="text"><![CDATA[学习目标 了解SpringBoot的作用 掌握java配置的方式 了解SpringBoot自动配置原理 掌握SpringBoot的基本使用 了解Thymeleaf的基本使用 了解SpringBoot 在这一部分，我们主要了解以下3个问题： 什么是SpringBoot 为什么要学习SpringBoot SpringBoot的特点 什么是SpringBoot SpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品: 我们可以看到下面的一段介绍： Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. 翻译一下： 用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。 其实人们把Spring Boot 称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。 为什么要学习SpringBoot java一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因注意是两点： 复杂的配置， 项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。 一个是混乱的依赖管理。 项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。 而SpringBoot让这一切成为过去！ Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。 我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。 SpringBoot的特点 Spring Boot 主要目标是： 为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验 开箱即用（启动器starter-其实就是SpringBoot提供的一个jar包），但通过自己设置参数（.properties），即可快速摆脱这种方式。 提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等 绝对没有代码生成，也无需 XML 配置。 更多细节，大家可以到官网查看。 快速入门 接下来，我们就来利用SpringBoot搭建一个web工程，体会一下SpringBoot的魅力所在！ 创建工程 我们先新建一个空的工程： 工程名为demo： 新建一个model： 使用maven来构建： 然后填写项目坐标： 目录结构： 项目结构： 添加依赖 看到这里很多同学会有疑惑，前面说传统开发的问题之一就是依赖管理混乱，怎么这里我们还需要管理依赖呢？难道SpringBoot不帮我们管理吗？ 别着急，现在我们的项目与SpringBoot还没有什么关联。SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！ 添加父工程坐标 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;&lt;/parent&gt; 添加web启动器 为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为启动器。因为我们是web项目，这里我们引入web启动器： 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。 这个时候，我们会发现项目中多出了大量的依赖： 这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。 管理jdk版本 默认情况下，maven工程的jdk版本是1.5，而我们开发使用的是1.8，因此这里我们需要修改jdk版本，只需要简单的添加以下属性即可： 123&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt; 完整pom 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 启动类 Spring Boot项目通过main函数即可启动，我们需要创建一个启动类： 然后编写main函数： 123456@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 编写controller 接下来，我们就可以像以前那样开发SpringMVC的项目了！ 我们编写一个controller： 代码： 12345678@RestControllerpublic class HelloController &#123; @GetMapping("hello") public String hello()&#123; return "hello, spring boot!"; &#125;&#125; 启动测试 接下来，我们运行main函数，查看控制台： 并且可以看到监听的端口信息： 1）监听的端口是8080 2）SpringMVC的映射路径是：/ 3）/hello路径已经映射到了HelloController中的hello()方法 打开页面访问：http://localhost:8080/hello 测试成功了！ Java配置 在入门案例中，我们没有任何的配置，就可以实现一个SpringMVC的项目了，快速、高效！ 但是有同学会有疑问，如果没有任何的xml，那么我们如果要配置一个Bean该怎么办？比如我们要配置一个数据库连接池，以前会这么玩： 1234567&lt;!-- 配置连接池 --&gt;&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt;&lt;/bean&gt; 现在该怎么做呢？ 回顾历史 事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史： Spring1.0时代 在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒 Spring2.0时代 Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。 Spring3.0及以后 3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。 有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。 尝试java配置 java配置主要靠java类和一些注解，比较常用的注解有： @Configuration：声明一个类作为配置类，代替xml文件 @Bean：声明在方法上，将方法的返回值加入Bean容器，代替&lt;bean&gt;标签 @value：属性注入 @PropertySource：指定外部属性文件， 我们接下来用java配置来尝试实现连接池配置： 首先引入Druid连接池依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 创建一个jdbc.properties文件，编写jdbc属性： 1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/leyoujdbc.username=rootjdbc.password=123 然后编写代码： 1234567891011121314151617181920212223@Configuration@PropertySource("classpath:jdbc.properties")public class JdbcConfig &#123; @Value("$&#123;jdbc.url&#125;") String url; @Value("$&#123;jdbc.driverClassName&#125;") String driverClassName; @Value("$&#123;jdbc.username&#125;") String username; @Value("$&#123;jdbc.password&#125;") String password; @Bean public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setDriverClassName(driverClassName); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 解读： @Configuration：声明我们JdbcConfig是一个配置类 @PropertySource：指定属性文件的路径是:classpath:jdbc.properties 通过@Value为属性注入值 通过@Bean将 dataSource()方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。 然后我们就可以在任意位置通过@Autowired注入DataSource了！ 我们在HelloController中测试： 1234567891011@RestControllerpublic class HelloController &#123; @Autowired private DataSource dataSource; @GetMapping("hello") public String hello() &#123; return "hello, spring boot!" + dataSource; &#125;&#125; 然后Debug运行并查看： 属性注入成功了！ SpringBoot的属性注入 在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。 在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。 1）我们新建一个类，用来进行属性注入： 123456789@ConfigurationProperties(prefix = "jdbc")public class JdbcProperties &#123; private String url; private String driverClassName; private String username; private String password; // ... 略 // getters 和 setters&#125; 在类上通过@ConfigurationProperties注解声明当前类为属性读取类 prefix=&quot;jdbc&quot;读取属性文件中，前缀为jdbc的值。 在类上定义各个属性，名称必须与属性文件中jdbc.后面部分一致 需要注意的是，这里我们并没有指定属性文件的地址，所以我们需要把jdbc.properties名称改为application.properties，这是SpringBoot默认读取的属性文件名： 2）在JdbcConfig中使用这个属性： 1234567891011121314@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfig &#123; @Bean public DataSource dataSource(JdbcProperties jdbc) &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(jdbc.getUrl()); dataSource.setDriverClassName(jdbc.getDriverClassName()); dataSource.setUsername(jdbc.getUsername()); dataSource.setPassword(jdbc.getPassword()); return dataSource; &#125;&#125; 通过@EnableConfigurationProperties(JdbcProperties.class)来声明要使用JdbcProperties这个类的对象 然后你可以通过以下方式注入JdbcProperties： @Autowired注入 12@Autowiredprivate JdbcProperties prop; 构造函数注入 1234private JdbcProperties prop;public JdbcConfig(Jdbcproperties prop)&#123; this.prop = prop;&#125; 声明有@Bean的方法参数注入 1234@Beanpublic Datasource dataSource(JdbcProperties prop)&#123; // ...&#125; 本例中，我们采用第三种方式。 3）测试结果： 大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系： 优势： Relaxed binding：松散绑定 不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是user对象中的friend属性中的name属性，显然friend也是对象。@value注解就难以完成这样的注入方式。 meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。 ​ 更优雅的注入 事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可： 1234567891011@Configurationpublic class JdbcConfig &#123; @Bean // 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中 @ConfigurationProperties(prefix = "jdbc") public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); return dataSource; &#125;&#125; 我们直接把@ConfigurationProperties(prefix = &quot;jdbc&quot;)声明在需要使用的@Bean的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：该类必须有对应属性的set方法！ 我们将jdbc的url改成：/heima，再次测试： 自动配置原理 使用SpringBoot之后，一个整合了SpringMVC的WEB工程开发，变的无比简单，那些繁杂的配置都消失不见了，这是如何做到的？ 一切魔力的开始，都是从我们的main函数来的，所以我们再次来看下启动类： 我们发现特别的地方有两个： 注解：@SpringBootApplication run方法：SpringApplication.run() 我们分别来研究这两个部分。 了解@SpringBootApplication 点击进入，查看源码： 这里重点的注解有3个： @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan @SpringBootConfiguration 我们继续点击查看源码： 通过这段我们可以看出，在这个注解上面，又有一个@Configuration注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了@Configuration的类，并且读取其中的配置信息。而@SpringBootConfiguration是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。 @EnableAutoConfiguration 关于这个注解，官网上有一段说明： The second class-level annotation is @EnableAutoConfiguration. This annotationtells Spring Boot to “guess” how you want to configure Spring, based on the jardependencies that you have added. Since spring-boot-starter-web added Tomcatand Spring MVC, the auto-configuration assumes that you are developing a webapplication and sets up Spring accordingly. 简单翻译以下： 第二级的注解@EnableAutoConfiguration，告诉SpringBoot基于你所添加的依赖，去“猜测”你想要如何配置Spring。比如我们引入了spring-boot-starter-web，而这个启动器中帮我们添加了tomcat、SpringMVC的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！ 总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。 所以，我们使用SpringBoot构建一个项目，只需要引入所需框架的依赖，配置就可以交给SpringBoot处理了。除非你不希望使用SpringBoot的默认配置，它也提供了自定义配置的入口。 @ComponentScan 我们跟进源码： 并没有看到什么特殊的地方。我们查看注释： 大概的意思： 配置组件扫描的指令。提供了类似与&lt;context:component-scan&gt;标签的作用 通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包 而我们的@SpringBootApplication注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。因此，一般启动类会放在一个比较前的包目录中。 默认配置原理 默认配置类 通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了： 这些默认配置是在哪里定义的呢？ 为何依赖引入就会触发配置呢？ 其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类： 还有： 非常多，几乎涵盖了现在主流的开源框架，例如： redis jms amqp jdbc jackson mongodb jpa solr elasticsearch … 等等 我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类： 打开WebMvcAutoConfiguration： 我们看到这个类上的4个注解： @Configuration：声明这个类是一个配置类 @ConditionalOnWebApplication(type = Type.SERVLET) ConditionalOn，翻译就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程，显然我们就是 @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class }) 这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！ @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！ 接着，我们查看该类中定义了什么： 视图解析器： 处理器适配器（HandlerAdapter）： 还有很多，这里就不一一截图了。 默认配置属性 另外，这些默认配置的属性来自哪里呢？ 我们看到，这里通过@EnableAutoConfiguration注解引入了两个属性：WebMvcProperties和ResourceProperties。这不正是SpringBoot的属性注入玩法嘛。 我们查看这两个属性类： 找到了内部资源视图解析器的prefix和suffix属性。 ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径： 如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。 总结 SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个： 你引入了相关依赖 你自己没有配置 1）启动器 所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。 因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器，参考课前资料中提供的《SpringBoot启动器.txt》 2）全局配置 另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义application.properties文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。 因此，玩SpringBoot的第二件事情，就是通过application.properties来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key，非常多，参考课前资料提供的：《SpringBoot全局属性.md》 SpringBoot实践 接下来，我们来看看如何用SpringBoot来玩转以前的SSM,我们沿用之前讲解SSM用到的数据库tb_user和实体类User 整合SpringMVC 虽然默认配置已经可以使用SpringMVC了，不过我们有时候需要进行自定义配置。 修改端口 查看SpringBoot的全局属性可知，端口通过以下方式配置： 12# 映射端口server.port=80 重启服务后测试： 访问静态资源 现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？ 回顾我们上面看的源码，有一个叫做ResourceProperties的类，里面就定义了静态资源的默认查找路径： 默认的静态资源路径为： classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public 只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。 我们习惯会把静态资源放在classpath:/static/目录下。我们创建目录，并且添加一些静态资源： 重启项目后测试： 添加拦截器 拦截器也是我们经常需要使用的，在SpringBoot中该如何配置呢？ 拦截器不是一个普通属性，而是一个类，所以就要用到java配置方式了。在SpringBoot官方文档中有这么一段说明： If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 翻译： 如果你想要保持Spring Boot 的一些默认MVC特征，同时又想自定义一些MVC配置（包括：拦截器，格式化器, 视图控制器、消息转换器 等等），你应该让一个类实现WebMvcConfigurer，并且添加@Configuration注解，但是千万不要加@EnableWebMvc注解。如果你想要自定义HandlerMapping、HandlerAdapter、ExceptionResolver等组件，你可以创建一个WebMvcRegistrationsAdapter实例 来提供以上组件。 如果你想要完全自定义SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加@Configuration注解和@EnableWebMvc注解 总结：通过实现WebMvcConfigurer并添加@Configuration注解来实现自定义部分SpringMvc配置。 首先我们定义一个拦截器： 12345678910111213141516171819public class LoginInterceptor implements HandlerInterceptor &#123; private Logger logger = LoggerFactory.getLogger(LoginInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; logger.debug("preHandle method is now running!"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123; logger.debug("postHandle method is now running!"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; logger.debug("afterCompletion method is now running!"); &#125;&#125; 然后，我们定义配置类，注册拦截器： 123456789101112131415161718192021@Configurationpublic class MvcConfig implements WebMvcConfigurer&#123; /** * 通过@Bean注解，将我们定义的拦截器注册到Spring容器 * @return */ @Bean public LoginInterceptor loginInterceptor()&#123; return new LoginInterceptor(); &#125; /** * 重写接口中的addInterceptors方法，添加自定义拦截器 * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 通过registry来注册拦截器，通过addPathPatterns来添加拦截路径 registry.addInterceptor(this.loginInterceptor()).addPathPatterns("/**"); &#125;&#125; 结构如下： 接下来运行并查看日志： 你会发现日志中什么都没有，因为我们记录的log级别是debug，默认是显示info以上，我们需要进行配置。 SpringBoot通过logging.level.*=debug来配置日志级别，*填写包名 12# 设置com.leyou包的日志级别为debuglogging.level.com.leyou=debug 再次运行查看： 1232018-05-05 17:50:01.811 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : preHandle method is now running!2018-05-05 17:50:01.854 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : postHandle method is now running!2018-05-05 17:50:01.854 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : afterCompletion method is now running! 整合jdbc和事务 spring中的jdbc连接和事务是配置中的重要一环，在SpringBoot中该如何处理呢？ 答案是不需要处理，我们只要找到SpringBoot提供的启动器即可： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 当然，不要忘了数据库驱动，SpringBoot并不知道我们用的什么数据库，这里我们选择MySQL： 1234&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 至于事务，SpringBoot中通过注解来控制。就是我们熟知的@Transactional 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id)&#123; return this.userMapper.selectByPrimaryKey(id); &#125; @Transactional public void deleteById(Long id)&#123; this.userMapper.deleteByPrimaryKey(id); &#125;&#125; 整合连接池 其实，在刚才引入jdbc启动器的时候，SpringBoot已经自动帮我们引入了一个连接池： HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比： 因此，我们只需要指定连接池参数即可： 12345678910# 连接四大参数spring.datasource.url=jdbc:mysql://localhost:3306/heimaspring.datasource.username=rootspring.datasource.password=123# 可省略，SpringBoot自动推断spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.hikari.idle-timeout=60000spring.datasource.hikari.maximum-pool-size=30spring.datasource.hikari.minimum-idle=10 当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器： 123456&lt;!-- Druid连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同： 12345678910#初始化连接数spring.datasource.druid.initial-size=1#最小空闲连接spring.datasource.druid.min-idle=1#最大活动连接spring.datasource.druid.max-active=20#获取连接时测试是否可用spring.datasource.druid.test-on-borrow=true#监控页面启动spring.datasource.druid.stat-view-servlet.allow=true 整合mybatis mybatis SpringBoot官方并没有提供Mybatis的启动器，不过Mybatis官网自己实现了： 123456&lt;!--mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 配置，基本没有需要配置的： 1234# mybatis 别名扫描mybatis.type-aliases-package=com.heima.pojo# mapper.xml文件位置,如果没有映射文件，请注释掉mybatis.mapper-locations=classpath:mappers/*.xml 需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加@Mapper注解，才能被识别。 123@Mapperpublic interface UserMapper &#123;&#125; 通用mapper 通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可： 123456&lt;!-- 通用mapper --&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 不需要做任何配置就可以使用了。 123@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125; 启动测试 将controller进行简单改造： 123456789101112@RestControllerpublic class HelloController &#123; @Autowired private UserService userService; @GetMapping("/hello") public User hello() &#123; User user = this.userService.queryById(8L); return user; &#125;&#125; 我们启动项目，查看： Thymeleaf快速入门 SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术： 以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！ 为什么是Thymeleaf？ 简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点： 动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。 接下来，我们就通过入门案例来体会Thymeleaf的魅力： 编写接口 编写一个controller，返回一些用户数据，放入模型中，等会在页面渲染 123456789@GetMapping("/all")public String all(ModelMap model) &#123; // 查询用户 List&lt;User&gt; users = this.userService.queryAll(); // 放入模型 model.addAttribute("users", users); // 返回模板名称（就是classpath:/templates/目录下的html文件名） return "users";&#125; 引入启动器 直接引入启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot会自动为Thymeleaf注册一个视图解析器： 与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置： 默认前缀：classpath:/templates/ 默认后缀：.html 所以如果我们返回视图：users，会指向到 classpath:/templates/users.html 一般我们无需进行修改，默认即可。 静态页面 根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中： 编写html模板，渲染模型中的数据： 注意，把html 的名称空间，改成：xmlns:th=&quot;http://www.thymeleaf.org&quot; 会有语法提示 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style type="text/css"&gt; table &#123;border-collapse: collapse; font-size: 14px; width: 80%; margin: auto&#125; table, th, td &#123;border: 1px solid darkslategray;padding: 10px&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="text-align: center"&gt; &lt;span style="color: darkslategray; font-size: 30px"&gt;欢迎光临！&lt;/span&gt; &lt;hr/&gt; &lt;table class="list"&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;生日&lt;/th&gt; &lt;th&gt;备注&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="user : $&#123;users&#125;"&gt; &lt;td th:text="$&#123;user.id&#125;"&gt;1&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;张三&lt;/td&gt; &lt;td th:text="$&#123;user.userName&#125;"&gt;zhangsan&lt;/td&gt; &lt;td th:text="$&#123;user.age&#125;"&gt;20&lt;/td&gt; &lt;td th:text="$&#123;user.sex&#125; == 1 ? '男': '女'"&gt;男&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(user.birthday, 'yyyy-MM-dd')&#125;"&gt;1980-02-30&lt;/td&gt; &lt;td th:text="$&#123;user.note&#125;"&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们看到这里使用了以下语法： ${} ：这个类似与el表达式，但其实是ognl的语法，比el表达式更加强大 th-指令：th-是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用data-th-来代替 th:each：类似于c:foreach 遍历集合，但是语法更加简洁 th:text：声明标签中的文本 例如&lt;td th-text=&#39;${user.id}&#39;&gt;1&lt;/td&gt;，如果user.id有值，会覆盖默认的1 如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！ 测试 接下来，我们打开页面测试一下： 模板缓存 Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用： 12# 开发阶段关闭thymeleaf的模板缓存spring.thymeleaf.cache=false 注意： ​ 在Idea中，我们需要在修改页面后按快捷键：Ctrl + Shift + F9 对项目进行rebuild才可以。 ​ eclipse中没有测试过。 我们可以修改页面，测试一下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot]]></title>
    <url>%2Fmyhexo%2F2019%2F04%2F03%2FSpringBoot%2F</url>
    <content type="text"><![CDATA[入门 启动 官网创建 第一个例子 编辑pom.xml 12345&lt;!-- springBoot的启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 编写controller 1234567891011121314151617/** * SpringBoot HelloWorld * @author Administrator * */@Controllerpublic class HelloWorld &#123; @RequestMapping("/hello") @ResponseBody public Map&lt;String, Object&gt; showHelloWorld()&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("msg", "HelloWorld"); return map; &#125;&#125; 编写启动类 1234567891011121314151617package com.bjsxt.app;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * SpringBoot 启动类 * @author Administrator * */@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 打包 进入到项目目录下，终端运行 1mvn clean package -Dmaven.test.skip=true 运行 1java -jar demo_springboot-0.0.1-SNAPSHOT.jar 整合Web开发 整合Servlet 注解扫描注册 通过注解扫描完成Servlet组件的注册 编写Servlet 12345678910111213141516171819202122232425/** *SpringBoot整合Servlet方式一 * *&lt;servlet&gt; * &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; * &lt;servlet-class&gt;com.bjsxt.servlet.FirstServlet&lt;/servlet-class&gt; *&lt;/servlet&gt; * *&lt;servlet-mapping&gt; * &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; * &lt;url-pattern&gt;/first&lt;/url-pattern&gt; *&lt;/servlet-mapping&gt; * */@WebServlet(name="FirstServlet",urlPatterns="/first")public class FirstServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("FirstServlet............"); &#125;&#125; 编写启动类 1234567891011121314151617/** * SpringBoot整合Servlet方式一 * * */@SpringBootApplication//在springBoot启动时会扫描@WebServlet，并将该类实例化@ServletComponentScan public class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 方法注册 通过方法完成Servlet组件的注册 编写Servlet 1234567891011121314/** *SpringBoot整合Servlet方式二 * */public class SecondServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("SecondServlet.........."); &#125; &#125; 编写启动类 123456789101112131415161718192021/** * SpringBoot整合Servlet方式二 * * */@SpringBootApplicationpublic class App2 &#123; public static void main(String[] args) &#123; SpringApplication.run(App2.class, args); &#125; @Bean public ServletRegistrationBean getServletRegistrationBean()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new SecondServlet()); bean.addUrlMappings("/second"); return bean; &#125;&#125; 整合Filter 注解扫描注册 编写Filter 1234567891011121314151617181920212223242526272829303132333435/** *SpringBoot整合Filter 方式一 *&lt;filter&gt; * &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt; * &lt;filter-class&gt;com.bjsxt.filter.FirstFilter&lt;/filter-class&gt; *&lt;/filter&gt; *&lt;filter-mapping&gt; * &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt; * &lt;url-pattern&gt;/first&lt;/url-pattern&gt; *&lt;/filter-mapping&gt; *///@WebFilter(filterName="FirstFilter",urlPatterns=&#123;"*.do","*.jsp"&#125;)@WebFilter(filterName="FirstFilter",urlPatterns="/first")public class FirstFilter implements Filter &#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException &#123; System.out.println("进入Filter"); arg2.doFilter(arg0, arg1); System.out.println("离开Filter"); &#125; @Override public void init(FilterConfig arg0) throws ServletException &#123; // TODO Auto-generated method stub &#125;&#125; 编写启动类 12345678910111213141516/** *SpringBoot整合Filter 方式一 * */@SpringBootApplication@ServletComponentScanpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 方法注册 编写Filter 123456789101112131415161718192021222324/** * *SpringBoot整合Filter 方式二 * */public class SecondFilter implements Filter &#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException &#123; System.out.println("进入SecondFilter"); arg2.doFilter(arg0, arg1); System.out.println("离开SecondFilter"); &#125; @Override public void init(FilterConfig arg0) throws ServletException &#123; // TODO Auto-generated method stub &#125;&#125; 编写启动类 1234567891011121314151617181920212223242526/** * SpringBoot整合Filter方式二 * * */@SpringBootApplicationpublic class App2 &#123; public static void main(String[] args) &#123; SpringApplication.run(App2.class, args); &#125; /** * 注册Filter */ @Bean public FilterRegistrationBean getFilterRegistrationBean()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(new SecondFilter()); //bean.addUrlPatterns(new String[]&#123;"*.do","*.jsp"&#125;); bean.addUrlPatterns("/second"); return bean; &#125;&#125; 整合Listener 注解扫描注册 编写Listener 12345678910111213141516171819202122232425262728package com.bjsxt.listener;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.annotation.WebListener;/** * springBoot整合Listener * *&lt;listener&gt; * &lt;listener-class&gt;com.bjsxt.listener.FirstListener&lt;/listener-class&gt; *&lt;/listener&gt; */@WebListenerpublic class FirstListener implements ServletContextListener &#123; @Override public void contextDestroyed(ServletContextEvent arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void contextInitialized(ServletContextEvent arg0) &#123; System.out.println("Listener...init......"); &#125;&#125; 编写启动类 1234567891011121314151617181920package com.bjsxt;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.ServletComponentScan;/** * springBoot整合Listener方式一 * * */@SpringBootApplication@ServletComponentScanpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 方法注册 编写Listener 12345678910111213141516171819202122package com.bjsxt.listener;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;/** * springBoot整合Listener方式二。 * * */public class SecondListener implements ServletContextListener &#123; @Override public void contextDestroyed(ServletContextEvent arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void contextInitialized(ServletContextEvent arg0) &#123; System.out.println("SecondListener..init....."); &#125;&#125; 编写启动类 12345678910111213141516171819202122/** * SpringBoot整合Listener方式二 * * */@SpringBootApplicationpublic class App2 &#123; public static void main(String[] args) &#123; SpringApplication.run(App2.class, args); &#125; /** * 注册listener */ @Bean public ServletListenerRegistrationBean&lt;SecondListener&gt; getServletListenerRegistrationBean()&#123; ServletListenerRegistrationBean&lt;SecondListener&gt; bean= new ServletListenerRegistrationBean&lt;SecondListener&gt;(new SecondListener()); return bean; &#125;&#125; 访问静态资源 从classpath/static的目录下读取 从ServletContext根目录下读取,即webapp目录 文件上传 编写Controller 12345678910111213141516171819202122/** * SpringBoot文件上传 * * *///@Controller@RestController //表示该类下的方法的返回值会自动做json格式的转换public class FileUploadController &#123; /* * 处理文件上传 */ @RequestMapping("/fileUploadController") public Map&lt;String, Object&gt; fileUpload(MultipartFile filename)throws Exception&#123; System.out.println(filename.getOriginalFilename()); filename.transferTo(new File("e:/"+filename.getOriginalFilename())); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("msg", "ok"); return map; &#125;&#125; 编写启动类 12345678910111213141516171819package com.bjsxt;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * SpringBoot文件上传 * * */@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 编写文件上传表单 进入src/main/resources/static目录下,新增upload.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="fileUploadController" method="post" enctype="multipart/form-data"&gt; 上传文件：&lt;input type="file" name="filename"/&gt;&lt;br/&gt; &lt;input type="submit"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 设置上传文件大小的默认值 进入/src/main/resources目录，编辑application.properties文件 12spring.http.multipart.maxFileSize=200MBspring.http.multipart.maxRequestSize=200MB 整合jsp 编辑pom.xml 1234567891011121314151617181920212223 &lt;!-- jdk1.7 --&gt; &lt;properties&gt; &lt;java.version&gt;1.7&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- springBoot的启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jasper --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建application.properties 进入src/main/resources目录，新增编辑application.properties文件 12spring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.jsp 编写Controller 123456789101112131415161718192021222324/** * SpringBoot整合jsp * * */@Controllerpublic class UserController &#123; /* * 处理请求，产生数据 */ @RequestMapping("/showUser") public String showUser(Model model)&#123; List&lt;Users&gt; list = new ArrayList&lt;&gt;(); list.add(new Users(1,"张三",20)); list.add(new Users(2,"李四",22)); list.add(new Users(3,"王五",24)); //需要一个Model对象 model.addAttribute("list", list); //跳转视图 return "userList"; &#125;&#125; 创建jsp 进入src/main/webapp/WEB-INF/jsp目录,新增userList.jsp 1234567891011121314151617181920212223242526&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border="1" align="center" width="50%"&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;list &#125;" var="user"&gt; &lt;tr&gt; &lt;td&gt;$&#123;user.userid &#125;&lt;/td&gt; &lt;td&gt;$&#123;user.username &#125;&lt;/td&gt; &lt;td&gt;$&#123;user.userage &#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 创建启动类 1234567891011121314151617package com.bjsxt;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * SpringBoot启动类 * * */@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 整合freemarker 编辑pom.xml 12345678910111213141516&lt;properties&gt; &lt;java.version&gt;1.7&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt;&lt;!-- springBoot的启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- freemarker启动器的坐标 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt;&lt;/dependencies&gt; 创建 Controller 12345678910111213141516171819202122232425/** * SpringBoot整合jsp * * */@Controllerpublic class UserController &#123; /* * 处理请求，产生数据 */ @RequestMapping("/showUser") public String showUser(Model model)&#123; List&lt;Users&gt; list = new ArrayList&lt;&gt;(); list.add(new Users(1,"张三",20)); list.add(new Users(2,"李四",22)); list.add(new Users(3,"王五",24)); //需要一个Model对象 model.addAttribute("list", list); //跳转视图 return "userList"; &#125;&#125; 编写前端页面 springBoot要求模板形式的视图层技术的文件必须要放到src/main/resources目录下必须要一个名称为templates 进入到src/main/resources/templates目录,新增userList.ftl文件 123456789101112131415161718192021222324252627&lt;html&gt; &lt;head&gt; &lt;title&gt;展示用户数据&lt;/title&gt; &lt;meta charset="utf-9"&gt;&lt;/meta&gt; &lt;/head&gt; &lt;body&gt; &lt;table border="1" align="center" width="50%"&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;/tr&gt; &lt;#list list as user &gt; &lt;tr&gt; &lt;td&gt;$&#123;user.userid&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.username&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.userage&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 创建启动类 1234567891011121314151617package com.bjsxt;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * SpringBoot启动类 * * */@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 整合Thymeleaf 编辑pom.xml 123456789101112131415161718&lt;properties&gt;&lt;java.version&gt;1.7&lt;/java.version&gt;&lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt;&lt;thymeleaf-layout-dialect.version&gt;2.0.4&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- springBoot的启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- springBoot的启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;/dependencies&gt; 编辑前端页面 进入src/main/resources/templates,templates目录是安全的。意味着该目录下的内容是不允许外界直接访问的。 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Thymeleaf入门&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;span th:text="Hello"&gt;&lt;/span&gt; &lt;hr/&gt; &lt;span th:text="$&#123;msg&#125;"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 编辑Controller 12345678910111213141516171819package com.bjsxt.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;/** * Thymeleaf入门案例 * * */@Controllerpublic class DemoController &#123; @RequestMapping("/show") public String showInfo(Model model)&#123; model.addAttribute("msg", "Thymeleaf 第一个案例"); return "index"; &#125;&#125; 编辑启动类 1234567891011121314151617package com.bjsxt;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * *Thymeleaf入门案例 * */@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 坑 org.xml.sax.SAXParseException:元素类型 &quot;meta&quot; 必须由匹配的结束标记&quot;&lt;/meta&gt;&quot;终止 解决 方式一 让html的标记按照严禁的语法编写 1&lt;meta charset="UTF-8"/&gt; 方式二 thymeleaf.jar更新为3.0以上的版本 thymeleaf-layout-dialect.jar更新为2.0以上的版本 12345&lt;properties&gt; &lt;java.version&gt;1.7&lt;/java.version&gt; &lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.0.4&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt; Thymeleaf语法 变量输出与字符串操作 调用内置对象一定要用# 大部分的内置对象都以s结尾strings、numbers、dates 后台数据 1234567891011package com.bjsxt.controller;@Controllerpublic class DemoController &#123; @RequestMapping("/show") public String showInfo(HttpServletRequest request,Model model)&#123; model.addAttribute("msg", "Thymeleaf 第一个案例"); model.addAttribute("key", new Date()); return "index"; &#125;&#125; th:text 1234&lt;span th:text="Hello"&gt;&lt;/span&gt;&lt;hr/&gt;&lt;span th:text="$&#123;msg&#125; "&gt;&lt;/span&gt;&lt;hr/&gt; th:value 1&lt;span th:text="$&#123;msg&#125; "&gt;&lt;/span&gt; 判断字符串是否为空 1&lt;span th:text="$&#123;#strings.isEmpty(msg)&#125;"&gt;&lt;/span&gt; 判断字符串是否包含指定的子串 12&lt;span th:text="$&#123;#strings.contains(msg,'9')&#125;"&gt;&lt;/span&gt;&lt;span th:text="$&#123;#strings.contains(msg,'T')&#125;"&gt;&lt;/span&gt; 判断当前字符串是否以子串开头 12&lt;span th:text="$&#123;#strings.startsWith(msg,'a')&#125;"&gt;&lt;/span&gt;&lt;span th:text="$&#123;#strings.startsWith(msg,'T')&#125;"&gt;&lt;/span&gt; 判断当前字符串是否以子串结尾 12&lt;span th:text="$&#123;#strings.endsWith(msg,'a')&#125;"&gt;&lt;/span&gt;&lt;span th:text="$&#123;#strings.endsWith(msg,'案例')&#125;"&gt;&lt;/span&gt; 返回字符串的长度 1&lt;span th:text="$&#123;#strings.length(msg)&#125;"&gt;&lt;/span&gt; 查找子串的位置 返回该子串的下标，如果没找到则返回-1 1&lt;span th:text="$&#123;#strings.indexOf(msg,'h')&#125;"&gt;&lt;/span&gt; 截取子串 12&lt;span th:text="$&#123;#strings.substring(msg,13)&#125;"&gt;&lt;/span&gt;&lt;span th:text="$&#123;#strings.substring(msg,13,14)&#125;"&gt;&lt;/span&gt; 字符串转大小写 12&lt;span th:text="$&#123;#strings.toUpperCase(msg)&#125;"&gt;&lt;/span&gt;&lt;span th:text="$&#123;#strings.toLowerCase(msg)&#125;"&gt;&lt;/span&gt; 日期格式化处理 后台数据 1234567891011package com.bjsxt.controller;@Controllerpublic class DemoController &#123; @RequestMapping("/show") public String showInfo(HttpServletRequest request,Model model)&#123; model.addAttribute("key", new Date()); return "index"; &#125; &#125; 默认格式日期 1&lt;span th:text="$&#123;#dates.format(key)&#125;"&gt;&lt;/span&gt; 按照自定义的格式做日期转换 1&lt;span th:text="$&#123;#dates.format(key,'yyy/MM/dd')&#125;"&gt;&lt;/span&gt; 取年 1&lt;span th:text="$&#123;#dates.year(key)&#125;"&gt;&lt;/span&gt; 取月 1&lt;span th:text="$&#123;#dates.month(key)&#125;"&gt;&lt;/span&gt; 取日 1&lt;span th:text="$&#123;#dates.day(key)&#125;"&gt;&lt;/span&gt; 条件判断 后台数据 1234567891011package com.bjsxt.controller;@Controllerpublic class DemoController &#123; @RequestMapping("/show2") public String showInfo2(Model model)&#123; model.addAttribute("sex", "女"); model.addAttribute("id","1"); return "index2"; &#125;&#125; th:if 123456&lt;span th:if="$&#123;sex&#125; == '男'"&gt; 性别：男&lt;/span&gt;&lt;span th:if="$&#123;sex&#125; == '女'"&gt; 性别：女&lt;/span&gt; th:switch 12345&lt;div th:switch="$&#123;id&#125;"&gt; &lt;span th:case="1"&gt;ID为1&lt;/span&gt; &lt;span th:case="2"&gt;ID为2&lt;/span&gt; &lt;span th:case="3"&gt;ID为3&lt;/span&gt;&lt;/div&gt; 迭代遍历 后台数据 1234567891011121314151617181920212223242526package com.bjsxt.controller;@Controllerpublic class DemoController &#123; @RequestMapping("/show3") public String showInfo3(Model model)&#123; List&lt;Users&gt; list = new ArrayList&lt;&gt;(); list.add(new Users(1,"张三",20)); list.add(new Users(2,"李四",22)); list.add(new Users(3,"王五",24)); model.addAttribute("list", list); return "index3"; &#125; @RequestMapping("/show4") public String showInfo4(Model model)&#123; Map&lt;String, Users&gt; map = new HashMap&lt;&gt;(); map.put("u1", new Users(1,"张三",20)); map.put("u2", new Users(2,"李四",22)); map.put("u3", new Users(3,"王五",24)); model.addAttribute("map", map); return "index4"; &#125; &#125; th:each迭代list 12345&lt;tr th:each="u : $&#123;list&#125;"&gt; &lt;td th:text="$&#123;u.userid&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;u.username&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;u.userage&#125;"&gt;&lt;/td&gt;&lt;/tr&gt; th:each状态变量 index当前迭代器的索引从0开始count当前迭代对象的计数从1开始size被迭代对象的长度even/odd布尔值,当前循环是否是偶数/奇数从0开始first布尔值，当前循环的是否是第一条,如果是返回true否则返回falselast布尔值，当前循环的是否是最后一条,如果是则返回true否则返回false 123456789101112&lt;tr th:each="u,var : $&#123;list&#125;"&gt; &lt;td th:text="$&#123;u.userid&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;u.username&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;u.userage&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;var.index&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;var.count&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;var.size&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;var.even&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;var.odd&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;var.first&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;var.last&#125;"&gt;&lt;/td&gt;&lt;/tr&gt; th:each迭代Map 12345&lt;tr th:each="maps : $&#123;map&#125;"&gt; &lt;td th:each="entry:$&#123;maps&#125;" th:text="$&#123;entry.value.userid&#125;" &gt;&lt;/td&gt; &lt;td th:each="entry:$&#123;maps&#125;" th:text="$&#123;entry.value.username&#125;"&gt;&lt;/td&gt; &lt;td th:each="entry:$&#123;maps&#125;" th:text="$&#123;entry.value.userage&#125;"&gt;&lt;/td&gt;&lt;/tr&gt; 域对象操作 后台数据 1234567891011121314package com.bjsxt.controller;@Controllerpublic class DemoController &#123; @RequestMapping("/show5") public String showInfo5(HttpServletRequest request,Model model)&#123; request.setAttribute("req", "HttpServletRequest"); request.getSession().setAttribute("sess", "HttpSession"); request.getSession().getServletContext().setAttribute("app", "Application"); return "index5"; &#125; &#125; HttpServletRequest 1Request:&lt;span th:text="$&#123;#httpServletRequest.getAttribute('req')&#125;"&gt;&lt;/span&gt;&lt;br/&gt; HttpSession 1Session:&lt;span th:text="$&#123;session.sess&#125;"&gt;&lt;/span&gt;&lt;br/&gt; ServletContext 1Application:&lt;span th:text="$&#123;application.app&#125;"&gt;&lt;/span&gt; URL表达式 基本语法@{} 后台数据 123456789101112package com.bjsxt.controller;@Controllerpublic class DemoController &#123; @RequestMapping("/&#123;page&#125;") public String showInfo(@PathVariable String page,Integer id,String name)&#123; System.out.println(id+"--"+name); return page; &#125; &#125; 绝对路径 12&lt;a th:href="@&#123;http://www.baidu.com&#125;"&gt;绝对路径&lt;/a&gt;&lt;br/&gt;&lt;a href="http://www.baidu.com"&gt;绝对路径2&lt;/a&gt; 相对路径 1234567&lt;a th:href="@&#123;/show&#125;"&gt;相对路径&lt;/a&gt;&lt;hr/&gt;&lt;a th:href="@&#123;~/project2/resourcename&#125;"&gt;相对于服务器的根&lt;/a&gt;&lt;hr/&gt;&lt;a th:href="@&#123;/show(id=1,name=zhagnsan)&#125;"&gt;相对路径-传参&lt;/a&gt;&lt;hr/&gt;&lt;a th:href="@&#123;/path/&#123;id&#125;/show(id=1,name=zhagnsan)&#125;"&gt;相对路径-传参-restful&lt;/a&gt; 整合MyBatis 编辑pom.xml 1234567891011121314151617&lt;!-- Mybatis启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql数据库驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- druid数据库连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt;&lt;/dependency&gt; 编辑application.properties 进入src/main/resources目录,编辑application.properties 12345678spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/ssmspring.datasource.username=rootspring.datasource.password=rootspring.datasource.type=com.alibaba.druid.pool.DruidDataSourcemybatis.type-aliases-package=com.bjsxt.pojo 数据库表设计 123456CREATE TABLE `users` ( `id` INT (11) NOT NULL AUTO_INCREMENT, `name` VARCHAR (255) DEFAULT NULL, `age` INT (11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE = INNODB DEFAULT CHARSET = utf8; 添加用户 创建实体类 1234567891011121314151617181920212223242526package com.bjsxt.pojo;public class Users &#123; private Integer id; private String name; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; &#125; 创建mapper接口以及映射配置文件 12345678package com.bjsxt.mapper;import com.bjsxt.pojo.Users;public interface UsersMapper &#123; void insertUser(Users users);&#125; 123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.bjsxt.mapper.UsersMapper"&gt; &lt;insert id="insertUser" parameterType="users"&gt; insert into users(name,age) values(#&#123;name&#125;,#&#123;age&#125;) &lt;/insert&gt;&lt;/mapper&gt; 创建业务层 所有方法开启事务@Transactional标注在类上 12345678910111213@Service@Transactionalpublic class UsersServiceImpl implements UsersService &#123; @Autowired private UsersMapper usersMapper; @Override public void addUser(Users users) &#123; this.usersMapper.insertUser(users); &#125;&#125; 创建Controller 前端请求http://localhost:8080/users/input跳转到input.html页面 12345678910111213141516171819202122232425@Controller@RequestMapping("/users")public class UsersController &#123; @Autowired private UsersService usersService; /** * 页面跳转 */ @RequestMapping("/&#123;page&#125;") public String showPage(@PathVariable String page)&#123; return page; &#125; /** * 添加用户 */ @RequestMapping("/addUser") public String addUser(Users users)&#123; this.usersService.addUser(users); return "ok"; &#125;&#125; 编写页面 使用thymeleaf模板,页面必须放在src/main/resources/templates目录下 添加用户页面input.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;添加用户&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form th:action="@&#123;/users/addUser&#125;" method="post"&gt; 用户姓名：&lt;input type="text" name="name"/&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="age"/&gt;&lt;br/&gt; &lt;input type="submit" value="确定"/&gt;&lt;br/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 添加成功页面ok.html 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;操作提示页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 操作成功！！！&lt;/body&gt;&lt;/html&gt; 创建启动类 用户扫描MyBatis的Mapper接口,使用@MapperScan(&quot;com.bjsxt.mapper&quot;)注解 1234567891011121314package com.bjsxt;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan("com.bjsxt.mapper") //@MapperScan 用户扫描MyBatis的Mapper接口public class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 查询用户 修改mapper接口中以及映射配置文件 1List&lt;Users&gt; selectUsersAll(); 123&lt;select id="selectUsersAll" resultType="users"&gt; select id,name,age from users&lt;/select&gt; 修改业务层 添加查询方法 1234@Overridepublic List&lt;Users&gt; findUserAll() &#123; return this.usersMapper.selectUsersAll();&#125; 修改Controller 浏览器请求http://localhost:8080/findUserAll,跳转到showUsers.html 123456789/** * 查询全部用户 */@RequestMapping("/findUserAll")public String findUserAll(Model model)&#123; List&lt;Users&gt; list = this.usersService.findUserAll(); model.addAttribute("list", list); return "showUsers";&#125; 创建页面 查询用户页面showUsers.html 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;展示用户数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border="1" style="width:300px;"&gt; &lt;tr&gt; &lt;th&gt;用户ID&lt;/th&gt; &lt;th&gt;用户姓名&lt;/th&gt; &lt;th&gt;用户年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="user : $&#123;list&#125;"&gt; &lt;td th:text="$&#123;user.id&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;user.age&#125;"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 更新用户 数据回显 更新用户之前的查询，将数据在页面中回显 修改mapper接口以及映射配置文件 1Users selectUsersById(Integer id); 123&lt;select id="selectUsersById" resultType="users"&gt; select id,name,age from users where id = #&#123;value&#125;&lt;/select&gt; 修改业务层代码 1234@Overridepublic Users findUserById(Integer id) &#123; return this.usersMapper.selectUsersById(id);&#125; 修改Controller 浏览器请求http://localhost:8080/findUserById,跳转到updateUser.html页面，将数据用户数据回显 123456789/** * 根据用户id查询用户 */@RequestMapping("/findUserById")public String findUserById(Integer id,Model model)&#123; Users user = this.usersService.findUserById(id); model.addAttribute("user", user); return "updateUser";&#125; 编写页面 更新用户页面updateUser.html进行数据回显,使用th:field取得controller中的模型数据 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form th:action="@&#123;/users/editUser&#125;" method="post"&gt; &lt;input type="hidden" name="id" th:field="$&#123;user.id&#125;"/&gt; 用户姓名：&lt;input type="text" name="name" th:field="$&#123;user.name&#125;"/&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="age" th:field="$&#123;user.age&#125;"/&gt;&lt;br/&gt; &lt;input type="submit" value="确定"/&gt;&lt;br/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 更新 修改mapper接口以及映射配置文件 1void updateUser(Users users); 123&lt;update id="updateUser" parameterType="users"&gt; update users set name=#&#123;name&#125; ,age=#&#123;age&#125; where id=#&#123;id&#125;&lt;/update&gt; 修改业务层代码 1234@Overridepublic void updateUser(Users users) &#123; this.usersMapper.updateUser(users);&#125; 修改Controller 更新用户页面updateUser.html点击提交，浏览器请求http://localhost:8080/editUser,跳转到修改成功页面ok.html 12345678/** * 更新用户 */@RequestMapping("/editUser")public String editUser(Users users)&#123; this.usersService.updateUser(users); return "ok";&#125; 删除用户 修改mapper接口以及映射配置文件 1void deleteUserById(Integer id); 123&lt;delete id="deleteUserById"&gt; delete from users where id = #&#123;value&#125;&lt;/delete&gt; 修改业务层 1234@Overridepublic void deleteUserById(Integer id) &#123; this.usersMapper.deleteUserById(id);&#125; 修改Controller 浏览器请求http://localhost:8080/delUser重定向请求/users/findUserAll，跳转到查询用户页面showUsers.html 12345678/** * 删除用户 */@RequestMapping("/delUser")public String delUser(Integer id)&#123; this.usersService.deleteUserById(id); return "redirect:/users/findUserAll";&#125; 修改页面 修改查询用户页面showUsers.html,增加删除按钮链接 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;展示用户数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border="1" style="width:500px;"&gt; &lt;tr&gt; &lt;th&gt;用户ID&lt;/th&gt; &lt;th&gt;用户姓名&lt;/th&gt; &lt;th&gt;用户年龄&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="user : $&#123;list&#125;"&gt; &lt;td th:text="$&#123;user.id&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;user.age&#125;"&gt;&lt;/td&gt; &lt;td&gt; &lt;a th:href="@&#123;/users/findUserById(id=$&#123;user.id&#125;)&#125;"&gt;更新用户&lt;/a&gt; &lt;a th:href="@&#123;/users/delUser(id=$&#123;user.id&#125;)&#125;"&gt;删除用户&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 服务端表单数据校验 表单做数据校验 修改实体类 非空校验使用@NotBlank注解标注在属性上 12345678910111213141516171819202122232425262728293031323334package com.bjsxt.pojo;import org.hibernate.validator.constraints.NotBlank;public class Users &#123; @NotBlank //非空校验 private String name; @NotBlank //密码非空校验 private String password; private Integer age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Users [name=" + name + ", password=" + password + ", age=" + age + "]"; &#125; &#125; 修改Controller 浏览器请求http://localhost:8080/addUser,跳转到添加用户页面add.html,点击提交按钮浏览器请求http://localhost:8080/save,如果校验通过跳转到成功页面ok.html,校验不通过跳转到添加用户页面add.html 开启校验使用@Valid注解封装了校验的结果BindingResult 1234567891011121314151617181920212223242526272829/** * SpringBoot 表单数据校验 * * */@Controllerpublic class UsersController &#123; @RequestMapping("/addUser") public String showPage()&#123; return "add"; &#125; /** * 完成用户添加 *@Valid 开启对Users对象的数据校验 *BindingResult:封装了校验的结果 */ @RequestMapping("/save") public String saveUser(@Valid Users users,BindingResult result)&#123; if(result.hasErrors())&#123; return "add"; &#125; System.out.println(users); return "ok"; &#125;&#125; 修改页面 添加用户页面add.html,使用th:errors取得校验信息 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;添加用户&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form th:action="@&#123;/save&#125;" method="post"&gt; 用户姓名：&lt;input type="text" name="name"/&gt;&lt;font color="red" th:errors="$&#123;users.name&#125;"&gt;&lt;/font&gt;&lt;br/&gt; 用户密码：&lt;input type="password" name="password" /&gt;&lt;font color="red" th:errors="$&#123;users.password&#125;"&gt;&lt;/font&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="age" /&gt;&lt;font color="red" th:errors="$&#123;users.age&#125;"&gt;&lt;/font&gt;&lt;br/&gt; &lt;input type="submit" value="OK"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 坑 java.lang.IllegalStateException: Neither BindingResult nor plain target object for bean name ‘users’ available as request attribute 描述 浏览器请求http://localhost:8080/addUser方法，该方法并没有传递Users对象，跳转到添加用户页面add.html取不到数据所以报错 解决 方式一 跳转页面注入对象 可以在浏览器请求http://localhost:8080/addUser方法中注入一个Uesrs对象由于springmvc会将Uesrs对象放入到Model模型中传递,使用驼峰命名规则,参数的变量名需要与对象的名称相同,将首字母小写 修改Controller 1234567891011121314151617181920212223242526272829303132333435/** * SpringBoot 表单数据校验 * * */@Controllerpublic class UsersController &#123; /** * * 如果想为传递的对象更改名称，可以使用@ModelAttribute("aa")这表示当前传递的对象的key为aa。 * 那么我们在页面中获取该对象的key也需要修改为aa * @param users * @return */ @RequestMapping("/addUser") public String showPage(Users users)&#123; return "add"; &#125; /** * 完成用户添加 *@Valid 开启对Users对象的数据校验 *BindingResult:封装了校验的结果 */ @RequestMapping("/save") public String saveUser(@Valid Users users,BindingResult result)&#123; if(result.hasErrors())&#123; return "add"; &#125; System.out.println(users); return "ok"; &#125;&#125; 方式二 设置参数名称可变 如果想为传递的对象更改名称,可以使用@ModelAttribute(&quot;aa&quot;)这表示当前传递的对象的key为aa那么我们在页面中获取该对象的key也需要修改为aa 修改Controller 1234567891011121314151617181920212223242526272829303132333435/** * SpringBoot 表单数据校验 * * */@Controllerpublic class UsersController &#123; /** * * 如果想为传递的对象更改名称，可以使用@ModelAttribute("aa")这表示当前传递的对象的key为aa。 * 那么我们在页面中获取该对象的key也需要修改为aa * @param users * @return */ @RequestMapping("/addUser") public String showPage(@ModelAttribute("aa") Users users)&#123; return "add"; &#125; /** * 完成用户添加 *@Valid 开启对Users对象的数据校验 *BindingResult:封装了校验的结果 */ @RequestMapping("/save") public String saveUser(@ModelAttribute("aa") @Valid Users users,BindingResult result)&#123; if(result.hasErrors())&#123; return "add"; &#125; System.out.println(users); return "ok"; &#125;&#125; 修改页面 添加用户页面add.html,${aa.name}需要和请求http://localhost:8080/addUser方法中设置的@ModelAttribute(&quot;aa&quot;)一样 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;添加用户&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form th:action="@&#123;/save&#125;" method="post"&gt; 用户姓名：&lt;input type="text" name="name"/&gt;&lt;font color="red" th:errors="$&#123;aa.name&#125;"&gt;&lt;/font&gt;&lt;br/&gt; 用户密码：&lt;input type="password" name="password" /&gt;&lt;font color="red" th:errors="$&#123;aa.password&#125;"&gt;&lt;/font&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="age" /&gt;&lt;font color="red" th:errors="$&#123;aa.age&#125;"&gt;&lt;/font&gt;&lt;br/&gt; 用户邮箱：&lt;input type="text" name="email" /&gt;&lt;font color="red" th:errors="$&#123;aa.email&#125;"&gt;&lt;/font&gt;&lt;br/&gt; &lt;input type="submit" value="OK"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 其他校验规则 @NotBlank判断字符串是否为null或者是空串(去掉首尾空格)。@NotEmpty判断字符串是否null或者是空串。@Length判断字符的长度(最大或者最小)@Min判断数值最小值@Max判断数值最大值@Email判断邮箱是否合法 修改实体类 123456789101112131415161718192021222324252627282930313233343536373839404142public class Users &#123; @NotBlank(message="用户名不能为空") //非空校验 @Length(min=2,max=6,message="最小长度为2位，最大长度为6位") private String name; @NotEmpty private String password; @Min(value=15) private Integer age; @Email private String email; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Users [name=" + name + ", password=" + password + ", age=" + age + "]"; &#125; &#125; 异常处理 SpringBoot中对于异常处理提供了五种处理方式 自定义错误页面 默认的处理异常的机制 一旦程序中出现了异常SpringBoot会向/error发送请求。在springBoot中提供了一个叫BasicExceptionController类来处理/error请求，然后跳转到默认显示异常的页面来展示异常信息 修改Controller 浏览器请求http://localhost:8080/show和http://localhost:8080/show2发生了异常,并不会跳转到index.html页面，而是会有默认异常页面error.html来显示异常信息 12345678910111213141516171819202122232425262728package com.bjsxt.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * SpringBoot处理异常方式一：自定义错误页面 * * */@Controllerpublic class DemoController &#123; @RequestMapping("/show") public String showInfo()&#123; String str = null; str.length(); return "index"; &#125; @RequestMapping("/show2") public String showInfo2()&#123; int a = 10/0; return "index"; &#125; &#125; 效果 修改页面 如果我们需要将所有的异常同一跳转到自定义的错误页面需要在src/main/resources/templates目录下创建error.html页面,名称必须叫error.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;错误提示页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 出错了，请与管理员联系。。。 &lt;span th:text="$&#123;exception&#125;"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 弊端 对所有异常都显示到异常页面error.html,不能处理对不同的异常跳转到不同的异常显示页面 @ExceptionHandle 修改Controller 使用@ExceptionHandler注解标注在方法上分别对不同的异常进行处理 使用ModelAndView可以指定异常信息及异常视图页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * SpringBoot处理异常方式二：@ExceptionHandle注解处理异常 * * */@Controllerpublic class DemoController &#123; @RequestMapping("/show") public String showInfo()&#123; String str = null; str.length(); return "index"; &#125; @RequestMapping("/show2") public String showInfo2()&#123; int a = 10/0; return "index"; &#125; /** * java.lang.ArithmeticException * 该方法需要返回一个ModelAndView：目的是可以让我们封装异常信息以及视图的指定 * 参数Exception e:会将产生异常对象注入到方法中 */ @ExceptionHandler(value=&#123;java.lang.ArithmeticException.class&#125;) public ModelAndView arithmeticExceptionHandler(Exception e)&#123; ModelAndView mv = new ModelAndView(); mv.addObject("error", e.toString()); mv.setViewName("error1"); return mv; &#125; /** * java.lang.NullPointerException * 该方法需要返回一个ModelAndView：目的是可以让我们封装异常信息以及视图的指定 * 参数Exception e:会将产生异常对象注入到方法中 */ @ExceptionHandler(value=&#123;java.lang.NullPointerException.class&#125;) public ModelAndView nullPointerExceptionHandler(Exception e)&#123; ModelAndView mv = new ModelAndView(); mv.addObject("error", e.toString()); mv.setViewName("error2"); return mv; &#125; &#125; 修改页面 进入src/main/resources/templates目录下，创建空指针和算术异常页面 算术异常页面error1.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;错误提示页面-ArithmeticException&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 出错了，请与管理员联系。。。 &lt;span th:text="$&#123;error&#125;"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 空指针异常页面error2.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;错误提示页面-NullPointerException&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 出错了，请与管理员联系。。。 &lt;span th:text="$&#123;error&#125;"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 效果 弊端 只有标记了@ExceptionHandle注解的Controller类才能处理跳转到自定义异常页面，而其它的Controller类中的方法则还是跳转到springboot默认机制的异常处理 @ControllerAdvice+@ExceptionHandler 修改Controller 全局异常控制类GlobalException.java,浏览器请求Controller，如果发生了异常，则会走全局异常控制类GlobalException.java,该类可以对不同的异常进行不同的处理(指定异常信息、视图页面) 该方式优于@ExceptionHandle注解处理异常 1234567891011121314151617181920212223242526272829303132333435/** * 全局异常处理类 * * */@ControllerAdvicepublic class GlobalException &#123; /** * java.lang.ArithmeticException * 该方法需要返回一个ModelAndView：目的是可以让我们封装异常信息以及视图的指定 * 参数Exception e:会将产生异常对象注入到方法中 */ @ExceptionHandler(value=&#123;java.lang.ArithmeticException.class&#125;) public ModelAndView arithmeticExceptionHandler(Exception e)&#123; ModelAndView mv = new ModelAndView(); mv.addObject("error", e.toString()); mv.setViewName("error1"); return mv; &#125; /** * java.lang.NullPointerException * 该方法需要返回一个ModelAndView：目的是可以让我们封装异常信息以及视图的指定 * 参数Exception e:会将产生异常对象注入到方法中 */ @ExceptionHandler(value=&#123;java.lang.NullPointerException.class&#125;) public ModelAndView nullPointerExceptionHandler(Exception e)&#123; ModelAndView mv = new ModelAndView(); mv.addObject("error", e.toString()); mv.setViewName("error2"); return mv; &#125; &#125; 效果 SimpleMappingExceptionResolver 比起@ControllerAdvice+@ExceptionHandler处理异常,通过SimpleMappingExceptionResolver做全局异常处理,方式更优雅,但是有个缺点即在异常页面不能输出异常信息 修改Controller 1234567891011121314151617181920212223242526272829303132/** * 通过SimpleMappingExceptionResolver做全局异常处理 * * */@Configurationpublic class GlobalException &#123; /** * 该方法必须要有返回值。返回值类型必须是：SimpleMappingExceptionResolver */ @Bean public SimpleMappingExceptionResolver getSimpleMappingExceptionResolver()&#123; SimpleMappingExceptionResolver resolver = new SimpleMappingExceptionResolver(); Properties mappings = new Properties(); /** * 参数一：异常的类型，注意必须是异常类型的全名 * 参数二：视图名称 */ mappings.put("java.lang.ArithmeticException", "error1"); mappings.put("java.lang.NullPointerException","error2"); //设置异常与视图映射信息的 resolver.setExceptionMappings(mappings); return resolver; &#125; &#125; 效果 不能输出异常信息 弊端 不能在异常页面输出异常信息，SimpleMappingExceptionResolver类处理异常只能针对不同的异常映射不同的视图逻辑 自定义HandlerExceptionResolver 修改Controller 定义全局异常控制类必须要实现HandlerExceptionResolver接口,该种方式可以针对不同异常跳转不同的异常页面，并且在异常异页面可以输出异常信息，但是平常异常信息不会直接输出在异常页，避免异常数据被人窃取 推荐使用 1234567891011121314151617181920212223242526/** * 通过实现HandlerExceptionResolver接口做全局异常处理 * * */@Configurationpublic class GlobalException implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; ModelAndView mv = new ModelAndView(); //判断不同异常类型，做不同视图跳转 if(ex instanceof ArithmeticException)&#123; mv.setViewName("error1"); &#125; if(ex instanceof NullPointerException)&#123; mv.setViewName("error2"); &#125; mv.addObject("error", ex.toString()); return mv; &#125;&#125; 单元测试 修改pom.xml 12345&lt;!-- 添加junit环境的jar包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt; 创建dao 1234567891011package com.bjsxt.dao;import org.springframework.stereotype.Repository;@Repositorypublic class UserDaoImpl &#123; public void saveUser()&#123; System.out.println("insert into users....."); &#125;&#125; 创建service 1234567891011121314151617package com.bjsxt.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.bjsxt.dao.UserDaoImpl;@Servicepublic class UserServiceImpl &#123; @Autowired private UserDaoImpl userDaoImpl; public void addUser()&#123; this.userDaoImpl.saveUser(); &#125;&#125; 创建启动类 12345678910111213package com.bjsxt;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 整合Junit做单元测试 @RunWith启动器SpringJUnit4ClassRunner.class让junit与spring环境进行整合 @SpringBootTest(classes={App.class})说明当前类为springBoot的测试类加载SpringBoot启动类App.class 1234567891011121314151617181920212223242526272829303132package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.App;import com.bjsxt.service.UserServiceImpl;/** * SpringBoot测试类 *@RunWith:启动器 *SpringJUnit4ClassRunner.class：让junit与spring环境进行整合 * *@SpringBootTest(classes=&#123;App.class&#125;) 1,当前类为springBoot的测试类 *@SpringBootTest(classes=&#123;App.class&#125;) 2,加载SpringBoot启动类。启动springBoot * *junit与spring整合 @Contextconfiguartion("classpath:applicationContext.xml") */@RunWith(SpringJUnit4ClassRunner.class) @SpringBootTest(classes=&#123;App.class&#125;)public class UserServiceTest &#123; @Autowired private UserServiceImpl userServiceImpl; @Test public void testAddUser()&#123; this.userServiceImpl.addUser(); &#125;&#125; 热部署 SpringLoader插件 创建controller 12345678910111213141516171819package com.bjsxt.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * SpringBoot----SpringLoader * * */@Controllerpublic class UsersController &#123; @RequestMapping("/show") public String showPage()&#123; System.out.println("ShowPage......"); return "index"; &#125;&#125; 创建页面 进入/src/main/resources/templates目录下，创建热部署前端测试页面 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;span th:text="Hello...."&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 创建启动类 1234567891011package com.bjsxt;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 运行 方式一 修改pom.xml 12345678910111213141516&lt;!-- springloader插件 --&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;version&gt;1.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; maven命令启动 弊端 这种方式的缺点是Springloader热部署程序是在系统后台以进程的形式来运行,需要手动关闭该进程对Java代码做部署处理,但是对页面无能为力 方式二 在项目中直接使用jar包的方式 启动命令VM Options参数-javaagent:.\lib\springloaded-1.2.5.RELEASE.jar -noverify DevTools工具 修改pom.xml 123456&lt;!-- DevTools的坐标 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; SpringLoader与DevTools的区别 SpringLoader在部署项目时使用的是热部署的方式 DevTools在部署项目时使用的是重新部署的方式 整合Ehcache 修改pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;dependencies&gt; &lt;!-- springBoot的启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springBoot的启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springBoot的启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 测试工具的启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- druid连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Boot缓存支持启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Ehcache坐标 --&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建Ehcache的配置文件 进入src/main/resources/目录下,创建ehcache.xml 123456789101112131415161718192021222324252627&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../config/ehcache.xsd"&gt; &lt;diskStore path="java.io.tmpdir"/&gt; &lt;!--defaultCache:echcache的默认缓存策略 --&gt; &lt;defaultCache maxElementsInMemory="10000" eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="120" maxElementsOnDisk="10000000" diskExpiryThreadIntervalSeconds="120" memoryStoreEvictionPolicy="LRU"&gt; &lt;persistence strategy="localTempSwap"/&gt; &lt;/defaultCache&gt; &lt;!-- 自定义缓存策略 --&gt; &lt;cache name="users" maxElementsInMemory="10000" eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="120" maxElementsOnDisk="10000000" diskExpiryThreadIntervalSeconds="120" memoryStoreEvictionPolicy="LRU"&gt; &lt;persistence strategy="localTempSwap"/&gt; &lt;/cache&gt;&lt;/ehcache&gt; 修改application.properties文件 进入src/main/resources/目录下,修改application.properties 1234567891011spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/ssmspring.datasource.username=rootspring.datasource.password=rootspring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.jpa.hibernate.ddl-auto=updatespring.jpa.show-sql=truespring.cache.ehcache.cofnig=ehcache.xml 创建service 使用缓存策略@Cacheable(value=&quot;users&quot;) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.bjsxt.service.impl;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.Cacheable;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.stereotype.Service;import com.bjsxt.dao.UsersRepository;import com.bjsxt.pojo.Users;import com.bjsxt.service.UsersService;/** * UsersService接口实现类 * * */@Servicepublic class UsersServiceImpl implements UsersService &#123; @Autowired private UsersRepository usersRepository; @Override public List&lt;Users&gt; findUserAll() &#123; return this.usersRepository.findAll(); &#125; @Override //@Cacheable:对当前查询的对象做缓存处理 @Cacheable(value="users") public Users findUserById(Integer id) &#123; return this.usersRepository.findOne(id); &#125; @Override public Page&lt;Users&gt; findUserByPage(Pageable pageable) &#123; return this.usersRepository.findAll(pageable); &#125; @Override public void saveUsers(Users users) &#123; this.usersRepository.save(users); &#125;&#125; 修改实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.bjsxt.pojo;import java.io.Serializable;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;@Entity@Table(name="t_users")public class Users implements Serializable &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name="id") private Integer id; @Column(name="name") private String name; @Column(name="age") private Integer age; @Column(name="address") private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "Users [id=" + id + ", name=" + name + ", age=" + age + ", address=" + address + "]"; &#125;&#125; 创建启动类 开启缓存使用@EnableCaching注解 123456789101112131415package com.bjsxt;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cache.annotation.EnableCaching;@SpringBootApplication@EnableCachingpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 测试 1234567891011121314151617181920212223242526272829303132package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.App;import com.bjsxt.service.UsersService;/** * UsersService测试 * * */@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes=App.class)public class UsersServiceTest &#123; @Autowired private UsersService usersService; @Test public void testFindUserById()&#123; //第一次查询 System.out.println(this.usersService.findUserById(1)); //第二次查询 System.out.println(this.usersService.findUserById(1)); &#125;&#125; 效果 后台输出执行了一次sql查询，第二条结果是从缓存中取出来的 123456Hibernate: select users0_.id as id1_0_0_, users0_.address as address2_0_0_, users0_.age as age3_0_0_, users0_.name as name4_0_0_ from t_users users0_ where users0_.id=?Users [id=1, name=shenlibing, age=18, address=haikoou]Users [id=1, name=shenlibing, age=18, address=haikoou]2019-04-08 15:28:17.262 INFO 1320 --- [ Thread-4] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@5b94b04d: startup date [Mon Apr 08 15:28:11 CST 2019]; root of context hierarchy2019-04-08 15:28:17.265 INFO 1320 --- [ Thread-4] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit &apos;default&apos;2019-04-08 15:28:17.270 INFO 1320 --- [ Thread-4] com.alibaba.druid.pool.DruidDataSource : &#123;dataSource-1&#125; closed @Cacheable 把方法的返回值添加到Ehcache中做缓存 Value属性：指定一个Ehcache配置文件中的缓存策略，如果么有给定value，则表示使用默认的缓存策略 Key属性：给存储的值起个名称。在查询时如果有名称相同的，那么则知己从缓存中将数据返回 修改service 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.bjsxt.service.impl;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.Cacheable;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.stereotype.Service;import com.bjsxt.dao.UsersRepository;import com.bjsxt.pojo.Users;import com.bjsxt.service.UsersService;/** * UsersService接口实现类 * * */@Servicepublic class UsersServiceImpl implements UsersService &#123; @Autowired private UsersRepository usersRepository; @Override public List&lt;Users&gt; findUserAll() &#123; return this.usersRepository.findAll(); &#125; @Override //@Cacheable:对当前查询的对象做缓存处理 @Cacheable(value="users") public Users findUserById(Integer id) &#123; return this.usersRepository.findOne(id); &#125; @Override @Cacheable(value="users",key="#pageable.pageSize") public Page&lt;Users&gt; findUserByPage(Pageable pageable) &#123; return this.usersRepository.findAll(pageable); &#125; @Override public void saveUsers(Users users) &#123; this.usersRepository.save(users); &#125;&#125; 修改测试 123456789101112131415161718192021222324252627282930313233343536373839package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.App;import com.bjsxt.service.UsersService;/** * UsersService测试 * * */@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes=App.class)public class UsersServiceTest &#123; @Autowired private UsersService usersService; @Test public void testFindUserByPage()&#123; Pageable pageable = new PageRequest(0, 2); //第一次查询 System.out.println(this.usersService.findUserByPage(pageable).getTotalElements()); //第二次查询 System.out.println(this.usersService.findUserByPage(pageable).getTotalElements()); //第三次查询 pageable = new PageRequest(1, 2); System.out.println(this.usersService.findUserByPage(pageable).getTotalElements()); &#125;&#125; 效果 后台输出执行了一次sql查询，后面两次是从缓存取出来的 因为service层使用了缓存策略@Cacheable(value=&quot;users&quot;,key=&quot;#pageable.pageSize&quot;)且指定了key为分页的每页条数在测试查询的时候虽然第三次查询重新new PageRequest(1, 2)，但是size还是为2，所以还是从缓存中取 12345678Hibernate: select users0_.id as id1_0_, users0_.address as address2_0_, users0_.age as age3_0_, users0_.name as name4_0_ from t_users users0_ limit ?Hibernate: select count(users0_.id) as col_0_0_ from t_users users0_5552019-04-08 15:45:08.451 INFO 20352 --- [ Thread-4] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@192c3f1e: startup date [Mon Apr 08 15:45:02 CST 2019]; root of context hierarchy2019-04-08 15:45:08.457 INFO 20352 --- [ Thread-4] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit &apos;default&apos;2019-04-08 15:45:08.464 INFO 20352 --- [ Thread-4] com.alibaba.druid.pool.DruidDataSource : &#123;dataSource-1&#125; closed @CacheEvict 清除缓存,在对频繁查询的数据可以从缓存中取,然而一旦有新的数据写入数据库,必须重新刷新缓存,即清除缓存 修改service 1234567@Override//@CacheEvict(value="users",allEntries=true) 清除缓存中以users缓存策略缓存的对象@CacheEvict(value="users",allEntries=true)public void saveUsers(Users users) &#123; this.usersRepository.save(users);&#125; 修改测试 1234567891011121314151617181920212223242526272829303132333435363738394041package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.App;import com.bjsxt.pojo.Users;import com.bjsxt.service.UsersService;/** * UsersService测试 * * */@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes=App.class)public class UsersServiceTest &#123; @Autowired private UsersService usersService; @Test public void testFindAll()&#123; //第一次查询 System.out.println(this.usersService.findUserAll().size()); Users users = new Users(); users.setAddress("南京"); users.setAge(43); users.setName("朱七"); this.usersService.saveUsers(users); //第二次查询 System.out.println(this.usersService.findUserAll().size()); &#125;&#125; 效果 后台输出第一次查询和第二次查询之间插入了一条新数据，第一次查询结果是5条，在插入数据方法saveUsers上开启了清除缓存，所以插入数据之后再一次查询的数据也就同步过来更新为6条 12345678Hibernate: select users0_.id as id1_0_, users0_.address as address2_0_, users0_.age as age3_0_, users0_.name as name4_0_ from t_users users0_5Hibernate: insert into t_users (address, age, name) values (?, ?, ?)Hibernate: select users0_.id as id1_0_, users0_.address as address2_0_, users0_.age as age3_0_, users0_.name as name4_0_ from t_users users0_62019-04-08 15:54:13.046 INFO 19660 --- [ Thread-4] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@192c3f1e: startup date [Mon Apr 08 15:54:08 CST 2019]; root of context hierarchy2019-04-08 15:54:13.049 INFO 19660 --- [ Thread-4] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit &apos;default&apos;2019-04-08 15:54:13.053 INFO 19660 --- [ Thread-4] com.alibaba.druid.pool.DruidDataSource : &#123;dataSource-1&#125; closed 整合Redis 修改pom.xml 12345&lt;!-- Spring Data Redis的启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 创建Redis配置类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.bjsxt.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.StringRedisSerializer;import redis.clients.jedis.JedisPoolConfig;/** * 完成对Redis的整合的一些配置 * * */@Configurationpublic class RedisConfig &#123; /** * 1.创建JedisPoolConfig对象。在该对象中完成一些链接池配置 * */ @Bean public JedisPoolConfig jedisPoolConfig()&#123; JedisPoolConfig config = new JedisPoolConfig(); //最大空闲数 config.setMaxIdle(10); //最小空闲数 config.setMinIdle(5); //最大链接数 config.setMaxTotal(20); return config; &#125; /** * 2.创建JedisConnectionFactory：配置redis链接信息 */ @Bean public JedisConnectionFactory jedisConnectionFactory(JedisPoolConfig config)&#123; JedisConnectionFactory factory = new JedisConnectionFactory(); //关联链接池的配置对象 factory.setPoolConfig(config); //配置链接Redis的信息 //主机地址 factory.setHostName("192.168.1.104"); //端口 factory.setPort(6379); return factory; &#125; /** * 3.创建RedisTemplate:用于执行Redis操作的方法 */ @Bean public RedisTemplate&lt;String,Object&gt; redisTemplate(JedisConnectionFactory factory)&#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); //关联 template.setConnectionFactory(factory); //为key设置序列化器 template.setKeySerializer(new StringRedisSerializer()); //为value设置序列化器 template.setValueSerializer(new StringRedisSerializer()); return template; &#125;&#125; 创建测试 修改pom.xml 添加测试启动依赖坐标 12345&lt;!-- Test的启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt; 测试 12345678910111213141516171819202122232425262728293031323334353637383940package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.App;/** * Spring Data Redis测试 * * */@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes=App.class)public class RedisTest &#123; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; /** * 添加一个字符串 */ @Test public void testSet()&#123; this.redisTemplate.opsForValue().set("key", "北京尚学堂"); &#125; /** * 获取一个字符串 */ @Test public void testGet()&#123; String value = (String)this.redisTemplate.opsForValue().get("key"); System.out.println(value); &#125;&#125; 提取redis的配置信息 修改application.properties 进入src/main/resource/目录,修改application.properties 123456spring.redis.pool.max-idle=10spring.redis.pool.min-idle=5spring.redis.pool.max-total=20spring.redis.hostName=192.168.1.104spring.redis.port=6379 修改redis配置类 将前缀相同的内容创建一个实体使用@ConfigurationProperties注解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.bjsxt.config;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.StringRedisSerializer;import redis.clients.jedis.JedisPoolConfig;/** * 完成对Redis的整合的一些配置 * * */@Configurationpublic class RedisConfig &#123; /** * 1.创建JedisPoolConfig对象。在该对象中完成一些链接池配置 * @ConfigurationProperties:会将前缀相同的内容创建一个实体。 */ @Bean @ConfigurationProperties(prefix="spring.redis.pool") public JedisPoolConfig jedisPoolConfig()&#123; JedisPoolConfig config = new JedisPoolConfig(); /*//最大空闲数 config.setMaxIdle(10); //最小空闲数 config.setMinIdle(5); //最大链接数 config.setMaxTotal(20);*/ System.out.println("默认值："+config.getMaxIdle()); System.out.println("默认值："+config.getMinIdle()); System.out.println("默认值："+config.getMaxTotal()); return config; &#125; /** * 2.创建JedisConnectionFactory：配置redis链接信息 */ @Bean @ConfigurationProperties(prefix="spring.redis") public JedisConnectionFactory jedisConnectionFactory(JedisPoolConfig config)&#123; System.out.println("配置完毕："+config.getMaxIdle()); System.out.println("配置完毕："+config.getMinIdle()); System.out.println("配置完毕："+config.getMaxTotal()); JedisConnectionFactory factory = new JedisConnectionFactory(); //关联链接池的配置对象 factory.setPoolConfig(config); //配置链接Redis的信息 //主机地址 /*factory.setHostName("192.168.1.104"); //端口 factory.setPort(6379);*/ return factory; &#125; /** * 3.创建RedisTemplate:用于执行Redis操作的方法 */ @Bean public RedisTemplate&lt;String,Object&gt; redisTemplate(JedisConnectionFactory factory)&#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); //关联 template.setConnectionFactory(factory); //为key设置序列化器 template.setKeySerializer(new StringRedisSerializer()); //为value设置序列化器 template.setValueSerializer(new StringRedisSerializer()); return template; &#125;&#125; 效果 12345678910111213141516172019-04-08 16:24:36.624 INFO 9340 --- [ main] .s.d.r.c.RepositoryConfigurationDelegate : Multiple Spring Data modules found, entering strict repository configuration mode!默认值：8默认值：0默认值：8配置完毕：10配置完毕：5配置完毕：202019-04-08 16:24:38.113 INFO 9340 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.web.context.support.GenericWebApplicationContext@79d8407f: startup date [Mon Apr 08 16:24:35 CST 2019]; root of context hierarchy2019-04-08 16:24:38.184 INFO 9340 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error]&#125;&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2019-04-08 16:24:38.185 INFO 9340 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error],produces=[text/html]&#125;&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2019-04-08 16:24:38.221 INFO 9340 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2019-04-08 16:24:38.221 INFO 9340 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2019-04-08 16:24:38.269 INFO 9340 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2019-04-08 16:24:38.317 WARN 9340 --- [ main] org.thymeleaf.templatemode.TemplateMode : [THYMELEAF][main] Template Mode &apos;HTML5&apos; is deprecated. Using Template Mode &apos;HTML&apos; instead.2019-04-08 16:24:38.931 INFO 9340 --- [ main] com.bjsxt.test.RedisTest : Started RedisTest in 4.089 seconds (JVM running for 5.112)北京尚学堂2019-04-08 16:24:39.039 INFO 9340 --- [ Thread-2] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@79d8407f: startup date [Mon Apr 08 16:24:35 CST 2019]; root of context hierarchy 存储实体对象 创建实体 实体必须实现序列化接口 123456789101112131415161718192021222324252627282930313233package com.bjsxt.pojo;import java.io.Serializable;public class Users implements Serializable &#123; private Integer id; private String name; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Users [id=" + id + ", name=" + name + ", age=" + age + "]"; &#125; &#125; 修改测试 保存实体前时必须重新设置序列化器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.JdkSerializationRedisSerializer;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.App;import com.bjsxt.pojo.Users;/** * Spring Data Redis测试 * * */@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes=App.class)public class RedisTest &#123; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; /** * 添加Users对象 */ @Test public void testSetUesrs()&#123; Users users = new Users(); users.setAge(20); users.setName("张三丰"); users.setId(1); //重新设置序列化器 this.redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer()); this.redisTemplate.opsForValue().set("users", users); &#125; /** * 取Users对象 */ @Test public void testGetUsers()&#123; //重新设置序列化器 this.redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer()); Users users = (Users)this.redisTemplate.opsForValue().get("users"); System.out.println(users); &#125; &#125; 效果 12345678910111213141516172019-04-08 16:29:32.045 INFO 12720 --- [ main] .s.d.r.c.RepositoryConfigurationDelegate : Multiple Spring Data modules found, entering strict repository configuration mode!默认值：8默认值：0默认值：8配置完毕：10配置完毕：5配置完毕：202019-04-08 16:29:33.400 INFO 12720 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.web.context.support.GenericWebApplicationContext@1e66f1f5: startup date [Mon Apr 08 16:29:31 CST 2019]; root of context hierarchy2019-04-08 16:29:33.477 INFO 12720 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error]&#125;&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2019-04-08 16:29:33.478 INFO 12720 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error],produces=[text/html]&#125;&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2019-04-08 16:29:33.518 INFO 12720 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2019-04-08 16:29:33.518 INFO 12720 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2019-04-08 16:29:33.564 INFO 12720 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2019-04-08 16:29:33.607 WARN 12720 --- [ main] org.thymeleaf.templatemode.TemplateMode : [THYMELEAF][main] Template Mode &apos;HTML5&apos; is deprecated. Using Template Mode &apos;HTML&apos; instead.2019-04-08 16:29:34.223 INFO 12720 --- [ main] com.bjsxt.test.RedisTest : Started RedisTest in 3.616 seconds (JVM running for 4.489)Users [id=1, name=张三丰, age=20]2019-04-08 16:29:34.352 INFO 12720 --- [ Thread-2] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@1e66f1f5: startup date [Mon Apr 08 16:29:31 CST 2019]; root of context hierarchy JdkSerializationRedisSerializer弊端 实体对象通过JdkSerializationRedisSerializer序列化后存到Redis中占用空间大 JSON格式存储实体对象 推荐使用 修改测试 重置序列化Jackson2JsonRedisSerializer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.bjsxt.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.JdkSerializationRedisSerializer;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.bjsxt.App;import com.bjsxt.pojo.Users;/** * Spring Data Redis测试 * * */@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes=App.class)public class RedisTest &#123; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; /** * 基于JSON格式存Users对象 */ @Test public void testSetUsersUseJSON()&#123; Users users = new Users(); users.setAge(20); users.setName("李四丰"); users.setId(1); this.redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Users.class)); this.redisTemplate.opsForValue().set("users_json", users); &#125; /** * 基于JSON格式取Users对象 */ @Test public void testGetUseJSON()&#123; this.redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Users.class)); Users users = (Users)this.redisTemplate.opsForValue().get("users_json"); System.out.println(users); &#125;&#125; 效果 12345678910111213141516172019-04-08 16:41:53.694 INFO 19280 --- [ main] .s.d.r.c.RepositoryConfigurationDelegate : Multiple Spring Data modules found, entering strict repository configuration mode!默认值：8默认值：0默认值：8配置完毕：10配置完毕：5配置完毕：202019-04-08 16:41:55.094 INFO 19280 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.web.context.support.GenericWebApplicationContext@1e66f1f5: startup date [Mon Apr 08 16:41:52 CST 2019]; root of context hierarchy2019-04-08 16:41:55.177 INFO 19280 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error]&#125;&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2019-04-08 16:41:55.178 INFO 19280 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error],produces=[text/html]&#125;&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2019-04-08 16:41:55.216 INFO 19280 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2019-04-08 16:41:55.216 INFO 19280 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2019-04-08 16:41:55.259 INFO 19280 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2019-04-08 16:41:55.311 WARN 19280 --- [ main] org.thymeleaf.templatemode.TemplateMode : [THYMELEAF][main] Template Mode &apos;HTML5&apos; is deprecated. Using Template Mode &apos;HTML&apos; instead.2019-04-08 16:41:55.957 INFO 19280 --- [ main] com.bjsxt.test.RedisTest : Started RedisTest in 3.767 seconds (JVM running for 4.678)Users [id=1, name=李四丰, age=20]2019-04-08 16:41:56.141 INFO 19280 --- [ Thread-2] o.s.w.c.s.GenericWebApplicationContext : Closing org.springframework.web.context.support.GenericWebApplicationContext@1e66f1f5: startup date [Mon Apr 08 16:41:52 CST 2019]; root of context hierarchy]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tomcat集群与Redis分布式]]></title>
    <url>%2Fmyhexo%2F2019%2F03%2F25%2FJava%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AFTomcat%E9%9B%86%E7%BE%A4%E4%B8%8ERedis%E5%88%86%E5%B8%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Lombok原理及使用 下载 官网 插件下载 IDEA安装Lombok插件 Add the Lombok IntelliJ plugin to add lombok support for IntelliJ:Go to File &gt; Settings &gt; PluginsClick on Browse repositories…Search for Lombok PluginClick on Install pluginRestart IntelliJ IDEA Maven引入Lombok 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.4&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Java Decompiler 官网 下载 Lombok验证 通过Java Decompiler验证class文件 Lombok原理 Maven环境隔离 项目环境 本地开发环境(Local) 开发环境(Dev) 测试环境(Beta) 线上环境(Prod) 目录初始化 配置pom.xml build节点中的resources中增加resource节点 1234567891011&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources.$&#123;deploy.type&#125;&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;*.jsp&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt;&lt;/resources&gt; project节点中增加profiles节点 1234567891011121314151617181920212223&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;deploy.type&gt;dev&lt;/deploy.type&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;beta&lt;/id&gt; &lt;properties&gt; &lt;deploy.type&gt;beta&lt;/deploy.type&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;deploy.type&gt;prod&lt;/deploy.type&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; IDEA中设置默认环境 在IDEA右侧Maven Projects,选中本地开发环境对应的的环境，点击右下角出现import changes进行更新 这里设置的默认环境作用于IDEA中配置的Tomcat启动时发布部署的war包 编译打包命令 开发环境 手动打war包 1mvn clean package -Dmaven.test.skip=true -Pdev 线上环境 1mvn clean package -Dmaven.test.skip=true -Pprod 验证 Tomcat集群搭建 原理 通过Nginx负载均衡进行请求转发 单机部署多应用 单机部署多个Tomcat，第一个Tomcat不变,修改第二个Tomcat 配置环境变量 修改/etc/profile增加Tomcat环境变量 123456789#tomcatexport CATALINA_BASE=/opt/module/tomcat1export CATALINA_HOME=/opt/module/tomcat1export TOMCAT_HOME=/opt/module/tomcat1export CATALINA_BASE_2=/opt/module/tomcat2export CATALINA_HOME_2=/opt/module/tomcat2export TOMCAT_HOME_2=/opt/module/tomcat2#export PATH=$PATH:$CATALINA_HOME/bin source /etc/profile使配置文件立即生效 编辑catalina.sh 进入/opt/module/tomcat2/bin目录,编辑catalina.sh 123# OS specific support. $var _must_ be set to either true or false.export CATALINA_BASE=$CATALINA_BASE_2export CATALINA_HOME=$CATALINA_HOME_2 编辑server.xml 进入/opt/module/tomcat2/conf目录，编辑server.xml，修改3个端口，为了方便，每个端口号加上1000 启动 启动Tomcat2 123456789[root@192 bin]# pwd/opt/module/tomcat2/bin[root@192 bin]# ./startup.sh Using CATALINA_BASE: /opt/module/tomcat2Using CATALINA_HOME: /opt/module/tomcat2Using CATALINA_TMPDIR: /opt/module/tomcat2/tempUsing JRE_HOME: /usr/java/jdk1.7.0_80Using CLASSPATH: /opt/module/tomcat2/bin/bootstrap.jar:/opt/module/tomcat2/bin/tomcat-juli.jarTomcat started. 启动Tomcat1 123456789[root@192 bin]# pwd/opt/module/tomcat1/bin[root@192 bin]# ./startup.sh Using CATALINA_BASE: /opt/module/tomcat1Using CATALINA_HOME: /opt/module/tomcat1Using CATALINA_TMPDIR: /opt/module/tomcat1/tempUsing JRE_HOME: /usr/java/jdk1.7.0_80Using CLASSPATH: /opt/module/tomcat1/bin/bootstrap.jar:/opt/module/tomcat1/bin/tomcat-juli.jarTomcat started. 多机部署多应用 多个服务器并且每个服务器只安装一个Tomcat，要保证它们之间的网络是互通的，方可集群，Nginx在任意一台服务器上即可，也可单独把Nginx服务独立出来一台。 Nginx负载均衡实现 负载均衡常用策略 轮询 默认优点：实现简单缺点：不考虑每台服务器处理能力 权重 优点：考虑了每台服务器处理能力的不同，weight默认是1 ip hash 优点：能实现同一个用户访问同一个服务器,可以不改变现有技术架构，直接实现横向拓展缺点：导致服务器请求(负载)不平均(完全依赖ip hash的结果)在ip变化的环境下无法服务 url hash(第三方) 优点：能实现同一个服务器访问同一个服务器缺点：根据url hash分配请求会不平均，请求频繁的url会请求到同一个服务器上的 fair(第三方) 缺点：按后端服务器的响应时间来分配请求，响应时间短的优先分配 负载均衡策略权重配置 编辑/usr/local/nginx/conf/nginx.conf文件，追加 12###########################vhost############################################## include vhost/*.conf; 在/usr/local/nginx/conf目录下，新建vhost文件夹 在/usr/local/nginx/conf/vhost目录下，编辑www.mytest.com.conf配置文件 1234567891011121314151617181920[root@192 sbin]# cat ../conf/vhost/www.mytest.com.confupstream 127.0.0.1&#123; server 127.0.0.1:8080 weight=1; server 127.0.0.1:9080 weight=2;&#125;#Start www.mytest.comserver &#123; listen 80; server_name www.mytest.com; access_log /usr/local/nginx/logs/access.log combined; index index.html index.htm index.php; # send request back to apach location / &#123; proxy_pass http://127.0.0.1; &#125;&#125; 验证 替换/opt/module/tomcat2/webapps/ROOT目录下tomcat.png 访问www.mytest.com,请求分流一下打到Tomcat1，一下打到Tomcat2，Nginx负载均衡策略权重Tomcat2配置weight=2，Tomcat1配置weight=1，所以访问到Tomcat2的概率是Tomcat1的2倍 坑 Session登录信息存储及读取的问题 轮询 登录的时候登录了A服务器，session信息存储到A服务器上了Nginx负载均衡策略使用轮询或者最小连接会导致，第一次访问A服务器，第二次可能访问到B服务器，这个时候存储在A服务器上的session信息在B服务器上读取不到。 ip hash Nginx负载均衡策略使用ip hash，那么登录信息还可以从A服务器上访问，但是这个有可能造成某些服务器压力过大，某些服务器又没有什么压力，这个时候压力过大的机器(包括网卡带宽)有可能成为瓶颈，并且请求不够分散。 服务器定时任务并发的问题 假设有定时关单的Job，单个Tomcat没有任何问题，但是在集群环境下，Spring Schedule定时执行的时候，会都一起执行，会导致数据错乱和资源浪费 Redis 简介 高性能的key-value数据库 内存数据库，支持数据持久化 安装 linux下载redis-2.8.0.tar.gzwindows 解压 1[root@192 soft]# tar -zxvf redis-2.8.0.tar.gz -C /opt/module/ 服务端 启动 直接启动 默认是6379端口 123456789101112131415161718192021222324[root@192 src]# pwd/opt/module/redis-2.8.0/src[root@192 src]# ./redis-server [6448] 26 Mar 18:30:37.044 # Warning: no config file specified, using the default config. In order to specify a config file use ./redis-server /path/to/redis.conf[6448] 26 Mar 18:30:37.045 * Max number of open files set to 10032 _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 2.8.0 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in stand alone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6379 | `-._ `._ / _.-&apos; | PID: 6448 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos; [6448] 26 Mar 18:30:37.046 # Server started, Redis version 2.8.0 指定端口启动 123456789101112131415161718192021[root@192 src]# ./redis-server --port 6380[6457] 26 Mar 18:32:55.317 * Max number of open files set to 10032 _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 2.8.0 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in stand alone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6380 | `-._ `._ / _.-&apos; | PID: 6457 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos; [6457] 26 Mar 18:32:55.318 # Server started, Redis version 2.8.0 指定配置文件配置启动 配置文件修改端口,登录密码 123[root@192 redis-2.8.0]# pwd/opt/module/redis-2.8.0[root@192 redis-2.8.0]# vim redis.conf 123456789101112131415161718192021[root@192 src]# ./redis-server ../redis.conf [6468] 26 Mar 18:37:12.957 * Max number of open files set to 10032 _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 2.8.0 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in stand alone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6380 | `-._ `._ / _.-&apos; | PID: 6468 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos; [6468] 26 Mar 18:37:12.959 # Server started, Redis version 2.8.0 关闭 直接关闭 1[root@192 src]# ./redis-cli shutdown 指定端口关闭 启动如果指定了端口，关闭必须指定端口 1[root@192 src]# ./redis-cli -p 6379 shutdown 指定端口、ip地址、密码关闭 启动指定配置文件启动，配置文件修改了端口、密码，关闭的时候必须指定端口、密码 123456[root@192 src]# ./redis-cli -p 6380 shutdown(error) NOAUTH Authentication required.[root@192 src]# ./redis-cli -p 6380 -h 127.0.0.1 -a 000000 shutdown[root@192 src]# ps -ef | grep redisroot 6526 6337 0 18:51 pts/6 00:00:00 grep redis[root@192 src]# 客户端 连接服务端 直接连接 服务端默认启动，客户端可以直接默认连接 123456789101112[root@192 src]# ./redis-cli 127.0.0.1:6379&gt; keys *1) &quot;b&quot;2) &quot;hash&quot;3) &quot;a2&quot;4) &quot;a1&quot;5) &quot;1&quot;6) &quot;hash2&quot;7) &quot;word&quot;8) &quot;a&quot;9) &quot;a3&quot;127.0.0.1:6379&gt; quit 指定端口连接 服务端指定端口启动，客户端启连接必须指定端口 1[root@192 src]# ./redis-cli -p 6379 指定端口、ip连接 1[root@192 src]# ./redis-cli -p 6379 -h 127.0.0.1 指定端口、ip、密码连接 服务端指定配置文件启动，配置文件修改了端口、密码，客户端连接必须指定端口、密码 123456789101112131415161718[root@192 src]# pwd/opt/module/redis-2.8.0/src[root@192 src]# ./redis-cli -p 6380127.0.0.1:6380&gt; keys *(error) NOAUTH Authentication required.127.0.0.1:6380&gt; quit[root@192 src]# ./redis-cli -p 6380 -h 127.0.0.1 -a 000000127.0.0.1:6380&gt; keys *1) &quot;1&quot;2) &quot;a&quot;3) &quot;a2&quot;4) &quot;hash2&quot;5) &quot;word&quot;6) &quot;b&quot;7) &quot;hash&quot;8) &quot;a3&quot;9) &quot;a1&quot;127.0.0.1:6380&gt; 关闭 1127.0.0.1:6379&gt; quit 数据结构 系统命令 查看键 1127.0.0.1:6379&gt; keys * 查看基本信息 1127.0.0.1:6379&gt; info 退出 1127.0.0.1:6379&gt; exit 1127.0.0.1:6379&gt; quit 切换库 默认使用0库 1127.0.0.1:6379&gt; select 2 清除当前库数据 1127.0.0.1:6379&gt; flushdb 清除所有库数据 1127.0.0.1:6379&gt; flushall 查看键的数量 1127.0.0.1:6379&gt; dbsize 查看键生命时间 -1代表永久有效 12345127.0.0.1:6379[1]&gt; keys *1) &quot;a&quot;2) &quot;b&quot;127.0.0.1:6379[1]&gt; ttl a(integer) -1 查看类型 12127.0.0.1:6379[1]&gt; type astring 日志监听 12127.0.0.1:6379&gt; monitorOK String字符串 设置 设置单个 12127.0.0.1:6379[1]&gt; set c cOK 设置指定生命时间(秒) 123456127.0.0.1:6379[1]&gt; setex d 10 dOK127.0.0.1:6379[1]&gt; ttl d(integer) 7127.0.0.1:6379[1]&gt; ttl d(integer) 6 设置指定生命时间(毫秒秒) 12345678127.0.0.1:6379[1]&gt; psetex e 10000 eOK127.0.0.1:6379[1]&gt; ttl e(integer) 8127.0.0.1:6379[1]&gt; ttl e(integer) 6127.0.0.1:6379[1]&gt; ttl e(integer) 5 重置单个 123456127.0.0.1:6379[1]&gt; get a&quot;a&quot;127.0.0.1:6379[1]&gt; getset a aaa&quot;a&quot;127.0.0.1:6379[1]&gt; get a&quot;aaa&quot; 设置多个 1234567891011127.0.0.1:6379[1]&gt; mset a1 a1_value a2 a2_value a3 a3_valueOK127.0.0.1:6379[1]&gt; keys *1) &quot;a&quot;2) &quot;b&quot;3) &quot;a1&quot;4) &quot;a3&quot;5) &quot;hello&quot;6) &quot;a2&quot;7) &quot;c&quot;127.0.0.1:6379[1]&gt; 设置前判断键是否存在setnx 1234567891011121314127.0.0.1:6379[1]&gt; keys *1) &quot;a&quot;2) &quot;b&quot;3) &quot;a1&quot;4) &quot;a3&quot;5) &quot;hello&quot;6) &quot;a2&quot;7) &quot;c&quot;127.0.0.1:6379[1]&gt; get a&quot;aaa&quot;127.0.0.1:6379[1]&gt; setnx a a(integer) 0127.0.0.1:6379[1]&gt; get a&quot;aaa&quot; 设置多个，判断键是否存在，只要一个失败就失败 12345678127.0.0.1:6379[1]&gt; keys *(empty list or set)127.0.0.1:6379[1]&gt; msetnx a a b b c c(integer) 1127.0.0.1:6379[1]&gt; keys *1) &quot;a&quot;2) &quot;b&quot;3) &quot;c&quot; 追加 12345127.0.0.1:6379[1]&gt; append a aaa(integer) 4127.0.0.1:6379[1]&gt; get a&quot;aaaa&quot; 默认增长 只能是数字增长，默认步长是1 12345678127.0.0.1:6379[1]&gt; set 1 1OK127.0.0.1:6379[1]&gt; incr 1 (integer) 2127.0.0.1:6379[1]&gt; incr 1 (integer) 3127.0.0.1:6379[1]&gt; get 1&quot;3&quot; 指定步长增长 12345678127.0.0.1:6379[1]&gt; get 1&quot;3&quot;127.0.0.1:6379[1]&gt; incrby 1 100(integer) 103127.0.0.1:6379[1]&gt; incrby 1 100(integer) 203127.0.0.1:6379[1]&gt; get 1&quot;203&quot; 默认减值 12345678910127.0.0.1:6379[1]&gt; get 1&quot;203&quot;127.0.0.1:6379[1]&gt; decr 1(integer) 202127.0.0.1:6379[1]&gt; decr 1(integer) 201127.0.0.1:6379[1]&gt; decr 1(integer) 200127.0.0.1:6379[1]&gt; get 1&quot;200&quot; 指定步长减值 12345678910127.0.0.1:6379[1]&gt; get 1&quot;200&quot;127.0.0.1:6379[1]&gt; decrby 1 20(integer) 180127.0.0.1:6379[1]&gt; decrby 1 20(integer) 160127.0.0.1:6379[1]&gt; decrby 1 20(integer) 140127.0.0.1:6379[1]&gt; get 1&quot;140&quot; 获取 获取单个 1234127.0.0.1:6379[1]&gt; get a&quot;a&quot;127.0.0.1:6379[1]&gt; get b&quot;b&quot; 截取 1234127.0.0.1:6379[1]&gt; set hello helloOK127.0.0.1:6379[1]&gt; getrange hello 0 2&quot;hel&quot; 获取多个 12345127.0.0.1:6379[1]&gt; mget a1 a2 a3 1) &quot;a1_value&quot;2) &quot;a2_value&quot;3) &quot;a3_value&quot;127.0.0.1:6379[1]&gt; 长度 1234127.0.0.1:6379[1]&gt; get hello&quot;hello&quot;127.0.0.1:6379[1]&gt; strlen hello(integer) 5 哈希hash 设置 设置单个 12127.0.0.1:6379[1]&gt; hset hash username shenlibing(integer) 1 设置多个 12345678910111213141516127.0.0.1:6379[1]&gt; hmset hash address haikou phone 15501892660OK127.0.0.1:6379[1]&gt; hgetall hash1) &quot;username&quot;2) &quot;shenlibing&quot;3) &quot;age&quot;4) &quot;18&quot;5) &quot;address&quot;6) &quot;haikou&quot;7) &quot;phone&quot;8) &quot;15501892660&quot;127.0.0.1:6379[1]&gt; hkeys hash1) &quot;username&quot;2) &quot;age&quot;3) &quot;address&quot;4) &quot;phone&quot; 删除多个 12345678910127.0.0.1:6379[1]&gt; hkeys hash1) &quot;username&quot;2) &quot;age&quot;3) &quot;address&quot;4) &quot;phone&quot;127.0.0.1:6379[1]&gt; hdel hash address phone(integer) 2127.0.0.1:6379[1]&gt; hkeys hash1) &quot;username&quot;2) &quot;age&quot; 设置单个前判断键是否存在 1234127.0.0.1:6379[1]&gt; hsetnx hash username xiaobingbing(integer) 0127.0.0.1:6379[1]&gt; hget hash username&quot;shenlibing&quot; 获取 获取单个 12127.0.0.1:6379[1]&gt; hget hash username&quot;shenlibing&quot; 判断键是否存在 12127.0.0.1:6379[1]&gt; hexists hash username(integer) 1 获取整个 12345127.0.0.1:6379[1]&gt; hgetall hash1) &quot;username&quot;2) &quot;shenlibing&quot;3) &quot;age&quot;4) &quot;18&quot; 获取键 123127.0.0.1:6379[1]&gt; hkeys hash1) &quot;username&quot;2) &quot;age&quot; 获取值 123127.0.0.1:6379[1]&gt; hvals hash1) &quot;shenlibing&quot;2) &quot;18&quot; 获取长度 12127.0.0.1:6379[1]&gt; hlen hash(integer) 2 获取多个 123127.0.0.1:6379[1]&gt; hmget hash username age1) &quot;shenlibing&quot;2) &quot;18&quot; 列表list 设置 从左往右进 12127.0.0.1:6379&gt; lpush list 1 2 3 4 5 6 7 8 9 10(integer) 10 重置 根据索引重置某个元素 12127.0.0.1:6379&gt; lset list 0 100OK 向左弹出 12127.0.0.1:6379&gt; lpop list&quot;100&quot; 向右弹出 12127.0.0.1:6379&gt; rpop list&quot;1&quot; 获取 获取多个 根据索引截取list元素，获取多个元素 1234127.0.0.1:6379&gt; lrange list 0 21) &quot;10&quot;2) &quot;9&quot;3) &quot;8&quot; 获取单个 根据索引查找list中某个元素，获取单个元素 12127.0.0.1:6379&gt; lindex list 0&quot;100&quot; 长度 12127.0.0.1:6379&gt; llen list(integer) 10 获取所有 1234567891011127.0.0.1:6379&gt; llen list(integer) 8127.0.0.1:6379&gt; lrange list 0 71) &quot;9&quot;2) &quot;8&quot;3) &quot;7&quot;4) &quot;6&quot;5) &quot;5&quot;6) &quot;4&quot;7) &quot;3&quot;8) &quot;2&quot; 集合set 无序，不允许重复 设置 设置多个 12127.0.0.1:6379&gt; sadd set a b c d(integer) 4 重命名 12127.0.0.1:6379&gt; rename set set1OK 删除指定元素,一个或者多个 1234127.0.0.1:6379&gt; srem set1 a b(integer) 2127.0.0.1:6379&gt; srem set1 c(integer) 1 随机删除一个元素 12127.0.0.1:6379&gt; spop set2&quot;f&quot; 获取 长度 12127.0.0.1:6379&gt; scard set1(integer) 4 获取所有 12345127.0.0.1:6379&gt; smembers set21) &quot;d&quot;2) &quot;e&quot;3) &quot;c&quot;4) &quot;f&quot; 差集 12345678910111213127.0.0.1:6379&gt; smembers set1 1) &quot;d&quot;2) &quot;b&quot;3) &quot;c&quot;4) &quot;a&quot;127.0.0.1:6379&gt; smembers set21) &quot;d&quot;2) &quot;e&quot;3) &quot;c&quot;4) &quot;f&quot;127.0.0.1:6379&gt; sdiff set1 set21) &quot;b&quot;2) &quot;a&quot; 123127.0.0.1:6379&gt; sdiff set2 set11) &quot;e&quot;2) &quot;f&quot; 交集 123127.0.0.1:6379&gt; sinter set1 set21) &quot;c&quot;2) &quot;d&quot; 并集 1234567127.0.0.1:6379&gt; sunion set1 set21) &quot;c&quot;2) &quot;e&quot;3) &quot;f&quot;4) &quot;a&quot;5) &quot;b&quot;6) &quot;d&quot; 是否存在某个元素 12127.0.0.1:6379&gt; sismember set1 a(integer) 1 有序集合sortedset 设置 根据分数设置 12127.0.0.1:6379&gt; zadd sortedset1 100 a 200 b 300 c(integer) 3 重命名 12127.0.0.1:6379&gt; rename sortedset1 sortedsetOK 加分数 1234127.0.0.1:6379&gt; zincrby sortedset 1000 a&quot;1100&quot;127.0.0.1:6379&gt; zrank sortedset a(integer) 2 获取 长度 12127.0.0.1:6379&gt; zcard sortedset(integer) 3 获取分数 获取元素的分数 12127.0.0.1:6379&gt; zscore sortedset a&quot;100&quot; 根据分数范围返回成员个数 1234127.0.0.1:6379&gt; zcount sortedset 0 200(integer) 2127.0.0.1:6379&gt; zcount sortedset 0 300(integer) 3 获取元素索引 1234127.0.0.1:6379&gt; zrank sortedset a(integer) 0127.0.0.1:6379&gt; zrank sortedset b(integer) 1 根据索引区间返回元素 可以带分数显示 12345678910111213127.0.0.1:6379&gt; zcard sortedset(integer) 3127.0.0.1:6379&gt; zrange sortedset 0 21) &quot;b&quot;2) &quot;c&quot;3) &quot;a&quot;127.0.0.1:6379&gt; zrange sortedset 0 2 withscores1) &quot;b&quot;2) &quot;200&quot;3) &quot;c&quot;4) &quot;300&quot;5) &quot;a&quot;6) &quot;1100&quot; Redis_Desktop_Manager工具 下载 下载2 Quick Start 原生单点登录 原生Redis+Cookie+Jackson+Filter解决session共享问题实现单点登录 java使用Jedis客户端 编辑pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt;&lt;/dependency&gt; 获取连接 从连接池获取连接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.mmall.common;import com.mmall.util.PropertiesUtil;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/** * Created by geely */public class RedisPool &#123; //jedis连接池 private static JedisPool pool; //最大连接数 private static Integer maxTotal = Integer.parseInt(PropertiesUtil.getProperty("redis.max.total", "20")); //在jedispool中最大的idle状态(空闲的)的jedis实例的个数 private static Integer maxIdle = Integer.parseInt(PropertiesUtil.getProperty("redis.max.idle", "20")); //在jedispool中最小的idle状态(空闲的)的jedis实例的个数 private static Integer minIdle = Integer.parseInt(PropertiesUtil.getProperty("redis.min.idle", "20")); //在borrow一个jedis实例的时候，是否要进行验证操作，如果赋值true。则得到的jedis实例肯定是可以用的。 private static Boolean testOnBorrow = Boolean.parseBoolean(PropertiesUtil.getProperty("redis.test.borrow", "true")); //在return一个jedis实例的时候，是否要进行验证操作，如果赋值true。则放回jedispool的jedis实例肯定是可以用的。 private static Boolean testOnReturn = Boolean.parseBoolean(PropertiesUtil.getProperty("redis.test.return", "true")); private static String redisIp = PropertiesUtil.getProperty("redis.ip"); private static Integer redisPort = Integer.parseInt(PropertiesUtil.getProperty("redis.port")); private static void initPool() &#123; JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(maxTotal); config.setMaxIdle(maxIdle); config.setMinIdle(minIdle); config.setTestOnBorrow(testOnBorrow); config.setTestOnReturn(testOnReturn); //连接耗尽的时候，是否阻塞，false会抛出异常，true阻塞直到超时。默认为true。 config.setBlockWhenExhausted(true); pool = new JedisPool(config, redisIp, redisPort, 1000 * 2); &#125; static &#123; initPool(); &#125; public static Jedis getJedis() &#123; return pool.getResource(); &#125; public static void returnBrokenResource(Jedis jedis) &#123; pool.returnBrokenResource(jedis); &#125; public static void returnResource(Jedis jedis) &#123; pool.returnResource(jedis); &#125; public static void main(String[] args) &#123; Jedis jedis = pool.getResource(); jedis.set("geelykey", "geelyvalue"); returnResource(jedis); //临时调用，销毁连接池中的所有连接 pool.destroy(); System.out.println("program is end"); &#125;&#125; Jedis API封装 读写数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121package com.mmall.util;import com.mmall.common.RedisPool;import lombok.extern.slf4j.Slf4j;import redis.clients.jedis.Jedis;/** * Created by geely */@Slf4jpublic class RedisPoolUtil &#123; /** * 设置key的有效期，单位是秒 * @param key * @param exTime * @return */ public static Long expire(String key,int exTime)&#123; Jedis jedis = null; Long result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.expire(key,exTime); &#125; catch (Exception e) &#123; log.error("expire key:&#123;&#125; error",key,e); RedisPool.returnBrokenResource(jedis); return result; &#125; RedisPool.returnResource(jedis); return result; &#125; //exTime的单位是秒 public static String setEx(String key,String value,int exTime)&#123; Jedis jedis = null; String result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.setex(key,exTime,value); &#125; catch (Exception e) &#123; log.error("setex key:&#123;&#125; value:&#123;&#125; error",key,value,e); RedisPool.returnBrokenResource(jedis); return result; &#125; RedisPool.returnResource(jedis); return result; &#125; public static String set(String key,String value)&#123; Jedis jedis = null; String result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.set(key,value); &#125; catch (Exception e) &#123; log.error("set key:&#123;&#125; value:&#123;&#125; error",key,value,e); RedisPool.returnBrokenResource(jedis); return result; &#125; RedisPool.returnResource(jedis); return result; &#125; public static String get(String key)&#123; Jedis jedis = null; String result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.get(key); &#125; catch (Exception e) &#123; log.error("get key:&#123;&#125; error",key,e); RedisPool.returnBrokenResource(jedis); return result; &#125; RedisPool.returnResource(jedis); return result; &#125; public static Long del(String key)&#123; Jedis jedis = null; Long result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.del(key); &#125; catch (Exception e) &#123; log.error("del key:&#123;&#125; error",key,e); RedisPool.returnBrokenResource(jedis); return result; &#125; RedisPool.returnResource(jedis); return result; &#125; public static void main(String[] args) &#123; Jedis jedis = RedisPool.getJedis(); RedisPoolUtil.set("keyTest","value"); String value = RedisPoolUtil.get("keyTest"); RedisPoolUtil.setEx("keyex","valueex",60*10); RedisPoolUtil.expire("keyTest",60*20); RedisPoolUtil.del("keyTest"); String aaa = RedisPoolUtil.get(null); System.out.println(aaa); System.out.println("end"); &#125;&#125; Jackson封装JacksonUtil 编辑pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.12&lt;/version&gt;&lt;/dependency&gt; 多泛型序列化和反序列化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168package com.mmall.util;import com.google.common.collect.Lists;import com.mmall.pojo.Category;import com.mmall.pojo.TestPojo;import com.mmall.pojo.User;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang.StringUtils;import org.codehaus.jackson.map.DeserializationConfig;import org.codehaus.jackson.map.ObjectMapper;import org.codehaus.jackson.map.SerializationConfig;import org.codehaus.jackson.map.annotate.JsonSerialize.Inclusion;import org.codehaus.jackson.type.JavaType;import org.codehaus.jackson.type.TypeReference;import java.io.IOException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Created by geely */@Slf4jpublic class JsonUtil &#123; private static ObjectMapper objectMapper = new ObjectMapper(); static&#123; //对象的所有字段全部列入 objectMapper.setSerializationInclusion(Inclusion.ALWAYS); //取消默认转换timestamps形式 objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS,false); //忽略空Bean转json的错误 objectMapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS,false); //所有的日期格式都统一为以下的样式，即yyyy-MM-dd HH:mm:ss objectMapper.setDateFormat(new SimpleDateFormat(DateTimeUtil.STANDARD_FORMAT)); //忽略 在json字符串中存在，但是在java对象中不存在对应属性的情况。防止错误 objectMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES,false); &#125; public static &lt;T&gt; String obj2String(T obj)&#123; if(obj == null)&#123; return null; &#125; try &#123; return obj instanceof String ? (String)obj : objectMapper.writeValueAsString(obj); &#125; catch (Exception e) &#123; log.warn("Parse Object to String error",e); return null; &#125; &#125; public static &lt;T&gt; String obj2StringPretty(T obj)&#123; if(obj == null)&#123; return null; &#125; try &#123; return obj instanceof String ? (String)obj : objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj); &#125; catch (Exception e) &#123; log.warn("Parse Object to String error",e); return null; &#125; &#125; public static &lt;T&gt; T string2Obj(String str,Class&lt;T&gt; clazz)&#123; if(StringUtils.isEmpty(str) || clazz == null)&#123; return null; &#125; try &#123; return clazz.equals(String.class)? (T)str : objectMapper.readValue(str,clazz); &#125; catch (Exception e) &#123; log.warn("Parse String to Object error",e); return null; &#125; &#125; public static &lt;T&gt; T string2Obj(String str, TypeReference&lt;T&gt; typeReference)&#123; if(StringUtils.isEmpty(str) || typeReference == null)&#123; return null; &#125; try &#123; return (T)(typeReference.getType().equals(String.class)? str : objectMapper.readValue(str,typeReference)); &#125; catch (Exception e) &#123; log.warn("Parse String to Object error",e); return null; &#125; &#125; public static &lt;T&gt; T string2Obj(String str,Class&lt;?&gt; collectionClass,Class&lt;?&gt;... elementClasses)&#123; JavaType javaType = objectMapper.getTypeFactory().constructParametricType(collectionClass,elementClasses); try &#123; return objectMapper.readValue(str,javaType); &#125; catch (Exception e) &#123; log.warn("Parse String to Object error",e); return null; &#125; &#125; public static void main(String[] args) &#123; TestPojo testPojo = new TestPojo(); testPojo.setName("Geely"); testPojo.setId(666); //&#123;"name":"Geely","id":666&#125; String json = "&#123;\"name\":\"Geely\",\"color\":\"blue\",\"id\":666&#125;"; TestPojo testPojoObject = JsonUtil.string2Obj(json,TestPojo.class);// String testPojoJson = JsonUtil.obj2String(testPojo);// log.info("testPojoJson:&#123;&#125;",testPojoJson); log.info("end");// User user = new User();// user.setId(2);// user.setEmail("geely@happymmall.com");// user.setCreateTime(new Date());// String userJsonPretty = JsonUtil.obj2StringPretty(user);// log.info("userJson:&#123;&#125;",userJsonPretty);// User u2 = new User();// u2.setId(2);// u2.setEmail("geelyu2@happymmall.com");//////// String user1Json = JsonUtil.obj2String(u1);//// String user1JsonPretty = JsonUtil.obj2StringPretty(u1);//// log.info("user1Json:&#123;&#125;",user1Json);//// log.info("user1JsonPretty:&#123;&#125;",user1JsonPretty);////// User user = JsonUtil.string2Obj(user1Json,User.class);////// List&lt;User&gt; userList = Lists.newArrayList();// userList.add(u1);// userList.add(u2);//// String userListStr = JsonUtil.obj2StringPretty(userList);//// log.info("==================");//// log.info(userListStr);////// List&lt;User&gt; userListObj1 = JsonUtil.string2Obj(userListStr, new TypeReference&lt;List&lt;User&gt;&gt;() &#123;// &#125;);////// List&lt;User&gt; userListObj2 = JsonUtil.string2Obj(userListStr,List.class,User.class); System.out.println("end"); &#125;&#125; Cookie封装 其中COOKIE_NAME和COOKIE_DOMAIN是根据实际项目，线上的域名来配置的，如果扩展开来讲，对于里面每个属性，在二级/三级域名下的读写问题是必须要细化的 Cookie的读、写、删 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.mmall.util;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang.StringUtils;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Created by geely */@Slf4jpublic class CookieUtil &#123; private final static String COOKIE_DOMAIN = ".happymmall.com"; private final static String COOKIE_NAME = "mmall_login_token"; public static String readLoginToken(HttpServletRequest request)&#123; Cookie[] cks = request.getCookies(); if(cks != null)&#123; for(Cookie ck : cks)&#123; log.info("read cookieName:&#123;&#125;,cookieValue:&#123;&#125;",ck.getName(),ck.getValue()); if(StringUtils.equals(ck.getName(),COOKIE_NAME))&#123; log.info("return cookieName:&#123;&#125;,cookieValue:&#123;&#125;",ck.getName(),ck.getValue()); return ck.getValue(); &#125; &#125; &#125; return null; &#125; //X:domain=".happymmall.com" //a:A.happymmall.com cookie:domain=A.happymmall.com;path="/" //b:B.happymmall.com cookie:domain=B.happymmall.com;path="/" //c:A.happymmall.com/test/cc cookie:domain=A.happymmall.com;path="/test/cc" //d:A.happymmall.com/test/dd cookie:domain=A.happymmall.com;path="/test/dd" //e:A.happymmall.com/test cookie:domain=A.happymmall.com;path="/test" public static void writeLoginToken(HttpServletResponse response,String token)&#123; Cookie ck = new Cookie(COOKIE_NAME,token); ck.setDomain(COOKIE_DOMAIN); ck.setPath("/");//代表设置在根目录 ck.setHttpOnly(true); //单位是秒。 //如果这个maxage不设置的话，cookie就不会写入硬盘，而是写在内存。只在当前页面有效。 ck.setMaxAge(60 * 60 * 24 * 365);//如果是-1，代表永久 log.info("write cookieName:&#123;&#125;,cookieValue:&#123;&#125;",ck.getName(),ck.getValue()); response.addCookie(ck); &#125; public static void delLoginToken(HttpServletRequest request,HttpServletResponse response)&#123; Cookie[] cks = request.getCookies(); if(cks != null)&#123; for(Cookie ck : cks)&#123; if(StringUtils.equals(ck.getName(),COOKIE_NAME))&#123; ck.setDomain(COOKIE_DOMAIN); ck.setPath("/"); ck.setMaxAge(0);//设置成0，代表删除此cookie。 log.info("del cookieName:&#123;&#125;,cookieValue:&#123;&#125;",ck.getName(),ck.getValue()); response.addCookie(ck); return; &#125; &#125; &#125; &#125;&#125; SessionExpireFilter构建Session时间重置过滤器 编辑web.xml 12345678&lt;filter&gt; &lt;filter-name&gt;sessionExpireFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.mmall.controller.common.SessionExpireFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;sessionExpireFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 时间重置过滤器类 SessionExpireFilter.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.mmall.controller.common;import com.mmall.common.Const;import com.mmall.pojo.User;import com.mmall.util.CookieUtil;import com.mmall.util.JsonUtil;import com.mmall.util.RedisShardedPoolUtil;import org.apache.commons.lang.StringUtils;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import java.io.IOException;/** * Created by geely */public class SessionExpireFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest; String loginToken = CookieUtil.readLoginToken(httpServletRequest); if(StringUtils.isNotEmpty(loginToken))&#123; //判断logintoken是否为空或者""； //如果不为空的话，符合条件，继续拿user信息 String userJsonStr = RedisShardedPoolUtil.get(loginToken); User user = JsonUtil.string2Obj(userJsonStr,User.class); if(user != null)&#123; //如果user不为空，则重置session的时间，即调用expire命令 RedisShardedPoolUtil.expire(loginToken, Const.RedisCacheExtime.REDIS_SESSION_EXTIME); &#125; &#125; filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; Guava Cache迁移Redis分布式缓存 描述：修改密码时需要验证token，token的生成是在校验忘记密码的问题答案是正确的时候生成，如果答案是正确的话，返回给前台。重置密码发起请求携带该token到后台校验是否一致。 集群后Guava Cache的不足 Tomcat之前使用的guava cache存储token，它只存在于tomcat实例上，tomcat及tomcat之间并不共享，所以必须迁移。否则负载均衡就TomcatA存储了guava cache，TomcatB想拿就拿不到了 Guava Cache迁移Redis缓存 修改前 guava cache存储token 12345678910111213141516171819202122232425262728293031323334353637public ServerResponse&lt;String&gt; checkAnswer(String username,String question,String answer)&#123; int resultCount = userMapper.checkAnswer(username,question,answer); if(resultCount&gt;0)&#123; //说明问题及问题答案是这个用户的,并且是正确的 String forgetToken = UUID.randomUUID().toString(); TokenCache.setKey(TokenCache.TOKEN_PREFIX+username,forgetToken); return ServerResponse.createBySuccess(forgetToken); &#125; return ServerResponse.createByErrorMessage("问题的答案错误");&#125;public ServerResponse&lt;String&gt; forgetResetPassword(String username,String passwordNew,String forgetToken)&#123; if(org.apache.commons.lang3.StringUtils.isBlank(forgetToken))&#123; return ServerResponse.createByErrorMessage("参数错误,token需要传递"); &#125; ServerResponse validResponse = this.checkValid(username,Const.USERNAME); if(validResponse.isSuccess())&#123; //用户不存在 return ServerResponse.createByErrorMessage("用户不存在"); &#125; String token = TokenCache.getKey(TokenCache.TOKEN_PREFIX+username); if(org.apache.commons.lang3.StringUtils.isBlank(token))&#123; return ServerResponse.createByErrorMessage("token无效或者过期"); &#125; if(org.apache.commons.lang3.StringUtils.equals(forgetToken,token))&#123; String md5Password = MD5Util.MD5EncodeUtf8(passwordNew); int rowCount = userMapper.updatePasswordByUsername(username,md5Password); if(rowCount &gt; 0)&#123; return ServerResponse.createBySuccessMessage("修改密码成功"); &#125; &#125;else&#123; return ServerResponse.createByErrorMessage("token错误,请重新获取重置密码的token"); &#125; return ServerResponse.createByErrorMessage("修改密码失败");&#125; 修改后 后台token保存在Redis上 12345678910111213141516171819202122232425262728293031323334353637public ServerResponse&lt;String&gt; checkAnswer(String username,String question,String answer)&#123; int resultCount = userMapper.checkAnswer(username,question,answer); if(resultCount&gt;0)&#123; //说明问题及问题答案是这个用户的,并且是正确的 String forgetToken = UUID.randomUUID().toString(); RedisShardedPoolUtil.setEx(Const.TOKEN_PREFIX+username,forgetToken,60*60*12); return ServerResponse.createBySuccess(forgetToken); &#125; return ServerResponse.createByErrorMessage("问题的答案错误");&#125;public ServerResponse&lt;String&gt; forgetResetPassword(String username,String passwordNew,String forgetToken)&#123; if(org.apache.commons.lang3.StringUtils.isBlank(forgetToken))&#123; return ServerResponse.createByErrorMessage("参数错误,token需要传递"); &#125; ServerResponse validResponse = this.checkValid(username,Const.USERNAME); if(validResponse.isSuccess())&#123; //用户不存在 return ServerResponse.createByErrorMessage("用户不存在"); &#125; String token = RedisShardedPoolUtil.get(Const.TOKEN_PREFIX+username); if(org.apache.commons.lang3.StringUtils.isBlank(token))&#123; return ServerResponse.createByErrorMessage("token无效或者过期"); &#125; if(org.apache.commons.lang3.StringUtils.equals(forgetToken,token))&#123; String md5Password = MD5Util.MD5EncodeUtf8(passwordNew); int rowCount = userMapper.updatePasswordByUsername(username,md5Password); if(rowCount &gt; 0)&#123; return ServerResponse.createBySuccessMessage("修改密码成功"); &#125; &#125;else&#123; return ServerResponse.createByErrorMessage("token错误,请重新获取重置密码的token"); &#125; return ServerResponse.createByErrorMessage("修改密码失败");&#125; Redis分布式环境搭建 第一个Redis不变，修改第二个Redis 编辑redis.conf 启动 第一个默认启动,默认端口6379 1[root@192 src]# ./redis-server &amp; 第二个指定配置文件启动，修改后的端口6380 1[root@192 src]# ./redis-server ../redis.conf &amp; java代码连接Redis分布式缓存 一致性算法 获取连接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.mmall.common;import com.mmall.util.PropertiesUtil;import redis.clients.jedis.JedisPoolConfig;import redis.clients.jedis.JedisShardInfo;import redis.clients.jedis.ShardedJedis;import redis.clients.jedis.ShardedJedisPool;import redis.clients.util.Hashing;import redis.clients.util.Sharded;import java.util.ArrayList;import java.util.List;/** * Created by geely */public class RedisShardedPool &#123; private static ShardedJedisPool pool;//sharded jedis连接池 private static Integer maxTotal = Integer.parseInt(PropertiesUtil.getProperty("redis.max.total","20")); //最大连接数 private static Integer maxIdle = Integer.parseInt(PropertiesUtil.getProperty("redis.max.idle","20"));//在jedispool中最大的idle状态(空闲的)的jedis实例的个数 private static Integer minIdle = Integer.parseInt(PropertiesUtil.getProperty("redis.min.idle","20"));//在jedispool中最小的idle状态(空闲的)的jedis实例的个数 private static Boolean testOnBorrow = Boolean.parseBoolean(PropertiesUtil.getProperty("redis.test.borrow","true"));//在borrow一个jedis实例的时候，是否要进行验证操作，如果赋值true。则得到的jedis实例肯定是可以用的。 private static Boolean testOnReturn = Boolean.parseBoolean(PropertiesUtil.getProperty("redis.test.return","true"));//在return一个jedis实例的时候，是否要进行验证操作，如果赋值true。则放回jedispool的jedis实例肯定是可以用的。 private static String redis1Ip = PropertiesUtil.getProperty("redis1.ip"); private static Integer redis1Port = Integer.parseInt(PropertiesUtil.getProperty("redis1.port")); private static String redis2Ip = PropertiesUtil.getProperty("redis2.ip"); private static Integer redis2Port = Integer.parseInt(PropertiesUtil.getProperty("redis2.port")); private static void initPool()&#123; JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(maxTotal); config.setMaxIdle(maxIdle); config.setMinIdle(minIdle); config.setTestOnBorrow(testOnBorrow); config.setTestOnReturn(testOnReturn); //连接耗尽的时候，是否阻塞，false会抛出异常，true阻塞直到超时。默认为true。 config.setBlockWhenExhausted(true); JedisShardInfo info1 = new JedisShardInfo(redis1Ip,redis1Port,1000*2); JedisShardInfo info2 = new JedisShardInfo(redis2Ip,redis2Port,1000*2); List&lt;JedisShardInfo&gt; jedisShardInfoList = new ArrayList&lt;JedisShardInfo&gt;(2); jedisShardInfoList.add(info1); jedisShardInfoList.add(info2); pool = new ShardedJedisPool(config,jedisShardInfoList, Hashing.MURMUR_HASH, Sharded.DEFAULT_KEY_TAG_PATTERN); &#125; static&#123; initPool(); &#125; public static ShardedJedis getJedis()&#123; return pool.getResource(); &#125; public static void returnBrokenResource(ShardedJedis jedis)&#123; pool.returnBrokenResource(jedis); &#125; public static void returnResource(ShardedJedis jedis)&#123; pool.returnResource(jedis); &#125; public static void main(String[] args) &#123; ShardedJedis jedis = pool.getResource(); for(int i =0;i&lt;10;i++)&#123; jedis.set("key"+i,"value"+i); &#125; returnResource(jedis);// pool.destroy();//临时调用，销毁连接池中的所有连接 System.out.println("program is end"); &#125;&#125; 读写数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151package com.mmall.util;import com.mmall.common.RedisShardedPool;import lombok.extern.slf4j.Slf4j;import redis.clients.jedis.ShardedJedis;/** * Created by geely */@Slf4jpublic class RedisShardedPoolUtil &#123; /** * 设置key的有效期，单位是秒 * @param key * @param exTime * @return */ public static Long expire(String key,int exTime)&#123; ShardedJedis jedis = null; Long result = null; try &#123; jedis = RedisShardedPool.getJedis(); result = jedis.expire(key,exTime); &#125; catch (Exception e) &#123; log.error("expire key:&#123;&#125; error",key,e); RedisShardedPool.returnBrokenResource(jedis); return result; &#125; RedisShardedPool.returnResource(jedis); return result; &#125; //exTime的单位是秒 public static String setEx(String key,String value,int exTime)&#123; ShardedJedis jedis = null; String result = null; try &#123; jedis = RedisShardedPool.getJedis(); result = jedis.setex(key,exTime,value); &#125; catch (Exception e) &#123; log.error("setex key:&#123;&#125; value:&#123;&#125; error",key,value,e); RedisShardedPool.returnBrokenResource(jedis); return result; &#125; RedisShardedPool.returnResource(jedis); return result; &#125; public static String set(String key,String value)&#123; ShardedJedis jedis = null; String result = null; try &#123; jedis = RedisShardedPool.getJedis(); result = jedis.set(key,value); &#125; catch (Exception e) &#123; log.error("set key:&#123;&#125; value:&#123;&#125; error",key,value,e); RedisShardedPool.returnBrokenResource(jedis); return result; &#125; RedisShardedPool.returnResource(jedis); return result; &#125; public static String getSet(String key,String value)&#123; ShardedJedis jedis = null; String result = null; try &#123; jedis = RedisShardedPool.getJedis(); result = jedis.getSet(key,value); &#125; catch (Exception e) &#123; log.error("getset key:&#123;&#125; value:&#123;&#125; error",key,value,e); RedisShardedPool.returnBrokenResource(jedis); return result; &#125; RedisShardedPool.returnResource(jedis); return result; &#125; public static String get(String key)&#123; ShardedJedis jedis = null; String result = null; try &#123; jedis = RedisShardedPool.getJedis(); result = jedis.get(key); &#125; catch (Exception e) &#123; log.error("get key:&#123;&#125; error",key,e); RedisShardedPool.returnBrokenResource(jedis); return result; &#125; RedisShardedPool.returnResource(jedis); return result; &#125; public static Long del(String key)&#123; ShardedJedis jedis = null; Long result = null; try &#123; jedis = RedisShardedPool.getJedis(); result = jedis.del(key); &#125; catch (Exception e) &#123; log.error("del key:&#123;&#125; error",key,e); RedisShardedPool.returnBrokenResource(jedis); return result; &#125; RedisShardedPool.returnResource(jedis); return result; &#125; public static Long setnx(String key,String value)&#123; ShardedJedis jedis = null; Long result = null; try &#123; jedis = RedisShardedPool.getJedis(); result = jedis.setnx(key,value); &#125; catch (Exception e) &#123; log.error("setnx key:&#123;&#125; value:&#123;&#125; error",key,value,e); RedisShardedPool.returnBrokenResource(jedis); return result; &#125; RedisShardedPool.returnResource(jedis); return result; &#125; public static void main(String[] args) &#123; ShardedJedis jedis = RedisShardedPool.getJedis(); RedisPoolUtil.set("keyTest","value"); String value = RedisPoolUtil.get("keyTest"); RedisPoolUtil.setEx("keyex","valueex",60*10); RedisPoolUtil.expire("keyTest",60*20); RedisPoolUtil.del("keyTest"); String aaa = RedisPoolUtil.get(null); System.out.println(aaa); System.out.println("end"); &#125;&#125; Spring Session单点登录 参考 官网 官方文档 GitHub地址 Quick Start 引入依赖 123456&lt;!-- spring session 单点登录 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;1.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring Session整合Redis applicationContext.xml引入整合配置文件 1&lt;import resource="applicationContext-spring-session.xml"/&gt; 新建applicationContext-spring-session.xml资源文件 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;bean id="redisHttpSessionConfiguration" class="org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"&gt; &lt;property name="maxInactiveIntervalInSeconds" value="1800" /&gt; &lt;/bean&gt; &lt;bean id="defaultCookieSerializer" class="org.springframework.session.web.http.DefaultCookieSerializer"&gt; &lt;property name="domainName" value="localhost" /&gt; &lt;property name="useHttpOnlyCookie" value="true" /&gt; &lt;property name="cookiePath" value="/" /&gt; &lt;property name="cookieMaxAge" value="31536000" /&gt; &lt;/bean&gt; &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;property name="maxTotal" value="20"/&gt; &lt;/bean&gt; &lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt; &lt;property name="hostName" value="192.168.1.104" /&gt; &lt;property name="port" value="6379" /&gt; &lt;property name="poolConfig" ref="jedisPoolConfig" /&gt; &lt;/bean&gt;&lt;/beans&gt; 配置web.xml 12345678&lt;filter&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 使用 这里的session是经过包装过的代理类 123session.setAttribute(Const.CURRENT_USER,response.getData());session.removeAttribute(Const.CURRENT_USER);User user = (User)session.getAttribute(Const.CURRENT_USER); 坑 Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [org.springframework.session.SessionRepository] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {} 描述： 启动报错 解决：修改&lt;org.springframework.version&gt;4.0.0.RELEASE&lt;/org.springframework.version&gt;为 &lt;org.springframework.version&gt;4.0.3.RELEASE&lt;/org.springframework.version&gt; No bean named ‘springSessionRepositoryFilter’ is defined 描述：启动报错，容器找不到该bean 12345678&lt;filter&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 解决： spring配置文件没有引入spring-session整合配置文件 1&lt;import resource="applicationContext-spring-session.xml"/&gt; SpringMVC全局异常控制 Spring及SpringMVC包扫描隔离 Spring扫描 排除controller扫描注解 123&lt;context:component-scan base-package="com.mmall" annotation-config="true"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt;&lt;/context:component-scan&gt; SpringMVC扫描 123456&lt;!--springmvc扫描包指定到controller，防止重复扫描 use-default-filters="false" 关闭默认扫描 --&gt;&lt;context:component-scan base-package="com.mmall.controller" annotation-config="true" use-default-filters="false"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;&lt;/context:component-scan&gt; @Component注解 异常包装类ExceptionResolver.java,必须要加上@Component注解，使其成为容器中的bean，@Component类似于@Controller、@Service、@Repository dao层用@Repositoryservice层用@Servicecontroller层用@Controller其它的用@Component 123456789101112131415161718192021222324252627282930313233package com.mmall.common;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component;import org.springframework.stereotype.Repository;import org.springframework.stereotype.Service;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.view.json.MappingJacksonJsonView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Created by geely */@Slf4j@Componentpublic class ExceptionResolver implements HandlerExceptionResolver&#123; @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123; log.error("&#123;&#125; Exception",httpServletRequest.getRequestURI(),e); ModelAndView modelAndView = new ModelAndView(new MappingJacksonJsonView()); //当使用是jackson2.x的时候使用MappingJackson2JsonView，本项目使用的是1.9。 modelAndView.addObject("status",ResponseCode.ERROR.getCode()); modelAndView.addObject("msg","接口异常,详情请查看服务端日志的异常信息"); modelAndView.addObject("data",e.toString()); return modelAndView; &#125;&#125; SpringMVC拦截器 springmvc配置拦截器 &lt;mvc:mapping path=&quot;/manage/**&quot;/&gt;代表请求经过/manage目录下的子目录下的controller也会被拦截 &lt;mvc:mapping path=&quot;/manage/*&quot;/&gt;代表请求经过/manage目录下的controller会被拦截，而子目录下的controller不会被拦截 &lt;mvc:exclude-mapping path=&quot;/manage/user/login.do&quot;/&gt;配置不拦截某些请求 12345678910111213&lt;mvc:interceptors&gt; &lt;!-- 定义在这里的，所有的都会拦截--&gt; &lt;mvc:interceptor&gt; &lt;!--manage/a.do /manage/*--&gt; &lt;!--manage/b.do /manage/*--&gt; &lt;!--manage/product/save.do /manage/**--&gt; &lt;!--manage/order/detail.do /manage/**--&gt; &lt;mvc:mapping path="/manage/**"/&gt; &lt;!--&lt;mvc:exclude-mapping path="/manage/user/login.do"/&gt;--&gt; &lt;bean class="com.mmall.controller.common.interceptor.AuthorityInterceptor" /&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 定义拦截器处理类 preHandle请求到达controll之前会调用该方法 postHandle请求到达controller处理后会调用该方法 afterCompletion请求到达controller处理后返回ModelAndView后会调用该方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package com.mmall.controller.common.interceptor;import com.google.common.collect.Maps;import com.mmall.common.Const;import com.mmall.common.ServerResponse;import com.mmall.pojo.User;import com.mmall.util.CookieUtil;import com.mmall.util.JsonUtil;import com.mmall.util.RedisShardedPoolUtil;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang.StringUtils;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.PrintWriter;import java.util.Arrays;import java.util.Iterator;import java.util.Map;/** * Created by geely */@Slf4jpublic class AuthorityInterceptor implements HandlerInterceptor&#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; log.info("preHandle"); //请求中Controller中的方法名 HandlerMethod handlerMethod = (HandlerMethod)handler; //解析HandlerMethod String methodName = handlerMethod.getMethod().getName(); String className = handlerMethod.getBean().getClass().getSimpleName(); //解析参数,具体的参数key以及value是什么，我们打印日志 StringBuffer requestParamBuffer = new StringBuffer(); Map paramMap = request.getParameterMap(); Iterator it = paramMap.entrySet().iterator(); while (it.hasNext())&#123; Map.Entry entry = (Map.Entry)it.next(); String mapKey = (String)entry.getKey(); String mapValue = StringUtils.EMPTY; //request这个参数的map，里面的value返回的是一个String[] Object obj = entry.getValue(); if(obj instanceof String[])&#123; String[] strs = (String[])obj; mapValue = Arrays.toString(strs); &#125; requestParamBuffer.append(mapKey).append("=").append(mapValue); &#125; if(StringUtils.equals(className,"UserManageController") &amp;&amp; StringUtils.equals(methodName,"login"))&#123; log.info("权限拦截器拦截到请求,className:&#123;&#125;,methodName:&#123;&#125;",className,methodName); //如果是拦截到登录请求，不打印参数，因为参数里面有密码，全部会打印到日志中，防止日志泄露 return true; &#125; log.info("权限拦截器拦截到请求,className:&#123;&#125;,methodName:&#123;&#125;,param:&#123;&#125;",className,methodName,requestParamBuffer.toString()); User user = null; String loginToken = CookieUtil.readLoginToken(request); if(StringUtils.isNotEmpty(loginToken))&#123; String userJsonStr = RedisShardedPoolUtil.get(loginToken); user = JsonUtil.string2Obj(userJsonStr,User.class); &#125; if(user == null || (user.getRole().intValue() != Const.Role.ROLE_ADMIN))&#123; //返回false.即不会调用controller里的方法 response.reset();//geelynote 这里要添加reset，否则报异常 getWriter() has already been called for this response. response.setCharacterEncoding("UTF-8");//geelynote 这里要设置编码，否则会乱码 response.setContentType("application/json;charset=UTF-8");//geelynote 这里要设置返回值的类型，因为全部是json接口。 PrintWriter out = response.getWriter(); //上传由于富文本的控件要求，要特殊处理返回值，这里面区分是否登录以及是否有权限 if(user == null)&#123; if(StringUtils.equals(className,"ProductManageController") &amp;&amp; StringUtils.equals(methodName,"richtextImgUpload"))&#123; Map resultMap = Maps.newHashMap(); resultMap.put("success",false); resultMap.put("msg","请登录管理员"); out.print(JsonUtil.obj2String(resultMap)); &#125;else&#123; out.print(JsonUtil.obj2String(ServerResponse.createByErrorMessage("拦截器拦截,用户未登录"))); &#125; &#125;else&#123; if(StringUtils.equals(className,"ProductManageController") &amp;&amp; StringUtils.equals(methodName,"richtextImgUpload"))&#123; Map resultMap = Maps.newHashMap(); resultMap.put("success",false); resultMap.put("msg","无权限操作"); out.print(JsonUtil.obj2String(resultMap)); &#125;else&#123; out.print(JsonUtil.obj2String(ServerResponse.createByErrorMessage("拦截器拦截,用户无权限操作"))); &#125; &#125; out.flush(); out.close();//geelynote 这里要关闭 return false; &#125; return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; log.info("postHandle"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; log.info("afterCompletion"); &#125;&#125; 登录死循环 描述：springmvc配置拦截器，如果登录请求也拦截的话，会导致一直登录不上，陷入死循环当中 解决：方式一：可以在配置拦截器的时候过滤掉登录请求&lt;mvc:exclude-mapping path=&quot;/manage/user/login.do&quot;/&gt; 方式二：拦截器处理类的preHandle方法会在到达controller调用该方法,因此可以在该方法中过滤掉登录请求不拦截 12345if(StringUtils.equals(className,"UserManageController") &amp;&amp; StringUtils.equals(methodName,"login"))&#123; log.info("权限拦截器拦截到请求,className:&#123;&#125;,methodName:&#123;&#125;",className,methodName); //如果是拦截到登录请求，不打印参数，因为参数里面有密码，全部会打印到日志中，防止日志泄露 return true;&#125; 重置响应对象 描述：拦截器处理类的三个方法都是返回布尔值，而controller都是返回json数据，请求如果被拦截到没有到达controller，那么在拦截器处理类的preHandle方法中必须重置响应对象 解决： 12345678910111213141516171819202122232425262728293031323334if(user == null || (user.getRole().intValue() != Const.Role.ROLE_ADMIN))&#123; //返回false.即不会调用controller里的方法 response.reset();//geelynote 这里要添加reset，否则报异常 getWriter() has already been called for this response. response.setCharacterEncoding("UTF-8");//geelynote 这里要设置编码，否则会乱码 response.setContentType("application/json;charset=UTF-8");//geelynote 这里要设置返回值的类型，因为全部是json接口。 PrintWriter out = response.getWriter(); //上传由于富文本的控件要求，要特殊处理返回值，这里面区分是否登录以及是否有权限 if(user == null)&#123; if(StringUtils.equals(className,"ProductManageController") &amp;&amp; StringUtils.equals(methodName,"richtextImgUpload"))&#123; Map resultMap = Maps.newHashMap(); resultMap.put("success",false); resultMap.put("msg","请登录管理员"); out.print(JsonUtil.obj2String(resultMap)); &#125;else&#123; out.print(JsonUtil.obj2String(ServerResponse.createByErrorMessage("拦截器拦截,用户未登录"))); &#125; &#125;else&#123; if(StringUtils.equals(className,"ProductManageController") &amp;&amp; StringUtils.equals(methodName,"richtextImgUpload"))&#123; Map resultMap = Maps.newHashMap(); resultMap.put("success",false); resultMap.put("msg","无权限操作"); out.print(JsonUtil.obj2String(resultMap)); &#125;else&#123; out.print(JsonUtil.obj2String(ServerResponse.createByErrorMessage("拦截器拦截,用户无权限操作"))); &#125; &#125; out.flush(); out.close();//geelynote 这里要关闭 return false;&#125; SpringMVC RESTful改造 编辑web.xml 修改前 12345678910&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 修改后 12345678910&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; controller使用RESTful风格 根据id查询产品 修改前 12345@RequestMapping("detail.do")@ResponseBodypublic ServerResponse&lt;ProductDetailVo&gt; detail(Integer productId)&#123; return iProductService.getProductDetail(productId);&#125; 修改后 12345@RequestMapping(value = "/&#123;productId&#125;", method = RequestMethod.GET)@ResponseBodypublic ServerResponse&lt;ProductDetailVo&gt; detailRESTful(@PathVariable Integer productId)&#123; return iProductService.getProductDetail(productId);&#125; 搜索产品 keyword、categoryId不为空 修改前 123456789@RequestMapping("list.do")@ResponseBodypublic ServerResponse&lt;PageInfo&gt; list(@RequestParam(value = "keyword",required = false)String keyword, @RequestParam(value = "categoryId",required = false)Integer categoryId, @RequestParam(value = "pageNum",defaultValue = "1") int pageNum, @RequestParam(value = "pageSize",defaultValue = "10") int pageSize, @RequestParam(value = "orderBy",defaultValue = "") String orderBy)&#123; return iProductService.getProductByKeywordCategory(keyword,categoryId,pageNum,pageSize,orderBy);&#125; 修改后 1234567891011121314151617181920//http://www.happymmall.com/product/手机/100012/1/10/price_asc@RequestMapping(value = "/&#123;keyword&#125;/&#123;categoryId&#125;/&#123;pageNum&#125;/&#123;pageSize&#125;/&#123;orderBy&#125;",method = RequestMethod.GET)@ResponseBodypublic ServerResponse&lt;PageInfo&gt; listRESTful(@PathVariable(value = "keyword")String keyword, @PathVariable(value = "categoryId")Integer categoryId, @PathVariable(value = "pageNum") Integer pageNum, @PathVariable(value = "pageSize") Integer pageSize, @PathVariable(value = "orderBy") String orderBy)&#123; if(pageNum == null)&#123; pageNum = 1; &#125; if(pageSize == null)&#123; pageSize = 10; &#125; if(StringUtils.isBlank(orderBy))&#123; orderBy = "price_asc"; &#125; return iProductService.getProductByKeywordCategory(keyword,categoryId,pageNum,pageSize,orderBy);&#125; keyword、categoryId有一个为空 修改后版本一 keyword为空 12345678910111213141516171819// http://www.happymmall.com/product/100012/1/10/price_asc@RequestMapping(value = "/&#123;categoryId&#125;/&#123;pageNum&#125;/&#123;pageSize&#125;/&#123;orderBy&#125;",method = RequestMethod.GET)@ResponseBodypublic ServerResponse&lt;PageInfo&gt; listRESTfulBadcase(@PathVariable(value = "categoryId")Integer categoryId, @PathVariable(value = "pageNum") Integer pageNum, @PathVariable(value = "pageSize") Integer pageSize, @PathVariable(value = "orderBy") String orderBy)&#123; if(pageNum == null)&#123; pageNum = 1; &#125; if(pageSize == null)&#123; pageSize = 10; &#125; if(StringUtils.isBlank(orderBy))&#123; orderBy = "price_asc"; &#125; return iProductService.getProductByKeywordCategory("",categoryId,pageNum,pageSize,orderBy);&#125; categoryId为空 123456789101112131415161718@RequestMapping(value = "/&#123;keyword&#125;/&#123;pageNum&#125;/&#123;pageSize&#125;/&#123;orderBy&#125;",method = RequestMethod.GET)@ResponseBodypublic ServerResponse&lt;PageInfo&gt; listRESTfulBadcase(@PathVariable(value = "keyword")String keyword, @PathVariable(value = "pageNum") Integer pageNum, @PathVariable(value = "pageSize") Integer pageSize, @PathVariable(value = "orderBy") String orderBy)&#123; if(pageNum == null)&#123; pageNum = 1; &#125; if(pageSize == null)&#123; pageSize = 10; &#125; if(StringUtils.isBlank(orderBy))&#123; orderBy = "price_asc"; &#125; return iProductService.getProductByKeywordCategory(keyword,null,pageNum,pageSize,orderBy);&#125; 浏览器请求http://localhost:8088/mmall_war_exploded/product/100012/1/10/price_asc 发生了歧义，不知道要走哪一个方法，所以报错了 修改后版本二 categoryId为空 12345678910111213141516171819//http://www.happymmall.com/product/keyword/手机/1/10/price_asc@RequestMapping(value = "/keyword/&#123;keyword&#125;/&#123;pageNum&#125;/&#123;pageSize&#125;/&#123;orderBy&#125;",method = RequestMethod.GET)@ResponseBodypublic ServerResponse&lt;PageInfo&gt; listRESTful(@PathVariable(value = "keyword")String keyword, @PathVariable(value = "pageNum") Integer pageNum, @PathVariable(value = "pageSize") Integer pageSize, @PathVariable(value = "orderBy") String orderBy)&#123; if(pageNum == null)&#123; pageNum = 1; &#125; if(pageSize == null)&#123; pageSize = 10; &#125; if(StringUtils.isBlank(orderBy))&#123; orderBy = "price_asc"; &#125; return iProductService.getProductByKeywordCategory(keyword,null,pageNum,pageSize,orderBy);&#125; keyword为空 12345678910111213141516171819//http://www.happymmall.com/product/category/100012/1/10/price_asc@RequestMapping(value = "/category/&#123;categoryId&#125;/&#123;pageNum&#125;/&#123;pageSize&#125;/&#123;orderBy&#125;",method = RequestMethod.GET)@ResponseBodypublic ServerResponse&lt;PageInfo&gt; listRESTful(@PathVariable(value = "categoryId")Integer categoryId, @PathVariable(value = "pageNum") Integer pageNum, @PathVariable(value = "pageSize") Integer pageSize, @PathVariable(value = "orderBy") String orderBy)&#123; if(pageNum == null)&#123; pageNum = 1; &#125; if(pageSize == null)&#123; pageSize = 10; &#125; if(StringUtils.isBlank(orderBy))&#123; orderBy = "price_asc"; &#125; return iProductService.getProductByKeywordCategory("",categoryId,pageNum,pageSize,orderBy);&#125; 浏览器访问http://localhost:8088/mmall_war_exploded/product/keyword/手机/1/10/price_asc和http://localhost:8088/mmall_war_exploded/product/category/100002/1/10/price_asc 这样子就可以避免歧义 Spring Schedul定时任务 Cron生成器 在线Cron表达式生成器 定时任务配置 注解方式配置定时任务 编辑spring配置文件 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beansxmlns:task="http://www.springframework.org/schema/task"xsi:schemaLocation="http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd"&lt;task:annotation-driven/&gt;&lt;/beans&gt; 创建定时任务类 12345678910111213141516171819202122232425262728package com.mmall.task;import com.mmall.service.IOrderService;import com.mmall.util.PropertiesUtil;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;/** * Created by geely */@Component@Slf4jpublic class CloseOrderTask &#123; @Autowired private IOrderService iOrderService; //每隔5秒执行一次 @Scheduled(cron="*/5 * * * * ?") public void closeOrderTaskV1()&#123; log.info("关闭订单定时任务启动"); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour","2"));// iOrderService.closeOrder(hour); log.info("关闭订单定时任务结束"); &#125;&#125; MySQL行锁、表锁 行锁 明确的主键 明确指定主键id，并且有结果集,产生行锁 123456SELECT *FROM mmall_productWHERE id = '26' FOR UPDATE; 明确指定主键id，并且无结果集,无锁 123456SELECT *FROM mmall_productWHERE id = '66' FOR UPDATE; 表锁 无明确的主键 无主键,产生表锁 123456SELECT *FROM mmall_productWHERE NAME = 'Apple iPhone 7 Plus (A1661) 128G 玫瑰金色 移动联通电信4G手机' FOR UPDATE; 主键不明确产生表锁 123456SELECT *FROM mmall_productWHERE id &lt;&gt; '66' FOR UPDATE; 123456SELECT *FROM mmall_productWHERE id LIKE '66' FOR UPDATE; 使用 关单:查询订单的时候，订单包含了子订单，根据子订单号查询产品 1234567&lt;select id="selectStockByProductId" resultType="int" parameterType="java.lang.Integer"&gt;selectstockfrom mmall_productwhere id = #&#123;id&#125;for update&lt;/select&gt; xml转义 用&lt;![CDATA[]]&gt;包裹住有转义的字符即可 12345678910&lt;select id="selectOrderStatusByCreateTime" resultMap="BaseResultMap" parameterType="map"&gt;SELECT&lt;include refid="Base_Column_List"/&gt;from mmall_orderwhere status = #&#123;status&#125;&lt;![CDATA[and create_time &lt;= #&#123;date&#125;]]&gt;order by create_time desc&lt;/select&gt; 原生分布式锁 Spring Schedule+Redis分布式锁构建分布式任务调度 简单版 获取到锁，锁住时间5秒，如果此期间发生中断，会导致死锁 12345678910111213141516171819202122232425// @Scheduled(cron="0 */1 * * * ?") public void closeOrderTaskV2()&#123; log.info("关闭订单定时任务启动"); long lockTimeout = Long.parseLong(PropertiesUtil.getProperty("lock.timeout","5000")); Long setnxResult = RedisShardedPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+lockTimeout)); if(setnxResult != null &amp;&amp; setnxResult.intValue() == 1)&#123; //如果返回值是1，代表设置成功，获取锁 closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125;else&#123; log.info("没有获得分布式锁:&#123;&#125;",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125; log.info("关闭订单定时任务结束"); &#125; private void closeOrder(String lockName)&#123; //有效期50秒，防止死锁 RedisShardedPoolUtil.expire(lockName,5); log.info("获取&#123;&#125;,ThreadName:&#123;&#125;",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName()); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour","2")); iOrderService.closeOrder(hour); RedisShardedPoolUtil.del(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); log.info("释放&#123;&#125;,ThreadName:&#123;&#125;",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName()); log.info("==============================="); &#125; 安全版 双重防死锁 未获取到锁，继续判断，判断时间戳，看是否可以重置并获取到锁 123456789101112131415161718192021222324252627282930313233343536373839@Scheduled(cron="0 */1 * * * ?")public void closeOrderTaskV3()&#123; log.info("关闭订单定时任务启动"); long lockTimeout = Long.parseLong(PropertiesUtil.getProperty("lock.timeout","5000")); Long setnxResult = RedisShardedPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+lockTimeout)); if(setnxResult != null &amp;&amp; setnxResult.intValue() == 1)&#123; closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125;else&#123; //未获取到锁，继续判断，判断时间戳，看是否可以重置并获取到锁 String lockValueStr = RedisShardedPoolUtil.get(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); if(lockValueStr != null &amp;&amp; System.currentTimeMillis() &gt; Long.parseLong(lockValueStr))&#123; String getSetResult = RedisShardedPoolUtil.getSet(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+lockTimeout)); //再次用当前时间戳getset。 //返回给定的key的旧值，-&gt;旧值判断，是否可以获取锁 //当key没有旧值时，即key不存在时，返回nil -&gt;获取锁 //这里我们set了一个新的value值，获取旧的值。 if(getSetResult == null || (getSetResult != null &amp;&amp; StringUtils.equals(lockValueStr,getSetResult)))&#123; //真正获取到锁 closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125;else&#123; log.info("没有获取到分布式锁:&#123;&#125;",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125; &#125;else&#123; log.info("没有获取到分布式锁:&#123;&#125;",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125; &#125; log.info("关闭订单定时任务结束");&#125;private void closeOrder(String lockName)&#123; //有效期50秒，防止死锁 RedisShardedPoolUtil.expire(lockName,5); log.info("获取&#123;&#125;,ThreadName:&#123;&#125;",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName()); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour","2")); iOrderService.closeOrder(hour); RedisShardedPoolUtil.del(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); log.info("释放&#123;&#125;,ThreadName:&#123;&#125;",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName()); log.info("===============================");&#125; Redisson分布式锁 编辑pom.xml 12345678910&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-avro&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 使用Redisson分布式锁 12345678910111213141516171819202122// @Scheduled(cron="0 */1 * * * ?") public void closeOrderTaskV4()&#123; RLock lock = redissonManager.getRedisson().getLock(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); boolean getLock = false; try &#123; if(getLock = lock.tryLock(0,50, TimeUnit.SECONDS))&#123; log.info("Redisson获取到分布式锁:&#123;&#125;,ThreadName:&#123;&#125;",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName()); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour","2"));// iOrderService.closeOrder(hour); &#125;else&#123; log.info("Redisson没有获取到分布式锁:&#123;&#125;,ThreadName:&#123;&#125;",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName()); &#125; &#125; catch (InterruptedException e) &#123; log.error("Redisson分布式锁获取异常",e); &#125; finally &#123; if(!getLock)&#123; return; &#125; lock.unlock(); log.info("Redisson分布式锁释放锁"); &#125; &#125;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>Tomcat</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS]]></title>
    <url>%2Fmyhexo%2F2019%2F03%2F20%2FNodeJS%2F</url>
    <content type="text"><![CDATA[NodeJS入门 NodeJS模块 http模块 server.js 123456789101112131415161718const http=require('http');let server=http.createServer((req, res)=&gt;&#123; switch(req.url)&#123; case '/aaa': res.write('abc'); break; case '/bbb': res.write('dddd'); break; case '/1.html': res.write('&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;sdfasfasf&lt;/body&gt;&lt;/html&gt;'); break; &#125; res.end();&#125;);server.listen(8080); server2.js 1234567891011121314const http=require('http');const fs=require('fs');let server=http.createServer((req, res)=&gt;&#123; fs.readFile(`www$&#123;req.url&#125;`, (err, data)=&gt;&#123; if(err)&#123; res.write('404'); //? &#125;else&#123; res.write(data); &#125; res.end(); &#125;);&#125;);server.listen(8080); 断言——assert 1234567891011const assert=require('assert');function sum(a, b)&#123; assert(arguments.length==2, '必须传2个参数'); assert(typeof a=='number', '第一个参数必须是数字'); assert(typeof b=='number', '第二个参数必须是数字'); return a+b;&#125;console.log(sum(12, 5)); File System 读写文件 fs.js 123456789101112131415161718const fs=require('fs');fs.readFile('1.txt', (err, data)=&gt;&#123; if(err)&#123; console.log('有错'); &#125;else&#123; //'ads'.charCodeAt(0) console.log(data.toString()); &#125;&#125;);/*fs.writeFile('3.txt', 'erqwreqwere', err=&gt;&#123; if(err)&#123; console.log(err); &#125;else&#123; console.log('成功'); &#125;&#125;);*/ fs2.js 1234567891011const fs=require('fs');fs.readFile('ofo.png', (err, data)=&gt;&#123; fs.writeFile('ofo2.png', data, (err)=&gt;&#123; if(err)&#123; console.log(err); &#125;else&#123; console.log('成功'); &#125; &#125;);&#125;); 多进程 进程和线程的区别： 进程拥有独立的执行空间、存储同一个进程内的所有线程共享一套空间、代码 多进程(PHP、Node) 成本高(慢)；安全(进程间隔离)；进程间通信麻烦；写代码简单多线程(Java、C) 成本低(快)；不安全(线程要死一块死)；线程间通信容易；写代码复杂 进程间通信的几种方式管道共享内存socket Crypto——签名 MD5是单向散列生成hash值，不可逆破解 md5.js 1234567891011const crypto=require('crypto');let obj=crypto.createHash('md5');obj.update('123456');// obj.update('123');// obj.update('4');// obj.update('56');console.log(obj.digest('hex')); 双重加密 md5_2.js 12345678910const crypto=require('crypto');function md5(str)&#123; let obj=crypto.createHash('md5'); obj.update(str); return obj.digest('hex');&#125;console.log(md5(md5('123456')+'se32ssdfsd43')); OS 获取系统信息 123const os=require('os');console.log(os.cpus()); Path 123456789const path=require('path');let str='/var/local/www/aaa/1.png';//dirname//basename//extnameconsole.log(path.extname(str)); Events事件队列 和普通js函数的定义调用区别：解耦 12345678910111213141516171819const Event=require('events').EventEmitter;let ev=new Event();//1.监听(接收)ev.on('msg', function (a, b, c)&#123; console.log('收到了msg事件：', a, b, c);&#125;);//2.派发(发送)ev.emit('msg', 12, 5, 88);/*function msg(a, b, c)&#123; console.log('收到了msg事件：', a, b, c);&#125;msg(12, 5, 88);*/ Query Strings、URL 地址解析 querystring.js 12345const querystring=require('querystring');let obj=querystring.parse('ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=aa&amp;rsv_pq=f80d982000063ffb&amp;rsv_t=6498LAZdRZjq9v4v0hs88kZItnCjDpT6UNBKr%2FF83%2F%2Bg4eiPURW2eQl9Iwc&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug2=0&amp;inputT=10&amp;rsv_sug4=10');console.log(obj); url.js 12345const url=require('url');let obj=url.parse('https://www.baidu.com:8080/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=aa&amp;rsv_pq=f80d982000063ffb&amp;rsv_t=6498LAZdRZjq9v4v0hs88kZItnCjDpT6UNBKr%2FF83%2F%2Bg4eiPURW2eQl9Iwc&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug2=0&amp;inputT=10&amp;rsv_sug4=10',true);console.log(obj); 域名解析 DNS、Domain 123456789const dns=require('dns');dns.resolve('www.goole.com', (err, res)=&gt;&#123; if(err)&#123; console.log('解析失败'); &#125;else&#123; console.log(res); &#125;&#125;); 流操作——Stream 连续数据都是流——视频流、网络流、文件流、语音流 TLS/SSL 加密、安全 ZLIB——gz 压缩 NodeJS数据交互 设置响应头 get请求 数据放在url地址上，存放的数量小(32k) post请求 在body里面,存放的数据量大(1G),一个大数据包切成一堆小包传输,容错性强 安全性 一切来自前台的数据都不可信前后台都得进行数据校验 前台校验：提高用户体验 后台校验：提高安全性 数据库 关系型数据库——MySQL、Oracle 特点 最常见、最常用,数据之间是有关系的MySQL使用占比80%，免费，绝大多数普通应用，性能很高、安全性很高，容灾略差Oracle收费，应用在金融、医疗，容灾特别强 SQL 增 INSERT INTO 表 (字段列表) VALUES(值列表) 1INSERT INTO user_table (ID, name, gender, chinese, math, english) VALUES(0, 'blue', '男', 35, 18, 29); 删 DELETE FROM 表 WHERE 条件 12DELETE FROM user_table WHERE ID=3; 改 UPDATE 表 SET 字段=值, 字段2=值2, … WHERE 条件 1UPDATE user_table SET chinese=100 WHERE ID=2; 查 SELECT 字段列表 FROM 表 WHERE 条件 1SELECT name, gender FROM user_table WHERE ID=2; 文件型数据库——sqlite 使用简单、存储数据量小 文档型数据库——MongoDB 直接存储异构数据，使用方便 NoSQL 没有复杂的关系、对性能有极高的要求常见的有redis、memcached、hypertable、bigtable NodeJS进阶上 文件数据解析 表单的三种POST text/plain,用的很少，纯文字application/x-www-form-urlencoded,默认,以url编码方式,xxx=xxx&amp;xxx=xx...multipart/form-data上传文件内容 file上传，是post请求方式 普通纯文本表单文件上传 普通纯文本文件上传可以用字符串拼接接收，有弊端，如果是图片文件上传，用字符串接收会出现数据错乱 描述：可以看到纯文本文件上传请求了2个资源 浏览器 后台结果输出 包含了前台表单用户名、密码和纯文本文件的描述和内容 1234567891011121314151617/upload------WebKitFormBoundaryNIoabcKEXajTUMAIContent-Disposition: form-data; name=&quot;user&quot;shenlibing------WebKitFormBoundaryNIoabcKEXajTUMAIContent-Disposition: form-data; name=&quot;pass&quot;000000------WebKitFormBoundaryNIoabcKEXajTUMAIContent-Disposition: form-data; name=&quot;f1&quot;; filename=&quot;1.txt&quot;Content-Type: text/plainabc------WebKitFormBoundaryNIoabcKEXajTUMAI--/favicon.ico Buffer接收文件上传的原始二进制数据 1234/upload&lt;Buffer 2d 2d 2d 2d 2d 2d 57 65 62 4b 69 74 46 6f 72 6d 42 6f 75 6e 64 61 72 79 75 42 6d 6b 78 4a 65 51 6d 35 6b 4a 4f 68 59 65 0d 0a 43 6f 6e 74 65 6e 74 2d ... &gt;/favicon.ico&lt;Buffer &gt; Buffer数据进行查找、截取、切分 如果是非纯文本文件上传，用字符串接收会破坏数据的完整性，需要用Buffer接收二进制数据 Buffer数据查找 123let b=new Buffer('abccc-=-dddder-=-qwerqwer');console.log(b.indexOf('-=-')); Buffer数据截取 123let b=new Buffer('abccc-=-dddder-=-qwerqwer');console.log(b.slice(17).toString()); Buffer数据切分 Buffer本身不具有split方法 123456789101112131415161718192021let b=new Buffer('abccc-=-dddder-=-qwerqwer');Buffer.prototype.split=Buffer.prototype.split||function (b)&#123; let arr=[]; let cur=0; let n=0; while((n=this.indexOf(b, cur))!=-1)&#123; arr.push(this.slice(cur, n)); cur=n+b.length; &#125; arr.push(this.slice(cur)); return arr;&#125;;let arr=b.split('-=-');console.log(arr);console.log(arr.map(buffer=&gt;buffer.toString())); 解析数据 数据化简 先对纯文本文件上传用字符串拼接的结果进行分析化简版本一 1234567891011121314分隔符Content-Disposition: form-data; name=&quot;user&quot;shenlibing分隔符Content-Disposition: form-data; name=&quot;pass&quot;000000分隔符Content-Disposition: form-data; name=&quot;f1&quot;; filename=&quot;1.txt&quot;Content-Type: text/plainabc分隔符-- 化简版本二：每一行末尾会自动加上\r\n 1234567891011121314分隔符\r\nContent-Disposition: form-data; name=&quot;user&quot;\r\n\r\nshenlibing\r\n分隔符\r\nContent-Disposition: form-data; name=&quot;pass&quot;\r\n\r\n000000\r\n分隔符\r\nContent-Disposition: form-data; name=&quot;f1&quot;; filename=&quot;1.txt&quot;\r\nContent-Type: text/plain\r\n\r\nabc\r\n分隔符--\r\n 化简版本三 1234分隔符\r\n数据描述\r\n\r\n数据值\r\n分隔符\r\n数据描述\r\n\r\n数据值\r\n分隔符\r\n数据描述1\r\n数据描述2\r\n\r\n文件内容\r\n分隔符--\r\n 化简到版本三的时候，就可以开始解析数据了 用分隔符切开数据 1234567[ 空, \r\n数据描述\r\n\r\n数据值\r\n, \r\n数据描述\r\n\r\n数据值\r\n, \r\n数据描述1\r\n数据描述2\r\n\r\n&lt;文件内容&gt;\r\n, --\r\n] 丢弃头尾元素 12345[ \r\n数据描述\r\n\r\n数据值\r\n, \r\n数据描述\r\n\r\n数据值\r\n, \r\n数据描述1\r\n数据描述2\r\n\r\n&lt;文件内容&gt;\r\n,] 丢弃每一项的头尾\r\n 12345[ 数据描述\r\n\r\n数据值, 数据描述\r\n\r\n数据值, 数据描述1\r\n数据描述2\r\n\r\n&lt;文件内容&gt;,] 用第一次出现的\r\n\r\n切分 普通数据：[数据描述, 数据值] 文件数据：[数据描述1\r\n数据描述2, &lt;文件内容&gt;] 判断描述的里面有没有\r\n 有的话就是文件数据：[数据描述1\r\n数据描述2, &lt;文件内容&gt;]没有的话就是普通数据：[数据描述, 数据值] 分析数据描述 文件上传代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687const http=require('http');const common=require('./libs/common');const fs=require('fs');const uuid=require('uuid/v4');let server=http.createServer((req, res)=&gt;&#123; let arr=[]; req.on('data', data=&gt;&#123; arr.push(data); &#125;); req.on('end', ()=&gt;&#123; let data=Buffer.concat(arr); //data //解析二进制文件上传数据 let post=&#123;&#125;; let files=&#123;&#125;; if(req.headers['content-type'])&#123; let str=req.headers['content-type'].split('; ')[1]; if(str)&#123; let boundary='--'+str.split('=')[1]; //1.用"分隔符切分整个数据" let arr=data.split(boundary); //2.丢弃头尾两个数据 arr.shift(); arr.pop(); //3.丢弃掉每个数据头尾的"\r\n" arr=arr.map(buffer=&gt;buffer.slice(2,buffer.length-2)); //4.每个数据在第一个"\r\n\r\n"处切成两半 arr.forEach(buffer=&gt;&#123; let n=buffer.indexOf('\r\n\r\n'); let disposition=buffer.slice(0, n); let content=buffer.slice(n+4); disposition=disposition.toString(); if(disposition.indexOf('\r\n')==-1)&#123; //普通数据 //Content-Disposition: form-data; name="user" content=content.toString(); let name=disposition.split('; ')[1].split('=')[1]; name=name.substring(1, name.length-1); post[name]=content; &#125;else&#123; //文件数据 /*Content-Disposition: form-data; name="f1"; filename="a.txt"\r\n Content-Type: text/plain*/ let [line1, line2]=disposition.split('\r\n'); let [,name,filename]=line1.split('; '); let type=line2.split(': ')[1]; name=name.split('=')[1]; name=name.substring(1,name.length-1); filename=filename.split('=')[1]; filename=filename.substring(1,filename.length-1); let path=`upload/$&#123;uuid().replace(/\-/g, '')&#125;`; fs.writeFile(path, content, err=&gt;&#123; if(err)&#123; console.log('文件写入失败', err); &#125;else&#123; files[name]=&#123;filename, path, type&#125;; console.log(files); &#125; &#125;); &#125; &#125;); //5.完成 console.log(post); &#125; &#125; res.end(); &#125;);&#125;);server.listen(8080); 流操作 fs.readFile和fs.writeFile的弊端 描述：以上文件上传的一个瑕疵就是会等到所有数据都到达了才开始处理，然后通过fs.writeFile上传文件 12345http.createServer((req, res)=&gt;&#123; fs.readFile(`www$&#123;req.url&#125;`, (err, data)=&gt;&#123; res.write(data); &#125;);&#125;); fs.readFile先把所有数据全读到内存中，然后回调,这种方式极其占用内存且资源利用极其不充分，读取文件的过程中网络传输一直空闲，等到文件IO读取完毕，IO一直空闲，网络传输变得繁忙 解决：收到一部分就解析一部分，极大节约内存,使用流读取文件，读一点、发一点 分类 读取流fs.createReadStream写入流fs.createWriteStream 12345678910111213141516const http=require('http');const fs=require('fs');let server=http.createServer((req, res)=&gt;&#123; let rs=fs.createReadStream(`www$&#123;req.url&#125;`); rs.pipe(res); rs.on('error', err=&gt;&#123; res.writeHeader(404); res.write('Not Found'); res.end(); &#125;);&#125;);server.listen(8080); gz压缩 无gz压缩传输 没有通过gz压缩传输,请求资源1.html文件大小321B，jquery.js文件大小262KB 12345678910111213141516171819202122const http=require('http');const fs=require('fs');const zlib=require('zlib');let server=http.createServer((req, res)=&gt;&#123; let rs=fs.createReadStream(`www$&#123;req.url&#125;`); rs.pipe(res); /*res.setHeader('content-encoding', 'gzip'); let gz=zlib.createGzip(); rs.pipe(gz).pipe(res);*/ rs.on('error', err=&gt;&#123; res.writeHeader(404); res.write('Not Found'); res.end(); &#125;);&#125;);server.listen(8080); gz压缩传输 读写流,通过gz压缩传输,请求资源1.html文件大小292B，jquery.js文件大小77.8KB 创建读取流读取www${req.url}文件，通过gz压缩、加密该文件然后返回给浏览器，需要设置响应头res.setHeader(&#39;content-encoding&#39;, &#39;gzip&#39;),让浏览器识别该资源是通过gz压缩的文件 12345678910111213141516171819202122const http=require('http');const fs=require('fs');const zlib=require('zlib');let server=http.createServer((req, res)=&gt;&#123; let rs=fs.createReadStream(`www$&#123;req.url&#125;`); //rs.pipe(res); res.setHeader('content-encoding', 'gzip'); let gz=zlib.createGzip(); rs.pipe(gz).pipe(res); rs.on('error', err=&gt;&#123; res.writeHeader(404); res.write('Not Found'); res.end(); &#125;);&#125;);server.listen(8080); NodeJS进阶下 缓存 标记文件修改时间实现缓存 获得文件修改时间 123456789const fs=require('fs');fs.stat('./www/1.html', (err, stat)=&gt;&#123; if(err)&#123; console.log('获取文件信息失败'); &#125;else&#123; console.log(stat.mtime.toGMTString()); &#125;&#125;); 服务器设置响应头Last-Modified 标记文件最后一次修改时间 缓存实现过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const http=require('http');const fs=require('fs');const url=require('url');http.createServer((req, res)=&gt;&#123; let &#123;pathname&#125;=url.parse(req.url); //获取文件日期 fs.stat(`www$&#123;pathname&#125;`, (err, stat)=&gt;&#123; if(err)&#123; res.writeHeader(404); res.write('Not Found'); res.end(); &#125;else&#123; // console.log(req) if(req.headers['if-modified-since'])&#123; let oDate=new Date(req.headers['if-modified-since']); let time_client=Math.floor(oDate.getTime()/1000); let time_server=Math.floor(stat.mtime.getTime()/1000); if(time_server&gt;time_client)&#123; //服务器的文件时间&gt;客户端手里的版本 sendFileToClient(); &#125;else&#123; res.writeHeader(304); res.write('Not Modified'); res.end(); &#125; &#125;else&#123; sendFileToClient(); &#125; function sendFileToClient()&#123; //发送 let rs=fs.createReadStream(`www$&#123;pathname&#125;`); res.setHeader('Last-Modified', stat.mtime.toGMTString()); //输出 rs.pipe(res); rs.on('error', err=&gt;&#123; res.writeHeader(404); res.write('Not Found'); res.end(); &#125;); &#125; &#125; &#125;);&#125;).listen(8080); 第一次请求,响应状态码200,浏览器没有缓存 服务器响应头带了Last-Modified标记该资源文件最后一次修改时间 第二次请求,响应状态码304，浏览器有缓存 请求头带了if-modified-since标记该资源文件的最后一次修改时间,通过该标记去告诉服务器我本地有这个文件及这个文件最后一次修改时间，服务器收到请求通过if-modified-since标记的时间和服务器上该文件的时间进行比较，如果服务器的文件等于if-modified-since的时间，说明该资源文件没有被修改过，浏览器决定从不从缓存中取出 缓存策略 服务器设置响应头cache-control和expires 多进程 主进程负责派生子进程，子进程负责干活 特点 普通程序不能“创建”进程，只有系统进程才能创建进程；只有主进程能分裂进程是分裂出来分裂出来的两个进程执行的是同一套代码父子进程之间可以共享”句柄”(如：8080端口) 进程分裂实现 通过cluster.isMaster判断是否是主进程，如果是主进程则cluster.fork()分裂子进程 12345678910111213141516171819202122232425const http=require('http');const cluster=require('cluster');const os=require('os');const process=require('process');if(cluster.isMaster)&#123; for(let i=0;i&lt;os.cpus().length;i++)&#123; cluster.fork(); &#125; console.log('主进程');&#125;else&#123; console.log('子进程'); let server=http.createServer((req, res)=&gt;&#123; //进程id console.log('子进程id',process.pid); res.write('aaaa'); res.end(); &#125;); server.listen(8080); console.log('服务器开好了，在8080上');&#125; 123456789101112131415161718主进程子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程服务器开好了，在8080上子进程 26956 进程调度 主进程通过系统的CPU核数分裂了8个子进程，浏览器发起请求的时候只有一个子进程 26956干活 多个进程同时存在时，进程的调度原则是第一个进程满了才开启第二个进程，前面两个进程满了才开启第三个进程，这样做的原因是因为进程调度即进程切换是需要花费开销的 坑 主进程能否分裂100个进程，有必要么 可以分裂100个进程，但是没有必要，进程调度需要花费开销，况且进程的实际工作计算能力需要根据计算机本身硬件的限制 NodeJS使用MySQL 连接 一条连接 1let db=mysql.createConnection(&#123;host: 'localhost', user: 'root', password: '', port: 3309, database: '20180127'&#125;); 连接池获取连接 12//连接池let db=mysql.createPool(&#123;host: 'localhost', user: 'root', password: '', port: 3309, database: '20180127'&#125;); 查询 1234567891011const mysql=require('mysql');let db=mysql.createConnection(&#123;host: 'localhost', user: 'root', password: '', port: 3309, database: '20180127'&#125;);db.query(`INSERT INTO user_table (ID, name, gender, chinese, math, english) VALUES(0, '小明', '男', 98, 5, 3);`, (err, data)=&gt;&#123; if(err)&#123; console.log('错了', err); &#125;else&#123; console.log(data); &#125;&#125;); 用户登录注册 数据库结构(数据字典) 接口格式(接口文档) 123注册： /reg?user=xxx&amp;pass=xxx =&gt;&#123;err: 0, msg: &apos;原因&apos;&#125; 123登陆： /login?user=xxx&amp;pass=xxx =&gt;&#123;err: 0, msg: &apos;原因&apos;&#125; 代码实现 前台 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; $(function ()&#123; //注册 $('#btn_reg').click(function ()&#123; $.ajax(&#123; url: '/reg', data: &#123;user: $('#user').val(),pass: $('#pass').val()&#125;, dataType: 'json', success(json)&#123; if(json.err)&#123; alert('注册失败'+json.msg); &#125;else&#123; alert('注册成功'); &#125; &#125;, error(err)&#123; alert('失败'); &#125; &#125;); &#125;); //登陆 $('#btn_login').click(function ()&#123; $.ajax(&#123; url: '/login', data: &#123;user: $('#user').val(),pass: $('#pass').val()&#125;, dataType: 'json', success(json)&#123; if(json.err)&#123; alert('登陆失败'+json.msg); &#125;else&#123; alert('登陆成功'); &#125; &#125;, error(err)&#123; alert('失败'); &#125; &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 用户：&lt;input type="text" id="user" /&gt;&lt;br&gt; 密码：&lt;input type="password" id="pass" /&gt;&lt;br&gt; &lt;input type="button" value="注册" id="btn_reg"&gt; &lt;input type="button" value="登陆" id="btn_login"&gt; &lt;/body&gt;&lt;/html&gt; 后台 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119const http=require('http');const mysql=require('mysql');const fs=require('fs');const url=require('url');const zlib=require('zlib');const crypto=require('crypto');//盐值const _key='sadfslekrtuew5iutoselgdtjiypoydse4ufhs.edtyo;s8te4arfeliawkfhtsie5tlfia;sefdshroiupeoutwyeli5gurse;ihf';//MD5加密function md5(str)&#123; let obj=crypto.createHash('md5'); obj.update(str); return obj.digest('hex');&#125;//MD5盐值加密function md5_2(str)&#123; return md5(md5(str)+_key);&#125;//从连接池获取连接let db=mysql.createPool(&#123;host: 'localhost', port: 3306, user: 'root', password: '000000', database: 'mytest'&#125;);let server=http.createServer((req, res)=&gt;&#123; let &#123;pathname, query&#125;=url.parse(req.url, true); let &#123;user, pass&#125;=query; switch(pathname)&#123; //接口 case '/reg': //校验 if(!user)&#123; res.write('&#123;"err": 1, "msg": "username can\'t be null"&#125;'); res.end(); &#125;else if(!pass)&#123; res.write('&#123;"err": 1, "msg": "password can\'t be null"&#125;'); res.end(); &#125;else if(!/^\w&#123;4,16&#125;$/.test(user))&#123; res.write('&#123;"err": 1, "msg": "username is invaild"&#125;'); res.end(); &#125;else if(/['|"]/.test(pass))&#123; res.write('&#123;"err": 1, "msg": "password is invaild"&#125;'); res.end(); &#125;else&#123; db.query(`SELECT * FROM user_table WHERE username='$&#123;user&#125;'`, (err, data)=&gt;&#123; if(err)&#123; res.write('&#123;"err": 1, "msg": "database error"&#125;'); res.end(); &#125;else if(data.length&gt;0)&#123; res.write('&#123;"err": 1, "msg": "this username exsits"&#125;'); res.end(); &#125;else&#123; db.query(`INSERT INTO user_table (ID,username,password) VALUES(0,'$&#123;user&#125;','$&#123;md5_2(pass)&#125;')`, (err, data)=&gt;&#123; if(err)&#123; res.write('&#123;"err": 1, "msg": "database error"&#125;'); res.end(); &#125;else&#123; res.write('&#123;"err": 0, "msg": "success"&#125;'); res.end(); &#125; &#125;); &#125; &#125;); &#125; break; case '/login': //校验 if(!user)&#123; res.write('&#123;"err": 1, "msg": "username can\'t be null"&#125;'); res.end(); &#125;else if(!pass)&#123; res.write('&#123;"err": 1, "msg": "password can\'t be null"&#125;'); res.end(); &#125;else if(!/^\w&#123;4,16&#125;$/.test(user))&#123; res.write('&#123;"err": 1, "msg": "username is invaild"&#125;'); res.end(); &#125;else if(/['|"]/.test(pass))&#123; res.write('&#123;"err": 1, "msg": "password is invaild"&#125;'); res.end(); &#125;else&#123; db.query(`SELECT * FROM user_table WHERE username='$&#123;user&#125;'`, (err, data)=&gt;&#123; if(err)&#123; res.write('&#123;"err": 1, "msg": "database error"&#125;'); res.end(); &#125;else if(data.length==0)&#123; res.write('&#123;"err": 1, "msg": "no this user"&#125;'); res.end(); &#125;else if(data[0].password!=md5_2(pass))&#123; res.write('&#123;"err": 1, "msg": "username or password is incorrect"&#125;'); res.end(); &#125;else&#123; res.write('&#123;"err": 0, "msg": "success"&#125;'); res.end(); &#125; &#125;); &#125; break; default: //缓存 TODO //静态文件 let rs=fs.createReadStream(`www$&#123;pathname&#125;`); let gz=zlib.createGzip(); res.setHeader('content-encoding', 'gzip'); rs.pipe(gz).pipe(res); rs.on('error', err=&gt;&#123; res.writeHeader(404); res.write('Not Found'); res.end(); &#125;); &#125;&#125;);server.listen(8080);]]></content>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0开始独立完成企业级Java电商网站开发（服务端）]]></title>
    <url>%2Fmyhexo%2F2019%2F03%2F13%2F%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%8B%AC%E7%AB%8B%E5%AE%8C%E6%88%90%E4%BC%81%E4%B8%9A%E7%BA%A7Java%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据表结构设计 唯一索引unique，保证数据唯一性 1234567891011121314CREATE TABLE `mmall_user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户表id', `username` varchar(50) NOT NULL COMMENT '用户名', `password` varchar(50) NOT NULL COMMENT '用户密码，MD5加密', `email` varchar(50) DEFAULT NULL, `phone` varchar(20) DEFAULT NULL, `question` varchar(100) DEFAULT NULL COMMENT '找回密码问题', `answer` varchar(100) DEFAULT NULL COMMENT '找回密码答案', `role` int(4) NOT NULL COMMENT '角色0-管理员,1-普通用户', `create_time` datetime NOT NULL COMMENT '创建时间', `update_time` datetime NOT NULL COMMENT '最后一次更新时间', PRIMARY KEY (`id`), UNIQUE KEY `user_name_unique` (`username`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8; 单索引及组合索引 12345678910111213141516CREATE TABLE `mmall_order_item` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '订单子表id', `user_id` int(11) DEFAULT NULL, `order_no` bigint(20) DEFAULT NULL, `product_id` int(11) DEFAULT NULL COMMENT '商品id', `product_name` varchar(100) DEFAULT NULL COMMENT '商品名称', `product_image` varchar(500) DEFAULT NULL COMMENT '商品图片地址', `current_unit_price` decimal(20,2) DEFAULT NULL COMMENT '生成订单时的商品单价，单位是元,保留两位小数', `quantity` int(10) DEFAULT NULL COMMENT '商品数量', `total_price` decimal(20,2) DEFAULT NULL COMMENT '商品总价,单位是元,保留两位小数', `create_time` datetime DEFAULT NULL, `update_time` datetime DEFAULT NULL, PRIMARY KEY (`id`), KEY `order_no_index` (`order_no`) USING BTREE, KEY `order_no_user_id_index` (`user_id`,`order_no`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=135 DEFAULT CHARSET=utf8; 查业务问题的后悔药 create_time 数据创建时间update_time 数据更新时间 mybatis三剑客 mybatis-generator自动化生成数据库交互代码 配置pom.xml 12345678910111213&lt;build&gt; &lt;finalName&gt;mmall&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/build&gt; datasource.properties 12345678910111213141516db.driverLocation=/Users/imooc/mysql-connector-java-5.1.6-bin.jardb.driverClassName=com.mysql.jdbc.Driver#db.url=jdbc:mysql://192.1.1.1:3306/mmall?characterEncoding=utf-8db.url=jdbc:mysql://你的数据库IP:你的数据库Port/你的database?characterEncoding=utf-8db.username=mmalldb.password=dbpassworddb.initialSize = 20db.maxActive = 50db.maxIdle = 20db.minIdle = 10db.maxWait = 10db.defaultAutoCommit = truedb.minEvictableIdleTimeMillis = 3600000 generatorConfig.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!--导入属性配置--&gt; &lt;properties resource="datasource.properties"&gt;&lt;/properties&gt; &lt;!--指定特定数据库的jdbc驱动jar包的位置--&gt; &lt;classPathEntry location="$&#123;db.driverLocation&#125;"/&gt; &lt;context id="default" targetRuntime="MyBatis3"&gt; &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--jdbc的数据库连接 --&gt; &lt;jdbcConnection driverClass="$&#123;db.driverClassName&#125;" connectionURL="$&#123;db.url&#125;" userId="$&#123;db.username&#125;" password="$&#123;db.password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类 targetPackage 指定生成的model生成所在的包名 targetProject 指定在该项目下所在的路径 --&gt; &lt;!--&lt;javaModelGenerator targetPackage="com.mmall.pojo" targetProject=".\src\main\java"&gt;--&gt; &lt;javaModelGenerator targetPackage="com.mmall.pojo" targetProject="./src/main/java"&gt; &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;!-- 是否对model添加 构造函数 --&gt; &lt;property name="constructorBased" value="true"/&gt; &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;!-- 建立的Model对象是否 不可改变 即生成的Model对象不会有 setter方法，只有构造方法 --&gt; &lt;property name="immutable" value="false"/&gt; &lt;/javaModelGenerator&gt; &lt;!--mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt; &lt;!--&lt;sqlMapGenerator targetPackage="mappers" targetProject=".\src\main\resources"&gt;--&gt; &lt;sqlMapGenerator targetPackage="mappers" targetProject="./src/main/resources"&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码 type="ANNOTATEDMAPPER",生成Java Model 和基于注解的Mapper对象 type="MIXEDMAPPER",生成基于注解的Java Model 和相应的Mapper对象 type="XMLMAPPER",生成SQLMap XML文件和独立的Mapper接口 --&gt; &lt;!-- targetPackage：mapper接口dao生成的位置 --&gt; &lt;!--&lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.mmall.dao" targetProject=".\src\main\java"&gt;--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.mmall.dao" targetProject="./src/main/java"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/javaClientGenerator&gt; &lt;table tableName="mmall_shipping" domainObjectName="Shipping" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_cart" domainObjectName="Cart" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_cart_item" domainObjectName="CartItem" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_category" domainObjectName="Category" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_order" domainObjectName="Order" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_order_item" domainObjectName="OrderItem" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_pay_info" domainObjectName="PayInfo" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_product" domainObjectName="Product" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt; &lt;columnOverride column="detail" jdbcType="VARCHAR" /&gt; &lt;columnOverride column="sub_images" jdbcType="VARCHAR" /&gt; &lt;/table&gt; &lt;table tableName="mmall_user" domainObjectName="User" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;!-- geelynote mybatis插件的搭建 --&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 运行 mybatis-plugin idea插件，实现mybatis的接口文件和xml自动跳转 下载 mybatis-pagehelper mybatis分页组件 配置pom.xml 12345678910111213141516171819&lt;!-- mybatis pager --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.miemiedev&lt;/groupId&gt; &lt;artifactId&gt;mybatis-paginator&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.4&lt;/version&gt; &lt;/dependency&gt; Tomcat加载spring、springmvc 方式一：配置web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 启动我们自己的listener --&gt; &lt;listener&gt; &lt;listener-class&gt;com.atguigu.scw.manager.listener.MyAppListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 启动spring容器 --&gt; &lt;!-- needed for ContextLoaderListener --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Bootstraps the root web application context before servlet initialization --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- The front controller of this Spring Web application, responsible for handling all application requests --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- Map all requests to the DispatcherServlet for handling --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 加上字符编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 只是指定了编码格式 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 进行请求乱码解决 --&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 方式二：配置web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 测试插件 FeHelper Restlet Client 用户模块 横向越权 入参需要指定当前用户id 纵向越权 MD5明文加密 盐值加密 MD5Util.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.mmall.util;import org.springframework.util.StringUtils;import java.security.MessageDigest;/** * Created by geely */public class MD5Util &#123; private static String byteArrayToHexString(byte b[]) &#123; StringBuffer resultSb = new StringBuffer(); for (int i = 0; i &lt; b.length; i++) resultSb.append(byteToHexString(b[i])); return resultSb.toString(); &#125; private static String byteToHexString(byte b) &#123; int n = b; if (n &lt; 0) n += 256; int d1 = n / 16; int d2 = n % 16; return hexDigits[d1] + hexDigits[d2]; &#125; /** * 返回大写MD5 * * @param origin * @param charsetname * @return */ private static String MD5Encode(String origin, String charsetname) &#123; String resultString = null; try &#123; resultString = new String(origin); MessageDigest md = MessageDigest.getInstance("MD5"); if (charsetname == null || "".equals(charsetname)) resultString = byteArrayToHexString(md.digest(resultString.getBytes())); else resultString = byteArrayToHexString(md.digest(resultString.getBytes(charsetname))); &#125; catch (Exception exception) &#123; &#125; return resultString.toUpperCase(); &#125; public static String MD5EncodeUtf8(String origin) &#123; origin = origin + PropertiesUtil.getProperty("password.salt", ""); return MD5Encode(origin, "utf-8"); &#125; private static final String hexDigits[] = &#123;"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"&#125;;&#125; PropertiesUtil.java 读取src/main/resources目录下的配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.mmall.util;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.io.InputStreamReader;import java.util.Properties;/** * Created by geely */public class PropertiesUtil &#123; private static Logger logger = LoggerFactory.getLogger(PropertiesUtil.class); private static Properties props; static &#123; String fileName = "mmall.properties"; props = new Properties(); try &#123; props.load(new InputStreamReader(PropertiesUtil.class.getClassLoader().getResourceAsStream(fileName),"UTF-8")); &#125; catch (IOException e) &#123; logger.error("配置文件读取异常",e); &#125; &#125; public static String getProperty(String key)&#123; String value = props.getProperty(key.trim()); if(StringUtils.isBlank(value))&#123; return null; &#125; return value.trim(); &#125; public static String getProperty(String key,String defaultValue)&#123; String value = props.getProperty(key.trim()); if(StringUtils.isBlank(value))&#123; value = defaultValue; &#125; return value.trim(); &#125;&#125; mmall.properties 123456789ftp.server.ip=你的FTP服务器ip地址ftp.user=mmallftpftp.pass=ftppasswordftp.server.http.prefix=http://img.happymmall.com/alipay.callback.url=http://www.happymmall.com/order/alipay_callback.dopassword.salt = geelysdafaqj23ou89ZXcj@#$@#$#@KJdjklj;D../dSF., 应用：明文加密 guava缓存 设置token并传给前台用户 验证token TokenCache.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.mmall.common;import com.google.common.cache.CacheBuilder;import com.google.common.cache.CacheLoader;import com.google.common.cache.LoadingCache;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.concurrent.TimeUnit;/** * Created by geely */public class TokenCache &#123; private static Logger logger = LoggerFactory.getLogger(TokenCache.class); public static final String TOKEN_PREFIX = "token_"; //LRU算法 private static LoadingCache&lt;String,String&gt; localCache = CacheBuilder.newBuilder().initialCapacity(1000).maximumSize(10000).expireAfterAccess(12, TimeUnit.HOURS) .build(new CacheLoader&lt;String, String&gt;() &#123; //默认的数据加载实现,当调用get取值的时候,如果key没有对应的值,就调用这个方法进行加载. @Override public String load(String s) throws Exception &#123; return "null"; &#125; &#125;); public static void setKey(String key,String value)&#123; localCache.put(key,value); &#125; public static String getKey(String key)&#123; String value = null; try &#123; value = localCache.get(key); if("null".equals(value))&#123; return null; &#125; return value; &#125;catch (Exception e)&#123; logger.error("localCache get error",e); &#125; return null; &#125;&#125; UserServiceImpl.java 12345678910111213141516171819202122232425262728293031323334353637383940public ServerResponse&lt;String&gt; checkAnswer(String username,String question,String answer)&#123; int resultCount = userMapper.checkAnswer(username,question,answer); if(resultCount&gt;0)&#123; //说明问题及问题答案是这个用户的,并且是正确的 String forgetToken = UUID.randomUUID().toString(); TokenCache.setKey(TokenCache.TOKEN_PREFIX+username,forgetToken); return ServerResponse.createBySuccess(forgetToken); &#125; return ServerResponse.createByErrorMessage("问题的答案错误"); &#125; public ServerResponse&lt;String&gt; forgetResetPassword(String username,String passwordNew,String forgetToken)&#123; if(org.apache.commons.lang3.StringUtils.isBlank(forgetToken))&#123; return ServerResponse.createByErrorMessage("参数错误,token需要传递"); &#125; ServerResponse validResponse = this.checkValid(username,Const.USERNAME); if(validResponse.isSuccess())&#123; //用户不存在 return ServerResponse.createByErrorMessage("用户不存在"); &#125; String token = TokenCache.getKey(TokenCache.TOKEN_PREFIX+username); if(org.apache.commons.lang3.StringUtils.isBlank(token))&#123; return ServerResponse.createByErrorMessage("token无效或者过期"); &#125; if(org.apache.commons.lang3.StringUtils.equals(forgetToken,token))&#123; String md5Password = MD5Util.MD5EncodeUtf8(passwordNew); int rowCount = userMapper.updatePasswordByUsername(username,md5Password); if(rowCount &gt; 0)&#123; return ServerResponse.createBySuccessMessage("修改密码成功"); &#125; &#125;else&#123; return ServerResponse.createByErrorMessage("token错误,请重新获取重置密码的token"); &#125; return ServerResponse.createByErrorMessage("修改密码失败"); &#125; 高复用服务响应对象的设计思想和封装 ServerResponse.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.mmall.common;import org.codehaus.jackson.annotate.JsonIgnore;import org.codehaus.jackson.map.annotate.JsonSerialize;import java.io.Serializable;/** * Created by geely */@JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL)//保证序列化json的时候,如果是null的对象,key也会消失public class ServerResponse&lt;T&gt; implements Serializable &#123; private int status; private String msg; private T data; private ServerResponse(int status)&#123; this.status = status; &#125; private ServerResponse(int status,T data)&#123; this.status = status; this.data = data; &#125; private ServerResponse(int status,String msg,T data)&#123; this.status = status; this.msg = msg; this.data = data; &#125; private ServerResponse(int status,String msg)&#123; this.status = status; this.msg = msg; &#125; @JsonIgnore //使之不在json序列化结果当中 public boolean isSuccess()&#123; return this.status == ResponseCode.SUCCESS.getCode(); &#125; public int getStatus()&#123; return status; &#125; public T getData()&#123; return data; &#125; public String getMsg()&#123; return msg; &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess()&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode()); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccessMessage(String msg)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),msg); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess(T data)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),data); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess(String msg,T data)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),msg,data); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByError()&#123; return new ServerResponse&lt;T&gt;(ResponseCode.ERROR.getCode(),ResponseCode.ERROR.getDesc()); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByErrorMessage(String errorMessage)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.ERROR.getCode(),errorMessage); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByErrorCodeMessage(int errorCode,String errorMessage)&#123; return new ServerResponse&lt;T&gt;(errorCode,errorMessage); &#125;&#125; ResponseCode.java 1234567891011121314151617181920212223242526272829package com.mmall.common;/** * Created by geely */public enum ResponseCode &#123; SUCCESS(0,"SUCCESS"), ERROR(1,"ERROR"), NEED_LOGIN(10,"NEED_LOGIN"), ILLEGAL_ARGUMENT(2,"ILLEGAL_ARGUMENT"); private final int code; private final String desc; ResponseCode(int code,String desc)&#123; this.code = code; this.desc = desc; &#125; public int getCode()&#123; return code; &#125; public String getDesc()&#123; return desc; &#125;&#125; 分类模块 递归算法 12345678910111213141516171819202122232425262728293031323334/** * 递归查询本节点的id及孩子节点的id * @param categoryId * @return */public ServerResponse&lt;List&lt;Integer&gt;&gt; selectCategoryAndChildrenById(Integer categoryId)&#123; Set&lt;Category&gt; categorySet = Sets.newHashSet(); findChildCategory(categorySet,categoryId); List&lt;Integer&gt; categoryIdList = Lists.newArrayList(); if(categoryId != null)&#123; for(Category categoryItem : categorySet)&#123; categoryIdList.add(categoryItem.getId()); &#125; &#125; return ServerResponse.createBySuccess(categoryIdList);&#125;//递归算法,算出子节点private Set&lt;Category&gt; findChildCategory(Set&lt;Category&gt; categorySet ,Integer categoryId)&#123; Category category = categoryMapper.selectByPrimaryKey(categoryId); if(category != null)&#123; categorySet.add(category); &#125; //查找子节点,递归算法一定要有一个退出的条件 List&lt;Category&gt; categoryList = categoryMapper.selectCategoryChildrenByParentId(categoryId); for(Category categoryItem : categoryList)&#123; findChildCategory(categorySet,categoryItem.getId()); &#125; return categorySet;&#125; 复杂对象排重 Set集合 重写自定义对象Category的equals和hashCode方法 无限层级树结构设计 商品模块 POJO、BO、VO抽象模型 Product.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package com.mmall.pojo;import java.math.BigDecimal;import java.util.Date;public class Product &#123; private Integer id; private Integer categoryId; private String name; private String subtitle; private String mainImage; private String subImages; private String detail; private BigDecimal price; private Integer stock; private Integer status; private Date createTime; private Date updateTime; public Product(Integer id, Integer categoryId, String name, String subtitle, String mainImage, String subImages, String detail, BigDecimal price, Integer stock, Integer status, Date createTime, Date updateTime) &#123; this.id = id; this.categoryId = categoryId; this.name = name; this.subtitle = subtitle; this.mainImage = mainImage; this.subImages = subImages; this.detail = detail; this.price = price; this.stock = stock; this.status = status; this.createTime = createTime; this.updateTime = updateTime; &#125; public Product() &#123; super(); &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getCategoryId() &#123; return categoryId; &#125; public void setCategoryId(Integer categoryId) &#123; this.categoryId = categoryId; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name == null ? null : name.trim(); &#125; public String getSubtitle() &#123; return subtitle; &#125; public void setSubtitle(String subtitle) &#123; this.subtitle = subtitle == null ? null : subtitle.trim(); &#125; public String getMainImage() &#123; return mainImage; &#125; public void setMainImage(String mainImage) &#123; this.mainImage = mainImage == null ? null : mainImage.trim(); &#125; public String getSubImages() &#123; return subImages; &#125; public void setSubImages(String subImages) &#123; this.subImages = subImages == null ? null : subImages.trim(); &#125; public String getDetail() &#123; return detail; &#125; public void setDetail(String detail) &#123; this.detail = detail == null ? null : detail.trim(); &#125; public BigDecimal getPrice() &#123; return price; &#125; public void setPrice(BigDecimal price) &#123; this.price = price; &#125; public Integer getStock() &#123; return stock; &#125; public void setStock(Integer stock) &#123; this.stock = stock; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; public Date getCreateTime() &#123; return createTime; &#125; public void setCreateTime(Date createTime) &#123; this.createTime = createTime; &#125; public Date getUpdateTime() &#123; return updateTime; &#125; public void setUpdateTime(Date updateTime) &#123; this.updateTime = updateTime; &#125;&#125; ProductDetailVo.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package com.mmall.vo;import java.math.BigDecimal;/** * Created by geely */public class ProductDetailVo &#123; private Integer id; private Integer categoryId; private String name; private String subtitle; private String mainImage; private String subImages; private String detail; private BigDecimal price; private Integer stock; private Integer status; private String createTime; private String updateTime; private String imageHost; private Integer parentCategoryId; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getCategoryId() &#123; return categoryId; &#125; public void setCategoryId(Integer categoryId) &#123; this.categoryId = categoryId; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSubtitle() &#123; return subtitle; &#125; public void setSubtitle(String subtitle) &#123; this.subtitle = subtitle; &#125; public String getMainImage() &#123; return mainImage; &#125; public void setMainImage(String mainImage) &#123; this.mainImage = mainImage; &#125; public String getSubImages() &#123; return subImages; &#125; public void setSubImages(String subImages) &#123; this.subImages = subImages; &#125; public String getDetail() &#123; return detail; &#125; public void setDetail(String detail) &#123; this.detail = detail; &#125; public BigDecimal getPrice() &#123; return price; &#125; public void setPrice(BigDecimal price) &#123; this.price = price; &#125; public Integer getStock() &#123; return stock; &#125; public void setStock(Integer stock) &#123; this.stock = stock; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; public String getCreateTime() &#123; return createTime; &#125; public void setCreateTime(String createTime) &#123; this.createTime = createTime; &#125; public String getUpdateTime() &#123; return updateTime; &#125; public void setUpdateTime(String updateTime) &#123; this.updateTime = updateTime; &#125; public String getImageHost() &#123; return imageHost; &#125; public void setImageHost(String imageHost) &#123; this.imageHost = imageHost; &#125; public Integer getParentCategoryId() &#123; return parentCategoryId; &#125; public void setParentCategoryId(Integer parentCategoryId) &#123; this.parentCategoryId = parentCategoryId; &#125;&#125; 静态代码块&gt;普通代码块&gt;构造代码块 Tomcat启动加载静态代码块 时间转换工具类DateTimeUtil.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.mmall.util;import org.apache.commons.lang3.StringUtils;import org.joda.time.DateTime;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;import java.util.Date;/** * Created by geely */public class DateTimeUtil &#123; //joda-time //str-&gt;Date //Date-&gt;str public static final String STANDARD_FORMAT = "yyyy-MM-dd HH:mm:ss"; public static Date strToDate(String dateTimeStr,String formatStr)&#123; DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(formatStr); DateTime dateTime = dateTimeFormatter.parseDateTime(dateTimeStr); return dateTime.toDate(); &#125; public static String dateToStr(Date date,String formatStr)&#123; if(date == null)&#123; return StringUtils.EMPTY; &#125; DateTime dateTime = new DateTime(date); return dateTime.toString(formatStr); &#125; public static Date strToDate(String dateTimeStr)&#123; DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(STANDARD_FORMAT); DateTime dateTime = dateTimeFormatter.parseDateTime(dateTimeStr); return dateTime.toDate(); &#125; public static String dateToStr(Date date)&#123; if(date == null)&#123; return StringUtils.EMPTY; &#125; DateTime dateTime = new DateTime(date); return dateTime.toString(STANDARD_FORMAT); &#125; public static void main(String[] args) &#123; System.out.println(DateTimeUtil.dateToStr(new Date(),"yyyy-MM-dd HH:mm:ss")); System.out.println(DateTimeUtil.strToDate("2010-01-01 11:11:11","yyyy-MM-dd HH:mm:ss")); &#125;&#125; mybatis-pagehelper高效分页 配置pom.xml 实现 mybatis-pagehelper动态排序 mybatis对List遍历的实现方法 mybatis对where语句动态拼装 FTP服务对接 先将文件上传到本地======&gt;上传到远程ftp====&gt;删除本地文件 配置pom.xml 12345678910111213&lt;!-- file upload --&gt; &lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; 配置dispatcher-servlet.xml 123456&lt;!-- 文件上传 --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="10485760"/&gt; &lt;!-- 10m --&gt; &lt;property name="maxInMemorySize" value="4096" /&gt; &lt;property name="defaultEncoding" value="UTF-8"&gt;&lt;/property&gt;&lt;/bean&gt; FileServiceImpl.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.mmall.service.impl;import com.google.common.collect.Lists;import com.mmall.service.IFileService;import com.mmall.util.FTPUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Service;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;import java.util.UUID;/** * Created by geely */@Service("iFileService")public class FileServiceImpl implements IFileService &#123; private Logger logger = LoggerFactory.getLogger(FileServiceImpl.class); public String upload(MultipartFile file,String path)&#123; String fileName = file.getOriginalFilename(); //扩展名 //abc.jpg String fileExtensionName = fileName.substring(fileName.lastIndexOf(".")+1); String uploadFileName = UUID.randomUUID().toString()+"."+fileExtensionName; logger.info("开始上传文件,上传文件的文件名:&#123;&#125;,上传的路径:&#123;&#125;,新文件名:&#123;&#125;",fileName,path,uploadFileName); File fileDir = new File(path); if(!fileDir.exists())&#123; fileDir.setWritable(true); fileDir.mkdirs(); &#125; File targetFile = new File(path,uploadFileName); try &#123; file.transferTo(targetFile); //文件已经上传成功了 FTPUtil.uploadFile(Lists.newArrayList(targetFile)); //已经上传到ftp服务器上 targetFile.delete(); &#125; catch (IOException e) &#123; logger.error("上传文件异常",e); return null; &#125; //A:abc.jpg //B:abc.jpg return targetFile.getName(); &#125;&#125; 连接远程ftp，上传文件 FTPUtil.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.mmall.util;import org.apache.commons.net.ftp.FTPClient;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.util.List;/** * Created by geely */public class FTPUtil &#123; private static final Logger logger = LoggerFactory.getLogger(FTPUtil.class); private static String ftpIp = PropertiesUtil.getProperty("ftp.server.ip"); private static String ftpUser = PropertiesUtil.getProperty("ftp.user"); private static String ftpPass = PropertiesUtil.getProperty("ftp.pass"); public FTPUtil(String ip,int port,String user,String pwd)&#123; this.ip = ip; this.port = port; this.user = user; this.pwd = pwd; &#125; public static boolean uploadFile(List&lt;File&gt; fileList) throws IOException &#123; FTPUtil ftpUtil = new FTPUtil(ftpIp,21,ftpUser,ftpPass); logger.info("开始连接ftp服务器"); boolean result = ftpUtil.uploadFile("img",fileList); logger.info("开始连接ftp服务器,结束上传,上传结果:&#123;&#125;"); return result; &#125; private boolean uploadFile(String remotePath,List&lt;File&gt; fileList) throws IOException &#123; boolean uploaded = true; FileInputStream fis = null; //连接FTP服务器 if(connectServer(this.ip,this.port,this.user,this.pwd))&#123; try &#123; ftpClient.changeWorkingDirectory(remotePath); ftpClient.setBufferSize(1024); ftpClient.setControlEncoding("UTF-8"); ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); ftpClient.enterLocalPassiveMode(); for(File fileItem : fileList)&#123; fis = new FileInputStream(fileItem); ftpClient.storeFile(fileItem.getName(),fis); &#125; &#125; catch (IOException e) &#123; logger.error("上传文件异常",e); uploaded = false; e.printStackTrace(); &#125; finally &#123; fis.close(); ftpClient.disconnect(); &#125; &#125; return uploaded; &#125; private boolean connectServer(String ip,int port,String user,String pwd)&#123; boolean isSuccess = false; ftpClient = new FTPClient(); try &#123; ftpClient.connect(ip); isSuccess = ftpClient.login(user,pwd); &#125; catch (IOException e) &#123; logger.error("连接FTP服务器异常",e); &#125; return isSuccess; &#125; private String ip; private int port; private String user; private String pwd; private FTPClient ftpClient; public String getIp() &#123; return ip; &#125; public void setIp(String ip) &#123; this.ip = ip; &#125; public int getPort() &#123; return port; &#125; public void setPort(int port) &#123; this.port = port; &#125; public String getUser() &#123; return user; &#125; public void setUser(String user) &#123; this.user = user; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; public FTPClient getFtpClient() &#123; return ftpClient; &#125; public void setFtpClient(FTPClient ftpClient) &#123; this.ftpClient = ftpClient; &#125;&#125; 富文本上传 和ftp文件上传类似，只是对返回值有特殊要求 购物车模块 商品总价计算复用封装 123456789101112131415161718192021222324252627282930313233343536373839404142package com.mmall.util;import java.math.BigDecimal;/** * Created by geely */public class BigDecimalUtil &#123; private BigDecimalUtil()&#123; &#125; public static BigDecimal add(double v1,double v2)&#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.add(b2); &#125; public static BigDecimal sub(double v1,double v2)&#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.subtract(b2); &#125; public static BigDecimal mul(double v1,double v2)&#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.multiply(b2); &#125; public static BigDecimal div(double v1,double v2)&#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.divide(b2,2,BigDecimal.ROUND_HALF_UP);//四舍五入,保留2位小数 //除不尽的情况 &#125;&#125; 高复用的逻辑方法封装思想 解决商业运算丢失精度的坑 一定要用BigDecimal的String构造函数 123456789101112131415161718192021222324252627public class BigDecimalTest &#123; @Test public void test1()&#123; System.out.println(0.05+0.01); System.out.println(1.0-0.42); System.out.println(4.015*100); System.out.println(123.3/100); &#125; @Test public void test2()&#123; BigDecimal b1 = new BigDecimal(0.05); BigDecimal b2 = new BigDecimal(0.01); System.out.println(b1.add(b2)); &#125; @Test public void test3()&#123; BigDecimal b1 = new BigDecimal("0.05"); BigDecimal b2 = new BigDecimal("0.01"); System.out.println(b1.add(b2)); &#125;&#125; 订单模块 安全漏洞解决方案 订单号生成规则 强大的常量、枚举设计 Const.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package com.mmall.common;import com.google.common.collect.Sets;import java.util.Set;/** * Created by geely */public class Const &#123; public static final String CURRENT_USER = "currentUser"; public static final String EMAIL = "email"; public static final String USERNAME = "username"; public interface ProductListOrderBy&#123; Set&lt;String&gt; PRICE_ASC_DESC = Sets.newHashSet("price_desc","price_asc"); &#125; public interface Cart&#123; int CHECKED = 1;//即购物车选中状态 int UN_CHECKED = 0;//购物车中未选中状态 String LIMIT_NUM_FAIL = "LIMIT_NUM_FAIL"; String LIMIT_NUM_SUCCESS = "LIMIT_NUM_SUCCESS"; &#125; public interface Role&#123; int ROLE_CUSTOMER = 0; //普通用户 int ROLE_ADMIN = 1;//管理员 &#125; public enum ProductStatusEnum&#123; ON_SALE(1,"在线"); private String value; private int code; ProductStatusEnum(int code,String value)&#123; this.code = code; this.value = value; &#125; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; &#125; public enum OrderStatusEnum&#123; CANCELED(0,"已取消"), NO_PAY(10,"未支付"), PAID(20,"已付款"), SHIPPED(40,"已发货"), ORDER_SUCCESS(50,"订单完成"), ORDER_CLOSE(60,"订单关闭"); OrderStatusEnum(int code,String value)&#123; this.code = code; this.value = value; &#125; private String value; private int code; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; public static OrderStatusEnum codeOf(int code)&#123; for(OrderStatusEnum orderStatusEnum : values())&#123; if(orderStatusEnum.getCode() == code)&#123; return orderStatusEnum; &#125; &#125; throw new RuntimeException("么有找到对应的枚举"); &#125; &#125; public interface AlipayCallback&#123; String TRADE_STATUS_WAIT_BUYER_PAY = "WAIT_BUYER_PAY"; String TRADE_STATUS_TRADE_SUCCESS = "TRADE_SUCCESS"; String RESPONSE_SUCCESS = "success"; String RESPONSE_FAILED = "failed"; &#125; public enum PayPlatformEnum&#123; ALIPAY(1,"支付宝"); PayPlatformEnum(int code,String value)&#123; this.code = code; this.value = value; &#125; private String value; private int code; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; &#125; public enum PaymentTypeEnum&#123; ONLINE_PAY(1,"在线支付"); PaymentTypeEnum(int code,String value)&#123; this.code = code; this.value = value; &#125; private String value; private int code; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; public static PaymentTypeEnum codeOf(int code)&#123; for(PaymentTypeEnum paymentTypeEnum : values())&#123; if(paymentTypeEnum.getCode() == code)&#123; return paymentTypeEnum; &#125; &#125; throw new RuntimeException("么有找到对应的枚举"); &#125; &#125;&#125; 使用 mybatis批量插入 收货地址 同步获取自增主键 数据绑定的对象绑定 收货地址对象必须要有get和set方法 越权问题升级巩固 支付模块 支付宝SDK源码解析 当面付 当面付Demo 服务端SDK下载和使用教程 沙箱环境使用 生成RSA密钥 支付宝支付流程与集成 导入依赖 配置maven插件,除了pom.xml配置的依赖，lib包中的依赖也会一起打包部署 配置沙箱环境zfbinfo.properties 1234567891011121314151617181920212223242526272829303132333435# 支付宝网关名、partnerId和appIdopen_api_domain = https://openapi.alipaydev.com/gateway.domcloud_api_domain = http://mcloudmonitor.com/gateway.dopid = 2088102180444972appid = 2016102100728313# RSA私钥、公钥和支付宝公钥private_key = MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCKQ2pEIzXM4IoN1cMzOFXdlk8yVX2cKXWITZ92EGAQQcRytaV07yQOaz3UE9KTeT9Nu628G+HZMsJUxQjEUETagmY5nLtbeL35M2UcibYpM3e2gVTtUW86CA65GCdLzUhdIug8yf2F9zWayzG4sHZ9DcTezG6ZjFu+EtDpFgg+CtqY7n/ihjTIqeE1lX0C2ZIKpIYs7QjR8AztB/qRcpOJKRfMKGDgmT9GALN8LeFEYCbQ+W/GJHN8bQ0Bk1Ll6EKQ4cHXZ1Yko+aXaRfbXfUZYgD9hwAVlxtwZndgeFX8KapOCw0J25pzV4WkutIjMlt7I2Q1jaWNoKLuxtz4M2mzAgMBAAECggEAAhnsL4TpeGehMXyiLtEYXPm/0mACPLFUm/GyDrVJAHY/ag7gqNpJjf6LPgHfHWamU6Qai9VQpWBkG62y6Gjf4wJAU3fSUR2QpYzmaHyfTBkAJMHqbIDkU9lzf9SiJEDGbMPvC512QOb05ZlY9Bmac2QWLdylgafkbQsUKbawAWFa/BAOMIp0tgYLW8/yY2aG6jeLqhOgTo8MWIW5d1qHtX5m/x7g97dYYMdX3kTo2i1dFLUVfEOvZe4US6VBvLg71dMxwadVF5YMaY9jq/ShPD0Gkf29wdThwsjcH6u9Tq/KArQTK+z02DAGkdWOcue3pHql+gvoIA8U5uFDdIeYwQKBgQDri3jPkDKi48efdKQk38rn+CJYeNFNRAhlly3h2AHaFEY92XRlBsho/vGFg43BvHu+cMz0Run4SS8Vo09vcTIY6p2xNMffjR0w2gQqx6PUdGHBFtw7FavxN4uVtVhL6uTAqfBv97mqQO0bq+DhOGwSRNIWqvnzfXywqwmXhKYECwKBgQCWRTl6tNv8scxPq4fpRL/uw71TU6XqSS/nME7KT4uyQPAXPk0mXVVwdmyST9Crlr6O6WJopPe9nMIFUYdjdkLfGKLCR96AH3U7frr4jf60eDYEhfHGIzln/ptrTJLvvbXTaPctAaZd6TIv63QVz3yim4MMl3VSdRlrE+O9R5ZR+QKBgQDjEP8TyUSnNsJX+4/JZFwsp04kz8OlorIdjVHT5/JREz5rnVfRlGpanXqjZSCg5Vy9R+ysiDhA+/wB9f87xXmv/2ypSeJspZLAZ0uhGffbdZ5PEASaiNfKn+tWFQ3bkcOX37tDlSJM+G4bQOR2+XdlXSbSZ1yx2AT+IsQKZvvL5QKBgQCPZEUiEz0sV1kX2R2a+XCQ3RVnUxWqh+X/HPjCUr+B/DdeZqPl7QAfjdGymBkN842o/4lZQ7nnpJL70j14KpxLGM4Ox9fIuLv8ZsTxc0XOXjtle48nO+uGkc0qyWoY/RVpQ+tBdiaTzHeIhIxEV7adz/lwZYKdiYIUzGjv8ES/uQKBgCgeWysXjahCQItxx5fTrS8SQFP7Dx5vDW+UkqQ2pbL0AlHyUS7pWJj3AAe3pn4AJZZp4SZPoQP+Z8JPqDA6MrQWHYMi0XkMuMYwLWbGCkmf1MnjUxgOaLXoItjxS/y3jQfeOmHhmOAVkjnEvAh+BWlZxFMv2kiuHRU72bNa0rDIpublic_key = MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAikNqRCM1zOCKDdXDMzhV3ZZPMlV9nCl1iE2fdhBgEEHEcrWldO8kDms91BPSk3k/TbutvBvh2TLCVMUIxFBE2oJmOZy7W3i9+TNlHIm2KTN3toFU7VFvOggOuRgnS81IXSLoPMn9hfc1mssxuLB2fQ3E3sxumYxbvhLQ6RYIPgramO5/4oY0yKnhNZV9AtmSCqSGLO0I0fAM7Qf6kXKTiSkXzChg4Jk/RgCzfC3hRGAm0PlvxiRzfG0NAZNS5ehCkOHB12dWJKPml2kX2131GWIA/YcAFZcbcGZ3YHhV/CmqTgsNCduac1eFpLrSIzJbeyNkNY2ljaCi7sbc+DNpswIDAQAB#SHA1withRsa对应支付宝公钥#alipay_public_key = MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDI6d306Q8fIfCOaTXyiUeJHkrIvYISRcc73s3vF1ZT7XN8RNPwJxo8pWaJMmvyTn9N4HQ632qJBVHf8sxHi/fEsraprwCtzvzQETrNRwVxLO5jVmRGi60j8Ue1efIlzPXV9je9mkjzOmdssymZkh2QhUrCmZYI/FCEa3/cNMW0QIDAQAB#SHA256withRsa对应支付宝公钥alipay_public_key = MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqzWgVL/NWrJAeyEImwtaK3IDwj0dKkqUDIfqqWn5SiLaWMYi9RmKhn+jY9VM7JXEIkYYeVlqIL6Xn7OvYFRTi4buTCXGKvFLn95aDcaur77/S/0ibcdN1K2wIoHzaqQhXAb1ezKxTnFP7OLJsAL22b0NzrQDj2OH9SA06gJb8nHBfR+7Sx7DfwcqE0OtTcDHjbbcB24Qgg/dfItxoEnKuSyRVrf6BtpUnJxSzG/Ge7FfF+VBq8re1t4ZTSxaDEjto071I5VFBxr7I4SyqZsc7WpAmZL8AqUgEbQ1XYBWx2LnpJXM5GQW/thUvcDDqzea7LJNWJOQPM5DaZQgu7QuuwIDAQAB# 签名类型: RSA-&gt;SHA1withRsa,RSA2-&gt;SHA256withRsasign_type = RSA2# 当面付最大查询次数和查询间隔（毫秒）max_query_retry = 5query_duration = 5000# 当面付最大撤销次数和撤销间隔（毫秒）max_cancel_retry = 3cancel_duration = 2000# 交易保障线程第一次调度延迟和调度间隔（秒）heartbeat_delay = 5heartbeat_duration = 900 二维码生成，扫码支付 配置回调url 两次回调，扫码进行一次回调，扫码付款成功进行一次回调 生成二维码，上传到ftp服务器 OrderServiceImpl.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216package com.mmall.service.impl;/** * Created by geely */@Service("iOrderService")public class OrderServiceImpl implements IOrderService &#123; private static AlipayTradeService tradeService; static &#123; /** 一定要在创建AlipayTradeService之前调用Configs.init()设置默认参数 * Configs会读取classpath下的zfbinfo.properties文件配置信息，如果找不到该文件则确认该文件是否在classpath目录 */ Configs.init("zfbinfo.properties"); /** 使用Configs提供的默认参数 * AlipayTradeService可以使用单例或者为静态成员对象，不需要反复new */ tradeService = new AlipayTradeServiceImpl.ClientBuilder().build(); &#125; private static final Logger logger = LoggerFactory.getLogger(OrderServiceImpl.class); @Autowired private OrderMapper orderMapper; @Autowired private OrderItemMapper orderItemMapper; @Autowired private PayInfoMapper payInfoMapper; @Autowired private CartMapper cartMapper; @Autowired private ProductMapper productMapper; @Autowired private ShippingMapper shippingMapper; public ServerResponse pay(Long orderNo,Integer userId,String path)&#123; Map&lt;String ,String&gt; resultMap = Maps.newHashMap(); Order order = orderMapper.selectByUserIdAndOrderNo(userId,orderNo); if(order == null)&#123; return ServerResponse.createByErrorMessage("用户没有该订单"); &#125; resultMap.put("orderNo",String.valueOf(order.getOrderNo())); // (必填) 商户网站订单系统中唯一订单号，64个字符以内，只能包含字母、数字、下划线， // 需保证商户系统端不能重复，建议通过数据库sequence生成， String outTradeNo = order.getOrderNo().toString(); // (必填) 订单标题，粗略描述用户的支付目的。如“xxx品牌xxx门店当面付扫码消费” String subject = new StringBuilder().append("happymmall扫码支付,订单号:").append(outTradeNo).toString(); // (必填) 订单总金额，单位为元，不能超过1亿元 // 如果同时传入了【打折金额】,【不可打折金额】,【订单总金额】三者,则必须满足如下条件:【订单总金额】=【打折金额】+【不可打折金额】 String totalAmount = order.getPayment().toString(); // (可选) 订单不可打折金额，可以配合商家平台配置折扣活动，如果酒水不参与打折，则将对应金额填写至此字段 // 如果该值未传入,但传入了【订单总金额】,【打折金额】,则该值默认为【订单总金额】-【打折金额】 String undiscountableAmount = "0"; // 卖家支付宝账号ID，用于支持一个签约账号下支持打款到不同的收款账号，(打款到sellerId对应的支付宝账号) // 如果该字段为空，则默认为与支付宝签约的商户的PID，也就是appid对应的PID String sellerId = ""; // 订单描述，可以对交易或商品进行一个详细地描述，比如填写"购买商品2件共15.00元" String body = new StringBuilder().append("订单").append(outTradeNo).append("购买商品共").append(totalAmount).append("元").toString(); // 商户操作员编号，添加此参数可以为商户操作员做销售统计 String operatorId = "test_operator_id"; // (必填) 商户门店编号，通过门店号和商家后台可以配置精准到门店的折扣信息，详询支付宝技术支持 String storeId = "test_store_id"; // 业务扩展参数，目前可添加由支付宝分配的系统商编号(通过setSysServiceProviderId方法)，详情请咨询支付宝技术支持 ExtendParams extendParams = new ExtendParams(); extendParams.setSysServiceProviderId("2088100200300400500"); // 支付超时，定义为120分钟 String timeoutExpress = "120m"; // 商品明细列表，需填写购买商品详细信息， List&lt;GoodsDetail&gt; goodsDetailList = new ArrayList&lt;GoodsDetail&gt;(); List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNoUserId(orderNo,userId); for(OrderItem orderItem : orderItemList)&#123; GoodsDetail goods = GoodsDetail.newInstance(orderItem.getProductId().toString(), orderItem.getProductName(), BigDecimalUtil.mul(orderItem.getCurrentUnitPrice().doubleValue(),new Double(100).doubleValue()).longValue(), orderItem.getQuantity()); goodsDetailList.add(goods); &#125; // 创建扫码支付请求builder，设置请求参数 AlipayTradePrecreateRequestBuilder builder = new AlipayTradePrecreateRequestBuilder() .setSubject(subject).setTotalAmount(totalAmount).setOutTradeNo(outTradeNo) .setUndiscountableAmount(undiscountableAmount).setSellerId(sellerId).setBody(body) .setOperatorId(operatorId).setStoreId(storeId).setExtendParams(extendParams) .setTimeoutExpress(timeoutExpress) .setNotifyUrl(PropertiesUtil.getProperty("alipay.callback.url"))//支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置 .setGoodsDetailList(goodsDetailList); AlipayF2FPrecreateResult result = tradeService.tradePrecreate(builder); switch (result.getTradeStatus()) &#123; case SUCCESS: logger.info("支付宝预下单成功: )"); AlipayTradePrecreateResponse response = result.getResponse(); dumpResponse(response); File folder = new File(path); if(!folder.exists())&#123; folder.setWritable(true); folder.mkdirs(); &#125; // 需要修改为运行机器上的路径 //细节细节细节 String qrPath = String.format(path+"/qr-%s.png",response.getOutTradeNo()); String qrFileName = String.format("qr-%s.png",response.getOutTradeNo()); ZxingUtils.getQRCodeImge(response.getQrCode(), 256, qrPath); File targetFile = new File(path,qrFileName); try &#123; FTPUtil.uploadFile(Lists.newArrayList(targetFile)); &#125; catch (IOException e) &#123; logger.error("上传二维码异常",e); &#125; logger.info("qrPath:" + qrPath); String qrUrl = PropertiesUtil.getProperty("ftp.server.http.prefix")+targetFile.getName(); resultMap.put("qrUrl",qrUrl); return ServerResponse.createBySuccess(resultMap); case FAILED: logger.error("支付宝预下单失败!!!"); return ServerResponse.createByErrorMessage("支付宝预下单失败!!!"); case UNKNOWN: logger.error("系统异常，预下单状态未知!!!"); return ServerResponse.createByErrorMessage("系统异常，预下单状态未知!!!"); default: logger.error("不支持的交易状态，交易返回异常!!!"); return ServerResponse.createByErrorMessage("不支持的交易状态，交易返回异常!!!"); &#125; &#125; // 简单打印应答 private void dumpResponse(AlipayResponse response) &#123; if (response != null) &#123; logger.info(String.format("code:%s, msg:%s", response.getCode(), response.getMsg())); if (StringUtils.isNotEmpty(response.getSubCode())) &#123; logger.info(String.format("subCode:%s, subMsg:%s", response.getSubCode(), response.getSubMsg())); &#125; logger.info("body:" + response.getBody()); &#125; &#125; public ServerResponse aliCallback(Map&lt;String,String&gt; params)&#123; Long orderNo = Long.parseLong(params.get("out_trade_no")); String tradeNo = params.get("trade_no"); String tradeStatus = params.get("trade_status"); Order order = orderMapper.selectByOrderNo(orderNo); if(order == null)&#123; return ServerResponse.createByErrorMessage("非快乐慕商城的订单,回调忽略"); &#125; if(order.getStatus() &gt;= Const.OrderStatusEnum.PAID.getCode())&#123; return ServerResponse.createBySuccess("支付宝重复调用"); &#125; if(Const.AlipayCallback.TRADE_STATUS_TRADE_SUCCESS.equals(tradeStatus))&#123; order.setPaymentTime(DateTimeUtil.strToDate(params.get("gmt_payment"))); order.setStatus(Const.OrderStatusEnum.PAID.getCode()); orderMapper.updateByPrimaryKeySelective(order); &#125; PayInfo payInfo = new PayInfo(); payInfo.setUserId(order.getUserId()); payInfo.setOrderNo(order.getOrderNo()); payInfo.setPayPlatform(Const.PayPlatformEnum.ALIPAY.getCode()); payInfo.setPlatformNumber(tradeNo); payInfo.setPlatformStatus(tradeStatus); payInfoMapper.insert(payInfo); return ServerResponse.createBySuccess(); &#125; public ServerResponse queryOrderPayStatus(Integer userId,Long orderNo)&#123; Order order = orderMapper.selectByUserIdAndOrderNo(userId,orderNo); if(order == null)&#123; return ServerResponse.createByErrorMessage("用户没有该订单"); &#125; if(order.getStatus() &gt;= Const.OrderStatusEnum.PAID.getCode())&#123; return ServerResponse.createBySuccess(); &#125; return ServerResponse.createByError(); &#125;&#125; 内网穿透 NATAPP1分钟快速新手图文教程 线上部署 云服务器vsftpd、nginx等配置 云服务器的配置与域名解析 发布上线注意事项]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Mysql</tag>
        <tag>Git</tag>
        <tag>Maven</tag>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux系统下开发环境安装与配置]]></title>
    <url>%2Fmyhexo%2F2019%2F03%2F07%2Flinux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装系统环境 CentOS 6.8 64位 jdk版本 7u80 64位 Tomcat版本 Tomcat7 maven版本 Apache Maven 3.6.0 vsftpd版本 vsftpd-2.2.2-24.el6.x86_64 Nginx版本 nginx-1.14.2 mysql版本 mysql-server-5.1.73-8.el6_8.x86_64 git版本 git version 2.18.0 阿里源配置 123456#备份[root@192 yum.repos.d]# mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup#下载新的CentOS-Base.repo 到/etc/yum.repos.d/[root@192 yum.repos.d]# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo#生成缓存[root@192 yum.repos.d]# yum makecache 设置开机时关闭防火墙 1[root@192 vsftpd]# chkconfig iptables off jdk安装 下载 清理系统默认自带jdk 12345[root@192 yum.repos.d]# rpm -qa | grep jdkjava-1.6.0-openjdk-1.6.0.38-1.13.10.4.el6.x86_64java-1.7.0-openjdk-1.7.0.99-2.6.5.1.el6.x86_64[root@192 yum.repos.d]# yum remove java-1.6.0-openjdk-1.6.0.38-1.13.10.4.el6.x86_64[root@192 yum.repos.d]# yum remove java-1.7.0-openjdk-1.7.0.99-2.6.5.1.el6.x86_64 授权 1[root@192 soft]# chmod 777 jdk-7u80-linux-x64.rpm 安装 1[root@192 soft]# rpm -ivh jdk-7u80-linux-x64.rpm 默认安装路径/user/java jdk配置环境变量,编辑/etc/profile文件，末尾追加 1234#jdkexport JAVA_HOME=/usr/java/jdk1.7.0_80export PATH=$PATH:$JAVA_HOME/binexport CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 使得/etc/profile文件立即生效 1[root@192 apache-maven-3.6.0]# source /etc/profile Tomcat安装 下载 解压 12[root@192 soft]# tar -zxvf apache-tomcat-7.0.93.tar.gz -C /opt/module/ Tomcat配置环境变量,编辑/etc/profile文件，末尾追加 123#tomcatexport CATALINA_HOME=/opt/module/apache-tomcat-7.0.93export PATH=$PATH:$CATALINA_HOME/bin 使得/etc/profile文件立即生效 1[root@192 apache-maven-3.6.0]# source /etc/profile 配置UTF-8字符集，进入Tomcat安装的conf文件夹，编辑server.xml文件，找到配置8080默认端口的位置，在xml节点末尾增加URIEncoding=&quot;UTF-8&quot; 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; /&gt; 启动Tomcat，进入/opt/module/apache-tomcat-7.0.93/bin目录，执行./startup.sh 访问http://192.168.1.104:8080/ Maven安装 下载 解压 1[root@192 soft]# tar -zxvf apache-maven-3.6.0-bin.tar.gz -C /opt/module/ Maven配置环境变量,编辑/etc/profile文件，末尾追加 123#mavenexport MAVEN_HOME=/opt/module/apache-maven-3.6.0export PATH=$PATH:$MAVEN_HOME/bin 使得/etc/profile文件立即生效 1[root@192 apache-maven-3.6.0]# source /etc/profile 验证 1[root@192 apache-maven-3.6.0]# mvn -version vsftpd安装 安装 1[root@192 apache-maven-3.6.0]# yum -y install vsftpd 查看是否已安装 12[root@192 apache-maven-3.6.0]# rpm -qa | grep vsftpdvsftpd-2.2.2-24.el6.x86_64 默认配置文件/etc/vsftpd/vsftpd.conf 创建虚拟用户 根目录下创建ftp文件夹 12[root@192 vsftpd]# cd /[root@192 /]# mkdir ftpfile 添加匿名用户 1[root@192 /]# useradd ftpuser -d /ftpfile/ -s /sbin/nologin 修改ftpfile权限 1[root@192 /]# chown -R ftpuser.ftpuser /ftpfile/ 重设ftpuser密码 1[root@192 /]# passwd ftpuser 将刚刚新增的虚拟用户添加到此配置文件中 1234[root@192 ~]# cd /etc/vsftpd/[root@192 vsftpd]# vim chroo_list [root@192 bin]# cat /etc/vsftpd/chroo_list ftpuser 编辑配置文件/etc/vsftpd/vsftpd.conf，末尾追加 1234local_root=/ftpfileanon_root=/ftpfileuse_localtime=YESanonymous_enable=no 登录验证的时候出现500提示,编辑/etc/selinux/config文件，设置SELINUX=disabled 1[root@192 vsftpd]# vim /etc/selinux/config 如果还报500，执行 1[root@192 vsftpd]# setsebool -P ftp_home_dir 1 设置开启启动vsftpd服务 1[root@192 vsftpd]# chkconfig vsftpd on 访问ftp://192.168.1.104/ 安装Nginx 下载 安装依赖gcc、pcre、zlib、openssl 1[root@192 vsftpd]# yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 解压 1[root@192 soft]# tar -zxvf nginx-1.14.2.tar.gz -C /opt/module/ 编译安装 12345[root@192 nginx-1.14.2]# pwd/opt/module/nginx-1.14.2[root@192 nginx-1.14.2]# ./configure[root@192 nginx-1.14.2]# make[root@192 nginx-1.14.2]# make install 查看Nginx安装目录、版本 1234[root@192 nginx-1.14.2]# whereis nginxnginx: /usr/local/nginx[root@192 nginx-1.14.2]# /usr/local/nginx/sbin/nginx -vnginx version: nginx/1.14.2 测试配置文件nginx.conf的正确性 1[root@192 nginx-1.14.2]# /usr/local/nginx/sbin/nginx -t 启动Nginx 12345[root@192 nginx-1.14.2]# /usr/local/nginx/sbin/nginx[root@192 nginx-1.14.2]# ps -ef | grep nginxroot 5606 1 0 01:02 ? 00:00:00 nginx: master process /usr/local/nginx/sbin/nginxnobody 5607 5606 0 01:02 ? 00:00:00 nginx: worker process root 5626 2868 0 01:09 pts/0 00:00:00 grep nginx 停止Nginx 1[root@192 nginx-1.14.2]# /usr/local/nginx/sbin/nginx -s stop 访问http://192.168.1.104/ Nginx配置虚拟域名 配置虚拟域名映射 12345678[root@192 vhost]# cat /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6#centos#192.168.1.104 www.imooc.com127.0.0.1 www.imooc.com 测试 1234[root@192 sbin]# ping www.imooc.comPING www.imooc.com (127.0.0.1) 56(84) bytes of data.64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.013 ms64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.032 ms 编辑/usr/local/nginx/conf/nginx.conf文件，追加 12###########################vhost############################################## include vhost/*.conf; 在/usr/local/nginx/conf目录下，新建vhost文件夹 在/usr/local/nginx/conf/vhost目录下，新建域名转发www.mytest.com.conf配置文件 123456789101112131415161718[root@192 vhost]# cat /usr/local/nginx/conf/vhost/www.mytest.com.conf #Start www.mytest.comserver &#123; listen 80; server_name www.mytest.com; access_log /usr/local/nginx/logs/access.log combined; index index.html index.htm index.php; if ( $query_string ~* &quot;.*[\;&apos;\&lt;\&gt;].*&quot; )&#123; return 404; &#125; # send request back to apach location / &#123; proxy_pass http://127.0.0.1:8080/; &#125;&#125; 访问www.mytest.com Nginx配置静态资源转发 编辑/usr/local/nginx/conf/nginx.conf文件，追加 12###########################vhost############################################## include vhost/*.conf; 在/usr/local/nginx/conf目录下，新建vhost文件夹 在/usr/local/nginx/conf/vhost目录下，新建域名转发www.mytest.com.conf配置文件 123456789101112131415161718[root@192 vhost]# cat /usr/local/nginx/conf/vhost/www.mytest.com.conf #Start www.mytest.comserver &#123; listen 80; server_name www.mytest.com; access_log /usr/local/nginx/logs/access.log combined; index index.html index.htm index.php; if ( $query_string ~* &quot;.*[\;&apos;\&lt;\&gt;].*&quot; )&#123; return 404; &#125; # send request back to apach location / &#123; root /ftpfile/; &#125;&#125; mysql安装 安装 1[root@192 ~]# yum -y install mysql-server 配置字符集,编辑/etc/my.cnf文件，追加 12#utf8default-character-set=utf8 设置mysql服务随系统自动启动 123[root@192 ~]# chkconfig mysqld on[root@192 ~]# chkconfig --list mysqldmysqld 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭 启动mysql服务 12[root@192 ~]# service mysqld start正在启动 mysqld： [确定] 登录，使用非密码登录 1234567891011121314[root@192 mysql]# mysql -uroot Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 5Server version: 5.1.73 Source distributionCopyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; 查看mysql的用户 1234567891011mysql&gt; select user,host,password from mysql.user;+------+---------------+----------+| user | host | password |+------+---------------+----------+| root | localhost | || root | 192.168.1.104 | || root | 127.0.0.1 | || | localhost | || | 192.168.1.104 | |+------+---------------+----------+5 rows in set (0.00 sec) 删除匿名用户 12mysql&gt; delete from mysql.user where user=&apos;&apos;;Query OK, 2 rows affected (0.00 sec) 刷新，立即生效 12mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec) 修改root密码 12mysql&gt; set password for root@localhost=password(&quot;000000&quot;);Query OK, 0 rows affected (0.00 sec) 插入mysql新用户 12mysql&gt; insert into mysql.user(Host,User,Password) values(&quot;localhost&quot;,&quot;admin&quot;,password(&quot;000000&quot;));Query OK, 1 row affected, 3 warnings (0.01 sec) 查看用户权限 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162mysql&gt; select * from mysql.user \G*************************** 1. row *************************** Host: localhost User: root Password: *032197AE5731D4664921A6CCAC7CFCE6A0698693 Select_priv: Y Insert_priv: Y Update_priv: Y Delete_priv: Y Create_priv: Y Drop_priv: Y Reload_priv: Y Shutdown_priv: Y Process_priv: Y File_priv: Y Grant_priv: Y References_priv: Y Index_priv: Y Alter_priv: Y Show_db_priv: Y Super_priv: YCreate_tmp_table_priv: Y Lock_tables_priv: Y Execute_priv: Y Repl_slave_priv: Y Repl_client_priv: Y Create_view_priv: Y Show_view_priv: Y Create_routine_priv: Y Alter_routine_priv: Y Create_user_priv: Y Event_priv: Y Trigger_priv: Y ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0*************************** 2. row *************************** Host: 192.168.1.104 User: root Password: Select_priv: Y Insert_priv: Y Update_priv: Y Delete_priv: Y Create_priv: Y Drop_priv: Y Reload_priv: Y Shutdown_priv: Y Process_priv: Y File_priv: Y Grant_priv: Y References_priv: Y Index_priv: Y Alter_priv: Y Show_db_priv: Y Super_priv: YCreate_tmp_table_priv: Y Lock_tables_priv: Y Execute_priv: Y Repl_slave_priv: Y Repl_client_priv: Y Create_view_priv: Y Show_view_priv: Y Create_routine_priv: Y Alter_routine_priv: Y Create_user_priv: Y Event_priv: Y Trigger_priv: Y ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0*************************** 3. row *************************** Host: 127.0.0.1 User: root Password: Select_priv: Y Insert_priv: Y Update_priv: Y Delete_priv: Y Create_priv: Y Drop_priv: Y Reload_priv: Y Shutdown_priv: Y Process_priv: Y File_priv: Y Grant_priv: Y References_priv: Y Index_priv: Y Alter_priv: Y Show_db_priv: Y Super_priv: YCreate_tmp_table_priv: Y Lock_tables_priv: Y Execute_priv: Y Repl_slave_priv: Y Repl_client_priv: Y Create_view_priv: Y Show_view_priv: Y Create_routine_priv: Y Alter_routine_priv: Y Create_user_priv: Y Event_priv: Y Trigger_priv: Y ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0*************************** 4. row *************************** Host: localhost User: admin Password: *032197AE5731D4664921A6CCAC7CFCE6A0698693 Select_priv: N Insert_priv: N Update_priv: N Delete_priv: N Create_priv: N Drop_priv: N Reload_priv: N Shutdown_priv: N Process_priv: N File_priv: N Grant_priv: N References_priv: N Index_priv: N Alter_priv: N Show_db_priv: N Super_priv: NCreate_tmp_table_priv: N Lock_tables_priv: N Execute_priv: N Repl_slave_priv: N Repl_client_priv: N Create_view_priv: N Show_view_priv: N Create_routine_priv: N Alter_routine_priv: N Create_user_priv: N Event_priv: N Trigger_priv: N ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 04 rows in set (0.00 sec) 查库，新建database数据库 123456789101112131415161718192021mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || test |+--------------------+3 rows in set (0.01 sec)mysql&gt; create database mytest default character set utf8 collate utf8_general_ci;Query OK, 1 row affected (0.00 sec)mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || mytest || test |+--------------------+4 rows in set (0.00 sec) 本地用户赋予所有权限、给账号开通外网所有权限 1234mysql&gt; grant all privileges on mytest.* to admin@&apos;%&apos; identified by &apos;000000&apos; with grant option;Query OK, 0 rows affected (0.00 sec)mysql&gt; grant select,delete,create on mytest.* to admin@&apos;192.168.1.104&apos; identified by &apos;000000&apos; with grant option;Query OK, 0 rows affected (0.00 sec) 导入sql文件 1mysql&gt; source /opt/module/mmall.sql git安装 下载 解压 1[root@192 ~]# tar -zxvf git-2.18.0.tar.gz -C /opt/module/ 安装依赖 1[root@192 ~]# yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker cpio 编译安装 1[root@192 git-2.18.0]# make prefix=/usr/local/ install 验证 12[root@192 ~]# git --versiongit version 2.18.0 生成公私密钥对 123456789101112131415161718192021[root@192 ~]# ssh-keygen -t rsa -C &quot;782125244@qq.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:85:1e:ef:5a:33:ab:e7:79:a4:46:f6:8e:8f:7f:af:cd 782125244@qq.comThe key&apos;s randomart image is:+--[ RSA 2048]----+| || . || o . || . + || S . || .o . || o=+ || o+Bo .o || o=*=+..oE|+-----------------+ 复制公钥粘贴到码云或者GitHub上SSH公钥上 12[root@192 .ssh]# cat id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA1sZvTnjQyVn7r2C7G9Q/WyVTTmJYqWhQdVfh3tBCUX8kJHaAcThwR4sl8ROz6xXl/22wbzlsKtfsiyr5zrV0Ifnq7KuCeNVNUYjOQCTn+ODaRzdj7DYC4Mz9BvxZAr0MDfSbgpLp6ZLAvZlkP3DioOPda7VnfJSAHGEYztOVPITj31pVnP1nXkPZRQlsTwImXEGJpuU+zOaurMShpaukrY/ONxWHR6xlG5M1FgOLdBvEnlbhOFoME1HHziI4/08Xw/NrHIUhvjZZgkAzWUo5NvYZLEwrUjOPtlVxHbYwBEtgBWRgWLFMfTlxQnEJVKzbwUDPLvZWac9WSpGLx5xiww== 782125244@qq.com 配置用户名、邮箱，提交时会引用 12345[root@192 mytest]# git config --global user.name &quot;shenlibng&quot;[root@192 mytest]# git config --global user.email &quot;782125244@qq.com&quot;[root@192 mytest]# git config --global core.autocrlf false[root@192 mytest]# git config --global core.quotepath off[root@192 mytest]# git config --global gui.encoding utf-8 开启防火墙配置 查看防火墙初始化配置 1234567891011121314[root@192 ~]# cat /etc/sysconfig/iptables# Firewall configuration written by system-config-firewall# Manual customization of this file is not recommended.*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibitedCOMMIT 开放Tomcat端口 重启生效防火墙 12345[root@192 ~]# service iptables restartiptables：将链设置为政策 ACCEPT：filter [确定]iptables：清除防火墙规则： [确定]iptables：正在卸载模块： [确定]iptables：应用防火墙规则： [确定] 查看防火墙状态 1234567891011121314151617[root@192 ~]# service iptables status表格：filterChain INPUT (policy ACCEPT)num target prot opt source destination 1 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 2 ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 3 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 4 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22 5 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8080 6 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain FORWARD (policy ACCEPT)num target prot opt source destination 1 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain OUTPUT (policy ACCEPT)num target prot opt source destination]]></content>
      <tags>
        <tag>maven</tag>
        <tag>mysql</tag>
        <tag>linux</tag>
        <tag>jdk</tag>
        <tag>tomcat</tag>
        <tag>vsftpd</tag>
        <tag>nginx</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh无密登录_集群分发脚本xsync]]></title>
    <url>%2Fmyhexo%2F2019%2F02%2F18%2Fssh%E6%97%A0%E5%AF%86%E7%99%BB%E5%BD%95-%E9%9B%86%E7%BE%A4%E5%88%86%E5%8F%91%E8%84%9A%E6%9C%ACxsync%2F</url>
    <content type="text"><![CDATA[1、ssh免密登录 ssh ip地址 123[root@192 ~]# ssh 192.168.1.102root@192.168.1.102&apos;s password: Last login: Mon Feb 18 20:40:28 2019 from 192.168.1.101 免密登录配置 生成公钥和私钥 1234567891011121314151617181920212223[root@192 ~]# ssh-keygen -t rsa Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:d4:95:6c:a8:21:9b:27:62:79:43:76:e8:4b:32:6c:fe root@192.168.1.101The key&apos;s randomart image is:+--[ RSA 2048]----+| . o.. || = o...+ || . = =.o.. || O O.o || + * =S || . . || . || E || |+-----------------+[root@192 ~]# ls /root/.ssh/id_rsa id_rsa.pub 将公钥拷贝到要免密登录的目标机器上 .ssh文件夹下（~/.ssh）的文件功能解释（1）known_hosts ：记录ssh访问过计算机的公钥(public key)（2）id_rsa ：生成的私钥（3）id_rsa.pub ：生成的公钥（4）authorized_keys ：存放授权过得无密登录服务器公钥 123456789101112131415161718192021[root@192 ~]# hostname 192.168.1.101[root@192 ~]# ssh-copy-id 192.168.1.102The authenticity of host &apos;192.168.1.102 (192.168.1.102)&apos; can&apos;t be established.RSA key fingerprint is 56:57:4c:81:94:e0:47:fe:1e:aa:8c:9c:2a:87:a6:dc.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;192.168.1.102&apos; (RSA) to the list of known hosts.root@192.168.1.102&apos;s password: Now try logging into the machine, with &quot;ssh &apos;192.168.1.102&apos;&quot;, and check in: .ssh/authorized_keysto make sure we haven&apos;t added extra keys that you weren&apos;t expecting.[root@192 ~]# ls /root/.ssh/id_rsa id_rsa.pub known_hosts[root@192 ~]# ssh 192.168.1.102Last login: Mon Feb 18 22:50:53 2019 from 192.168.1.101[root@192 ~]# ls /root/.ssh/authorized_keys 2、集群分发脚本xsync 服务器与服务器数据拷贝 rsync和scp区别：用rsync做文件的复制要比scp的速度快，rsync只对差异文件做更新。scp是把所有文件都复制过去。 scp 12[root@192 ~]# scp -r /tmp/1.txt root@192.168.1.102:/tmp/1.txt rsync 选项 功能-r 递归-v 显示复制过程-l 拷贝符号连接 123456[root@192 ~]# rsync -rvl /tmp/2.txt root@192.168.1.102:/tmp/sending incremental file list2.txtsent 84 bytes received 31 bytes 76.67 bytes/sectotal size is 13 speedup is 0.11 集群分发脚本xsync 12345[root@192 ~]# mkdir bin[root@192 ~]# cd bin/[root@192 bin]# touch xsync[root@192 bin]# vim xsync[root@192 bin]# chmod 777 xsync 12345678910111213141516171819202122232425262728#!/bin/bash#1 获取输入参数个数，如果没有参数，直接退出pcount=$#if((pcount==0)); thenecho no args;exit;fi#2 获取文件名称p1=$1fname=`basename $p1`echo fname=$fname#3 获取上级目录到绝对路径pdir=`cd -P $(dirname $p1); pwd`echo pdir=$pdir#4 获取当前用户名称user=`whoami`#5 循环for((host=102; host&lt;104; host++)); do echo --------------------- 192.168.1.$host ---------------- rsync -rvl $pdir/$fname $user@192.168.1.$host:$pdir #echo ------"rsync -rvl $pdir/$fname $user@192.168.1.$host:$pdir complete"------------done xsync调用 1234567891011121314151617181920[root@192 bin]# xsync /tmp/1.txt /tmp/fname=1.txtpdir=/tmp--------------------- 192.168.1.102 ----------------sending incremental file list1.txtsent 516 bytes received 31 bytes 364.67 bytes/sectotal size is 445 speedup is 0.81--------------------- 192.168.1.103 ----------------The authenticity of host &apos;192.168.1.103 (192.168.1.103)&apos; can&apos;t be established.RSA key fingerprint is 56:57:4c:81:94:e0:47:fe:1e:aa:8c:9c:2a:87:a6:dc.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;192.168.1.103&apos; (RSA) to the list of known hosts.root@192.168.1.103&apos;s password: sending incremental file list1.txtsent 71 bytes received 37 bytes 5.84 bytes/sectotal size is 445 speedup is 4.12]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ssh</tag>
        <tag>scp</tag>
        <tag>rsync</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机配置静态ip]]></title>
    <url>%2Fmyhexo%2F2019%2F02%2F15%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81ip%2F</url>
    <content type="text"><![CDATA[镜像下载链接 https://wiki.centos.org/Download 环境：CentOS-6.8-x86_64-bin-DVD1.iso 1、克隆虚拟机 修改主机名 [root@192 桌面]# vim /etc/sysconfig/network12NETWORKING=yesHOSTNAME=192.168.1.104 修改网卡信息 [root@192 桌面]# vim /etc/udev/rules.d/70-persistent-net.rules删除或者注释eth0该行；将eth1修改为eth0，同时复制物理ip地址00:0c:29:ac:81:e4 123456789101112# This file was automatically generated by the /lib/udev/write_net_rules# program, run by the persistent-net-generator.rules rules file.## You can modify it, as long as you keep each rule on a single# line, and change only the value of the NAME= key.# PCI device 0x8086:0x100f (e1000)#SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;00:0c:29:00:88:b3&quot;, ATTR&#123;type&#125;==&quot;1&quot;, KERNEL==&quot;eth*&quot;, NAME=&quot;eth0&quot;# PCI device 0x8086:0x100f (e1000)SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;00:0c:29:ac:81:e4&quot;, ATTR&#123;type&#125;==&quot;1&quot;, KERNEL==&quot;eth*&quot;, NAME=&quot;eth0&quot;[root@192 桌面]# 更新物理ip地址HWADDR=00:0c:29:ac:81:e4 [root@192 桌面]# vim /etc/sysconfig/network-scripts/ifcfg-eth0 1234567DEVICE=eth0HWADDR=00:0c:29:ac:81:e4TYPE=EthernetUUID=55735d7f-16c6-46fe-9db8-f7d484b3e7c0ONBOOT=noneNM_CONTROLLED=yesBOOTPROTO=dhcp 2、NAT模式配置 编辑–虚拟网络编辑器 配置静态ip网段和子网掩码 NAT设置 网关ip不能和vmnet8的ip地址冲突 宿主机上的vmnet8网卡会自动分配ip 3、配置静态ip ONBOOT=yes系统启动时激活网卡BOOTPROTO=static通过指定方式的办法来获得地址，设置为静态手动配置IPADDR=192.168.1.104主机ip地址GATEWAY=192.168.1.2网关NETMASK=255.255.255.0子网掩码DNS1=8.8.8.8配置DNS域名解析访问互联网DNS2=8.8.4.4 123456789101112DEVICE=eth0HWADDR=00:0c:29:ac:81:e4TYPE=EthernetUUID=55735d7f-16c6-46fe-9db8-f7d484b3e7c0ONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.1.104GATEWAY=192.168.1.2NETMASK=255.255.255.0DNS1=8.8.8.8DNS2=8.8.4.4]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring定时任务_文件上传进度条]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F30%2Fspring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[spring定时任务 导依赖 123456&lt;!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz --&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt;&lt;/dependency&gt; 配置定时任务类 123456789101112package com.atguigu.scw.portal.service;import org.springframework.stereotype.Service;@Servicepublic class ExampleJob &#123; public void hello() &#123; System.out.println("定时任务触发===========&gt;"); &#125;&#125; 配置定时任务 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd"&gt; &lt;!-- &lt;bean id="exampleJob" class="com.atguigu.scw.portal.service.ExampleJob"&gt;&lt;/bean&gt; --&gt; &lt;!--配置定时任务触发类和方法 --&gt; &lt;bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;property name="targetObject" ref="exampleJob" /&gt; &lt;property name="targetMethod" value="hello" /&gt; &lt;/bean&gt; &lt;!--配置触发器，指定何时触发 --&gt; &lt;bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="jobDetail" /&gt; &lt;!-- run every morning at 6 AM --&gt; &lt;property name="cronExpression" value="*/5 * * * * ?" /&gt; &lt;/bean&gt; &lt;!--配置定时任务调用哪一个触发器 --&gt; &lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt; &lt;property name="triggers"&gt; &lt;list&gt; &lt;ref bean="cronTrigger" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; cron表达式使用 123456789每隔5秒执行一次：*/5 * * * * ?每隔1分钟执行一次：0 */1 * * * ?每天23点执行一次：0 0 23 * * ?每天凌晨1点执行一次：0 0 1 * * ?每月1号凌晨1点执行一次：0 0 1 1 * ?每月最后一天23点执行一次：0 0 23 L * ?每周星期天凌晨1点实行一次：0 0 1 ? * L在26分、29分、33分执行一次：0 26,29,33 * * * ?每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ? 参考 https://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#scheduling-quartz 文件上传进度条 ajax异步提交表单$(&quot;#subBtn&quot;).on(&#39;click&#39;, function() { return false}是js对象的机制 &lt;button type=&quot;submit&quot; id=&#39;subBtn&#39; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;点击按钮直接提交是浏览器的机制 文件上传 表单直接提交action=&#39;${ctp}/member/upload&#39; method=&#39;post&#39; enctype=&quot;multipart/form-data&quot; 1234567891011&lt;form action='$&#123;ctp&#125;/member/upload' method='post' enctype="multipart/form-data"&gt; &lt;div class="form-group"&gt; &lt;input type="file" class="form-control" id="file" name='file'&gt; &lt;/div&gt; &lt;div class="progress"&gt; &lt;div class="progress-bar" role="progressbar" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100" style="width: 60%;"&gt; 60%&lt;/div&gt; &lt;/div&gt; &lt;button type="submit" id='subBtn' class="btn btn-default"&gt;Submit&lt;/button&gt;&lt;/form&gt; ajax提交type : &quot;post&quot;,contentType : false,processData : false 进度条:获取myXhr = $.ajaxSettings.xhr()对象并返回 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;form id='submitForm'&gt; &lt;div class="form-group"&gt; &lt;input type="file" class="form-control" id="file" name='file'&gt; &lt;/div&gt; &lt;div class="progress" style='display: none;'&gt; &lt;div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%;"&gt;0%&lt;/div&gt; &lt;/div&gt; &lt;button type="submit" id='subBtn' class="btn btn-default"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script type="text/javascript"&gt; $("#subBtn").on('click', function() &#123; var fd = new FormData($("#submitForm")[0]); $.ajax(&#123; url : "$&#123;ctp&#125;/member/upload", data : fd, type : "post", contentType : false, processData : false, //获取ajaxSettings中的xhr对象，为它的upload属性绑定progress事件的处理函数 xhr : function() &#123; myXhr = $.ajaxSettings.xhr() //检查upload属性是否存在 if (myXhr.upload) &#123; //绑定progress事件的回调函数 myXhr.upload.addEventListener('progress', progressHandlingFunction, false) &#125; //xhr对象返回给jQuery使用 return myXhr; &#125;, success : function(result) &#123; console.log("result==========&gt;", result) &#125;, error : function(e) &#123; console.log('e=========&gt;', e) &#125; &#125;) return false &#125;) var progressHandlingFunction = function(e) &#123; var curr = e.loaded var total = e.total process = curr / total * 100 console.log('上传进度============&gt;', process) $('.progress').attr('style', 'display:show;') $('.progress-bar').html(process + '%') $('.progress-bar').attr('style', 'width:' + process + '%;') &#125;&lt;/script&gt; 图片预览 123456789101112131415161718$("#ad_file_input").on('change', function(event) &#123; $(this).empty() $(this).parent('.form-group').next('.form-group').find('.imgdiv').empty() fileList = event.currentTarget.files log('fileList==============&gt;', fileList) var URL = window.URL || window.webkitURL var imgURL //遍历上传的文件进行显示 $.each(fileList, function (index, item) &#123; //创建一个临时的url地址 imgURL = URL.createObjectURL(item) log('this=========&gt;',this) log('item==========&gt;',item) $('#ad_file_input').parent(".form-group").next(".form-group").find(".imgdiv").append("&lt;img src='"+imgURL+"' style='width:200px;height:220px;'/&gt;").append('&lt;p&gt;'+item.name+'&lt;p&gt;') &#125;)&#125;)]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多表连接查询]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F29%2F%E5%A4%9A%E8%A1%A8%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[1、查询用户拥有的权限 尚筹网第16天_讨论权限与安全 子查询和连接查询2种，比较推荐连接查询，子查询比较影响性能，子查询看起来比较容易理解，而连接查询需要比较熟悉各个表之间的关系 123456789101112131415161718SELECT DISTINCT p.* FROM t_permission p LEFT JOIN t_role_permission trp ON trp.`permissionid`=p.`id` LEFT JOIN t_role tr ON tr.`id`=trp.`roleid` WHERE tr.id IN( SELECT t_r.id FROM t_role t_r LEFT JOIN t_user_role t_u_r ON t_u_r.`roleid`=t_r.`id` WHERE t_u_r.`userid`=31 );子查询不太推荐，比较影响性能推荐连接查询SELECT DISTINCT p.* FROM t_permission p LEFT JOIN t_role_permission trp ON trp.`permissionid`=p.`id` LEFT JOIN t_role tr ON tr.`id`=trp.`roleid` LEFT JOIN t_user_role tur ON tur.`roleid`=tr.`id` LEFT JOIN t_user tu ON tu.`id`=tur.`userid` WHERE tu.`id`=31;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HttpClient远程接口调用_实名认证]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F28%2FHttpClient%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8-%E5%AE%9E%E5%90%8D%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[1、HttpClient远程接口调用 1)用户注册 注册按钮button提交表单时，要return false form表单 12345&lt;!-- action="http://localhost:8082/scw-restapi/member/regist" --&gt;&lt;form class="form-signin" role="form" action="$&#123;ctp&#125;/member/regist" method="post" id="regForm"&gt;...&lt;/form&gt; js提交表单 1234567891011121314$("#submitBtn").click(function() &#123; var loginType = $("select.form-control").val(); log("注册类型==============&gt;", loginType) /* if (loginType == "管理") &#123; $("#regForm").submit(); &#125; else &#123; alert("此功能尚未开通"); &#125; */ $("#regForm").submit(); return false&#125;) 2)加载外部资源文件 app.properties 123restapi.server.ip=127.0.0.1restapi.server.port=8082restapi.server.apppath=scw-restapi 编辑springmvc.xml 123&lt;!-- 引入外部配置文件 --&gt;&lt;context:property-placeholder location="classpath:other/app.properties" /&gt; RestApiServerInfo.java 123456789101112131415161718@Controllerpublic class RestApiServerInfo &#123; // MemberService memberService; @Value("$&#123;restapi.server.ip&#125;") private String restapiserver; @Value("$&#123;restapi.server.port&#125;") private String restapiport; @Value("$&#123;restapi.server.apppath&#125;") private String appPath; public String getRestApiURL() &#123; System.out.println("http://" + restapiserver + ":" + restapiport); return "http://" + restapiserver + ":" + restapiport + "/" + appPath; &#125;&#125; 3)HTTPClient工具远程调用接口 导入依赖 123456&lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.3&lt;/version&gt;&lt;/dependency&gt; 发送post请求 1public static String httpPostRequest(String url, Map&lt;String, Object&gt; params) 工具类HttpClientUtil.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152package com.atguigu.project;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.URISyntaxException;import java.util.ArrayList;import java.util.Map;import org.apache.http.HttpEntity;import org.apache.http.NameValuePair;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.client.methods.HttpRequestBase;import org.apache.http.client.utils.URIBuilder;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;/** * @author Nan 2015-11 */public class HttpClientUtil &#123; private static PoolingHttpClientConnectionManager cm; private static String EMPTY_STR = ""; private static String UTF_8 = "UTF-8"; private static void init() &#123; if (cm == null) &#123; cm = new PoolingHttpClientConnectionManager(); cm.setMaxTotal(50);// 整个连接池最大连接数 cm.setDefaultMaxPerRoute(5);// 每路由最大连接数，默认值是2 &#125; &#125; /** * 通过连接池获取HttpClient * * @return */ private static CloseableHttpClient getHttpClient() &#123; init(); return HttpClients.custom().setConnectionManager(cm).build(); &#125; /** * @param url * @return */ public static String httpGetRequest(String url) &#123; HttpGet httpGet = new HttpGet(url); return getResult(httpGet); &#125; public static String httpGetRequest(String url, Map&lt;String, Object&gt; params) throws URISyntaxException &#123; URIBuilder ub = new URIBuilder(); ub.setPath(url); ArrayList&lt;NameValuePair&gt; pairs = covertParams2NVPS(params); ub.setParameters(pairs); HttpGet httpGet = new HttpGet(ub.build()); return getResult(httpGet); &#125; public static String httpGetRequest(String url, Map&lt;String, Object&gt; headers, Map&lt;String, Object&gt; params) throws URISyntaxException &#123; URIBuilder ub = new URIBuilder(); ub.setPath(url); ArrayList&lt;NameValuePair&gt; pairs = covertParams2NVPS(params); ub.setParameters(pairs); HttpGet httpGet = new HttpGet(ub.build()); for (Map.Entry&lt;String, Object&gt; param : headers.entrySet()) &#123; httpGet.addHeader(param.getKey(), String.valueOf(param.getValue())); &#125; return getResult(httpGet); &#125; public static String httpPostRequest(String url) &#123; HttpPost httpPost = new HttpPost(url); return getResult(httpPost); &#125; public static String httpPostRequest(String url, Map&lt;String, Object&gt; params) throws UnsupportedEncodingException &#123; HttpPost httpPost = new HttpPost(url); ArrayList&lt;NameValuePair&gt; pairs = covertParams2NVPS(params); httpPost.setEntity(new UrlEncodedFormEntity(pairs, UTF_8)); return getResult(httpPost); &#125; public static String httpPostRequest(String url, Map&lt;String, Object&gt; headers, Map&lt;String, Object&gt; params) throws UnsupportedEncodingException &#123; HttpPost httpPost = new HttpPost(url); for (Map.Entry&lt;String, Object&gt; param : headers.entrySet()) &#123; httpPost.addHeader(param.getKey(), String.valueOf(param.getValue())); &#125; ArrayList&lt;NameValuePair&gt; pairs = covertParams2NVPS(params); httpPost.setEntity(new UrlEncodedFormEntity(pairs, UTF_8)); return getResult(httpPost); &#125; private static ArrayList&lt;NameValuePair&gt; covertParams2NVPS(Map&lt;String, Object&gt; params) &#123; ArrayList&lt;NameValuePair&gt; pairs = new ArrayList&lt;NameValuePair&gt;(); for (Map.Entry&lt;String, Object&gt; param : params.entrySet()) &#123; pairs.add(new BasicNameValuePair(param.getKey(), String.valueOf(param.getValue()))); &#125; return pairs; &#125; /** * 处理Http请求 * * @param request * @return */ private static String getResult(HttpRequestBase request) &#123; // CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpClient httpClient = getHttpClient(); try &#123; CloseableHttpResponse response = httpClient.execute(request); // response.getStatusLine().getStatusCode(); HttpEntity entity = response.getEntity(); if (entity != null) &#123; // long len = entity.getContentLength();// -1 表示长度未知 String result = EntityUtils.toString(entity); response.close(); // httpClient.close(); return result; &#125; &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; &#125; return EMPTY_STR; &#125;&#125; 远程接口返回ScwReturn&lt;T&gt;封装对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.atguigu.scw.restapi.bean;import java.util.Map;public class ScwReturn&lt;T&gt; &#123; private int code;// 状态码 1：表示成功 0:表示失败 private String msg;// 要给的提示信息 private T content;// 响应的内容； private Map&lt;String, Object&gt; ext;// 额外的数据 public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public T getContent() &#123; return content; &#125; public void setContent(T content) &#123; this.content = content; &#125; public Map&lt;String, Object&gt; getExt() &#123; return ext; &#125; public void setExt(Map&lt;String, Object&gt; ext) &#123; this.ext = ext; &#125; // 两个快速的成功失败方法 public static &lt;T&gt; ScwReturn&lt;T&gt; success(String msg, T content, Map&lt;String, Object&gt; ext) &#123; ScwReturn&lt;T&gt; t = new ScwReturn&lt;T&gt;(); t.setCode(1); t.setMsg(msg); t.setContent(content); t.setExt(ext); return t; &#125; public static &lt;T&gt; ScwReturn&lt;T&gt; fail(String msg, T content, Map&lt;String, Object&gt; ext) &#123; ScwReturn&lt;T&gt; t = new ScwReturn&lt;T&gt;(); t.setCode(0); t.setMsg(msg); t.setContent(content); t.setExt(ext); return t; &#125;&#125; 注册调用远程接口 发送请求 1String response = HttpClientUtil.httpPostRequest(url, params); 远程接口返回的响应字符串转java对象 12readValue = new ObjectMapper().readValue(response.getBytes(), new TypeReference&lt;ScwReturn&lt;TMemeber&gt;&gt;() &#123; &#125;); 1234567891011121314151617181920212223242526272829303132333435363738394041@RequestMapping("/regist")public String regist(TMemeber memeber, Model model) throws Exception &#123; // 需要利用http工具去模拟发调用接口的请求 // http://localhost:8082/scw-restapi/member/regist // &lt;httpclient.version&gt;4.5.3&lt;/httpclient.version&gt; // httpclient使用java代码来模拟发送请求 // 能收到api调用后产生的json数据； // 1、可以将产生的json逆向成对象ScwReturn&lt;TMemeber&gt; // 2、可以直接将json写给页面 System.out.println("memeber===========&gt;" + memeber); // 注册成功以后可以来到一个页面； // 1、应该去发送请求来进行注册；java代码发请求 String url = serverInfo.getRestApiURL() + "/member/regist"; System.out.println("url===========&gt;" + url); // 2、构建请求参数 Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;(); params.put("loginacct", memeber.getLoginacct()); // 密码是业务逻辑加密的，我们不用管 params.put("userpswd", memeber.getUserpswd()); params.put("email", memeber.getEmail()); // 响应内容； String response = HttpClientUtil.httpPostRequest(url, params); // 封装响应为对象 ScwReturn&lt;TMemeber&gt; readValue = null; readValue = new ObjectMapper().readValue(response.getBytes(), new TypeReference&lt;ScwReturn&lt;TMemeber&gt;&gt;() &#123; &#125;); // 判断，注册成功！来到登陆页面 if (readValue.getCode() == 1) &#123; return "redirect:/login.jsp"; &#125; else &#123; // 注册失败！来到注册页面进行回显 model.addAttribute("msg", "用户名和邮箱已经被注册了！"); return "forward:/reg.jsp"; &#125;&#125; 远程接口注册方法 控制层 123456789101112131415161718192021222324252627/** * ScwReturn&lt;List&lt;TMemeber&gt;&gt;:泛型是content内容的对象的类型 * * @Description (TODO这里用一句话描述这个方法的作用) * @param memeber * @return */ @RequestMapping("/regist") public ScwReturn&lt;TMemeber&gt; regist(TMemeber memeber) &#123; // 创建一个空的对象 TMemeber regist = new TMemeber(); Map&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;(); try &#123; regist = memberService.regist(memeber); &#125; catch (Exception e) &#123; // 判断异常类型来放错误 // e.printStackTrace(); hashMap.put("error", "触犯唯一约束，请保证用户名和邮箱唯一"); &#125; regist.setUserpswd(""); if (regist.getId() != null) &#123; return ScwReturn.success("用户注册成功！", regist, null); &#125; else &#123; return ScwReturn.fail("用户注册失败!", null, hashMap); &#125; &#125; 业务层 带条件插入 1int i = memeberMapper.insertSelective(tMemeber); 12345678910111213141516171819202122@Override public TMemeber regist(TMemeber tMemeber) &#123; // TODO Auto-generated method stub String digest = MD5Util.digest(tMemeber.getUserpswd()); // 加密密码保存 tMemeber.setUserpswd(digest); // 初始化用户名和账号 tMemeber.setUsername(tMemeber.getLoginacct()); // 实名认证状态 0:未实名认证 1::实名认证 tMemeber.setAuthstatus("0"); // 真实姓名；实名认证是保存的 tMemeber.setRealname("未实名"); // 0：普通会员 1：月费会员 2：年费会员 3： tMemeber.setUsertype("0"); // 身份证号，账户类型；（实名认证是做的） // 账户类型：直接保存账户的全名 int i = memeberMapper.insertSelective(tMemeber); // 刚才就是按照这个对象给数据库插入值，希望获取到数据库分配的自增主键 return tMemeber; &#125; 2、实名认证文件上传 1)上传用户资质证件 导入依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt; 编辑springmvc.xml文件 1234&lt;!-- 1、文件上传需要一个文件上传解析器 --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="defaultEncoding" value="utf-8"&gt;&lt;/property&gt;&lt;/bean&gt; 前台ajax提交 带有文件表单，一次提交所有项 1var fd = new FormData($(&quot;#certForm&quot;)[0]) 带有文件表单,提交部分内容 123456//使用formData（js对象来包装form表单）var fd = new FormData();log($(&quot;#ad_name_input&quot;).val())log($(&quot;#ad_file_input&quot;)[0].files[0])fd.append(&quot;name&quot;, $(&quot;#ad_name_input&quot;).val());fd.append(&quot;ad&quot;, $(&quot;#ad_file_input&quot;)[0].files[0]) processData(默认: true) 默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 “application/x-www-form-urlencoded”。 contentType 不使用默认的内容类型；(默认: “application/x-www-form-urlencoded”) 发送信息至服务器时内容编码类型。 123456789101112131415161718//这是一个资质文件上传的页面//发送文件上传资质文件请求；var fd = new FormData($("#certForm")[0]);$.ajax(&#123; url:"http://localhost:8082/scw-restapi/auth/upload", data:fd, type:"post", contentType:false, dataType:"json", processData:false, success:function(result)&#123; //来到邮箱填写页面 location.href="$&#123;ctp&#125;/auth/apply-2.html" &#125;, error:function(e)&#123; layer.msg("上传失败:"+e); &#125;&#125;); 控制层 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//文件上传 private String uploadfile(String webPath,MultipartFile file,HttpSession session)&#123; ServletContext context = session.getServletContext(); String realPath = context.getRealPath(webPath); String name = UUID.randomUUID().toString().replace("-", "").substring(0, 10) +"_file_"+ file.getOriginalFilename(); try &#123; //webPath不存在的情况下必须创建 File file2 = new File(realPath); if(!file2.exists())&#123; //创建目录 file2.mkdirs(); &#125; file.transferTo(new File(realPath+"/"+name)); //返回这个图片在服务器下的路径 return webPath+"/"+name; &#125;catch (Exception e) &#123; return null; &#125; &#125; @RequestMapping("/upload") public ScwReturn&lt;Object&gt; upload(HttpSession session, @RequestParam("file")MultipartFile[] file, @RequestParam("certid")Integer[] certid,@RequestParam("memberid")Integer memberid)&#123; try &#123; System.out.println("资质的id"+certid); List&lt;TMemberCert&gt; certsList= new ArrayList&lt;TMemberCert&gt;(); for (int i=0;i&lt;certid.length;i++) &#123; TMemberCert cert = new TMemberCert(); MultipartFile multipartFile = file[i]; String uploadfile = uploadfile("/certsimg", multipartFile, session); cert.setCertid(certid[i]); cert.setMemberid(memberid); cert.setIconpath(uploadfile); certsList.add(cert); &#125; //调用业务逻辑进行保存;/删除原有资质，保存新的资质 certService.insertCerts(certsList); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block System.out.println(e); return ScwReturn.fail("资质保存失败！", null, null); &#125; return ScwReturn.success("保存成功！", null, null); &#125; 2)批量插入用户资质证件描述信息 业务层 CertService.java 1public void insertCerts(List&lt;TMemberCert&gt; certsList); CertServiceImpl.java 1234567891011@Override public void insertCerts(List&lt;TMemberCert&gt; certsList) &#123; // TODO Auto-generated method stub TMemberCertExample example = new TMemberCertExample(); Criteria criteria = example.createCriteria(); criteria.andMemberidEqualTo(certsList.get(0).getMemberid()); //先删除 memberCertMapper.deleteByExample(example); //后保存 certMapper.insertBatch(certsList); &#125; dao层 TCertMapper.java 1void insertBatch(@Param("certs")List&lt;TMemberCert&gt; certsList); TCertMapper.xml 12345678&lt;!-- void insertBatch(@Param("certs")List&lt;TMemberCert&gt; certsList); --&gt;&lt;insert id="insertBatch"&gt; INSERT INTO t_member_cert(memberid,certid,iconpath) VALUES&lt;foreach collection="certs" item="c" separator=","&gt; (#&#123;c.memberid&#125;,#&#123;c.certid&#125;,#&#123;c.iconpath&#125;)&lt;/foreach&gt;&lt;/insert&gt;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>HTTPClient</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术分享]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F26%2F%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[1、快速深入地学习一个新技术、知识点步骤 1）我们有一个需求 项目开发时，我们需要解决某个问题—页面局部刷新问题 跳槽，学习新技术 2）先看看使用现有的技术能否解决这个问题 可以解决，使用传统的方法iframe 发现使用传统的方法可以解决，但是不够好，使用新技术ajax 3）学习新技术或者知识点 原理 基本语法 4）快速入门案例 特点是简单 了解新技术或者知识点的基本使用，这里不需要涉及技术细节 5）讨论这个新技术或者知识点的细节 怎么使用更规范 使用该技术有没有什么陷阱 需要使用时，注意些什么 2、学习方法的介绍 1）高效而愉快地学习 2）先建立一个整体框架，然后细节 3）在实际工作中，要培养用到什么，能够快速学习什么的能力 4）先know how，再know why 5）软件编程是一门’做中学‘的学科，不是会了再做，而是做了才会 6）适当的囫囵吞枣 7）学习软件编程是在在琢磨别人怎么做，而不是我认为应该怎么做的过程 123for i:=0;i&lt;10;i++ &#123; fmt.Println(&quot;hello,world&quot;)&#125;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[es6异步]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F25%2Fes6%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[1、promise-解决异步操作 同步——串行 简单、方便 异步——并发 性能高、体验好 jQuery异步问题：回到地狱 123456789101112131415161718192021222324252627282930313233$.ajax(&#123; url: '/banner_data', success(banners)&#123; $.ajax(&#123; url: '/user_data', success(user)&#123; $.ajax(&#123; url: '/item_data', success(items)&#123; $.ajax(&#123; url: '/news_data', success(news)&#123; &#125;, error()&#123; alert('数据获取失败'); &#125; &#125;) &#125;, error()&#123; alert('数据获取失败'); &#125; &#125;) &#125;, error()&#123; alert('数据获取失败'); &#125; &#125;) &#125;, error()&#123; alert('数据获取失败'); &#125;&#125;) 使用Promise Promise.all() 与：所有的都成功 Promise.race() 或：只要有一个完成 123456789//PromisePromise.all([ $.ajax('/banner_data'), $.ajax('/item_data'), $.ajax('/user_data'), $.ajax('/news_data'),]).then(arr=&gt;&#123; let [banners, items, user, news]=arr;&#125;, ()=&gt;&#123;&#125;) 1.txt 1&#123;&quot;a&quot;: 3, &quot;b&quot;: 5&#125; 2.txt 1[12,5,8,3] 3.txt 1&#123;&quot;name&quot;: &quot;blue&quot;, &quot;age&quot;: 18&#125; promise怎么用.html 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; let p = new Promise((resolve, reject) =&gt; &#123; //resolve 解决-&gt;成功 //reject 拒绝-&gt;失败 $.ajax(&#123; url: '1.txt', dataType: 'json', success(json) &#123; resolve(json) &#125;, error(err) &#123; reject(err) &#125; &#125;) &#125;) debugger p.then(json =&gt; &#123; alert('成功') console.log(json) &#125;, err =&gt; &#123; alert('失败') &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; promise怎么用2.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; let p = new Promise((resolve, reject) =&gt; &#123; //resolve 解决-&gt;成功 //reject 拒绝-&gt;失败 $.ajax(&#123; url: '1.txt', dataType: 'json', success(json) &#123; resolve(json) &#125;, error(err) &#123; reject(err) &#125; &#125;) &#125;) let p2 = new Promise((resolve, reject) =&gt; &#123; //resolve 解决-&gt;成功 //reject 拒绝-&gt;失败 $.ajax(&#123; url: '2.txt', dataType: 'json', success(json) &#123; resolve(json) &#125;, error(err) &#123; reject(err) &#125; &#125;); &#125;); let p3 = new Promise((resolve, reject) =&gt; &#123; //resolve 解决-&gt;成功 //reject 拒绝-&gt;失败 $.ajax(&#123; url: '3.txt', dataType: 'json', success(json) &#123; resolve(json) &#125;, error(err) &#123; reject(err) &#125; &#125;) &#125;) Promise.all([p, p2, p3]).then(arr =&gt; &#123; let [j1, a, j2] = arr; alert('成功') console.log(j1, a, j2) &#125;, err =&gt; &#123; alert('失败') &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; promise怎么用3.html 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; $.ajax(&#123; url: '1.txt', dataType: 'json' &#125;).then(json=&gt;&#123; alert('成了'); &#125;, err=&gt;&#123; alert('错了'); &#125;); debugger /* Promise.all([p, p2, p3]).then(arr=&gt;&#123; let [j1, a, j2]=arr; alert('成功'); console.log(j1, a, j2); &#125;, err=&gt;&#123; alert('失败'); &#125;); */ &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; promise怎么用4.html 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; Promise.all([ $.ajax(&#123;url: '1.txt', dataType: 'json'&#125;), $.ajax(&#123;url: '2.txt', dataType: 'json'&#125;), $.ajax(&#123;url: '3.txt', dataType: 'json'&#125;), ]).then(arr=&gt;&#123; let [j1, a, j2]=arr; console.log(j1, a, j2); &#125;, err=&gt;&#123; alert('失败'); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 结论 Proimse有用——解除异步操作 Promise有局限——带逻辑的异步操作麻烦 2、generator-生成器（过渡） 可以暂停 generator函数.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function* show() &#123; alert('aaa') yield alert('bbb') &#125; let gen = show() gen.next() //aaa setTimeout(function() &#123; gen.next() //bbb &#125;, 5000) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; generator函数3.html 传参 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function *show()&#123; alert('aaa'); let a=yield; alert('bbb'+a); &#125; let gen=show(); gen.next(); gen.next(12); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; generator函数4.html 返回值 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function* show() &#123; alert('aaa') yield 55 alert('bbb') return 89 &#125; let gen = show() let res1 = gen.next() // debugger console.log(res1) //&#123;value: 55, done: false&#125; let res2 = gen.next() console.log(res2) //&#123;value: 89, done: true&#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 3、async/await（推荐，es7） 可以暂停且可以处理带业务逻辑、异常 async和await.html 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function sleep(sec) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; resolve() &#125;, sec * 1000) &#125;) &#125; async function show() &#123; alert('a') await sleep(1) alert('b') await sleep(2) alert('c') &#125; show() &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 处理带业务逻辑 async和await2.html 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; (async () =&gt; &#123; let data1 = await $.ajax(&#123; url: '1.txt', dataType: 'json' &#125;) console.log('data1=========&gt;', data1) if (data1.a + data1.b &lt; 10) &#123; let data2 = await $.ajax(&#123; url: '2.txt', dataType: 'json' &#125;) alert(data2[0]) &#125; else &#123; let data3 = await $.ajax(&#123; url: '3.txt', dataType: 'json' &#125;) alert(data3.name) &#125; &#125;)() &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 处理异常 async和await3.html 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; async function show() &#123; try &#123; let data1 = await $.ajax(&#123; url: '1.txt', dataType: 'json' &#125;) let data2 = await $.ajax(&#123; url: '33.txt', dataType: 'json' &#125;) let data3 = await $.ajax(&#123; url: '3.txt', dataType: 'json' &#125;) console.log(data1, data2, data3) &#125; catch (e) &#123; alert('有问题') throw new Error('我错了....') &#125; &#125; show() &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F23%2Fhexo%2F</url>
    <content type="text"><![CDATA[安装Node.jshttps://nodejs.org/en/ 安装Githttps://git-scm.com/ 安装Hexo12//全局安装$ npm install -g hexo-cli 存放位置 1C:\Users\libingshen\AppData\Roaming\npm\node_modules 验证安装是否成功 1234567891011121314151617181920212223242526C:\Users\libingshen&gt;node --versionv10.15.0C:\Users\libingshen&gt;npm --version6.4.1C:\Users\libingshen&gt;git --versiongit version 2.16.2.windows.1C:\Users\libingshen&gt;hexo --versionhexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64http_parser: 2.8.0node: 10.15.0v8: 6.8.275.32-node.45uv: 1.23.2zlib: 1.2.11ares: 1.15.0modules: 64nghttp2: 1.34.0napi: 3openssl: 1.1.0jicu: 62.1unicode: 11.0cldr: 33.1tz: 2018e Hexo博客初始化1234567891011$ cd D:\mytest\myhexo$ hexo init//安装依赖$ npm install//或者hexo generate生成静态页$ hexo g //或者hexo server，启动服务器，可以在http://localhost:4000/ 查看$ hexo s Hexo博客部署到GitHub本地客户端与GitHub建立授权连接生成公私钥1ssh-keygen -t rsa -C &quot;782125244@qq.com&quot; 公私钥存放位置 1C:\Users\libingshen\.ssh 将公钥内容上传到GitHub GitHub创建仓库作为hexo博客的站点hexo配置GitHub连接安装 hexo-deployer-git 1$ npm install hexo-deployer-git --save 修改配置D:\mytest\myhexo_config.yml 12345678910111213141516#配置GitHub博客站址访问路径# URL这里要是没有配置，GitHub样式显示不出来## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://shenlibing.github.io/myhexo/root: /myhexopermalink: :year/:month/:day/:title/permalink_defaults:#博客推送到GitHub地址配置# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/shenlibing/myhexo.git branch: [master] 配置GitHub Pages![](配置GitHub page.png) 备份博客源文件hexo部署到GitHub只上传.deploy_git文件夹的内容，并不会上传_posts文件夹下的博客源文件 123D:\mytest\myhexo\.deploy_gitD:\mytest\myhexo\source\_posts 解决： 将_posts文件夹作为git仓库，上传到GitHub，使得其作为另一个分支 创建并切换到新分支 123libingshen@DESKTOP-7V287SK MINGW64 /d/mytest/myhexo/source/_posts (master)$ git checkout -b srcSwitched to a new branch &apos;src&apos; 将新分支推送到GitHub 123git add .git commit -m &apos;add_v1:-新增hello-world笔记初始化&apos;git push origin src 将博客源文件分支设为推送的默认分支，git push推送直接推送到src分支 补充： 删除本地分支 1$ git branch -d src 删除远程分支 1$ git push origin -d src 切换分支 1$ git checkout master 查看提交日志 1$ git log --oneline 拓展更换hexo主题下载 https://github.com/theme-next/hexo-theme-next 解压放到D:\mytest\myhexo\themes 修改D:\mytest\myhexo\_config.yml配置文件 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-next-master 修改站点语言编辑D:\mytest\myhexo\_config.yml文件 12345678# Sitetitle: 小兵兵subtitle:description:keywords:author: shenlibinglanguage: zh-CNtimezone: 开启搜索、字数统计和阅读时长统计安装依赖hexo-symbols-count-time、hexo-generator-searchdb，安装依赖不成功时先删除D:\mytest\myhexo\node_modules文件夹，重新安装依赖 1234npm install hexo-symbols-count-time --savenpm install hexo-generator-searchdb --save 配置主题样式文件 进入D:\mytest\myhexo\themes\hexo-theme-next-master\文件夹，编辑_config.yml文件 123456789101112# Local search# Dependencies: https://github.com/theme-next/hexo-generator-searchdblocal_search: enable: true# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 4 wpm: 275 配置站点文件 编辑D:\mytest\myhexo\_config.yml文件 12345678910111213#阅读时长和本文字数symbols_count_time: symbols: true time: true total_symbols: true total_time: true#搜索功能search: path: search.xml field: post format: html limit: 10000 添加分类和标签123$ hexo new page categories$ hexo new page tags 编辑D:\mytest\myhexo\source\categories\index.md 123456---title: categoriesdate: 2019-01-22 16:37:58type: &quot;categories&quot; #这部分是新添加的--- 编辑D:\mytest\myhexo\source\tags\index.md 123456---title: tagsdate: 2019-01-22 16:38:40type: &quot;tags&quot; #新添加的内容--- 修改菜单，添加categories和tags到menu中 123456789menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 新增文章，添加categories、tags 123456789101112---title: hexo博客搭建date: 2019-01-23 09:07:30categories: 日常记录tags: - hexo - git - github - node - markdown--- 更换页面菜单布局位置12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 配置文章浏览量注册 https://leancloud.cn/ 创建应用 创建Class 配置web安全域名 获取app_id、app_key 编辑D:\mytest\myhexo\themes\hexo-theme-next-master\_config.yml配置文件，填app_id、 app_key;security设置为false 123456789101112# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: BedsOkBLOBR4nM4W52xTcBhb-gzGzoHsz #&lt;app_id&gt; app_key: EEaRfb6dCMaS38laDCkSYhM9 #&lt;app_key&gt; # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don&apos;t care about security in leancloud counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set `security` to `false`. security: false betterPerformance: false 插入本地图片安装依赖 1npm install hexo-asset-image --save 编辑D:\mytest\myhexo\_config.yml配置文件 1post_asset_folder: true 命令hexo new post test来生成博文时，/source/_post文件夹中除了test.md外，还有一个同名test文件夹 设置动态背景进入D:\mytest\myhexo\themes\hexo-theme-next-master\layout\文件夹，编辑_layout.swig文件，在&lt;/body&gt;之前添加 1&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt; 添加Fork me on GitHub进入D:\mytest\myhexo\themes\hexo-theme-next-master\layout\文件夹，编辑_layout.swig文件，在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面添加选择的图标样式代码 1&lt;a href=&quot;https://github.com/shenlibing/&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 添加友情链接方式一进入D:\mytest\myhexo\themes\hexo-theme-next-master\layout\_partials文件夹，在footer.swig文件末尾追加 123456&lt;div&gt;友情链接： &lt;a class=&quot;theme-link&quot; href=&quot;http://collect.w3ctrain.com/&quot;&gt; 前端收藏夹 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;a class=&quot;theme-link&quot; href=&quot;http://www.alloyteam.com/nav/&quot;&gt; Web前端导航 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;a class=&quot;theme-link&quot; href=&quot;http://www.runoob.com/&quot;&gt; 菜鸟教程 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;a class=&quot;theme-link&quot; href=&quot;https://mccxj.github.io/&quot;&gt; 小毛的胡思乱想 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/div&gt; 方式二进入D:\mytest\myhexo\themes\hexo-theme-next-master文件夹，编辑_config.yml文件 1234567891011# Blog rollslinks_icon: linklinks_title: Linkslinks_layout: block#links_layout: inline#links: #Title: http://example.comlinks: 美团技术团队: https://tech.meituan.com/ 百度FEX: http://fex.baidu.com/ 淘宝FED: http://taobaofed.org/ 设置阅读全文进入D:\mytest\myhexo\themes\hexo-theme-next-master文件夹，编辑_config.yml文件 12345# Automatically Excerpt. Not recommend.# Use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150 参考： 【持续更新】Github Pages + Hexo 博客搭建，Next主题个性化修改 Hexo+NexT 打造一个炫酷博客 hexo史上最全搭建教程]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化点击事件绑定]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F15%2F%E4%BC%98%E5%8C%96%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[1、优化点击事件绑定 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button data-action="id1"&gt;新增按钮1&lt;/button&gt;&lt;button data-action="id2"&gt;删除按钮2&lt;/button&gt;&lt;button data-action="id3"&gt;按钮3&lt;/button&gt;&lt;button data-action="id4"&gt;按钮4&lt;/button&gt;&lt;script&gt; var log = function () &#123; console.log.apply(console, arguments) &#125; var actionList = &#123; 'id1': function () &#123; alert('id1=============&gt;') &#125;, 'id2': function () &#123; alert('id2===============&gt;') &#125;, 'id3': function () &#123; alert('id3===============&gt;') &#125;, 'id4': function () &#123; alert('id4===============&gt;') &#125; &#125; let $body = $('body') $body.on('click', '[data-action]', function () &#123; //jQuery获取html标签自定义属性值或data值 let action_name = $(this).data('action') let action = actionList[action_name] // log(action) // log($.isFunction(action)) if ($.isFunction(action)) &#123; action() &#125; &#125;) //页面需要新增一个按钮，做扩展 $body.append('&lt;button data-action="id5"&gt;按钮5&lt;/button&gt;') $.extend(actionList, &#123; 'id5': function () &#123; alert('id5============&gt;') &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考 https://github.com/cssmagic/blog/issues/48]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户分配角色_角色维护权限树]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F14%2F%E7%94%A8%E6%88%B7%E5%88%86%E9%85%8D%E8%A7%92%E8%89%B2_%E8%A7%92%E8%89%B2%E7%BB%B4%E6%8A%A4%E6%9D%83%E9%99%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1、用户分配角色 效果图： 实现思路： 1）先静态实现页面 2）从数据库查询用户未分配角色和已分配角色，前端初始化该列表 3）添加、移除用户拥有的角色 前端： 1)左移、右移：append和appendTo的使用 12$(&quot;.unroles :selected&quot;).appendTo(&quot;.roles_select&quot;) 2）遍历选中的角色 123456//遍历选中的元素,拼接用户角色id$(&apos;.unroles :selected&apos;).each(function() &#123; log(this) rids += $(this).val() + &apos;,&apos;&#125;) 3)ajax发送异步请求（参数拼接：用户id,角色rids） 1234567uid = &apos;$&#123;param.uid&#125;&apos;url = &apos;$&#123;ctp&#125;/permission/user/assignrole?opt=remove&amp;uid=&apos; + uid + &apos;&amp;rids=&apos; + rids + &apos;&apos;//发送请求移除$.get(url, fnf) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;div class="panel panel-default"&gt; &lt;div class="panel-body"&gt; &lt;form role="form" class="form-inline"&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputPassword1"&gt;未分配角色列表&lt;/label&gt;&lt;br&gt; &lt;select class="form-control unroles" multiple size="10" style="width: 100px; overflow-y: auto;"&gt; &lt;c:forEach items="$&#123;list_user_unrole&#125;" var="user_unrole"&gt; &lt;option value="$&#123;user_unrole.id&#125;"&gt;$&#123;user_unrole.name&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;ul&gt; &lt;li class="btn btn-default glyphicon glyphicon-chevron-right"&gt;&lt;/li&gt; &lt;br&gt; &lt;li class="btn btn-default glyphicon glyphicon-chevron-left" style="margin-top: 20px;"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="form-group" style="margin-left: 40px;"&gt; &lt;label for="exampleInputPassword1"&gt;已分配角色列表&lt;/label&gt;&lt;br&gt; &lt;select class="form-control roles_select" multiple size="10" style="width: 100px; overflow-y: auto;"&gt; &lt;c:forEach items="$&#123;list_user_role&#125;" var="user_role"&gt; &lt;option value="$&#123;user_role.id&#125;"&gt;$&#123;user_role.name&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;script type="text/javascript"&gt; $(function() &#123; $(".list-group-item").click(function() &#123; if ($(this).find("ul")) &#123; $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) &#123; $("ul", this).hide("fast"); &#125; else &#123; $("ul", this).show("fast"); &#125; &#125; &#125;); &#125;); //页面加载完成执行 $(function() &#123; addUserRoleEvent() removeUserRoleEvent() &#125;) //用户添加角色事件 var addUserRoleEvent = function() &#123; $('.glyphicon-chevron-right').click( function() &#123; log('向右移动=============&gt;') var uid = '' var rids = '' //遍历选中的元素,拼接用户角色id $('.unroles :selected').each(function() &#123; log(this) rids += $(this).val() + ',' &#125;) rids = rids.substring(0, rids.length - 1) log('用户角色ids==========&gt;', rids) uid = '$&#123;param.uid&#125;' url = '$&#123;ctp&#125;/permission/user/assignrole?opt=add&amp;uid=' + uid + '&amp;rids=' + rids + '' //选中的得进行处理添加到用户角色表中 //发送请求给当前用户添加这几个角色，必须带上权限id的拼串和userid $.get(url, fns) &#125;) &#125; //用户删除角色事件 var removeUserRoleEvent = function() &#123; $('.glyphicon-chevron-left') .click( function() &#123; log('向左移动=============&gt;') var rids = '' $('.roles_select :selected').each(function() &#123; rids += $(this).val() + ',' &#125;) rids = rids.substring(0, rids.length - 1) log('用户角色ids==========&gt;', rids) uid = '$&#123;param.uid&#125;' url = '$&#123;ctp&#125;/permission/user/assignrole?opt=remove&amp;uid=' + uid + '&amp;rids=' + rids + '' //发送请求移除 $.get(url, fnf) &#125;) &#125; //异步请求成功的回调函数 var fns = function(data) &#123; log('异步请求成功的回调函数===============&gt;') log('data===========&gt;', data) //$('.roles_select').append($('.unroles :selected')) $(".unroles :selected").appendTo(".roles_select") &#125; //异步请求失败的回调函数 var fnf = function(data) &#123; log('异步请求失败的回调函数===============&gt;') log('data===========&gt;', data) $('.roles_select :selected').appendTo('.unroles') &#125;&lt;/script&gt; 控制层: 1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 添加移除用户角色 @RequestMapping("/assignrole") @ResponseBody public String userRole(@RequestParam("uid") Integer uid, @RequestParam("rids") String rids, @RequestParam("opt") String opt) &#123; System.out.println("添加移除用户角色==================&gt;"); System.out.println("用户id-----角色ids------类型：添加、移除"); System.out.println(uid); System.out.println(rids); System.out.println(opt); if ("add".equals(opt)) &#123; // 为某个用户添加角色 int i = userRoleService.add(uid, rids); &#125; else if ("remove".equals(opt)) &#123; // 为某个用户删除角色 int i = userRoleService.remove(uid, rids); &#125; return "success"; &#125; @RequestMapping("/toAssignRolePage") public String toAssignRolePage(@RequestParam(value = "uid") Integer uid, Model model) &#123; System.out.println("UserController.toAssignRolePage去分配角色页面=============&gt;"); // 1、查出所有角色 List&lt;TRole&gt; list_role = roleService.getAllRole(); System.out.println("所有角色===========&gt;"); System.out.println(list_role); // 2、查出当前用户拥有的角色 List&lt;TRole&gt; list_user_role = roleService.getUserRole(uid); System.out.println("当前用户的角色==========&gt;"); System.out.println(list_user_role); HashMap&lt;Integer, TRole&gt; map_user_role = new HashMap&lt;&gt;(); for (TRole tRole : list_user_role) &#123; map_user_role.put(tRole.getId(), tRole); &#125; // 3、用户未分配的角色 ArrayList&lt;TRole&gt; list_user_unrole = new ArrayList&lt;&gt;(); for (TRole tRole : list_role) &#123; if (!map_user_role.containsKey(tRole.getId())) &#123; list_user_unrole.add(tRole); &#125; &#125; System.out.println("用户未分配的角色=============&gt;"); System.out.println(list_user_unrole); model.addAttribute("list_user_role", list_user_role); model.addAttribute("list_user_unrole", list_user_unrole); // model.addAttribute("uid", uid); return "manager/permission/assignRole"; &#125; sql: 1)用户表、用户_角色表、角色表3个表多表查询 12345678910111213141516171819&lt;resultMap id="BaseResultMap" type="com.atguigu.scw.manager.bean.TRole"&gt; &lt;id column="id" jdbcType="INTEGER" property="id" /&gt; &lt;result column="name" jdbcType="VARCHAR" property="name" /&gt;&lt;/resultMap&gt;&lt;!-- List&lt;TRole&gt; getUserRole(Integer uid); --&gt;&lt;select id="getUserRole" resultMap="BaseResultMap"&gt; SELECT a.* FROM t_role a LEFT JOIN t_user_role b ON a.`id` = b.`roleid` LEFT JOIN t_user c ON b.`userid` = c.`id` WHERE c.`id` = #&#123;uid&#125;&lt;/select&gt; 2、角色维护权限树 效果图： 实现思路： 1）zTree展示权限树，初始化含有复选框的权限树，异步请求控制层（参数：角色rid）查询出角色拥有的权限 2）点击分配权限携带角色rid和权限permission_ids到控制层，先删除角色所拥有的权限，再更加permission_ids更新角色拥有的权限，同步到前端 3）bootstrap模态框–分配权限按钮绑定参数 前端： 1）zTree权限树复选框初始化的时候刚开始使用2次异步请求（一次请求所有权限，一次请求角色拥有的权限），展示数据有点混乱，后来改为一次异步请求同时查询出（所有权限、角色拥有的权限）。 2）bootstrap自定义图标显示不出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201&lt;!-- Modal模态框 --&gt;&lt;div class="modal fade" id="permissModel" tabindex="-1" role="dialog" aria-labelledby="myModalLabel"&gt; &lt;div class="modal-dialog" role="document"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"&gt; &lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;h4 class="modal-title" id="myModalLabel"&gt;Modal title&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;!--展示权限树 --&gt; &lt;ul id="permissionTree" class="ztree"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;关闭&lt;/button&gt; &lt;button type="button" class="btn btn-primary" id='addPermissionBtn'&gt;分配权限&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; $(function() &#123; $(".list-group-item").click(function() &#123; if ($(this).find("ul")) &#123; $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) &#123; $("ul", this).hide("fast"); &#125; else &#123; $("ul", this).show("fast"); &#125; &#125; &#125;); &#125;); /* $("tbody .btn-success").click(function() &#123; window.location.href = "assignPermission.html"; &#125;); */ var zTree //设置ajax同步 //$.ajaxSettings.async = false var assignPermissionEvent = function() &#123; $(".assignPermissionModelBtn").click(function() &#123; log('assignPermissionEvent==============&gt;') //获取当前角色id log('当前角色id==========&gt;', $(this).attr('rid')) var rid = $(this).attr('rid') loadModalAndTree(rid) &#125;) &#125; var loadModalAndTree = function(rid) &#123; //模态框设置 var options = &#123; backdrop : 'static', show : true &#125; //手动打开模态框 $('#permissModel').modal(options) //从数据库查出的所有权限节点数据 //发送ajax请求获取到所有权限的json数据 var url = '$&#123;ctp&#125;/permission/role/json/' + rid $.getJSON(url, fns) //将角色id保存到模态框的哪个属性中； //打开模态框将角色id传递给model里面的权限分配按钮 log('角色id===========&gt;', rid) $('#addPermissionBtn').attr("rid", rid) &#125; //成功回调函数，刷新权限树 var fns = function(data) &#123; log('成功返回数据', data) log('event==========&gt;', event) var ids = [] $.each(data.listCurrentPermission, function() &#123; ids.push(this.id) &#125;) log('ids===========&gt;', ids) //遍历每一条权限 $.each(data.listPermission, function() &#123; //给每一个节点修改或者添加一些属性 if (this.pid == 0) &#123; this.open = true &#125; if (ids.includes(this.id)) &#123; this.checked = true &#125; &#125;) var setting = &#123; data : &#123; simpleData : &#123; enable : true, idKey : "id", pIdKey : "pid", &#125;, key : &#123; url : "haha" &#125; &#125;, /* view : &#123; addDiyDom : showIcon &#125;, */ check : &#123; enable : true &#125; &#125; zTree = $.fn.zTree.init($("#permissionTree"), setting, data.listPermission) log('zTree赋值完成==========&gt;', zTree) &#125; //用于在节点上固定显示用户自定义控件 //?图标无法正常显示可能是字体样式没有引入进来 var showIcon = function(treeId, treeNode) &#123; log('自定义显示图标==============&gt;') log('treeId===============&gt;', treeId) log('treeNode===============&gt;', treeNode) //#permissionTree_10_ico $("#" + treeNode.tId + "_ico").removeClass() .addClass(treeNode.icon) &#125; //默认勾选当前角色的权限 var checkcurPermisson = function(rid) &#123; var url = '$&#123;ctp&#125;/permission/role/curPermission/' + rid $.getJSON(url, fns2) &#125; //获取当前角色权限成功回调函数 var fns2 = function(data) &#123; log('fns2===============&gt;') log('fns2_data================', data) //遍历当前角色拥有的权限 $.each(data, function() &#123; //$(this).attr('id') var node = zTree.getNodesByParam('id', this.id, null) log('使用zTree===========&gt;', zTree) log('当前角色拥有的权限=============&gt;', node) zTree.checkNode(node, true, false) log('是否选中=========&gt;', node.checked) node.nocheck = true //表示显示checkbox &#125;) &#125; //更新权限树 var updateTree = function() &#123; log('更新权限树===========&gt;') var rid = $('#addPermissionBtn').attr("rid") log('角色rid==========&gt;', rid) var permission_ids = '' //1、获取当前我们已经选中的权限 var nodes = zTree.getCheckedNodes(true) log('nodes=============&gt;', nodes) $.each(nodes, function() &#123; permission_ids += this.id + ',' &#125;) var url = '$&#123;ctp&#125;/permission/role/update?rid=' + rid + '&amp;permission_ids=' + permission_ids $.get(url, updateTreeFn) &#125; //更新权限树回调函数 var updateTreeFn = function(data) &#123; alert(data) log("权限分配成功===========&gt;"); $('#permissModel').modal("hide"); &#125; var addPermissionBtnEvent = function() &#123; $('#addPermissionBtn').click(function() &#123; log('点击分配权限按钮=============&gt;') updateTree() &#125;) &#125; var __main = function() &#123; assignPermissionEvent() addPermissionBtnEvent() &#125; $(function() &#123; __main() &#125;)&lt;/script&gt; 控制层： 123456789101112131415161718192021222324252627282930313233343536//分配权限@RequestMapping("/update") @ResponseBody public String updateRolePermission(@RequestParam("rid") Integer rid, @RequestParam("permission_ids") String permission_ids) &#123; System.out.println("更新权限==========&gt;"); System.out.println(rid); System.out.println(permission_ids); // 先删除该角色所有权限，在为该用户分配权限 boolean flag = rolePermissionService.updatePermission(rid, permission_ids); return flag ? "success" : "fail"; &#125; @RequestMapping("/curPermission/&#123;id&#125;") @ResponseBody public List&lt;TPermission&gt; getCurrentPermission(@PathVariable("id") Integer rid) &#123; System.out.println("当前角色拥有的权限==============&gt;"); List&lt;TPermission&gt; listPermission = permissionService.getPermissionsById(rid); System.out.println(listPermission); return listPermission; &#125;//查出角色拥有的权限、所有权限 @RequestMapping("/json/&#123;id&#125;") @ResponseBody public HashMap&lt;String, List&lt;TPermission&gt;&gt; getAllPermission(@PathVariable("id") Integer rid) &#123; List&lt;TPermission&gt; listPermission = permissionService.getPermissions(); List&lt;TPermission&gt; listCurrentPermission = permissionService.getPermissionsById(rid); HashMap&lt;String, List&lt;TPermission&gt;&gt; map = new HashMap&lt;&gt;(); map.put("listPermission", listPermission); map.put("listCurrentPermission", listCurrentPermission); return map; &#125; 业务层： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 更新权限树 @Override public boolean updatePermission(Integer rid, String permission_ids) &#123; // 删除角色权限 TRolePermissionExample tRolePermissionExample = new TRolePermissionExample(); Criteria criteria = tRolePermissionExample.createCriteria(); criteria.andRoleidEqualTo(rid); int count = mapper.deleteByExample(tRolePermissionExample); // 更新权限 if (permission_ids.contains(",")) &#123; String[] split = permission_ids.split(","); for (String permission_id : split) &#123; int i = Integer.parseInt(permission_id); TRolePermission rolePermission = new TRolePermission(); // 设置权限id rolePermission.setPermissionid(i); // 设置角色id rolePermission.setRoleid(rid); // 保存角色权限关系 mapper.insertSelective(rolePermission); &#125; &#125; else &#123; int i = Integer.parseInt(permission_ids); TRolePermission rolePermission = new TRolePermission(); // 设置权限id rolePermission.setPermissionid(i); // 设置角色id rolePermission.setRoleid(rid); // 保存角色权限关系 mapper.insertSelective(rolePermission); &#125; return true; &#125; // 为角色分配权限，查询所有权限 @Override public List&lt;TPermission&gt; getPermissions() &#123; List&lt;TPermission&gt; list_permission = mapper.selectByExample(null); return list_permission; &#125; @Override public List&lt;TPermission&gt; getPermissionsById(Integer rid) &#123; List&lt;TPermission&gt; list_permission = mapper.getRolePermission(rid); return list_permission; &#125;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>ztree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易邮箱服务器发送电子邮件_搭建James邮件服务器发送电子邮件]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F13%2F%E7%BD%91%E6%98%93%E9%82%AE%E7%AE%B1%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6_%E6%90%AD%E5%BB%BAJames%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1、网易邮箱发送电子邮件 为了安全，网易邮箱开启pop3授权码验证，该授权码可以让客户端进行登录 qq开启授权码 https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;no=1001256&amp;&amp;id=28 实现：JavaMailAPI使用比较麻烦，这里采用的是Apache Commons Email 导入依赖 1234567&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-email --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-email&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 测试：A simple text email 1234567891011121314151617181920212223@Test public void test01() throws Exception &#123; SimpleEmail email = new SimpleEmail(); // 设置主机名，远程服务器的主机名 email.setHostName(&quot;smtp.163.com&quot;); email.setSmtpPort(25); // 设置登陆远程服务器的账号和pop3授权码 email.setAuthentication(&quot;15501892660@163.com&quot;, &quot;xxxxxxx&quot;); // 编写一个邮件 // 设置发送给谁 email.addTo(&quot;782125244@qq.com&quot;); // 设置这个邮件来源于哪里 email.setFrom(&quot;15501892660@163.com&quot;); // 设置邮件主题 email.setSubject(&quot;163发给qq的测试邮件 &quot;); // 设置邮件内容 email.setMsg(&quot;测试邮件&quot;); // 邮件发送 email.send(); &#125; 参考： http://commons.apache.org/proper/commons-email/userguide.html 2、搭建James邮件服务器 下载 https://archive.apache.org/dist/james/server/ quick-start http://james.apache.org/server/quick-start.html 解压 D:\devsoft\apache-james-3.0-beta4 建库 配置数据源 启动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101D:\devsoft\apache-james-3.0-beta4\bin&gt;run.batINFO 09:28:46,331 | org.apache.james.container.spring.context.JamesServerApplicationContext | Refreshing org.apache.james.container.spring.context.JamesServerApplicationContext@153f5a29: startup date [Thu Jan 03 09:28:46 CST 2019]; root of context hierarchyException in thread &quot;main&quot; org.springframework.beans.factory.BeanDefinitionStoreException: Failed to create the JAXB binder; nested exception is javax.xml.bind.JAXBException: Provider com.sun.xml.internal.bind.v2.ContextFactory could not be instantiated: com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition - with linked exception:[com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition] at org.apache.camel.spring.handler.CamelNamespaceHandler$CamelContextBeanDefinitionParser.doParse(CamelNamespaceHandler.java:258) at org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser.parseInternal(AbstractSingleBeanDefinitionParser.java:85) at org.springframework.beans.factory.xml.AbstractBeanDefinitionParser.parse(AbstractBeanDefinitionParser.java:59) at org.springframework.beans.factory.xml.NamespaceHandlerSupport.parse(NamespaceHandlerSupport.java:73) at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1419) at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1409) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:184) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:140) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:111) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.registerBeanDefinitions(XmlBeanDefinitionReader.java:493) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:390) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:334) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:302) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:174) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:209) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:180) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:243) at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:127) at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:93) at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:131) at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:522) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:436) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:139) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:93) at org.apache.james.container.spring.context.JamesServerApplicationContext.&lt;init&gt;(JamesServerApplicationContext.java:39) at org.apache.james.app.spring.JamesAppSpringMain.init(JamesAppSpringMain.java:61) at org.apache.james.app.spring.JamesAppSpringMain.main(JamesAppSpringMain.java:42)Caused by: javax.xml.bind.JAXBException: Provider com.sun.xml.internal.bind.v2.ContextFactory could not be instantiated: com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition - with linked exception:[com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition] at javax.xml.bind.ContextFinder.newInstance(ContextFinder.java:146) at javax.xml.bind.ContextFinder.find(ContextFinder.java:356) at javax.xml.bind.JAXBContext.newInstance(JAXBContext.java:431) at javax.xml.bind.JAXBContext.newInstance(JAXBContext.java:394) at org.apache.camel.spring.handler.CamelNamespaceHandler.createJaxbContext(CamelNamespaceHandler.java:187) at org.apache.camel.spring.handler.CamelNamespaceHandler.getJaxbContext(CamelNamespaceHandler.java:174) at org.apache.camel.spring.handler.CamelNamespaceHandler$CamelContextBeanDefinitionParser.doParse(CamelNamespaceHandler.java:256) ... 26 moreCaused by: com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition at com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException$Builder.check(IllegalAnnotationsException.java:91) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl.getTypeInfoSet(JAXBContextImpl.java:445) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl.&lt;init&gt;(JAXBContextImpl.java:277) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl.&lt;init&gt;(JAXBContextImpl.java:124) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl$JAXBContextBuilder.build(JAXBContextImpl.java:1123) at com.sun.xml.internal.bind.v2.ContextFactory.createContext(ContextFactory.java:147) at com.sun.xml.internal.bind.v2.ContextFactory.createContext(ContextFactory.java:271) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at javax.xml.bind.ContextFinder.newInstance(ContextFinder.java:171) at javax.xml.bind.ContextFinder.newInstance(ContextFinder.java:131) ... 32 moreD:\devsoft\apache-james-3.0-beta4\bin&gt; 123456789101112131415161718192021222324252627282930313233D:\devsoft\apache-james-3.0-beta4\bin&gt;run.batINFO 09:37:44,247 | org.apache.james.container.spring.context.JamesServerApplicationContext | Refreshing org.apache.james.container.spring.context.JamesServerApplicationContext@7ca48474: startup date [Thu Jan 03 09:37:44 CST 2019]; root of context hierarchylog4j:WARN No appenders could be found for logger (org.apache.commons.configuration.ConfigurationUtils).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.INFO 09:37:45,153 | org.apache.james.container.spring.context.JamesServerApplicationContext | Bean &apos;logprovider&apos; of type [class org.apache.james.container.spring.lifecycle.LogProviderImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)INFO 09:37:45,544 | james.mailrepositorystore | JamesMailStore init...INFO 09:37:45,550 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.file.FileMailRepository to handle file protocol requests for repositories with key fileINFO 09:37:45,550 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.jdbc.JDBCMailRepository to handle db protocol requests for repositories with key dbINFO 09:37:45,550 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.jdbc.JDBCMailRepository to handle dbfile protocol requests for repositories with key dbfileINFO 09:37:45,551 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.file.MBoxMailRepository to handle mbox protocol requests for repositories with key mboxINFO 09:37:45,936 | james.dnsservice | Autodiscovery is enabled - trying to discover your system&apos;s DNS ServersINFO 09:37:45,942 | james.dnsservice | Adding autodiscovered server 202.100.192.68INFO 09:37:45,942 | james.dnsservice | Adding autodiscovered server 202.100.199.8INFO 09:37:45,943 | james.dnsservice | DNS Server is: 202.100.192.68INFO 09:37:45,943 | james.dnsservice | DNS Server is: 202.100.199.8INFO 09:37:45,949 | james.dnsservice | Registered cache, resolver and search paths as DNSJava defaults12 James WARN [main] openjpa.Runtime - An error occurred while registering a ClassTransformer with PersistenceUnitInfo: name &apos;James&apos;, root URL [file:/D:/devsoft/apache-james-3.0-beta4/conf/]. The error has been consumed. To see it, set your openjpa.Runtime log level to TRACE. Load-time class transformation will not be available.INFO 09:37:55,187 | james.domainlist | Set autodetect to: trueINFO 09:37:55,187 | james.domainlist | Set autodetectIP to: true28 James INFO [main] openjpa.Runtime - Starting OpenJPA 2.1.052 James INFO [main] openjpa.jdbc.JDBC - Using dictionary class &quot;org.apache.openjpa.jdbc.sql.MySQLDictionary&quot;.Cannot load JDBC driver class &apos;com.mysql.jdbc.Driver&apos;java.lang.ClassNotFoundException: com.mysql.jdbc.Driver at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at org.apache.commons.dbcp.BasicDataSource.createConnectionFactory(BasicDataSource.java:1420) at org.apache.commons.dbcp.BasicDataSource.createDataSource(BasicDataSource.java:1371) at org.apache.commons.dbcp.BasicDataSource.getConnection(BasicDataSource.java:1044) 解决办法 D:\devsoft\apache-james-3.0-beta4\conf\lib：存放自己导入的jar D:\devsoft\apache-james-3.0-beta4\lib：存放James默认jar 复制jaxb-impl-2.1.3.jar，mysql驱动jar包到conf/lib下 设置服务器域名、建立账户 1234567D:\devsoft\apache-james-3.0-beta4\bin&gt; james-cli.bat -h localhost -p 9999 adddomain atguigu.comadddomain command executed sucessfully in 106 ms.D:\devsoft\apache-james-3.0-beta4\bin&gt; james-cli.bat -h localhost -p 9999 adduser test@atguigu.com testadduser command executed sucessfully in 94 ms. 配置Foxmail客户端连接James邮件服务器 测试： 123456789101112131415161718192021222324252627282930/** * 测试james发送邮件 * @Description (TODO这里用一句话描述这个方法的作用) * @throws Exception */ @Test public void test02() throws Exception&#123; SimpleEmail email = new SimpleEmail(); //设置主机名，远程服务器的主机名 email.setHostName("127.0.0.1"); //自定义的ip，一定要手动设置好端口号 email.setSmtpPort(25); //设置登陆远程服务器的密码 email.setAuthentication("test@atguigu.com", "000000"); //编写一个邮件 //设置发送给谁 email.addTo("17512080612@163.com"); //设置这个邮件来源于哪里 email.setFrom("admin@atguigu.com"); //设置邮件主题 email.setSubject("哈哈，给你测试 "); //设置邮件内容 email.setMsg("我能给您发邮件&lt;a href='http://www.atguigu.com'&gt;尚硅谷&lt;/a&gt;"); //邮件发送 email.send(); &#125;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>email</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维矩阵显示账户类型和资质_ajax异步传参_插入mysql中文乱码]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F11%2F%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E6%98%BE%E7%A4%BA%E8%B4%A6%E6%88%B7%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%B5%84%E8%B4%A8_ajax%E5%BC%82%E6%AD%A5%E4%BC%A0%E5%8F%82_%E6%8F%92%E5%85%A5mysql%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1、二维矩阵显示账号类型和资质 效果： 表结构： 账号类型和资质中间表 资质表 思路： 业务层查出账户和资质中间表、资质表、账户表数据，前端展示图横轴根据账户数据填充，纵轴根据资质数据填充，选择框的确定–根据账户资质中间表数据和选择框上自定义属性绑定的账户名、资质id进行相等比较确定。 前端： 1）单选框勾选关系初始化 2）异步传参(封装成实体) 实体对象必须有get和set方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120 &lt;body&gt; &lt;% //设置导航条上的显示 pageContext.setAttribute("navinfo", "分类管理"); //设置点击高亮效果 pageContext.setAttribute("curUrl", "servicectrl/type/ctrl"); %&gt; &lt;!--引入导航条 --&gt; &lt;%@include file="/WEB-INF/includes/nav-bar.jsp"%&gt; &lt;div class="container-fluid"&gt; &lt;div class="row"&gt; &lt;!--引入树形菜单 --&gt; &lt;%@include file="/WEB-INF/includes/user_menu.jsp"%&gt; &lt;div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main"&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt; &lt;i class="glyphicon glyphicon-th"&gt;&lt;/i&gt; 数据矩阵 &lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;div class="table-responsive"&gt; &lt;table class="table table-bordered"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;名称&lt;/th&gt; &lt;c:forEach items="$&#123;types&#125;" var="type"&gt; &lt;th&gt;$&#123;type&#125;&lt;/th&gt; &lt;/c:forEach&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items="$&#123;certs&#125;" var="cert"&gt; &lt;tr&gt; &lt;td&gt;$&#123;cert.name&#125;&lt;/td&gt; &lt;c:forEach items="$&#123;types&#125;" var="type"&gt; &lt;td&gt;&lt;input class='checkSimple' type="checkbox" type_name='$&#123;type&#125;' cid='$&#123;cert.id&#125;'&gt;&lt;/td&gt; &lt;/c:forEach&gt; &lt;/c:forEach&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%@include file="/WEB-INF/includes/js-file.jsp"%&gt; &lt;!-- 引入树形菜单结构点击时动态显示页面高亮效果的js --&gt; &lt;%@include file="/WEB-INF/includes/common-js.jsp"%&gt; &lt;script type="text/javascript"&gt; $(function() &#123; $(".list-group-item").click(function() &#123; if ($(this).find("ul")) &#123; $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) &#123; $("ul", this).hide("fast"); &#125; else &#123; $("ul", this).show("fast"); &#125; &#125; &#125;) &#125;) $(function() &#123; //页面加载完成获取账户类型和资质的关系 var list_type_cert = '$&#123;list_type_cert_json&#125;' log('list_type_cert', list_type_cert) //string log('list_type_cert type=======&gt;', typeof (list_type_cert)) //JSON.parse(list_type_cert) 字符串转成json对象 $.each(JSON.parse(list_type_cert),function(index, content) &#123; log(index, content, content.accttype,content.certid) $('.checkSimple').each(function() &#123; //attr获取自定义属性值 if ($(this).attr('type_name') == (content.accttype)&amp;&amp; $(this).attr('cid') == (content.certid)) &#123; //设置原生属性值 $(this).prop('checked',true) &#125; &#125;) &#125;) //执行事件 __main() &#125;) //更新 var update_type_cert_event = function() &#123; var tAccountTypeCert = &#123;&#125; log('update_type_cert_event=============&gt;') $('body').on('click', 'input', function() &#123; log('update==========&gt;', this) var flag = $(this).prop('checked') log('flag==========&gt;', flag) accttype = $(this).attr('type_name') certid = $(this).attr('cid') log(accttype, certid) tAccountTypeCert.accttype = accttype tAccountTypeCert.certid = certid tAccountTypeCert.flag = flag var url = '$&#123;ctp&#125;/servicectrl/type/update_type_cert' var data = tAccountTypeCert $.getJSON(url, data, function(result) &#123; log(result) &#125;) &#125;) &#125; var __main = function() &#123; update_type_cert_event() &#125; &lt;/script&gt;&lt;/body&gt; 控制层： 1)接收异步传参实体返回json 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.atguigu.scw.manager.controller.manager;import java.util.Arrays;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import com.atguigu.scw.manager.bean.TAccountTypeCert;import com.atguigu.scw.manager.bean.TCert;import com.atguigu.scw.manager.service.CertService;import com.atguigu.scw.manager.service.CertTypeService;import com.fasterxml.jackson.databind.ObjectMapper;@Controller@RequestMapping("/servicectrl/type")public class TypeController &#123; @Autowired CertService certService; @Autowired CertTypeService cTypeService; private static ObjectMapper MAPPER = new ObjectMapper(); @RequestMapping("/ctrl") public String list(Model model) throws Exception &#123; System.out.println("分类管理界面============&gt;"); // 1、先去数据库查出表格横向的显示数据 List&lt;String&gt; types = Arrays.asList("商业公司", "个体工商户", "个人经营", "政府及非营利组织"); // 2、在查出纵向要显示的标题 List&lt;TCert&gt; certs = certService.getAllCert(); System.out.println("资质===========&gt;"); System.out.println(certs); // 3、查询经营类型与资质关系中间表 // List&lt;TAccountTypeCert&gt; cTypeService.getAllCertType(); List&lt;TAccountTypeCert&gt; list_type_cert = cTypeService.getAllCertType(); System.out.println("经营类型===============&gt;"); System.out.println(list_type_cert); // 4、将数据放到模型域当中 model.addAttribute("types", types); model.addAttribute("certs", certs); // list转json字符串 String list_type_cert_json = MAPPER.writeValueAsString(list_type_cert); System.out.println("经营类型--资质----"); System.out.println(list_type_cert_json); model.addAttribute("list_type_cert_json", list_type_cert_json); return "manager/servicemanager/type"; &#125; @RequestMapping("/update_type_cert") @ResponseBody public String update_type_cert(TAccountTypeCert tAccountTypeCert) &#123; System.out.println("更新经营类型---资质==========&gt;"); System.out.println(tAccountTypeCert); boolean flag = tAccountTypeCert.isFlag(); System.out.println("flag============&gt;"); System.out.println(flag); if (flag) &#123; System.out.println("增加一条记录========&gt;"); int count = cTypeService.updateTypeCert(tAccountTypeCert); &#125; else &#123; System.out.println("移除一条记录========&gt;"); cTypeService.removeTypeCert(tAccountTypeCert); &#125; return "success"; &#125;&#125; 业务层： 1）单表的写读操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.atguigu.scw.manager.service.impl;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.atguigu.scw.manager.bean.TAccountTypeCert;import com.atguigu.scw.manager.bean.TAccountTypeCertExample;import com.atguigu.scw.manager.bean.TAccountTypeCertExample.Criteria;import com.atguigu.scw.manager.dao.TAccountTypeCertMapper;import com.atguigu.scw.manager.service.CertTypeService;@Servicepublic class CertTypeServiceImpl implements CertTypeService &#123; @Autowired TAccountTypeCertMapper mapper; //查询资质和账户中间表 @Override public List&lt;TAccountTypeCert&gt; getAllCertType() &#123; List&lt;TAccountTypeCert&gt; list_type_cert = mapper.selectByExample(null); return list_type_cert; &#125; // 增加经营类型--资质 @Override public int updateTypeCert(TAccountTypeCert tAccountTypeCert) &#123; int count = mapper.insertSelective(tAccountTypeCert); return count; &#125; // 删除经营类型--资质 @Override public int removeTypeCert(TAccountTypeCert tAccountTypeCert) &#123; TAccountTypeCertExample example = new TAccountTypeCertExample(); Criteria criteria = example.createCriteria(); criteria.andAccttypeEqualTo(tAccountTypeCert.getAccttype()); criteria.andCertidEqualTo(tAccountTypeCert.getCertid()); int count = mapper.deleteByExample(example); return count; &#125;&#125; 2、mysql插入中文乱码 1）数据库编码和web.xml配置均为utf-8，Controller读取到的是正确的中文，但是保存到数据库后变成”??” 解决 12&lt;property name="url" value="jdbc:mysql://localhost:3306/scw_0325?useUnicode=true&amp;amp;characterEncoding=UTF-8" &gt;&lt;/property&gt;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ztree树形结构菜单_mybatis分页查询]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F10%2Fztree%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E8%8F%9C%E5%8D%95_mybatis%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[1、二级树形菜单 效果图 表结构 业务层： 二级菜单实现思路： 1）查出父菜单（pid=0），通过遍历父菜单获得父菜单(id)，根据父菜单id值作为条件查出子菜单（子菜单pid=父菜单id），接着整理父子菜单关系；这种不推荐，假如所有菜单为18个，查出父菜单3个封装到集合时需要遍历18次，根据父菜单id作为查询子菜单的条件需要遍历3*18次。 2）一次性查出所有菜单18个，使用程序进行组合，这种推荐，以空间换时间。 封装菜单实体 业务层： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public List&lt;TPermission&gt; getAllMenus() &#123; // 保存父菜单 List&lt;TPermission&gt; menus = new ArrayList&lt;TPermission&gt;(); Map&lt;Integer, TPermission&gt; map = new HashMap&lt;Integer, TPermission&gt;(); // 查询所有菜单 // 参数为null，表示不带条件查询菜单 List&lt;TPermission&gt; list = mapper.selectByExample(null); System.out.println("所有菜单=========&gt;"); System.out.println(list); // 1、将所有菜单都放在map中 // 都是引用，如果从map中拿到这个数据改变以后，map中页面变化 for (TPermission tPermission : list) &#123; map.put(tPermission.getId(), tPermission); &#125; // 2、先封装父菜单，再将子菜单放入到父菜单中 for (TPermission tPermission : list) &#123; if (tPermission.getPid() == 0) &#123; menus.add(tPermission); &#125; else &#123; // tPermission（子菜单），拿到父菜单 Integer pid = tPermission.getPid(); // 拿到父菜单；以pid的值作为map中的菜单id，就是父菜单 TPermission p_menu = map.get(pid); // 拿到当前父菜单的子菜单；子菜单会有一些额外的问题 // 这个list第一次获取是没有的，如果添加上一次以后。这个list是有的 List&lt;TPermission&gt; childs = p_menu.getChilds(); if (childs != null) &#123; // 当前有子菜单 childs.add(tPermission); &#125; else &#123; // 当前没有子菜单 childs = new ArrayList&lt;&gt;(); // 添加当前子菜单 childs.add(tPermission); // 将当前整理好的childs设置进去 p_menu.setChilds(childs); &#125; &#125; &#125; System.out.println("父菜单===========&gt;"); System.out.println(menus); return menus;&#125; 控制层 1）将整理好的父子菜单数据放入到session域中，当前用户的这次会话一直使用，只需要去数据库查询一次 12345678910111213141516171819202122232425@RequestMapping(value = "/main.html")public String toMainPage(HttpSession session) &#123; // 校验 // 判断session中是否有这个用户，如果没有去登陆页面 Object object = session.getAttribute(Constants.LOGIN_USER); if (object == null) &#123; // 用户没登陆 return "redirect:/login.jsp"; &#125; else &#123; // 用户登陆才来到主页，session中没有菜单，或者菜单被我们从session中清除了 if (session.getAttribute(Constants.USER_MENUS) == null) &#123; // 1、查出所有菜单，在页面进行显示 List&lt;TPermission&gt; menus = ps.getAllMenus(); // 2、将查到的菜单放在session域中 // 菜单这些数据没必要每次来到主页，都调用service方法进行查询；放在session用户， // 当前用户的这次会话一直使用，只需要去数据库查一次 session.setAttribute(Constants.USER_MENUS, menus); &#125; return "manager/main"; &#125;&#125; 前台： 1）引入：&lt;%@ taglib prefix=”fn” uri=”http://java.sun.com/jsp/jstl/functions&quot;%&gt;计算后台传过来的list集合的长度：${fn:length(p_menu.childs)} 123456789101112131415161718192021222324252627&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions"%&gt;&lt;div class="col-sm-3 col-md-2 sidebar"&gt; &lt;div class="tree"&gt; &lt;ul style="padding-left: 0px;" class="list-group"&gt; &lt;li class="list-group-item tree-closed"&gt;&lt;a href="main.html"&gt;&lt;i class="glyphicon glyphicon-dashboard"&gt;&lt;/i&gt; 控制面板&lt;/a&gt;&lt;/li&gt; &lt;!-- 遍历父菜单 --&gt; &lt;c:forEach items="$&#123;sessionScope.userMenus&#125;" var="p_menu"&gt; &lt;li class="list-group-item tree-closed"&gt;&lt;span&gt;&lt;i class="$&#123;p_menu.icon&#125;"&gt;&lt;/i&gt;$&#123;p_menu.name&#125; &lt;span class="badge" style="float: right"&gt;$&#123;fn:length(p_menu.childs)&#125;&lt;/span&gt;&lt;/span&gt; &lt;ul style="margin-top: 10px; display: none;"&gt; &lt;!-- 遍历子菜单 --&gt; &lt;c:forEach items="$&#123;p_menu.childs&#125;" var="c_menu"&gt; &lt;li style="height: 30px;"&gt;&lt;a href="$&#123;ctp&#125;/$&#123;c_menu.url&#125;" data-action="$&#123;c_menu.id&#125;"&gt;&lt;i class="$&#123;c_menu.icon&#125;"&gt;&lt;/i&gt;$&#123;c_menu.name&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:forEach&gt; &lt;/ul&gt;&lt;/li&gt; &lt;/c:forEach&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 2、mybatis分页查询 根据用户名或者账号进行查询 效果图： 引入依赖： 123456&lt;!-- 分页 插件 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;&lt;/dependency&gt; 业务层： 1）带条件查询 123456789101112131415161718@Overridepublic List&lt;TUser&gt; getAllUsersByCondition(String str) &#123; System.out.println("UserServiceImpl.getAllUsersByCondition 带条件查询员工============&gt;"); // 查询条件拼接 // 第一次创建的条件，默认使用and连接的 TUserExample tUserExample = new TUserExample(); Criteria criteria = tUserExample.createCriteria(); Criteria criteria2 = tUserExample.createCriteria(); if (!str.trim().equals("")) &#123; criteria.andLoginacctLike("%" + str + "%"); criteria.andUsernameLike("%" + str + "%"); &#125; tUserExample.or(criteria2); List&lt;TUser&gt; list_users_example = userMapper.selectByExample(tUserExample); return list_users_example;&#125; 控制层： 1）mybatis分页插件会对结果集进行包装，必须在查询前设置： PageHelper.startPage(pn, ps); 2）查询后输入框数据回显：model.addAttribute(“sp”, search);（转发） 1234567891011121314151617181920212223242526@RequestMapping("/list")public String users(@RequestParam(value = "pn", defaultValue = "1") Integer pn, @RequestParam(value = "ps", defaultValue = "5") Integer ps, @RequestParam(value = "sp", defaultValue = "") String search, Model model) &#123; System.out.println("UserController.users 用户列表显示页===========&gt;"); System.out.println("前台请求参数[第xxx页，每页显示xxx条数]==========&gt;"); System.out.println(pn); System.out.println(ps); // 分页显示数据,这里设置必须放到查询数据之前，否则前台会有问题 PageHelper.startPage(pn, ps); List&lt;TUser&gt; list_users = userService.getAllUsersByCondition(search); System.out.println("查询到的所有用户列表========&gt;"); System.out.println(list_users); PageInfo&lt;TUser&gt; users = new PageInfo&lt;&gt;(list_users, 5); System.out.println("分页后的数据处理"); System.out.println(users); // 将查询用户列表数据放在请求域中，表单查询参数回显到页面 model.addAttribute("users", users); model.addAttribute("sp", search); return "manager/permission/user";&#125; 前台： 1）为所有分页连接绑定单击事件，让其动态的带上分页的查询参数 123var href = $(this).attr("href") + "&amp;sp="+ $("input[name='sp']").val()&lt;br/&gt;$(this).attr("href", href) 2)全选和全不选函数 1234567891011121314//全选/全不选函数function checkall_reverse(check_all_btn, check_btn) &#123; check_all_btn.click(function() &#123; //如果是原生的属性，使用prop获取比较好 check_btn.prop("checked", $(this).prop("checked")) &#125;) check_btn.click(function() &#123; //当check_btn点满以后check_all_btn勾上，否则不选中 //获取被选中的checkbtn个数 var flag = check_btn.filter(":checked").length == check_btn.length check_all_btn.prop("checked", flag); &#125;)&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html lang="UTF-8"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;&lt;meta name="description" content=""&gt;&lt;meta name="author" content=""&gt;&lt;%@include file="/WEB-INF/includes/css-file.jsp"%&gt;&lt;link rel="stylesheet" href="$&#123;ctp&#125;/css/main.css"&gt;&lt;style&gt;.tree li &#123; list-style-type: none; cursor: pointer;&#125;table tbody tr:nth-child(odd) &#123; background: #F4F4F4;&#125;table tbody td:nth-child(even) &#123; color: #C00;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;% //设置导航条上的显示 pageContext.setAttribute("navinfo", "用户维护"); //设置点击高亮效果 pageContext.setAttribute("curUrl", "permission/user/list"); %&gt; &lt;!-- 引入navbar--&gt; &lt;%@include file="/WEB-INF/includes/nav-bar.jsp"%&gt;&lt;/nav&gt; &lt;div class="container-fluid"&gt; &lt;div class="row"&gt; &lt;!-- 引入树形菜单 --&gt; &lt;%@include file="/WEB-INF/includes/user_menu.jsp"%&gt; &lt;div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main"&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt; &lt;i class="glyphicon glyphicon-th"&gt;&lt;/i&gt; 数据列表 &lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;form class="form-inline" role="form" style="float: left;" action="$&#123;ctp &#125;/permission/user/list" method="post"&gt; &lt;div class="form-group has-feedback"&gt; &lt;div class="input-group"&gt; &lt;div class="input-group-addon"&gt;查询条件&lt;/div&gt; &lt;input class="form-control has-success" type="text" name="sp" placeholder="用户名/账号查询" value="$&#123;sp&#125;"&gt; &lt;/div&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-warning"&gt; &lt;i class="glyphicon glyphicon-search"&gt;&lt;/i&gt; 查询 &lt;/button&gt; &lt;/form&gt; &lt;button type="button" class="btn btn-danger" style="float: right; margin-left: 10px;"&gt; &lt;i class=" glyphicon glyphicon-remove"&gt;&lt;/i&gt; 删除 &lt;/button&gt; &lt;button type="button" class="btn btn-primary" style="float: right;" onclick="window.location.href='add.html'"&gt; &lt;i class="glyphicon glyphicon-plus"&gt;&lt;/i&gt; 新增 &lt;/button&gt; &lt;br&gt; &lt;hr style="clear: both;"&gt; &lt;div class="table-responsive"&gt; &lt;table class="table table-bordered"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th width="30"&gt;#&lt;/th&gt; &lt;th width="30"&gt;&lt;input type="checkbox" id="checkall_btn"&gt;&lt;/th&gt; &lt;th&gt;账号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;邮箱地址&lt;/th&gt; &lt;th width="100"&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items="$&#123;users.list&#125;" var="user"&gt; &lt;tr&gt; &lt;td&gt;$&#123;user.id&#125;&lt;/td&gt; &lt;td&gt;&lt;input type="checkbox" class="single_check"&gt;&lt;/td&gt; &lt;td&gt;$&#123;user.loginacct &#125;&lt;/td&gt; &lt;td&gt;$&#123;user.username &#125;&lt;/td&gt; &lt;td&gt;$&#123;user.email &#125;&lt;/td&gt; &lt;td&gt; &lt;button type="button" class="btn btn-success btn-xs"&gt; &lt;i class=" glyphicon glyphicon-check"&gt;&lt;/i&gt; &lt;/button&gt; &lt;button type="button" class="btn btn-primary btn-xs"&gt; &lt;i class=" glyphicon glyphicon-pencil"&gt;&lt;/i&gt; &lt;/button&gt; &lt;button type="button" class="btn btn-danger btn-xs"&gt; &lt;i class=" glyphicon glyphicon-remove"&gt;&lt;/i&gt; &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td colspan="6" align="center"&gt; &lt;ul class="pagination"&gt; &lt;!-- 即使点击分页连接也应该带上查询条件的值 --&gt; &lt;!-- 给分页超链接绑定单击事件； --&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=1"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;!-- 是否还有前一页 --&gt; &lt;c:if test="$&#123;users.hasPreviousPage&#125;"&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;users.prePage&#125;"&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;!-- 遍历页数 --&gt; &lt;c:forEach items="$&#123;users.navigatepageNums&#125;" var="pn"&gt; &lt;!-- 当前页 --&gt; &lt;c:if test="$&#123;pn==users.pageNum &#125;"&gt; &lt;li class="active"&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;pn&#125;"&gt;$&#123;pn&#125;&lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;c:if test="$&#123;pn != users.pageNum &#125;"&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;pn&#125;"&gt;$&#123;pn &#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;!--是否还有下一页 --&gt; &lt;c:if test="$&#123;users.hasNextPage&#125;"&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;users.nextPage&#125;"&gt;下一页&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;users.pages&#125;"&gt;末页&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%@include file="/WEB-INF/includes/js-file.jsp"%&gt; &lt;!-- 引入树形菜单结构点击时动态显示页面高亮效果的js --&gt; &lt;%@include file="/WEB-INF/includes/common-js.jsp"%&gt; &lt;script type="text/javascript"&gt; $(function() &#123; $(".list-group-item").click(function() &#123; if ($(this).find("ul")) &#123; $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) &#123; $("ul", this).hide("fast"); &#125; else &#123; $("ul", this).show("fast"); &#125; &#125; &#125;); &#125;); $("tbody .btn-success").click(function() &#123; window.location.href = "assignRole.html"; &#125;); $("tbody .btn-primary").click(function() &#123; window.location.href = "edit.html"; &#125;); //当前页面所在的哪个超链接是color:red //他的父list-group-item. tree-closed是没有的 //找到当前页面的a连接 //使用css为某个元素加样式 list-group-item //为所有分页连接绑定单击事件，让其动态的带上分页的查询参数 $(".pagination").find("a").click( function() &#123; //1、获取到查询表单的查询参数 //不禁用默认行为，而是为超链接多拼装上查询条件 //为超链接动态拼装查询条件 var href = $(this).attr("href") + "&amp;sp=" + $("input[name='sp']").val() $(this).attr("href", href) &#125;) //这是调用了抽取过来的方法； checkall_reverse($("#checkall_btn"), $(".single_check")) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>ztree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svn版本控制]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F09%2Fsvn%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1、svn下载 https://sourceforge.net/projects/win32svn/ 2、验证是否安装成功 12C:\Users\libingshen&gt;svn --version 3、创建版本库 12D:\mytest\mysvn\OA&gt;svnadmin create D:\mytest\mysvn\OA 4、启动svn服务 5、验证svn服务是否启动 svn服务监听3690端口 6、svn注册为Windows服务 tip:等号左边没有空格，等号右边有一个空格。 12C:\WINDOWS\system32&gt;sc create MySVNService binpath= &quot;C:\Pmyprogram\svn\bin\svnserve.exe --service -r D:\mytest\mysvn&quot; start= auto depend= Tcpip 原因：每次启动svn服务时必须启动一个cmd窗口，cmd窗口一关闭，svn服务就关闭。 非管理员运行时会失败。 管理员运行 启动、停止、删除svn服务（管理员身份运行cmd） 123456789//启动svn服务C:\WINDOWS\system32&gt;sc start MySVNService//停止服务C:\WINDOWS\system32&gt;sc stop MySVNService//删除服务C:\WINDOWS\system32&gt;sc delete MySVNService 7、检出项目 12D:\mytest\mycheckout&gt;svn checkout svn://localhost/OA MyOA 8、提交文件 –开启匿名权限访问 –先将文件加入版本库，然后提交（需添加提交日志信息，不然报错） svn commit 命令最后可以不指定具体文件，此时表示提交当前工作副本中的所有修改 9、更新 另一个客户端检出项目、更新并提交文件 1234//远程版本库具体位置 svn://localhost/OA//将OA检出到本地的目录 MyOA2D:\mytest\mycheckout&gt;svn checkout svn://localhost/OA MyOA2 10、授权访问版本库 –单版本库开启授权访问 –多版本库开启授权访问 123456在版本库根目录 D:\mytest\mysvn 下创建 commConf 目录将未修改的 authz 和 passwd 文件拷贝到 commConf 目录下修改需要设置权限的版本库的 svnserve.conf 文件①password-db = ../../commConf/passwd②authz-db = ../../commConf/authz passwd：设置访问版本库的用户信息 authz：设置用户访问版本库的权限]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc配置]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F07%2Fspringmvc%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1、springmvc路径跳转配置 目录结构 控制层 123456789101112131415161718192021&lt;!-- 使用注解开发，不用配置controller，需要配置一个组件扫描器 --&gt;&lt;context:component-scan base-package="com.*" /&gt;&lt;!-- 视图解析器 --&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置从项目根目录到指定目录一端路径 ,建议指定浅一点的目录 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"&gt;&lt;/property&gt; &lt;!-- 文件的后缀名 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--将index2.jsp放在/WEB-INF/jsp/目录下，请求index2时不经过controller处理;配置了mvc:view-controller后需要配置mvc:annotation-driven,不然走controller的请求会失效 --&gt;&lt;mvc:view-controller path="/index2" view-name="index2" /&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;!--处理静态资源 --&gt;&lt;mvc:default-servlet-handler/&gt; index.jsp 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page language="java" contentType="text/html; charset=ISO-8859-1" pageEncoding="ISO-8859-1"%&gt;&lt;%@ taglib uri="http://java.sun.com/jstl/core_rt" prefix="c"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="ISO-8859-1"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;% request.setAttribute("path", request.getContextPath());%&gt;&lt;/head&gt;&lt;body&gt; //走controller跳转 &lt;a href="hello"&gt;go controller&lt;/a&gt; &lt;br&gt; //不走controller跳转，在springmvc配置文件中配置了mvc-view;index2.jsp页面需放在/WEB-INF/jsp/目录下 &lt;a href="index2"&gt;not go controller&lt;/a&gt; &lt;br/&gt; //加载静态资源 &lt;a href="$&#123;path&#125;/static/index3.jsp"&gt;load static resource index3.jsp&lt;/a&gt; //加载静态资源，需在springmvc配置文件中配置mvc:default-servlet-handler &lt;script type="text/javascript" src="$&#123;path&#125;/ui/jquery/jquery-1.8.3.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function() &#123; console.log("$&#123;path&#125;") &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、springmvc获取请求参数，封装数据到请求域 前台 123456&lt;form action='testParam' method='get'&gt; 用户名：&lt;input type='text' name='username'&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; 控制层 处理方式一：方法参数为Map或者ModelMap类型，数据封装到Map或者Modelmap类型中，其实就是将数据放入到请求域当中 123456789101112@RequestMapping("/testParam")public String testParam(ModelMap modelMap,HttpServletRequest request) &#123; String username = request.getParameter("username"); System.out.println("接收前台发送过来的请求参数=========&gt;用户名："+username); //modelmap会将数据放到请求域当中 modelMap.put("address", "haikou"); //返回视图 return "hello";&#125; 处理方式二：用ModelAndView作为返回值，可以将数据放到请求域中且指定返回的视图 1234567891011@RequestMapping("/testParam")public ModelAndView testParam(HttpServletRequest request) &#123; String username = request.getParameter("username"); System.out.println("接收前台发送过来的请求参数=========&gt;用户名："+username); //参数为返回的视图 ModelAndView hello =new ModelAndView("hello"); hello.addObject("address", "haikou"); return hello;&#125; 前台获取 1234&lt;!-- 获取后台封装在请求域中的数据 --&gt;地址：$&#123;requestScope.address&#125;&lt;br/&gt;&lt;%=request.getAttribute(&quot;address&quot;)%&gt; 3、springmvc处理文件上传 springmvc.xml增加如下配置 1234567&lt;!--文件上传 --&gt;&lt;bean name="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="defaultEncoding" value="UTF-8"&gt;&lt;/property&gt; &lt;property name="maxUploadSize" value="10240000"&gt;&lt;/property&gt;&lt;/bean&gt; 前台表单提交 123456//必须是post请求，且enctype='multipart/form-data'&lt;form action='testFileUpload' method='post' enctype='multipart/form-data'&gt; 文件：&lt;input type='file' name='file' &gt;&lt;br/&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; 控制层 12345678910@RequestMapping("/testFileUpload")public String testFileUpload(@RequestParam("file")MultipartFile file) throws IOException &#123; //获取文件名 String fileName=file.getOriginalFilename(); //获取流，即可取得内容 InputStream in=file.getInputStream(); System.out.println("文件名===========&gt;"+fileName); return "hello";&#125; 4、springmvc返回json数据 pom.xml加入依赖 12345678910111213141516171819&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; 控制层 12345678910//需要加@ResponseBody注解@RequestMapping("/testJson")@ResponseBodypublic Map testFileUpload() &#123; Map&lt;String, Object&gt; map=new HashMap&lt;&gt;(); map.put("username", "沈利兵"); map.put("sex", "男"); return map;&#125;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my_en]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F06%2Fmy_en%2F</url>
    <content type="text"><![CDATA[###2018/12/14 12345678910111213141516171819202122232425262728293031323334353637383940414243eviction --赶出thorough --彻底fixed --固定notifications --通知traverse graphs --遍历图covers --覆盖block --阻塞Redis Releases --Redis 发布Benchmarks --基准Latency monitoring --延迟监控tune --调整High Availability --高可用性Signals Handling --信号处理Administration --管理troubleshoot --解决Troubleshooting --故障排除command line interface --命令行界面durability --持久力Credits --积分Sponsors --赞助商Trademark --商标Lexicographical order --字典顺序populated --填充reply --答复、回复indicating --指示、说明penultimate --倒数第二treat --对待、视其为abstractions --抽象separately --单独、分别地retrieve --检索、取出bitmaps --位图probabilistic --概率estimate --估计cardinality --基数scared --害怕trivial --不重要的、微不足道的crash course --速成班specification --规范Prerequisites --先决条件clause --条款、子句omit --忽略semantics --语义 ###20181215 参考https://tylermcginnis.com/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/ 123456789101112131415161718192021222324252627opinion --观点properly --正确地strategy --策略interpret --解释authoring --创作form --形式consist of --包括responsibilities --责任spot --点、发现key --关键phases --阶段deserve --值得cement --巩固Hoisting --提升exactly identical --完全相同fairly comfortable --相当熟悉adapt --调整、适应Set up memory space --设置内存空间Execution Stack --执行堆栈Call Stack --调用堆栈intuition --直觉scenario --脚本misunderstood --误解Implicit Binding --隐式绑定Explicit Binding --显示绑定Lexical Binding --词法绑定 ###20181217 参考 https://dev.to/siwalik/async-programming-basics-every-js-developer-should-know-in-2018-a9c 123hence --于是imensely --非常 ###20190117 参考： https://docs.python.org/3/library/stdtypes.html#comparisons 123456Comparisons --比较Comparisons can be chained arbitrarily --比较可以任意连接negated --否定notion --概念、主张raise --养、引发 https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range 12345678ascending --升序restrictions --限制imposed --加强lexicographically --字典顺序multidimensional list --多维列表Immutable Sequence Types --不可变序列类型slice --切片]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>english</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven配置]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F05%2Fmaven%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1、下载： https://maven.apache.org/download.cgi 2、配置path环境变量 3、验证安装是否成功 4、配置本地仓库、阿里镜像、jdk编译版本 配置本地仓库位置 12&lt;localRepository&gt;C:\greensoft\apache-maven-3.5.2\repository&lt;/localRepository&gt; 配置jar包下载阿里远程镜像 1234567&lt;mirror&gt; &lt;id&gt;aliyun-maven&lt;/id&gt; &lt;name&gt;aliyun-maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 配置jdk编译版本 12345678910111213&lt;profile&gt; &lt;id&gt;jdk-1.7&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.7&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 5、eclipse整合maven 使用自己的maven安装包 6、IDEA整合maven]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js面向对象_箭头函数this_数组常用方法]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F04%2Fjs%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this_%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、js面向对象 1)传统的面向对象 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function Person(name, age)&#123; this.name=name; this.age=age; &#125; Person.prototype.showName=function ()&#123; alert('我叫'+this.name); &#125;; Person.prototype.showAge=function ()&#123; alert('我'+this.age+'岁'); &#125;; let p=new Person('blue', 18); p.showName(); p.showAge(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function Person(name, age)&#123; this.name=name; this.age=age; &#125; Person.prototype.showName=function ()&#123; alert('我叫'+this.name); &#125;; Person.prototype.showAge=function ()&#123; alert('我'+this.age+'岁'); &#125;; //------------------------------------------------ function Worker(name, age, job)&#123; //通过call调用父类构造函数 Person.call(this, name, age); this.job=job; &#125; //使得子类实例对象共享父类原型对象上的方法 Worker.prototype=new Person(); //重写子类原型对象的构造，特别恶心 Worker.prototype.constructor=Worker; Worker.prototype.showJob=function ()&#123; alert('我是做：'+this.job); &#125;; let w=new Worker('blue', 18, '打杂的'); w.showName(); w.showAge(); w.showJob(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2）js标准的面向对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /*function Person(name, age)&#123; this.name=name; this.age=age; &#125; Person.prototype.showName=function ()&#123; alert('我叫'+this.name); &#125;; Person.prototype.showAge=function ()&#123; alert('我'+this.age+'岁'); &#125;;*/ //标准面向对象书写方式 class Person&#123; constructor(name, age)&#123; this.name=name; this.age=age; &#125; showName()&#123; alert('我叫'+this.name); &#125; showAge()&#123; alert('我'+this.age+'岁'); &#125; &#125; let p=new Person('blue', 18); p.showName(); p.showAge(); //------------------------------------------------ function Worker(name, age, job)&#123; Person.call(this, name, age); this.job=job; &#125; Worker.prototype=new Person(); Worker.prototype.constructor=Worker; Worker.prototype.showJob=function ()&#123; alert('我是做：'+this.job); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 标准的继承方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /*function Person(name, age)&#123; this.name=name; this.age=age; &#125; Person.prototype.showName=function ()&#123; alert('我叫'+this.name); &#125;; Person.prototype.showAge=function ()&#123; alert('我'+this.age+'岁'); &#125;;*/ //标准面向对象书写方式 class Person&#123; constructor(name, age)&#123; this.name=name; this.age=age; &#125; showName()&#123; alert('我叫'+this.name); &#125; showAge()&#123; alert('我'+this.age+'岁'); &#125; &#125; /*let p=new Person('blue', 18); p.showName(); p.showAge();*/ //------------------------------------------------ /*function Worker(name, age, job)&#123; Person.call(this, name, age); this.job=job; &#125; Worker.prototype=new Person(); Worker.prototype.constructor=Worker; Worker.prototype.showJob=function ()&#123; alert('我是做：'+this.job); &#125;;*/ //标准继承方式，子类通过extends实例化的子类可以访问到父类原型对象的方法 class Worker extends Person&#123; constructor(name, age, job)&#123; //super-超类(父类)，可以访问到构造方法，不需要通过call的方式调用 super(name, age); this.job=job; &#125; showJob()&#123; alert('我是做：'+this.job); &#125; &#125; let w=new Worker('blue', 18, '打杂的'); w.showName(); w.showAge(); w.showJob(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2、箭头函数this 普通函数：根据调用我的人 this老变 箭头函数：根据所在的环境 this恒定 bind——给函数定死一个this 例1： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr = [1, 2, 3]; //箭头函数所处的环境是window arr.a = () =&gt; &#123; console.log(this); &#125;; arr.a(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 输出 例2： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; document.onclick=function ()&#123; let arr=[1,2,3]; //箭头函数所处的环境是document arr.a=()=&gt;&#123; console.log(this); &#125;; arr.a(); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 输出 例3： 箭头函数所处的环境是document，尽管通过bind绑定死了12，但还是输出document，说明箭头函数的this优先级高于bind方式绑定的this 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; document.onclick=function ()&#123; let a=()=&gt;&#123; console.log(this); &#125;; let oBtn=document.getElementById('btn1'); oBtn.onclick=a.bind(12); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="button" value="aaa" id="btn1"&gt; &lt;/body&gt;&lt;/html&gt; 输出 3、数组常用方法 1）map 映射 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[62, 55, 82, 37, 26]; let arr2=arr.map(function (item)&#123; if(item&gt;=60)&#123; return true; &#125;else&#123; return false; &#125; &#125;); //true,false,true,false,false alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 改进1 map参数：回调函数使用箭头函数书写方式 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[62, 55, 82, 37, 26]; let arr2=arr.map((item)=&gt;&#123; if(item&gt;=60)&#123; return true; &#125;else&#123; return false; &#125; &#125;); alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 改进2 如果有且仅有1个参数，()可以省 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[62, 55, 82, 37, 26]; let arr2=arr.map(item=&gt;&#123; if(item&gt;=60)&#123; return true; &#125;else&#123; return false; &#125; &#125;); alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 改进3 如果函数体只有一句话，而且是return，{}可以省 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[62, 55, 82, 37, 26]; let arr2=arr.map(item=&gt;item&gt;=60); alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2）filter过滤 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[12,5,88,37,21,91,17,24]; let arr2=arr.filter(item=&gt;item%2); //5,37,21,91,17 alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 3）forEach 遍历 求和 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[12,5,88,37,21,91,17,24]; let sum=0; arr.forEach(item=&gt;&#123; sum+=item; &#125;); //结果295 alert(sum); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 4）reduce 汇总 参数 tmp:中间结果 item：元素项 index：元素索引 求和 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[12,5,88,37,21,91,17,24]; let sum=arr.reduce((tmp,item,index)=&gt;&#123; console.log(tmp, item, index); return tmp+item; &#125;); console.log(sum); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 输出 求平均 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[12,5,88,37,21,91,17,24]; let sum=arr.reduce((tmp,item,index)=&gt;&#123; return tmp+item; &#125;); //结果36.875 console.log(sum/arr.length); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 5）from 将类数组转换成数组 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; div &#123;width:200px; height:200px; background:#CCC; float:left; margin:10px;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; //DOM对象 let aDiv=document.getElementsByTagName('div'); console.log(aDiv); //数组 let aDiv2=Array.from(aDiv); console.log(aDiv2); Array.from(aDiv).forEach(div=&gt;&#123; div.style.background='yellow'; &#125;); Array.prototype.slice.call(aDiv).forEach(div=&gt;&#123; div.style.background='blue'; &#125;); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 输出]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js开发者经常忽略的基础知识点]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F03%2Fjs%E5%BC%80%E5%8F%91%E8%80%85%E7%BB%8F%E5%B8%B8%E5%BF%BD%E7%95%A5%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1、字符串匹配 匹配所有 1234567891011// Mistake// 踩到坑了var str = "David is an Arsenal fan, which means David is great";str.replace("David", "Darren");// "Darren is an Arsenal fan, which means David is great"// Desired// 符合预期str.replace(/David/g, "Darren");// "Darren is an Arsenal fan, which means Darren is great" 忽略大小写 123str.replace(/david/gi, "Darren");// "Darren will always be an Arsenal fan, which means Darren will always be great" 2、将“类数组”元素（比如 arguments 参数列表、节点列表和属性列表）转换成真正的数组 12345678var nodesArr = Array.prototype.slice.call(document.querySelectorAll("div"));// "true" array of DIVs// 得到一个由 div 元素组成的“真正的”数组var argsArr = Array.prototype.slice.call(arguments);// changes arguments to "true" array// 把 arguments 转换成一个“真正的”数组 克隆数组 1234var clone = myArray.slice(0);// naive clone// 浅克隆 3、数组的sort方法 简单排序 1234[1, 3, 9, 2].sort();// Returns: [1, 2, 3, 9]// 返回 [1, 2, 3, 9] 复杂排序 12345678910111213141516[ &#123; name: "Robin Van PurseStrings", age: 30 &#125;, &#123; name: "Theo Walcott", age: 24 &#125;, &#123; name: "Bacary Sagna", age: 28 &#125;].sort(function(obj1, obj2) &#123; // Ascending: first age less than the previous // 实现增序排列：前者的 age 小于后者 return obj1.age - obj2.age;&#125;); // Returns: // [ // &#123; name: "Theo Walcott", age: 24 &#125;, // &#123; name: "Bacary Sagna", age: 28 &#125;, // &#123; name: "Robin Van PurseStrings", age: 30 &#125; // ] 4、push合并数组 1234567var mergeTo = [4,5,6];var mergeFrom = [7,8,9];Array.prototype.push.apply(mergeTo, mergeFrom);mergeTo; // is: [4, 5, 6, 7, 8, 9] 5、join拼接字符串 1234567var str = [ '&lt;div&gt;', '&lt;button id="lucky-draw"&gt;Lucky Draw&lt;/button&gt;', '&lt;/div&gt;'].join('')log(str) 参考 https://github.com/cssmagic/blog/issues/21]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Inheritance and the Prototype Chain]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F02%2FJavaScript%20Inheritance%20and%20the%20Prototype%20Chain%2F</url>
    <content type="text"><![CDATA[参考： https://tylermcginnis.com/javascript-inheritance-and-the-prototype-chain/ ##JavaScript Inheritance and the Prototype Chain Post This post is designed to be read after you read JavaScript Private and Public Class Fields. Previously we learned how to create an Animal class both in ES5 as well as in ES6. We also learned how to share methods across those classes using JavaScript’s prototype. To review, here’s the code we saw in an earlier post. 12345678910111213141516171819202122function Animal (name, energy) &#123; this.name = name this.energy = energy&#125;Animal.prototype.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Animal.prototype.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Animal.prototype.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125;const leo = new Animal(&apos;Leo&apos;, 7) 123456789101112131415161718192021class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep() &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play() &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;const leo = new Animal(&apos;Leo&apos;, 7) Now let’s say we wanted to start making individual classes for specific animals. For example, what if we wanted to start making a bunch of dog instances. What properties and methods will these dogs have? Well, similar to our Animal class, we could give each dog a name, an energy level, and the ability to eat, sleep, and play. Unique to our Dog class, we could also give them a breed property as well as the ability to bark. In ES5, our Dog class could look something like this 12345678910111213141516171819202122232425262728function Dog (name, energy, breed) &#123; this.name = name this.energy = energy this.breed = breed&#125;Dog.prototype.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Dog.prototype.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Dog.prototype.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125;Dog.prototype.bark = function () &#123; console.log(&apos;Woof-Woof!&apos;) this.energy -= .1&#125;const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;) Alright, well… we just recreated the Animal class and added a few new properties to it. If we wanted to create another animal, say a Cat, at this point we’d again have to create a Cat class, duplicate all the common logic located in the Animal class to it, then add on Cat specific properties just like we did with the Dog class. In fact, we’d have to do this for each different type of animal we created. 12345678function Dog (name, energy, breed) &#123;&#125;function Cat (name, energy, declawed) &#123;&#125;function Giraffe (name, energy, height) &#123;&#125;function Monkey (name, energy, domesticated) &#123;&#125; This work, but it seems wasteful. The Animal class is the perfect base class. What that means is that it has all the properties that each one of our animals has in common. Whether we’re creating a dog, cat, giraffe, or monkey, all of them will have a name, energy level, and the ability to eat, sleep, and play. With that said, is there a way we can utilize the Animal class whenever we create the individual classes for each different animal? Let’s try it out. I’ll paste the Animal class again below for easy reference. 123456789101112131415161718192021222324function Animal (name, energy) &#123; this.name = name this.energy = energy&#125;Animal.prototype.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Animal.prototype.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Animal.prototype.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125;function Dog (name, energy, breed) &#123;&#125; What are some things we know about the Dog constructor function above? First, we know it takes 3 arguments, name, energy, and breed. Second, we know it’s going to be called with the new keyword so we’ll have a this object. And third, we know we need to utilize the Animal function so that any instance of dog will have a name, energy level, and be able to eat, sleep, and play. It’s the third one that’s the tricky one. The way you “utilize” a function is by calling it. So we know that inside of Dog, we want to call Animal. What we need to figure out though is how we can invoke Animal in the context of Dog. What that means it that we want to call Animal with the this keyword from Dog. If we do that correctly, then this inside of the Dog function will have all the properties of Animal (name, energy). If you remember from a previous section, every function in JavaScript has a .call method on it. .call() is a method on every function that allows you to invoke the function specifying in what context the function will be invoked. This sounds like exactly what we need. We want to invoke Animal in the context of Dog. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;) charlie.name // Charlie charlie.energy // 10 charlie.breed // GoldendoodleSolid, we’re half-way there. You’ll notice in the code above that because of this line Animal.call(this, name, energy), every instance of Dog will now have a name and energy property. Again, the reason for that is because it’s as if we ran the Animal function with the this keyword generated from Dog. Then after we added a name and energy property to this, we also added a breed property just as we normally would. Remember the goal here is to have each instance of Dog have not only all the properties of Animal, but also all the methods as well. If you run the code above, you’ll notice that if you try to run charlie.eat(10) you’ll get an error. Currently every instance of Dog will have the properties of Animal (name and energy), but we haven’t done anything to make sure that they also have the methods (play, eat, sleep). Let’s think about how we can solve this. We know that all the Animal’s methods are located on Animal.prototype. What that means is we somehow want to make sure that all instances of Dog will have access to the methods on Animal.prototype. What if we used our good friend Object.create here? If you’ll remember, Object.create allows you to create an object which will delegate to another object on failed lookups. So in our case, the object we want to create is going to be Dog’s prototype and the object we want to delegate to on failed lookups is Animal.prototype. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype)Now, whenever there’s a failed lookup on an instance of Dog, JavaScript will delegate that lookup to Animal.prototype. If this is still a little fuzzy, re-read A Beginner’s Guide to JavaScript’s Prototype where we talk all about Object.create and JavaScript’s prototype. Let’s look at the full code together then we’ll walk through what happens. function Animal (name, energy) { this.name = name this.energy = energy } Animal.prototype.eat = function (amount) { console.log(`${this.name} is eating.`) this.energy += amount } Animal.prototype.sleep = function (length) { console.log(`${this.name} is sleeping.`) this.energy += length } Animal.prototype.play = function (length) { console.log(`${this.name} is playing.`) this.energy -= length } function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype)Now we’ve created our base class (Animal) as well as our subclass (Dog), let’s see what it looks like under the hood when we create an instance of Dog. const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;) charlie.name // Charlie charlie.energy // 10 charlie.breed // GoldendoodleNothing fancy so far, but let’s look at what happens when we invoke a method located on Animal. 1234567891011 charlie.eat(10)/*1) JavaScript checks if charlie has an eat property - it doesn&apos;t.2) JavaScript then checks if Dog.prototype has an eat property - it doesn&apos;t.3) JavaScript then checks if Animal.prototype has an eat property - it does so it calls it.*/ The reason Dog.prototype gets checked is because when we created a new instance of Dog, we used the new keyword. Under the hood, the this object that was created for us delegates to Dog.prototype (seen in comments below). function Dog (name, energy, breed) { // this = Object.create(Dog.prototype) Animal.call(this, name, energy) this.breed = breed // return this }The reason Animal.prototype gets checked is because we overwrote Dog.prototype to delegate to Animal.prototype on failed lookups with this line Dog.prototype = Object.create(Animal.prototype)Now one thing we haven’t talked about is what if Dog has its own methods? Well, that’s a simple solution. Just like with Animal, if we want to share a method across all instances of that class, we add it to the function’s prototype. 123456789101112131415...function Dog (name, energy, breed) &#123; Animal.call(this, name, energy) this.breed = breed&#125;Dog.prototype = Object.create(Animal.prototype)Dog.prototype.bark = function () &#123; console.log(&apos;Woof Woof!&apos;) this.energy -= .1&#125; very nice. There’s just one small addition we need to make. If you remember back to the Beginner’s Guide to JavaScript’s Prototype post, we were able to get access to the instances’ constructor function by using instance.constructor. function Animal (name, energy) { this.name = name this.energy = energy } const leo = new Animal(&apos;Leo&apos;, 7) console.log(leo.constructor) // Logs the constructor functionAs explained in the previous post, “the reason this works is because any instances of Animal are going to delegate to Animal.prototype on failed lookups. So when you try to access leo.prototype, leo doesn’t have a prototype property so it will delegate that lookup to Animal.prototype which indeed does have a constructor property.” The reason I bring this up is because in our implementation, we overwrote Dog.prototype with an object that delegates to Animal.prototype. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&apos;Woof Woof!&apos;) this.energy -= .1 }What that means is that now, any instances of Dog which log instance.constructor are going to get the Animal constructor rather than the Dog constructor. You can see for yourself by running this code - function Animal (name, energy) { this.name = name this.energy = energy } Animal.prototype.eat = function (amount) { console.log(`${this.name} is eating.`) this.energy += amount } Animal.prototype.sleep = function (length) { console.log(`${this.name} is sleeping.`) this.energy += length } Animal.prototype.play = function (length) { console.log(`${this.name} is playing.`) this.energy -= length } function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&apos;Woof Woof!&apos;) this.energy -= .1 } const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;) console.log(charlie.constructor)Notice it gives you the Animal constructor even though charlie is a direct instance of Dog. Again, we can walk through what’s happening here just like we did above. 1234567891011const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;)console.log(charlie.constructor)/*1) JavaScript checks if charlie has a constructor property - it doesn&apos;t.2) JavaScript then checks if Dog.prototype has a constructor property - it doesn&apos;t because it was deleted when we overwrote Dog.prototype.3) JavaScript then checks if Animal.prototype has a constructor property - it does so it logs that.*/ How can we fix this? Well, it’s pretty simple. We can just add the correct constructor property to Dog.prototype once we overwrite it. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&apos;Woof Woof!&apos;) this.energy -= .1 } Dog.prototype.constructor = DogAt this point if we wanted to make another subclass, say Cat, we’d follow the same pattern. function Cat (name, energy, declawed) { Animal.call(this, name, energy) this.declawed = declawed } Cat.prototype = Object.create(Animal.prototype) Cat.prototype.constructor = Cat Cat.prototype.meow = function () { console.log(&apos;Meow!&apos;) this.energy -= .1 }This concept of having a base class with subclasses that delegate to it is called inheritance and it’s a staple of Object Oriented Programming (OOP). If you’re coming from a different programming language, odds are you’re already familiar with OOP and inheritance. Before ES6 classes, in JavaScript, inheritance was quite the task as you can see above. You need to understand now only when to use inheritance, but also a nice mix of .call, Object.create, this, and FN.prototype - all pretty advanced JS topics. Let’s see how we’d accomplish the same thing using ES6 classes though. First, let’s review what it looks like to go from an ES5 “class” to an ES6 class using our Animal class. function Animal (name, energy) { this.name = name this.energy = energy } Animal.prototype.eat = function (amount) { console.log(`${this.name} is eating.`) this.energy += amount } Animal.prototype.sleep = function (length) { console.log(`${this.name} is sleeping.`) this.energy += length } Animal.prototype.play = function (length) { console.log(`${this.name} is playing.`) this.energy -= length } const leo = new Animal(&apos;Leo&apos;, 7)123456789101112131415161718192021class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep() &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play() &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;const leo = new Animal(&apos;Leo&apos;, 7) Now that we’ve refactored our Animal constructor function into an ES6 class, the next thing we need to do is figure out how to refactor our base class (Dog). The good news is it’s much more intuitive. For reference, in ES5, here’s what we had. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&apos;Woof Woof!&apos;) this.energy -= .1 } Dog.prototype.constructor = DogBefore we get into inheritance, let’s refactor Dog to use an ES6 class as we learned in a previous post. 12345678910class Dog &#123; constructor(name, energy, breed) &#123; this.breed = breed &#125; bark() &#123; console.log(&apos;Woof Woof!&apos;) this.energy -= .1 &#125;&#125; Looks great. Now, let’s figure out how to make sure that Dog inherits from Animal. The first step we need to make is a pretty straight forward one. With ES6 classes, you can extend a base class with this syntax class Subclass extends Baseclass {}Translated into our example, that would make our Dog class look like this 1234567891011121314151617181920212223242526272829class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep() &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play() &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;class Dog extends Animal &#123; constructor(name, energy, breed) &#123; this.breed = breed &#125; bark() &#123; console.log(&apos;Woof Woof!&apos;) this.energy -= .1 &#125;&#125; In ES5 in order to make sure that every instance of Dog had a name and an energy property, we used .call in order to invoke the Animal constructor function in the context of the Dog instance. Luckily for us, in ES6 it’s much more straight forward. Whenever you are extending a baseclass and you need to invoke that baseclass’ constructor function, you invoke super passing it any arguments it needs. So in our example, our Dog constructor gets refactored to look like this 12345678910111213141516171819202122232425262728293031class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep() &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play() &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;class Dog extends Animal &#123; constructor(name, energy, breed) &#123; super(name, energy) // calls Animal&apos;s constructor this.breed = breed &#125; bark() &#123; console.log(&apos;Woof Woof!&apos;) this.energy -= .1 &#125;&#125; And that’s it. No using .call, no using Object.create, no worrying about resetting constructor on the prototype - just extends the baseclass and make sure to call super. What’s interesting about JavaScript is the same patterns you’ve learned these last few posts are directly caked into the language itself. Previously you learned that the reason all instances of Array have access to the array methods like pop, slice, filter, etc are because all of those methods live on Array.prototype. 123456789101112131415161718192021222324252627282930313233343536console.log(Array.prototype)/* concat: ƒn concat() constructor: ƒn Array() copyWithin: ƒn copyWithin() entries: ƒn entries() every: ƒn every() fill: ƒn fill() filter: ƒn filter() find: ƒn find() findIndex: ƒn findIndex() forEach: ƒn forEach() includes: ƒn includes() indexOf: ƒn indexOf() join: ƒn join() keys: ƒn keys() lastIndexOf: ƒn lastIndexOf() length: 0n map: ƒn map() pop: ƒn pop() push: ƒn push() reduce: ƒn reduce() reduceRight: ƒn reduceRight() reverse: ƒn reverse() shift: ƒn shift() slice: ƒn slice() some: ƒn some() sort: ƒn sort() splice: ƒn splice() toLocaleString: ƒn toLocaleString() toString: ƒn toString() unshift: ƒn unshift() values: ƒn values()*/ You also learned that the reason all instances of Object have access to methods like hasOwnProperty and toString is because those methods live on Object.prototype. 123456789101112console.log(Object.prototype)/* constructor: ƒn Object() hasOwnProperty: ƒn hasOwnProperty() isPrototypeOf: ƒn isPrototypeOf() propertyIsEnumerable: ƒn propertyIsEnumerable() toLocaleString: ƒn toLocaleString() toString: ƒn toString() valueOf: ƒn valueOf()*/ Here’s a challenge for you. With the list of Array methods and Object methods above, why does this code below work? 1234const friends = [&apos;Mikenzi&apos;, &apos;Jake&apos;, &apos;Ean&apos;]friends.hasOwnProperty(&apos;push&apos;) // false If you look at Array.prototype, there isn’t a hasOwnProperty method. Well if there isn’t a hasOwnProperty method located on Array.prototype, how does the friends array in the example above have access to hasOwnProperty? The reason for that is because the Array class extends the Object class. So in our example above, when JavaScript sees that friends doesn’t have a hasOwnProperty property, it checks if Array.prototype does. When Array.prototype doesn’t, it checks if Object.prototype does, then it invokes it. It’s the same process we’ve seen throughout this blog post. JavaScript has two types - Primitive types and Reference types. Primitive types are boolean, number, string, null, and undefined and are immutable. Everything else is a reference type and they all extend Object.prototype. That’s why you can add properties to functions and arrays and that’s why both functions and arrays have access to the methods located on Object.prototype. 12345678function speak()&#123;&#125;speak.woahFunctionsAreLikeObjects = trueconsole.log(speak.woahFunctionsAreLikeObjects) // trueconst friends = [&apos;Mikenzi&apos;, &apos;Jake&apos;, &apos;Ean&apos;]friends.woahArraysAreLikeObjectsToo = trueconsole.log(friends.woahArraysAreLikeObjectsToo) // true –未完待续]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel入门]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F01%2Fbabel%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1、babel Babel is a toolchain that is mainly used to convert ECMAScript 2015+ code into a backwards compatible version of JavaScript in current and older browsers or environments. 参考 https://babeljs.io/setup#installation 1)生成package.json文件(描述项目所需要的各种模块，以及项目的配置信息—比如名称、版本、许可证等元数据) npm init D:\mytest\babel&gt;npm init2)安装项目依赖 install Babel CLI locally D:\mytest\babel&gt;npm install --save-dev @babel/core @babel/cli3）添加编译运行脚本命令 &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;babel src -d src_build&quot; },结果 4）运行脚本命令 D:\mytest\babel&gt;npm run build此时并没有成功的将es6的语法转成es5 5）添加.babelrc文件 Great! You’ve configured Babel but you haven’t made it actually do anything. Create a .babelrc config in your project root and enable some plugins. To start, you can use the env preset, which enables transforms for ES2015+ D:\mytest\babel&gt;npm install @babel/preset-env --save-dev结果 6）重新运行脚本命令 D:\mytest\babel&gt;npm run build 7)使用编译后的js &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&apos;../src_build/1.js&apos;&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;babel官网参考手册 https://babeljs.io/docs/en/usage]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>babel</tag>
        <tag>npm</tag>
      </tags>
  </entry>
</search>

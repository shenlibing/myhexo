<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[技术分享]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F26%2F%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[1、快速深入地学习一个新技术、知识点步骤 1）我们有一个需求 项目开发时，我们需要解决某个问题—页面局部刷新问题 跳槽，学习新技术 2）先看看使用现有的技术能否解决这个问题 可以解决，使用传统的方法iframe 发现使用传统的方法可以解决，但是不够好，使用新技术ajax 3）学习新技术或者知识点 原理 基本语法 4）快速入门案例 特点是简单 了解新技术或者知识点的基本使用，这里不需要涉及技术细节 5）讨论这个新技术或者知识点的细节 怎么使用更规范 使用该技术有没有什么陷阱 需要使用时，注意些什么 2、学习方法的介绍 1）高效而愉快地学习 2）先建立一个整体框架，然后细节 3）在实际工作中，要培养用到什么，能够快速学习什么的能力 4）先know how，再know why 5）软件编程是一门’做中学‘的学科，不是会了再做，而是做了才会 6）适当的囫囵吞枣 7）学习软件编程是在在琢磨别人怎么做，而不是我认为应该怎么做的过程 123for i:=0;i&lt;10;i++ &#123; fmt.Println(&quot;hello,world&quot;)&#125;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[es6异步]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F25%2Fes6%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[1、promise-解决异步操作 同步——串行 简单、方便 异步——并发 性能高、体验好 jQuery异步问题：回到地狱 123456789101112131415161718192021222324252627282930313233$.ajax(&#123; url: '/banner_data', success(banners)&#123; $.ajax(&#123; url: '/user_data', success(user)&#123; $.ajax(&#123; url: '/item_data', success(items)&#123; $.ajax(&#123; url: '/news_data', success(news)&#123; &#125;, error()&#123; alert('数据获取失败'); &#125; &#125;) &#125;, error()&#123; alert('数据获取失败'); &#125; &#125;) &#125;, error()&#123; alert('数据获取失败'); &#125; &#125;) &#125;, error()&#123; alert('数据获取失败'); &#125;&#125;) 使用Promise Promise.all() 与：所有的都成功 Promise.race() 或：只要有一个完成 123456789//PromisePromise.all([ $.ajax('/banner_data'), $.ajax('/item_data'), $.ajax('/user_data'), $.ajax('/news_data'),]).then(arr=&gt;&#123; let [banners, items, user, news]=arr;&#125;, ()=&gt;&#123;&#125;) 1.txt 1&#123;&quot;a&quot;: 3, &quot;b&quot;: 5&#125; 2.txt 1[12,5,8,3] 3.txt 1&#123;&quot;name&quot;: &quot;blue&quot;, &quot;age&quot;: 18&#125; promise怎么用.html 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; let p = new Promise((resolve, reject) =&gt; &#123; //resolve 解决-&gt;成功 //reject 拒绝-&gt;失败 $.ajax(&#123; url: '1.txt', dataType: 'json', success(json) &#123; resolve(json) &#125;, error(err) &#123; reject(err) &#125; &#125;) &#125;) debugger p.then(json =&gt; &#123; alert('成功') console.log(json) &#125;, err =&gt; &#123; alert('失败') &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; promise怎么用2.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; let p = new Promise((resolve, reject) =&gt; &#123; //resolve 解决-&gt;成功 //reject 拒绝-&gt;失败 $.ajax(&#123; url: '1.txt', dataType: 'json', success(json) &#123; resolve(json) &#125;, error(err) &#123; reject(err) &#125; &#125;) &#125;) let p2 = new Promise((resolve, reject) =&gt; &#123; //resolve 解决-&gt;成功 //reject 拒绝-&gt;失败 $.ajax(&#123; url: '2.txt', dataType: 'json', success(json) &#123; resolve(json) &#125;, error(err) &#123; reject(err) &#125; &#125;); &#125;); let p3 = new Promise((resolve, reject) =&gt; &#123; //resolve 解决-&gt;成功 //reject 拒绝-&gt;失败 $.ajax(&#123; url: '3.txt', dataType: 'json', success(json) &#123; resolve(json) &#125;, error(err) &#123; reject(err) &#125; &#125;) &#125;) Promise.all([p, p2, p3]).then(arr =&gt; &#123; let [j1, a, j2] = arr; alert('成功') console.log(j1, a, j2) &#125;, err =&gt; &#123; alert('失败') &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; promise怎么用3.html 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; $.ajax(&#123; url: '1.txt', dataType: 'json' &#125;).then(json=&gt;&#123; alert('成了'); &#125;, err=&gt;&#123; alert('错了'); &#125;); debugger /* Promise.all([p, p2, p3]).then(arr=&gt;&#123; let [j1, a, j2]=arr; alert('成功'); console.log(j1, a, j2); &#125;, err=&gt;&#123; alert('失败'); &#125;); */ &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; promise怎么用4.html 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; Promise.all([ $.ajax(&#123;url: '1.txt', dataType: 'json'&#125;), $.ajax(&#123;url: '2.txt', dataType: 'json'&#125;), $.ajax(&#123;url: '3.txt', dataType: 'json'&#125;), ]).then(arr=&gt;&#123; let [j1, a, j2]=arr; console.log(j1, a, j2); &#125;, err=&gt;&#123; alert('失败'); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 结论 Proimse有用——解除异步操作 Promise有局限——带逻辑的异步操作麻烦 2、generator-生成器（过渡） 可以暂停 generator函数.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function* show() &#123; alert('aaa') yield alert('bbb') &#125; let gen = show() gen.next() //aaa setTimeout(function() &#123; gen.next() //bbb &#125;, 5000) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; generator函数3.html 传参 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function *show()&#123; alert('aaa'); let a=yield; alert('bbb'+a); &#125; let gen=show(); gen.next(); gen.next(12); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; generator函数4.html 返回值 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function* show() &#123; alert('aaa') yield 55 alert('bbb') return 89 &#125; let gen = show() let res1 = gen.next() // debugger console.log(res1) //&#123;value: 55, done: false&#125; let res2 = gen.next() console.log(res2) //&#123;value: 89, done: true&#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 3、async/await（推荐，es7） 可以暂停且可以处理带业务逻辑、异常 async和await.html 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function sleep(sec) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; resolve() &#125;, sec * 1000) &#125;) &#125; async function show() &#123; alert('a') await sleep(1) alert('b') await sleep(2) alert('c') &#125; show() &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 处理带业务逻辑 async和await2.html 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; (async () =&gt; &#123; let data1 = await $.ajax(&#123; url: '1.txt', dataType: 'json' &#125;) console.log('data1=========&gt;', data1) if (data1.a + data1.b &lt; 10) &#123; let data2 = await $.ajax(&#123; url: '2.txt', dataType: 'json' &#125;) alert(data2[0]) &#125; else &#123; let data3 = await $.ajax(&#123; url: '3.txt', dataType: 'json' &#125;) alert(data3.name) &#125; &#125;)() &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 处理异常 async和await3.html 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="jquery.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; async function show() &#123; try &#123; let data1 = await $.ajax(&#123; url: '1.txt', dataType: 'json' &#125;) let data2 = await $.ajax(&#123; url: '33.txt', dataType: 'json' &#125;) let data3 = await $.ajax(&#123; url: '3.txt', dataType: 'json' &#125;) console.log(data1, data2, data3) &#125; catch (e) &#123; alert('有问题') throw new Error('我错了....') &#125; &#125; show() &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F23%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[1、安装Node.js https://nodejs.org/en/ 2、安装Git https://git-scm.com/ 3、安装Hexo 12//全局安装$ npm install -g hexo-cli 存放位置 1C:\Users\libingshen\AppData\Roaming\npm\node_modules 验证安装是否成功 1234567891011121314151617181920212223242526C:\Users\libingshen&gt;node --versionv10.15.0C:\Users\libingshen&gt;npm --version6.4.1C:\Users\libingshen&gt;git --versiongit version 2.16.2.windows.1C:\Users\libingshen&gt;hexo --versionhexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64http_parser: 2.8.0node: 10.15.0v8: 6.8.275.32-node.45uv: 1.23.2zlib: 1.2.11ares: 1.15.0modules: 64nghttp2: 1.34.0napi: 3openssl: 1.1.0jicu: 62.1unicode: 11.0cldr: 33.1tz: 2018e 4、Hexo博客初始化 1234567891011$ cd D:\mytest\myhexo$ hexo init//安装依赖$ npm install//或者hexo generate生成静态页$ hexo g //或者hexo server，启动服务器，可以在http://localhost:4000/ 查看$ hexo s 5、Hexo博客部署到GitHub 1）本地客户端与GitHub建立授权连接生成公私钥 1ssh-keygen -t rsa -C &quot;782125244@qq.com&quot; 公私钥存放位置 1C:\Users\libingshen\.ssh 将公钥内容上传到GitHub 2)GitHub创建仓库作为hexo博客的站点 3）hexo配置GitHub连接 安装 hexo-deployer-git 1$ npm install hexo-deployer-git --save 修改配置D:\mytest\myhexo_config.yml 12345678910111213141516#配置GitHub博客站址访问路径# URL这里要是没有配置，GitHub样式显示不出来## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://shenlibing.github.io/myhexo/root: /myhexopermalink: :year/:month/:day/:title/permalink_defaults:#博客推送到GitHub地址配置# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/shenlibing/myhexo.git branch: [master] 4)配置GitHub Pages 6、备份博客源文件 hexo部署到GitHub只上传.deploy_git文件夹的内容，并不会上传_posts文件夹下的博客源文件 123D:\mytest\myhexo\.deploy_gitD:\mytest\myhexo\source\_posts 解决： 将_posts文件夹作为git仓库，上传到GitHub，使得其作为另一个分支 创建并切换到新分支 123libingshen@DESKTOP-7V287SK MINGW64 /d/mytest/myhexo/source/_posts (master)$ git checkout -b srcSwitched to a new branch &apos;src&apos; 将新分支推送到GitHub 123git add .git commit -m &apos;add_v1:-新增hello-world笔记初始化&apos;git push origin src 将博客源文件分支设为推送的默认分支，git push推送直接推送到src分支 补充： 删除本地分支 1$ git branch -d src 删除远程分支 1$ git push origin -d src 切换分支 1$ git checkout master 查看提交日志 1$ git log --oneline 7、拓展 1)更换hexo主题 下载 https://github.com/theme-next/hexo-theme-next 解压放到D:\mytest\myhexo\themes 修改D:\mytest\myhexo_config.yml配置文件 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-next-master 2）修改站点语言 编辑D:\mytest\myhexo_config.yml 12345678# Sitetitle: 小兵兵subtitle:description:keywords:author: shenlibinglanguage: zh-CNtimezone: 3）开启搜索、字数统计和阅读时长统计 安装依赖hexo-symbols-count-time、hexo-generator-searchdb，安装依赖不成功时先删除D:\mytest\myhexo\node_modules文件夹，重新安装依赖 1234npm install hexo-symbols-count-time --savenpm install hexo-generator-searchdb --save 配置主题样式文件 进入D:\mytest\myhexo\themes\hexo-theme-next-master\文件夹，编辑_config.yml文件 123456789101112# Local search# Dependencies: https://github.com/theme-next/hexo-generator-searchdblocal_search: enable: true# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 4 wpm: 275 配置站点文件 编辑D:\mytest\myhexo\_config.yml文件 12345678910111213#阅读时长和本文字数symbols_count_time: symbols: true time: true total_symbols: true total_time: true#搜索功能search: path: search.xml field: post format: html limit: 10000 4）添加分类和标签 123$ hexo new page categories$ hexo new page tags 编辑D:\mytest\myhexo\source\categories\index.md 123456---title: categoriesdate: 2019-01-22 16:37:58type: &quot;categories&quot; #这部分是新添加的--- 编辑D:\mytest\myhexo\source\tags\index.md 123456---title: tagsdate: 2019-01-22 16:38:40type: &quot;tags&quot; #新添加的内容--- 修改菜单，添加categories和tags到menu中 123456789menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 新增文章，添加categories、tags 123456789101112---title: hexo博客搭建date: 2019-01-23 09:07:30categories: 日常记录tags: - hexo - git - github - node - markdown--- 5）更换页面菜单布局位置 12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 6）配置文章浏览量 注册 https://leancloud.cn/ 创建应用 创建Class 配置web安全域名 获取app_id、app_key 编辑D:\mytest\myhexo\themes\hexo-theme-next-master_config.yml配置文件，填app_id、 app_key;security设置为false 123456789101112# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: BedsOkBLOBR4nM4W52xTcBhb-gzGzoHsz #&lt;app_id&gt; app_key: EEaRfb6dCMaS38laDCkSYhM9 #&lt;app_key&gt; # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don&apos;t care about security in leancloud counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set `security` to `false`. security: false betterPerformance: false 7）插入本地图片 安装依赖 1npm install hexo-asset-image --save 编辑D:\mytest\myhexo_config.yml配置文件 1post_asset_folder: true 命令hexo new post test来生成博文时，/source/_post文件夹中除了test.md外，还有一个同名test文件夹 8)设置动态背景 进入D:\mytest\myhexo\themes\hexo-theme-next-master\layout\文件夹，编辑_layout.swig文件，在&lt;/body&gt;之前添加 1&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt; 9)添加Fork me on GitHub 进入D:\mytest\myhexo\themes\hexo-theme-next-master\layout\文件夹，编辑_layout.swig文件，在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面添加选择的图标样式代码 1&lt;a href=&quot;https://github.com/shenlibing/&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 10）添加友情链接 进入D:\mytest\myhexo\themes\hexo-theme-next-master\layout\_partials文件夹，在footer.swig文件末尾追加 123456&lt;div&gt;友情链接： &lt;a class=&quot;theme-link&quot; href=&quot;http://collect.w3ctrain.com/&quot;&gt; 前端收藏夹 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;a class=&quot;theme-link&quot; href=&quot;http://www.alloyteam.com/nav/&quot;&gt; Web前端导航 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;a class=&quot;theme-link&quot; href=&quot;http://www.runoob.com/&quot;&gt; 菜鸟教程 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;a class=&quot;theme-link&quot; href=&quot;https://mccxj.github.io/&quot;&gt; 小毛的胡思乱想 &lt;/a&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/div&gt; 参考： 【持续更新】Github Pages + Hexo 博客搭建，Next主题个性化修改 Hexo+NexT 打造一个炫酷博客 hexo史上最全搭建教程]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化点击事件绑定]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F15%2F%E4%BC%98%E5%8C%96%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[1、优化点击事件绑定 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button data-action="id1"&gt;新增按钮1&lt;/button&gt;&lt;button data-action="id2"&gt;删除按钮2&lt;/button&gt;&lt;button data-action="id3"&gt;按钮3&lt;/button&gt;&lt;button data-action="id4"&gt;按钮4&lt;/button&gt;&lt;script&gt; var log = function () &#123; console.log.apply(console, arguments) &#125; var actionList = &#123; 'id1': function () &#123; alert('id1=============&gt;') &#125;, 'id2': function () &#123; alert('id2===============&gt;') &#125;, 'id3': function () &#123; alert('id3===============&gt;') &#125;, 'id4': function () &#123; alert('id4===============&gt;') &#125; &#125; let $body = $('body') $body.on('click', '[data-action]', function () &#123; //jQuery获取html标签自定义属性值或data值 let action_name = $(this).data('action') let action = actionList[action_name] // log(action) // log($.isFunction(action)) if ($.isFunction(action)) &#123; action() &#125; &#125;) //页面需要新增一个按钮，做扩展 $body.append('&lt;button data-action="id5"&gt;按钮5&lt;/button&gt;') $.extend(actionList, &#123; 'id5': function () &#123; alert('id5============&gt;') &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考 https://github.com/cssmagic/blog/issues/48]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户分配角色_角色维护权限树]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F14%2F%E7%94%A8%E6%88%B7%E5%88%86%E9%85%8D%E8%A7%92%E8%89%B2_%E8%A7%92%E8%89%B2%E7%BB%B4%E6%8A%A4%E6%9D%83%E9%99%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1、用户分配角色 效果图： 实现思路： 1）先静态实现页面 2）从数据库查询用户未分配角色和已分配角色，前端初始化该列表 3）添加、移除用户拥有的角色 前端： 1)左移、右移：append和appendTo的使用 12$(&quot;.unroles :selected&quot;).appendTo(&quot;.roles_select&quot;) 2）遍历选中的角色 123456//遍历选中的元素,拼接用户角色id$(&apos;.unroles :selected&apos;).each(function() &#123; log(this) rids += $(this).val() + &apos;,&apos;&#125;) 3)ajax发送异步请求（参数拼接：用户id,角色rids） 1234567uid = &apos;$&#123;param.uid&#125;&apos;url = &apos;$&#123;ctp&#125;/permission/user/assignrole?opt=remove&amp;uid=&apos; + uid + &apos;&amp;rids=&apos; + rids + &apos;&apos;//发送请求移除$.get(url, fnf) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;div class="panel panel-default"&gt; &lt;div class="panel-body"&gt; &lt;form role="form" class="form-inline"&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputPassword1"&gt;未分配角色列表&lt;/label&gt;&lt;br&gt; &lt;select class="form-control unroles" multiple size="10" style="width: 100px; overflow-y: auto;"&gt; &lt;c:forEach items="$&#123;list_user_unrole&#125;" var="user_unrole"&gt; &lt;option value="$&#123;user_unrole.id&#125;"&gt;$&#123;user_unrole.name&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;ul&gt; &lt;li class="btn btn-default glyphicon glyphicon-chevron-right"&gt;&lt;/li&gt; &lt;br&gt; &lt;li class="btn btn-default glyphicon glyphicon-chevron-left" style="margin-top: 20px;"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="form-group" style="margin-left: 40px;"&gt; &lt;label for="exampleInputPassword1"&gt;已分配角色列表&lt;/label&gt;&lt;br&gt; &lt;select class="form-control roles_select" multiple size="10" style="width: 100px; overflow-y: auto;"&gt; &lt;c:forEach items="$&#123;list_user_role&#125;" var="user_role"&gt; &lt;option value="$&#123;user_role.id&#125;"&gt;$&#123;user_role.name&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;script type="text/javascript"&gt; $(function() &#123; $(".list-group-item").click(function() &#123; if ($(this).find("ul")) &#123; $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) &#123; $("ul", this).hide("fast"); &#125; else &#123; $("ul", this).show("fast"); &#125; &#125; &#125;); &#125;); //页面加载完成执行 $(function() &#123; addUserRoleEvent() removeUserRoleEvent() &#125;) //用户添加角色事件 var addUserRoleEvent = function() &#123; $('.glyphicon-chevron-right').click( function() &#123; log('向右移动=============&gt;') var uid = '' var rids = '' //遍历选中的元素,拼接用户角色id $('.unroles :selected').each(function() &#123; log(this) rids += $(this).val() + ',' &#125;) rids = rids.substring(0, rids.length - 1) log('用户角色ids==========&gt;', rids) uid = '$&#123;param.uid&#125;' url = '$&#123;ctp&#125;/permission/user/assignrole?opt=add&amp;uid=' + uid + '&amp;rids=' + rids + '' //选中的得进行处理添加到用户角色表中 //发送请求给当前用户添加这几个角色，必须带上权限id的拼串和userid $.get(url, fns) &#125;) &#125; //用户删除角色事件 var removeUserRoleEvent = function() &#123; $('.glyphicon-chevron-left') .click( function() &#123; log('向左移动=============&gt;') var rids = '' $('.roles_select :selected').each(function() &#123; rids += $(this).val() + ',' &#125;) rids = rids.substring(0, rids.length - 1) log('用户角色ids==========&gt;', rids) uid = '$&#123;param.uid&#125;' url = '$&#123;ctp&#125;/permission/user/assignrole?opt=remove&amp;uid=' + uid + '&amp;rids=' + rids + '' //发送请求移除 $.get(url, fnf) &#125;) &#125; //异步请求成功的回调函数 var fns = function(data) &#123; log('异步请求成功的回调函数===============&gt;') log('data===========&gt;', data) //$('.roles_select').append($('.unroles :selected')) $(".unroles :selected").appendTo(".roles_select") &#125; //异步请求失败的回调函数 var fnf = function(data) &#123; log('异步请求失败的回调函数===============&gt;') log('data===========&gt;', data) $('.roles_select :selected').appendTo('.unroles') &#125;&lt;/script&gt; 控制层: 1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 添加移除用户角色 @RequestMapping("/assignrole") @ResponseBody public String userRole(@RequestParam("uid") Integer uid, @RequestParam("rids") String rids, @RequestParam("opt") String opt) &#123; System.out.println("添加移除用户角色==================&gt;"); System.out.println("用户id-----角色ids------类型：添加、移除"); System.out.println(uid); System.out.println(rids); System.out.println(opt); if ("add".equals(opt)) &#123; // 为某个用户添加角色 int i = userRoleService.add(uid, rids); &#125; else if ("remove".equals(opt)) &#123; // 为某个用户删除角色 int i = userRoleService.remove(uid, rids); &#125; return "success"; &#125; @RequestMapping("/toAssignRolePage") public String toAssignRolePage(@RequestParam(value = "uid") Integer uid, Model model) &#123; System.out.println("UserController.toAssignRolePage去分配角色页面=============&gt;"); // 1、查出所有角色 List&lt;TRole&gt; list_role = roleService.getAllRole(); System.out.println("所有角色===========&gt;"); System.out.println(list_role); // 2、查出当前用户拥有的角色 List&lt;TRole&gt; list_user_role = roleService.getUserRole(uid); System.out.println("当前用户的角色==========&gt;"); System.out.println(list_user_role); HashMap&lt;Integer, TRole&gt; map_user_role = new HashMap&lt;&gt;(); for (TRole tRole : list_user_role) &#123; map_user_role.put(tRole.getId(), tRole); &#125; // 3、用户未分配的角色 ArrayList&lt;TRole&gt; list_user_unrole = new ArrayList&lt;&gt;(); for (TRole tRole : list_role) &#123; if (!map_user_role.containsKey(tRole.getId())) &#123; list_user_unrole.add(tRole); &#125; &#125; System.out.println("用户未分配的角色=============&gt;"); System.out.println(list_user_unrole); model.addAttribute("list_user_role", list_user_role); model.addAttribute("list_user_unrole", list_user_unrole); // model.addAttribute("uid", uid); return "manager/permission/assignRole"; &#125; sql: 1)用户表、用户_角色表、角色表3个表多表查询 12345678910111213141516171819&lt;resultMap id="BaseResultMap" type="com.atguigu.scw.manager.bean.TRole"&gt; &lt;id column="id" jdbcType="INTEGER" property="id" /&gt; &lt;result column="name" jdbcType="VARCHAR" property="name" /&gt;&lt;/resultMap&gt;&lt;!-- List&lt;TRole&gt; getUserRole(Integer uid); --&gt;&lt;select id="getUserRole" resultMap="BaseResultMap"&gt; SELECT a.* FROM t_role a LEFT JOIN t_user_role b ON a.`id` = b.`roleid` LEFT JOIN t_user c ON b.`userid` = c.`id` WHERE c.`id` = #&#123;uid&#125;&lt;/select&gt; 2、角色维护权限树 效果图： 实现思路： 1）zTree展示权限树，初始化含有复选框的权限树，异步请求控制层（参数：角色rid）查询出角色拥有的权限 2）点击分配权限携带角色rid和权限permission_ids到控制层，先删除角色所拥有的权限，再更加permission_ids更新角色拥有的权限，同步到前端 3）bootstrap模态框–分配权限按钮绑定参数 前端： 1）zTree权限树复选框初始化的时候刚开始使用2次异步请求（一次请求所有权限，一次请求角色拥有的权限），展示数据有点混乱，后来改为一次异步请求同时查询出（所有权限、角色拥有的权限）。 2）bootstrap自定义图标显示不出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201&lt;!-- Modal模态框 --&gt;&lt;div class="modal fade" id="permissModel" tabindex="-1" role="dialog" aria-labelledby="myModalLabel"&gt; &lt;div class="modal-dialog" role="document"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"&gt; &lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;h4 class="modal-title" id="myModalLabel"&gt;Modal title&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;!--展示权限树 --&gt; &lt;ul id="permissionTree" class="ztree"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;关闭&lt;/button&gt; &lt;button type="button" class="btn btn-primary" id='addPermissionBtn'&gt;分配权限&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; $(function() &#123; $(".list-group-item").click(function() &#123; if ($(this).find("ul")) &#123; $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) &#123; $("ul", this).hide("fast"); &#125; else &#123; $("ul", this).show("fast"); &#125; &#125; &#125;); &#125;); /* $("tbody .btn-success").click(function() &#123; window.location.href = "assignPermission.html"; &#125;); */ var zTree //设置ajax同步 //$.ajaxSettings.async = false var assignPermissionEvent = function() &#123; $(".assignPermissionModelBtn").click(function() &#123; log('assignPermissionEvent==============&gt;') //获取当前角色id log('当前角色id==========&gt;', $(this).attr('rid')) var rid = $(this).attr('rid') loadModalAndTree(rid) &#125;) &#125; var loadModalAndTree = function(rid) &#123; //模态框设置 var options = &#123; backdrop : 'static', show : true &#125; //手动打开模态框 $('#permissModel').modal(options) //从数据库查出的所有权限节点数据 //发送ajax请求获取到所有权限的json数据 var url = '$&#123;ctp&#125;/permission/role/json/' + rid $.getJSON(url, fns) //将角色id保存到模态框的哪个属性中； //打开模态框将角色id传递给model里面的权限分配按钮 log('角色id===========&gt;', rid) $('#addPermissionBtn').attr("rid", rid) &#125; //成功回调函数，刷新权限树 var fns = function(data) &#123; log('成功返回数据', data) log('event==========&gt;', event) var ids = [] $.each(data.listCurrentPermission, function() &#123; ids.push(this.id) &#125;) log('ids===========&gt;', ids) //遍历每一条权限 $.each(data.listPermission, function() &#123; //给每一个节点修改或者添加一些属性 if (this.pid == 0) &#123; this.open = true &#125; if (ids.includes(this.id)) &#123; this.checked = true &#125; &#125;) var setting = &#123; data : &#123; simpleData : &#123; enable : true, idKey : "id", pIdKey : "pid", &#125;, key : &#123; url : "haha" &#125; &#125;, /* view : &#123; addDiyDom : showIcon &#125;, */ check : &#123; enable : true &#125; &#125; zTree = $.fn.zTree.init($("#permissionTree"), setting, data.listPermission) log('zTree赋值完成==========&gt;', zTree) &#125; //用于在节点上固定显示用户自定义控件 //?图标无法正常显示可能是字体样式没有引入进来 var showIcon = function(treeId, treeNode) &#123; log('自定义显示图标==============&gt;') log('treeId===============&gt;', treeId) log('treeNode===============&gt;', treeNode) //#permissionTree_10_ico $("#" + treeNode.tId + "_ico").removeClass() .addClass(treeNode.icon) &#125; //默认勾选当前角色的权限 var checkcurPermisson = function(rid) &#123; var url = '$&#123;ctp&#125;/permission/role/curPermission/' + rid $.getJSON(url, fns2) &#125; //获取当前角色权限成功回调函数 var fns2 = function(data) &#123; log('fns2===============&gt;') log('fns2_data================', data) //遍历当前角色拥有的权限 $.each(data, function() &#123; //$(this).attr('id') var node = zTree.getNodesByParam('id', this.id, null) log('使用zTree===========&gt;', zTree) log('当前角色拥有的权限=============&gt;', node) zTree.checkNode(node, true, false) log('是否选中=========&gt;', node.checked) node.nocheck = true //表示显示checkbox &#125;) &#125; //更新权限树 var updateTree = function() &#123; log('更新权限树===========&gt;') var rid = $('#addPermissionBtn').attr("rid") log('角色rid==========&gt;', rid) var permission_ids = '' //1、获取当前我们已经选中的权限 var nodes = zTree.getCheckedNodes(true) log('nodes=============&gt;', nodes) $.each(nodes, function() &#123; permission_ids += this.id + ',' &#125;) var url = '$&#123;ctp&#125;/permission/role/update?rid=' + rid + '&amp;permission_ids=' + permission_ids $.get(url, updateTreeFn) &#125; //更新权限树回调函数 var updateTreeFn = function(data) &#123; alert(data) log("权限分配成功===========&gt;"); $('#permissModel').modal("hide"); &#125; var addPermissionBtnEvent = function() &#123; $('#addPermissionBtn').click(function() &#123; log('点击分配权限按钮=============&gt;') updateTree() &#125;) &#125; var __main = function() &#123; assignPermissionEvent() addPermissionBtnEvent() &#125; $(function() &#123; __main() &#125;)&lt;/script&gt; 控制层： 123456789101112131415161718192021222324252627282930313233343536//分配权限@RequestMapping("/update") @ResponseBody public String updateRolePermission(@RequestParam("rid") Integer rid, @RequestParam("permission_ids") String permission_ids) &#123; System.out.println("更新权限==========&gt;"); System.out.println(rid); System.out.println(permission_ids); // 先删除该角色所有权限，在为该用户分配权限 boolean flag = rolePermissionService.updatePermission(rid, permission_ids); return flag ? "success" : "fail"; &#125; @RequestMapping("/curPermission/&#123;id&#125;") @ResponseBody public List&lt;TPermission&gt; getCurrentPermission(@PathVariable("id") Integer rid) &#123; System.out.println("当前角色拥有的权限==============&gt;"); List&lt;TPermission&gt; listPermission = permissionService.getPermissionsById(rid); System.out.println(listPermission); return listPermission; &#125;//查出角色拥有的权限、所有权限 @RequestMapping("/json/&#123;id&#125;") @ResponseBody public HashMap&lt;String, List&lt;TPermission&gt;&gt; getAllPermission(@PathVariable("id") Integer rid) &#123; List&lt;TPermission&gt; listPermission = permissionService.getPermissions(); List&lt;TPermission&gt; listCurrentPermission = permissionService.getPermissionsById(rid); HashMap&lt;String, List&lt;TPermission&gt;&gt; map = new HashMap&lt;&gt;(); map.put("listPermission", listPermission); map.put("listCurrentPermission", listCurrentPermission); return map; &#125; 业务层： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 更新权限树 @Override public boolean updatePermission(Integer rid, String permission_ids) &#123; // 删除角色权限 TRolePermissionExample tRolePermissionExample = new TRolePermissionExample(); Criteria criteria = tRolePermissionExample.createCriteria(); criteria.andRoleidEqualTo(rid); int count = mapper.deleteByExample(tRolePermissionExample); // 更新权限 if (permission_ids.contains(",")) &#123; String[] split = permission_ids.split(","); for (String permission_id : split) &#123; int i = Integer.parseInt(permission_id); TRolePermission rolePermission = new TRolePermission(); // 设置权限id rolePermission.setPermissionid(i); // 设置角色id rolePermission.setRoleid(rid); // 保存角色权限关系 mapper.insertSelective(rolePermission); &#125; &#125; else &#123; int i = Integer.parseInt(permission_ids); TRolePermission rolePermission = new TRolePermission(); // 设置权限id rolePermission.setPermissionid(i); // 设置角色id rolePermission.setRoleid(rid); // 保存角色权限关系 mapper.insertSelective(rolePermission); &#125; return true; &#125; // 为角色分配权限，查询所有权限 @Override public List&lt;TPermission&gt; getPermissions() &#123; List&lt;TPermission&gt; list_permission = mapper.selectByExample(null); return list_permission; &#125; @Override public List&lt;TPermission&gt; getPermissionsById(Integer rid) &#123; List&lt;TPermission&gt; list_permission = mapper.getRolePermission(rid); return list_permission; &#125;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>ztree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易邮箱服务器发送电子邮件_搭建James邮件服务器发送电子邮件]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F13%2F%E7%BD%91%E6%98%93%E9%82%AE%E7%AE%B1%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6_%E6%90%AD%E5%BB%BAJames%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1、网易邮箱发送电子邮件 为了安全，网易邮箱开启pop3授权码验证，该授权码可以让客户端进行登录 qq开启授权码 https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;no=1001256&amp;&amp;id=28 实现：JavaMailAPI使用比较麻烦，这里采用的是Apache Commons Email 导入依赖 1234567&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-email --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-email&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 测试：A simple text email 1234567891011121314151617181920212223@Test public void test01() throws Exception &#123; SimpleEmail email = new SimpleEmail(); // 设置主机名，远程服务器的主机名 email.setHostName(&quot;smtp.163.com&quot;); email.setSmtpPort(25); // 设置登陆远程服务器的账号和pop3授权码 email.setAuthentication(&quot;15501892660@163.com&quot;, &quot;xxxxxxx&quot;); // 编写一个邮件 // 设置发送给谁 email.addTo(&quot;782125244@qq.com&quot;); // 设置这个邮件来源于哪里 email.setFrom(&quot;15501892660@163.com&quot;); // 设置邮件主题 email.setSubject(&quot;163发给qq的测试邮件 &quot;); // 设置邮件内容 email.setMsg(&quot;测试邮件&quot;); // 邮件发送 email.send(); &#125; 参考： http://commons.apache.org/proper/commons-email/userguide.html 2、搭建James邮件服务器 下载 https://archive.apache.org/dist/james/server/ quick-start http://james.apache.org/server/quick-start.html 解压 D:\devsoft\apache-james-3.0-beta4 建库 配置数据源 启动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101D:\devsoft\apache-james-3.0-beta4\bin&gt;run.batINFO 09:28:46,331 | org.apache.james.container.spring.context.JamesServerApplicationContext | Refreshing org.apache.james.container.spring.context.JamesServerApplicationContext@153f5a29: startup date [Thu Jan 03 09:28:46 CST 2019]; root of context hierarchyException in thread &quot;main&quot; org.springframework.beans.factory.BeanDefinitionStoreException: Failed to create the JAXB binder; nested exception is javax.xml.bind.JAXBException: Provider com.sun.xml.internal.bind.v2.ContextFactory could not be instantiated: com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition - with linked exception:[com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition] at org.apache.camel.spring.handler.CamelNamespaceHandler$CamelContextBeanDefinitionParser.doParse(CamelNamespaceHandler.java:258) at org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser.parseInternal(AbstractSingleBeanDefinitionParser.java:85) at org.springframework.beans.factory.xml.AbstractBeanDefinitionParser.parse(AbstractBeanDefinitionParser.java:59) at org.springframework.beans.factory.xml.NamespaceHandlerSupport.parse(NamespaceHandlerSupport.java:73) at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1419) at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1409) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:184) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:140) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:111) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.registerBeanDefinitions(XmlBeanDefinitionReader.java:493) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:390) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:334) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:302) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:174) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:209) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:180) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:243) at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:127) at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:93) at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:131) at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:522) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:436) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:139) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:93) at org.apache.james.container.spring.context.JamesServerApplicationContext.&lt;init&gt;(JamesServerApplicationContext.java:39) at org.apache.james.app.spring.JamesAppSpringMain.init(JamesAppSpringMain.java:61) at org.apache.james.app.spring.JamesAppSpringMain.main(JamesAppSpringMain.java:42)Caused by: javax.xml.bind.JAXBException: Provider com.sun.xml.internal.bind.v2.ContextFactory could not be instantiated: com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition - with linked exception:[com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition] at javax.xml.bind.ContextFinder.newInstance(ContextFinder.java:146) at javax.xml.bind.ContextFinder.find(ContextFinder.java:356) at javax.xml.bind.JAXBContext.newInstance(JAXBContext.java:431) at javax.xml.bind.JAXBContext.newInstance(JAXBContext.java:394) at org.apache.camel.spring.handler.CamelNamespaceHandler.createJaxbContext(CamelNamespaceHandler.java:187) at org.apache.camel.spring.handler.CamelNamespaceHandler.getJaxbContext(CamelNamespaceHandler.java:174) at org.apache.camel.spring.handler.CamelNamespaceHandler$CamelContextBeanDefinitionParser.doParse(CamelNamespaceHandler.java:256) ... 26 moreCaused by: com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions类的两个属性具有相同名称 &quot;outputs&quot; this problem is related to the following location: at public java.util.List org.apache.camel.model.ResequenceDefinition.getOutputs() at org.apache.camel.model.ResequenceDefinition this problem is related to the following location: at private java.util.List org.apache.camel.model.ResequenceDefinition.outputs at org.apache.camel.model.ResequenceDefinition at com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException$Builder.check(IllegalAnnotationsException.java:91) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl.getTypeInfoSet(JAXBContextImpl.java:445) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl.&lt;init&gt;(JAXBContextImpl.java:277) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl.&lt;init&gt;(JAXBContextImpl.java:124) at com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl$JAXBContextBuilder.build(JAXBContextImpl.java:1123) at com.sun.xml.internal.bind.v2.ContextFactory.createContext(ContextFactory.java:147) at com.sun.xml.internal.bind.v2.ContextFactory.createContext(ContextFactory.java:271) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at javax.xml.bind.ContextFinder.newInstance(ContextFinder.java:171) at javax.xml.bind.ContextFinder.newInstance(ContextFinder.java:131) ... 32 moreD:\devsoft\apache-james-3.0-beta4\bin&gt; 123456789101112131415161718192021222324252627282930313233D:\devsoft\apache-james-3.0-beta4\bin&gt;run.batINFO 09:37:44,247 | org.apache.james.container.spring.context.JamesServerApplicationContext | Refreshing org.apache.james.container.spring.context.JamesServerApplicationContext@7ca48474: startup date [Thu Jan 03 09:37:44 CST 2019]; root of context hierarchylog4j:WARN No appenders could be found for logger (org.apache.commons.configuration.ConfigurationUtils).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.INFO 09:37:45,153 | org.apache.james.container.spring.context.JamesServerApplicationContext | Bean &apos;logprovider&apos; of type [class org.apache.james.container.spring.lifecycle.LogProviderImpl] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)INFO 09:37:45,544 | james.mailrepositorystore | JamesMailStore init...INFO 09:37:45,550 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.file.FileMailRepository to handle file protocol requests for repositories with key fileINFO 09:37:45,550 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.jdbc.JDBCMailRepository to handle db protocol requests for repositories with key dbINFO 09:37:45,550 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.jdbc.JDBCMailRepository to handle dbfile protocol requests for repositories with key dbfileINFO 09:37:45,551 | james.mailrepositorystore | Registering Repository instance of class org.apache.james.mailrepository.file.MBoxMailRepository to handle mbox protocol requests for repositories with key mboxINFO 09:37:45,936 | james.dnsservice | Autodiscovery is enabled - trying to discover your system&apos;s DNS ServersINFO 09:37:45,942 | james.dnsservice | Adding autodiscovered server 202.100.192.68INFO 09:37:45,942 | james.dnsservice | Adding autodiscovered server 202.100.199.8INFO 09:37:45,943 | james.dnsservice | DNS Server is: 202.100.192.68INFO 09:37:45,943 | james.dnsservice | DNS Server is: 202.100.199.8INFO 09:37:45,949 | james.dnsservice | Registered cache, resolver and search paths as DNSJava defaults12 James WARN [main] openjpa.Runtime - An error occurred while registering a ClassTransformer with PersistenceUnitInfo: name &apos;James&apos;, root URL [file:/D:/devsoft/apache-james-3.0-beta4/conf/]. The error has been consumed. To see it, set your openjpa.Runtime log level to TRACE. Load-time class transformation will not be available.INFO 09:37:55,187 | james.domainlist | Set autodetect to: trueINFO 09:37:55,187 | james.domainlist | Set autodetectIP to: true28 James INFO [main] openjpa.Runtime - Starting OpenJPA 2.1.052 James INFO [main] openjpa.jdbc.JDBC - Using dictionary class &quot;org.apache.openjpa.jdbc.sql.MySQLDictionary&quot;.Cannot load JDBC driver class &apos;com.mysql.jdbc.Driver&apos;java.lang.ClassNotFoundException: com.mysql.jdbc.Driver at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at org.apache.commons.dbcp.BasicDataSource.createConnectionFactory(BasicDataSource.java:1420) at org.apache.commons.dbcp.BasicDataSource.createDataSource(BasicDataSource.java:1371) at org.apache.commons.dbcp.BasicDataSource.getConnection(BasicDataSource.java:1044) 解决办法 D:\devsoft\apache-james-3.0-beta4\conf\lib：存放自己导入的jar D:\devsoft\apache-james-3.0-beta4\lib：存放James默认jar 复制jaxb-impl-2.1.3.jar，mysql驱动jar包到conf/lib下 设置服务器域名、建立账户 1234567D:\devsoft\apache-james-3.0-beta4\bin&gt; james-cli.bat -h localhost -p 9999 adddomain atguigu.comadddomain command executed sucessfully in 106 ms.D:\devsoft\apache-james-3.0-beta4\bin&gt; james-cli.bat -h localhost -p 9999 adduser test@atguigu.com testadduser command executed sucessfully in 94 ms. 配置Foxmail客户端连接James邮件服务器 测试： 123456789101112131415161718192021222324252627282930/** * 测试james发送邮件 * @Description (TODO这里用一句话描述这个方法的作用) * @throws Exception */ @Test public void test02() throws Exception&#123; SimpleEmail email = new SimpleEmail(); //设置主机名，远程服务器的主机名 email.setHostName("127.0.0.1"); //自定义的ip，一定要手动设置好端口号 email.setSmtpPort(25); //设置登陆远程服务器的密码 email.setAuthentication("test@atguigu.com", "000000"); //编写一个邮件 //设置发送给谁 email.addTo("17512080612@163.com"); //设置这个邮件来源于哪里 email.setFrom("admin@atguigu.com"); //设置邮件主题 email.setSubject("哈哈，给你测试 "); //设置邮件内容 email.setMsg("我能给您发邮件&lt;a href='http://www.atguigu.com'&gt;尚硅谷&lt;/a&gt;"); //邮件发送 email.send(); &#125;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>email</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[帆软报表部署配置_emoss5用户分配角色、角色分配权限]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F12%2F%E5%B8%86%E8%BD%AF%E6%8A%A5%E8%A1%A8%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE_emoss5%E7%94%A8%E6%88%B7%E5%88%86%E9%85%8D%E8%A7%92%E8%89%B2%E3%80%81%E8%A7%92%E8%89%B2%E5%88%86%E9%85%8D%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[1、帆软报表部署 客户端工具sftp下载链接 https://www.netsarang.com/download/down_form.html?code=623 使用sftp https://www.netsarang.com/download/down_xfp6.html?token=dEFiMWxoUEhuNU1hQlMrRG9qU20yZ0Bnc1hKVGJhaHpkY3hBUUNMNFBoaXVn 1）用客户端工具sftp登录到135.125.60.122机子 文件–新建 报表存放路径 12/opt/FineBI/webapps/WebReport/WEB-INF/reportlets 2）菜单配置 基础应用–权限模型–菜单管理 建立菜单层级关系 在资源评价菜单下-建立杜邦报表分析文件夹–建立2018杜邦报表3层目录结构 在2018杜邦报表(1)下配置报表位置引用–填写菜单编码(表名)、排序号、菜单名称(表名中文描述)、菜单URL 菜单URL的配置 2、建员工、建用户、为用户分配角色、为角色分配权限 1）建员工–基础应用–权限模型–员工管理 2）建用户–基础应用–权限模型–用户管理–新增 新建用户之前必须先建员工、角色、部门，在建用户的时候可以为该用户分配角色和菜单权限 3）为用户分配角色–基础应用–权限模型–角色用户设置 先选中角色，然后为该角色添加用户 4）为角色分配权限–基础应用–权限模型–角色管理 先选中角色，然后为该角色勾选拥有的菜单权限]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>emoss</tag>
        <tag>finereport</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维矩阵显示账户类型和资质_ajax异步传参_插入mysql中文乱码]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F11%2F%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E6%98%BE%E7%A4%BA%E8%B4%A6%E6%88%B7%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%B5%84%E8%B4%A8_ajax%E5%BC%82%E6%AD%A5%E4%BC%A0%E5%8F%82_%E6%8F%92%E5%85%A5mysql%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1、二维矩阵显示账号类型和资质 效果： 表结构： 账号类型和资质中间表 资质表 思路： 业务层查出账户和资质中间表、资质表、账户表数据，前端展示图横轴根据账户数据填充，纵轴根据资质数据填充，选择框的确定–根据账户资质中间表数据和选择框上自定义属性绑定的账户名、资质id进行相等比较确定。 前端： 1）单选框勾选关系初始化 2）异步传参(封装成实体) 实体对象必须有get和set方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120 &lt;body&gt; &lt;% //设置导航条上的显示 pageContext.setAttribute("navinfo", "分类管理"); //设置点击高亮效果 pageContext.setAttribute("curUrl", "servicectrl/type/ctrl"); %&gt; &lt;!--引入导航条 --&gt; &lt;%@include file="/WEB-INF/includes/nav-bar.jsp"%&gt; &lt;div class="container-fluid"&gt; &lt;div class="row"&gt; &lt;!--引入树形菜单 --&gt; &lt;%@include file="/WEB-INF/includes/user_menu.jsp"%&gt; &lt;div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main"&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt; &lt;i class="glyphicon glyphicon-th"&gt;&lt;/i&gt; 数据矩阵 &lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;div class="table-responsive"&gt; &lt;table class="table table-bordered"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;名称&lt;/th&gt; &lt;c:forEach items="$&#123;types&#125;" var="type"&gt; &lt;th&gt;$&#123;type&#125;&lt;/th&gt; &lt;/c:forEach&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items="$&#123;certs&#125;" var="cert"&gt; &lt;tr&gt; &lt;td&gt;$&#123;cert.name&#125;&lt;/td&gt; &lt;c:forEach items="$&#123;types&#125;" var="type"&gt; &lt;td&gt;&lt;input class='checkSimple' type="checkbox" type_name='$&#123;type&#125;' cid='$&#123;cert.id&#125;'&gt;&lt;/td&gt; &lt;/c:forEach&gt; &lt;/c:forEach&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%@include file="/WEB-INF/includes/js-file.jsp"%&gt; &lt;!-- 引入树形菜单结构点击时动态显示页面高亮效果的js --&gt; &lt;%@include file="/WEB-INF/includes/common-js.jsp"%&gt; &lt;script type="text/javascript"&gt; $(function() &#123; $(".list-group-item").click(function() &#123; if ($(this).find("ul")) &#123; $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) &#123; $("ul", this).hide("fast"); &#125; else &#123; $("ul", this).show("fast"); &#125; &#125; &#125;) &#125;) $(function() &#123; //页面加载完成获取账户类型和资质的关系 var list_type_cert = '$&#123;list_type_cert_json&#125;' log('list_type_cert', list_type_cert) //string log('list_type_cert type=======&gt;', typeof (list_type_cert)) //JSON.parse(list_type_cert) 字符串转成json对象 $.each(JSON.parse(list_type_cert),function(index, content) &#123; log(index, content, content.accttype,content.certid) $('.checkSimple').each(function() &#123; //attr获取自定义属性值 if ($(this).attr('type_name') == (content.accttype)&amp;&amp; $(this).attr('cid') == (content.certid)) &#123; //设置原生属性值 $(this).prop('checked',true) &#125; &#125;) &#125;) //执行事件 __main() &#125;) //更新 var update_type_cert_event = function() &#123; var tAccountTypeCert = &#123;&#125; log('update_type_cert_event=============&gt;') $('body').on('click', 'input', function() &#123; log('update==========&gt;', this) var flag = $(this).prop('checked') log('flag==========&gt;', flag) accttype = $(this).attr('type_name') certid = $(this).attr('cid') log(accttype, certid) tAccountTypeCert.accttype = accttype tAccountTypeCert.certid = certid tAccountTypeCert.flag = flag var url = '$&#123;ctp&#125;/servicectrl/type/update_type_cert' var data = tAccountTypeCert $.getJSON(url, data, function(result) &#123; log(result) &#125;) &#125;) &#125; var __main = function() &#123; update_type_cert_event() &#125; &lt;/script&gt;&lt;/body&gt; 控制层： 1)接收异步传参实体返回json 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.atguigu.scw.manager.controller.manager;import java.util.Arrays;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import com.atguigu.scw.manager.bean.TAccountTypeCert;import com.atguigu.scw.manager.bean.TCert;import com.atguigu.scw.manager.service.CertService;import com.atguigu.scw.manager.service.CertTypeService;import com.fasterxml.jackson.databind.ObjectMapper;@Controller@RequestMapping("/servicectrl/type")public class TypeController &#123; @Autowired CertService certService; @Autowired CertTypeService cTypeService; private static ObjectMapper MAPPER = new ObjectMapper(); @RequestMapping("/ctrl") public String list(Model model) throws Exception &#123; System.out.println("分类管理界面============&gt;"); // 1、先去数据库查出表格横向的显示数据 List&lt;String&gt; types = Arrays.asList("商业公司", "个体工商户", "个人经营", "政府及非营利组织"); // 2、在查出纵向要显示的标题 List&lt;TCert&gt; certs = certService.getAllCert(); System.out.println("资质===========&gt;"); System.out.println(certs); // 3、查询经营类型与资质关系中间表 // List&lt;TAccountTypeCert&gt; cTypeService.getAllCertType(); List&lt;TAccountTypeCert&gt; list_type_cert = cTypeService.getAllCertType(); System.out.println("经营类型===============&gt;"); System.out.println(list_type_cert); // 4、将数据放到模型域当中 model.addAttribute("types", types); model.addAttribute("certs", certs); // list转json字符串 String list_type_cert_json = MAPPER.writeValueAsString(list_type_cert); System.out.println("经营类型--资质----"); System.out.println(list_type_cert_json); model.addAttribute("list_type_cert_json", list_type_cert_json); return "manager/servicemanager/type"; &#125; @RequestMapping("/update_type_cert") @ResponseBody public String update_type_cert(TAccountTypeCert tAccountTypeCert) &#123; System.out.println("更新经营类型---资质==========&gt;"); System.out.println(tAccountTypeCert); boolean flag = tAccountTypeCert.isFlag(); System.out.println("flag============&gt;"); System.out.println(flag); if (flag) &#123; System.out.println("增加一条记录========&gt;"); int count = cTypeService.updateTypeCert(tAccountTypeCert); &#125; else &#123; System.out.println("移除一条记录========&gt;"); cTypeService.removeTypeCert(tAccountTypeCert); &#125; return "success"; &#125;&#125; 业务层： 1）单表的写读操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.atguigu.scw.manager.service.impl;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.atguigu.scw.manager.bean.TAccountTypeCert;import com.atguigu.scw.manager.bean.TAccountTypeCertExample;import com.atguigu.scw.manager.bean.TAccountTypeCertExample.Criteria;import com.atguigu.scw.manager.dao.TAccountTypeCertMapper;import com.atguigu.scw.manager.service.CertTypeService;@Servicepublic class CertTypeServiceImpl implements CertTypeService &#123; @Autowired TAccountTypeCertMapper mapper; //查询资质和账户中间表 @Override public List&lt;TAccountTypeCert&gt; getAllCertType() &#123; List&lt;TAccountTypeCert&gt; list_type_cert = mapper.selectByExample(null); return list_type_cert; &#125; // 增加经营类型--资质 @Override public int updateTypeCert(TAccountTypeCert tAccountTypeCert) &#123; int count = mapper.insertSelective(tAccountTypeCert); return count; &#125; // 删除经营类型--资质 @Override public int removeTypeCert(TAccountTypeCert tAccountTypeCert) &#123; TAccountTypeCertExample example = new TAccountTypeCertExample(); Criteria criteria = example.createCriteria(); criteria.andAccttypeEqualTo(tAccountTypeCert.getAccttype()); criteria.andCertidEqualTo(tAccountTypeCert.getCertid()); int count = mapper.deleteByExample(example); return count; &#125;&#125; 2、mysql插入中文乱码 1）数据库编码和web.xml配置均为utf-8，Controller读取到的是正确的中文，但是保存到数据库后变成”??” 解决 12&lt;property name="url" value="jdbc:mysql://localhost:3306/scw_0325?useUnicode=true&amp;amp;characterEncoding=UTF-8" &gt;&lt;/property&gt;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ztree树形结构菜单_mybatis分页查询]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F10%2Fztree%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E8%8F%9C%E5%8D%95_mybatis%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[1、二级树形菜单 效果图 表结构 业务层： 二级菜单实现思路： 1）查出父菜单（pid=0），通过遍历父菜单获得父菜单(id)，根据父菜单id值作为条件查出子菜单（子菜单pid=父菜单id），接着整理父子菜单关系；这种不推荐，假如所有菜单为18个，查出父菜单3个封装到集合时需要遍历18次，根据父菜单id作为查询子菜单的条件需要遍历3*18次。 2）一次性查出所有菜单18个，使用程序进行组合，这种推荐，以空间换时间。 封装菜单实体 业务层： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public List&lt;TPermission&gt; getAllMenus() &#123; // 保存父菜单 List&lt;TPermission&gt; menus = new ArrayList&lt;TPermission&gt;(); Map&lt;Integer, TPermission&gt; map = new HashMap&lt;Integer, TPermission&gt;(); // 查询所有菜单 // 参数为null，表示不带条件查询菜单 List&lt;TPermission&gt; list = mapper.selectByExample(null); System.out.println("所有菜单=========&gt;"); System.out.println(list); // 1、将所有菜单都放在map中 // 都是引用，如果从map中拿到这个数据改变以后，map中页面变化 for (TPermission tPermission : list) &#123; map.put(tPermission.getId(), tPermission); &#125; // 2、先封装父菜单，再将子菜单放入到父菜单中 for (TPermission tPermission : list) &#123; if (tPermission.getPid() == 0) &#123; menus.add(tPermission); &#125; else &#123; // tPermission（子菜单），拿到父菜单 Integer pid = tPermission.getPid(); // 拿到父菜单；以pid的值作为map中的菜单id，就是父菜单 TPermission p_menu = map.get(pid); // 拿到当前父菜单的子菜单；子菜单会有一些额外的问题 // 这个list第一次获取是没有的，如果添加上一次以后。这个list是有的 List&lt;TPermission&gt; childs = p_menu.getChilds(); if (childs != null) &#123; // 当前有子菜单 childs.add(tPermission); &#125; else &#123; // 当前没有子菜单 childs = new ArrayList&lt;&gt;(); // 添加当前子菜单 childs.add(tPermission); // 将当前整理好的childs设置进去 p_menu.setChilds(childs); &#125; &#125; &#125; System.out.println("父菜单===========&gt;"); System.out.println(menus); return menus;&#125; 控制层 1）将整理好的父子菜单数据放入到session域中，当前用户的这次会话一直使用，只需要去数据库查询一次 12345678910111213141516171819202122232425@RequestMapping(value = "/main.html")public String toMainPage(HttpSession session) &#123; // 校验 // 判断session中是否有这个用户，如果没有去登陆页面 Object object = session.getAttribute(Constants.LOGIN_USER); if (object == null) &#123; // 用户没登陆 return "redirect:/login.jsp"; &#125; else &#123; // 用户登陆才来到主页，session中没有菜单，或者菜单被我们从session中清除了 if (session.getAttribute(Constants.USER_MENUS) == null) &#123; // 1、查出所有菜单，在页面进行显示 List&lt;TPermission&gt; menus = ps.getAllMenus(); // 2、将查到的菜单放在session域中 // 菜单这些数据没必要每次来到主页，都调用service方法进行查询；放在session用户， // 当前用户的这次会话一直使用，只需要去数据库查一次 session.setAttribute(Constants.USER_MENUS, menus); &#125; return "manager/main"; &#125;&#125; 前台： 1）引入：&lt;%@ taglib prefix=”fn” uri=”http://java.sun.com/jsp/jstl/functions&quot;%&gt;计算后台传过来的list集合的长度：${fn:length(p_menu.childs)} 123456789101112131415161718192021222324252627&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions"%&gt;&lt;div class="col-sm-3 col-md-2 sidebar"&gt; &lt;div class="tree"&gt; &lt;ul style="padding-left: 0px;" class="list-group"&gt; &lt;li class="list-group-item tree-closed"&gt;&lt;a href="main.html"&gt;&lt;i class="glyphicon glyphicon-dashboard"&gt;&lt;/i&gt; 控制面板&lt;/a&gt;&lt;/li&gt; &lt;!-- 遍历父菜单 --&gt; &lt;c:forEach items="$&#123;sessionScope.userMenus&#125;" var="p_menu"&gt; &lt;li class="list-group-item tree-closed"&gt;&lt;span&gt;&lt;i class="$&#123;p_menu.icon&#125;"&gt;&lt;/i&gt;$&#123;p_menu.name&#125; &lt;span class="badge" style="float: right"&gt;$&#123;fn:length(p_menu.childs)&#125;&lt;/span&gt;&lt;/span&gt; &lt;ul style="margin-top: 10px; display: none;"&gt; &lt;!-- 遍历子菜单 --&gt; &lt;c:forEach items="$&#123;p_menu.childs&#125;" var="c_menu"&gt; &lt;li style="height: 30px;"&gt;&lt;a href="$&#123;ctp&#125;/$&#123;c_menu.url&#125;" data-action="$&#123;c_menu.id&#125;"&gt;&lt;i class="$&#123;c_menu.icon&#125;"&gt;&lt;/i&gt;$&#123;c_menu.name&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:forEach&gt; &lt;/ul&gt;&lt;/li&gt; &lt;/c:forEach&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 2、mybatis分页查询 根据用户名或者账号进行查询 效果图： 引入依赖： 123456&lt;!-- 分页 插件 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;&lt;/dependency&gt; 业务层： 1）带条件查询 123456789101112131415161718@Overridepublic List&lt;TUser&gt; getAllUsersByCondition(String str) &#123; System.out.println("UserServiceImpl.getAllUsersByCondition 带条件查询员工============&gt;"); // 查询条件拼接 // 第一次创建的条件，默认使用and连接的 TUserExample tUserExample = new TUserExample(); Criteria criteria = tUserExample.createCriteria(); Criteria criteria2 = tUserExample.createCriteria(); if (!str.trim().equals("")) &#123; criteria.andLoginacctLike("%" + str + "%"); criteria.andUsernameLike("%" + str + "%"); &#125; tUserExample.or(criteria2); List&lt;TUser&gt; list_users_example = userMapper.selectByExample(tUserExample); return list_users_example;&#125; 控制层： 1）mybatis分页插件会对结果集进行包装，必须在查询前设置： PageHelper.startPage(pn, ps); 2）查询后输入框数据回显：model.addAttribute(“sp”, search);（转发） 1234567891011121314151617181920212223242526@RequestMapping("/list")public String users(@RequestParam(value = "pn", defaultValue = "1") Integer pn, @RequestParam(value = "ps", defaultValue = "5") Integer ps, @RequestParam(value = "sp", defaultValue = "") String search, Model model) &#123; System.out.println("UserController.users 用户列表显示页===========&gt;"); System.out.println("前台请求参数[第xxx页，每页显示xxx条数]==========&gt;"); System.out.println(pn); System.out.println(ps); // 分页显示数据,这里设置必须放到查询数据之前，否则前台会有问题 PageHelper.startPage(pn, ps); List&lt;TUser&gt; list_users = userService.getAllUsersByCondition(search); System.out.println("查询到的所有用户列表========&gt;"); System.out.println(list_users); PageInfo&lt;TUser&gt; users = new PageInfo&lt;&gt;(list_users, 5); System.out.println("分页后的数据处理"); System.out.println(users); // 将查询用户列表数据放在请求域中，表单查询参数回显到页面 model.addAttribute("users", users); model.addAttribute("sp", search); return "manager/permission/user";&#125; 前台： 1）为所有分页连接绑定单击事件，让其动态的带上分页的查询参数 123var href = $(this).attr("href") + "&amp;sp="+ $("input[name='sp']").val()&lt;br/&gt;$(this).attr("href", href) 2)全选和全不选函数 1234567891011121314//全选/全不选函数function checkall_reverse(check_all_btn, check_btn) &#123; check_all_btn.click(function() &#123; //如果是原生的属性，使用prop获取比较好 check_btn.prop("checked", $(this).prop("checked")) &#125;) check_btn.click(function() &#123; //当check_btn点满以后check_all_btn勾上，否则不选中 //获取被选中的checkbtn个数 var flag = check_btn.filter(":checked").length == check_btn.length check_all_btn.prop("checked", flag); &#125;)&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html lang="UTF-8"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;&lt;meta name="description" content=""&gt;&lt;meta name="author" content=""&gt;&lt;%@include file="/WEB-INF/includes/css-file.jsp"%&gt;&lt;link rel="stylesheet" href="$&#123;ctp&#125;/css/main.css"&gt;&lt;style&gt;.tree li &#123; list-style-type: none; cursor: pointer;&#125;table tbody tr:nth-child(odd) &#123; background: #F4F4F4;&#125;table tbody td:nth-child(even) &#123; color: #C00;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;% //设置导航条上的显示 pageContext.setAttribute("navinfo", "用户维护"); //设置点击高亮效果 pageContext.setAttribute("curUrl", "permission/user/list"); %&gt; &lt;!-- 引入navbar--&gt; &lt;%@include file="/WEB-INF/includes/nav-bar.jsp"%&gt;&lt;/nav&gt; &lt;div class="container-fluid"&gt; &lt;div class="row"&gt; &lt;!-- 引入树形菜单 --&gt; &lt;%@include file="/WEB-INF/includes/user_menu.jsp"%&gt; &lt;div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main"&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt; &lt;i class="glyphicon glyphicon-th"&gt;&lt;/i&gt; 数据列表 &lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;form class="form-inline" role="form" style="float: left;" action="$&#123;ctp &#125;/permission/user/list" method="post"&gt; &lt;div class="form-group has-feedback"&gt; &lt;div class="input-group"&gt; &lt;div class="input-group-addon"&gt;查询条件&lt;/div&gt; &lt;input class="form-control has-success" type="text" name="sp" placeholder="用户名/账号查询" value="$&#123;sp&#125;"&gt; &lt;/div&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-warning"&gt; &lt;i class="glyphicon glyphicon-search"&gt;&lt;/i&gt; 查询 &lt;/button&gt; &lt;/form&gt; &lt;button type="button" class="btn btn-danger" style="float: right; margin-left: 10px;"&gt; &lt;i class=" glyphicon glyphicon-remove"&gt;&lt;/i&gt; 删除 &lt;/button&gt; &lt;button type="button" class="btn btn-primary" style="float: right;" onclick="window.location.href='add.html'"&gt; &lt;i class="glyphicon glyphicon-plus"&gt;&lt;/i&gt; 新增 &lt;/button&gt; &lt;br&gt; &lt;hr style="clear: both;"&gt; &lt;div class="table-responsive"&gt; &lt;table class="table table-bordered"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th width="30"&gt;#&lt;/th&gt; &lt;th width="30"&gt;&lt;input type="checkbox" id="checkall_btn"&gt;&lt;/th&gt; &lt;th&gt;账号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;邮箱地址&lt;/th&gt; &lt;th width="100"&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items="$&#123;users.list&#125;" var="user"&gt; &lt;tr&gt; &lt;td&gt;$&#123;user.id&#125;&lt;/td&gt; &lt;td&gt;&lt;input type="checkbox" class="single_check"&gt;&lt;/td&gt; &lt;td&gt;$&#123;user.loginacct &#125;&lt;/td&gt; &lt;td&gt;$&#123;user.username &#125;&lt;/td&gt; &lt;td&gt;$&#123;user.email &#125;&lt;/td&gt; &lt;td&gt; &lt;button type="button" class="btn btn-success btn-xs"&gt; &lt;i class=" glyphicon glyphicon-check"&gt;&lt;/i&gt; &lt;/button&gt; &lt;button type="button" class="btn btn-primary btn-xs"&gt; &lt;i class=" glyphicon glyphicon-pencil"&gt;&lt;/i&gt; &lt;/button&gt; &lt;button type="button" class="btn btn-danger btn-xs"&gt; &lt;i class=" glyphicon glyphicon-remove"&gt;&lt;/i&gt; &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td colspan="6" align="center"&gt; &lt;ul class="pagination"&gt; &lt;!-- 即使点击分页连接也应该带上查询条件的值 --&gt; &lt;!-- 给分页超链接绑定单击事件； --&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=1"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;!-- 是否还有前一页 --&gt; &lt;c:if test="$&#123;users.hasPreviousPage&#125;"&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;users.prePage&#125;"&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;!-- 遍历页数 --&gt; &lt;c:forEach items="$&#123;users.navigatepageNums&#125;" var="pn"&gt; &lt;!-- 当前页 --&gt; &lt;c:if test="$&#123;pn==users.pageNum &#125;"&gt; &lt;li class="active"&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;pn&#125;"&gt;$&#123;pn&#125;&lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;c:if test="$&#123;pn != users.pageNum &#125;"&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;pn&#125;"&gt;$&#123;pn &#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;!--是否还有下一页 --&gt; &lt;c:if test="$&#123;users.hasNextPage&#125;"&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;users.nextPage&#125;"&gt;下一页&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;li&gt;&lt;a href="$&#123;ctp&#125;/permission/user/list?pn=$&#123;users.pages&#125;"&gt;末页&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%@include file="/WEB-INF/includes/js-file.jsp"%&gt; &lt;!-- 引入树形菜单结构点击时动态显示页面高亮效果的js --&gt; &lt;%@include file="/WEB-INF/includes/common-js.jsp"%&gt; &lt;script type="text/javascript"&gt; $(function() &#123; $(".list-group-item").click(function() &#123; if ($(this).find("ul")) &#123; $(this).toggleClass("tree-closed"); if ($(this).hasClass("tree-closed")) &#123; $("ul", this).hide("fast"); &#125; else &#123; $("ul", this).show("fast"); &#125; &#125; &#125;); &#125;); $("tbody .btn-success").click(function() &#123; window.location.href = "assignRole.html"; &#125;); $("tbody .btn-primary").click(function() &#123; window.location.href = "edit.html"; &#125;); //当前页面所在的哪个超链接是color:red //他的父list-group-item. tree-closed是没有的 //找到当前页面的a连接 //使用css为某个元素加样式 list-group-item //为所有分页连接绑定单击事件，让其动态的带上分页的查询参数 $(".pagination").find("a").click( function() &#123; //1、获取到查询表单的查询参数 //不禁用默认行为，而是为超链接多拼装上查询条件 //为超链接动态拼装查询条件 var href = $(this).attr("href") + "&amp;sp=" + $("input[name='sp']").val() $(this).attr("href", href) &#125;) //这是调用了抽取过来的方法； checkall_reverse($("#checkall_btn"), $(".single_check")) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>ztree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svn版本控制]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F09%2Fsvn%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1、svn下载 https://sourceforge.net/projects/win32svn/ 2、验证是否安装成功 12C:\Users\libingshen&gt;svn --version 3、创建版本库 12D:\mytest\mysvn\OA&gt;svnadmin create D:\mytest\mysvn\OA 4、启动svn服务 5、验证svn服务是否启动 svn服务监听3690端口 6、svn注册为Windows服务 tip:等号左边没有空格，等号右边有一个空格。 12C:\WINDOWS\system32&gt;sc create MySVNService binpath= &quot;C:\Pmyprogram\svn\bin\svnserve.exe --service -r D:\mytest\mysvn&quot; start= auto depend= Tcpip 原因：每次启动svn服务时必须启动一个cmd窗口，cmd窗口一关闭，svn服务就关闭。 非管理员运行时会失败。 管理员运行 启动、停止、删除svn服务（管理员身份运行cmd） 123456789//启动svn服务C:\WINDOWS\system32&gt;sc start MySVNService//停止服务C:\WINDOWS\system32&gt;sc stop MySVNService//删除服务C:\WINDOWS\system32&gt;sc delete MySVNService 7、检出项目 12D:\mytest\mycheckout&gt;svn checkout svn://localhost/OA MyOA 8、提交文件 –开启匿名权限访问 –先将文件加入版本库，然后提交（需添加提交日志信息，不然报错） svn commit 命令最后可以不指定具体文件，此时表示提交当前工作副本中的所有修改 9、更新 另一个客户端检出项目、更新并提交文件 1234//远程版本库具体位置 svn://localhost/OA//将OA检出到本地的目录 MyOA2D:\mytest\mycheckout&gt;svn checkout svn://localhost/OA MyOA2 10、授权访问版本库 –单版本库开启授权访问 –多版本库开启授权访问 123456在版本库根目录 D:\mytest\mysvn 下创建 commConf 目录将未修改的 authz 和 passwd 文件拷贝到 commConf 目录下修改需要设置权限的版本库的 svnserve.conf 文件①password-db = ../../commConf/passwd②authz-db = ../../commConf/authz passwd：设置访问版本库的用户信息 authz：设置用户访问版本库的权限]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc配置]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F07%2Fspringmvc%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1、springmvc路径跳转配置 目录结构 控制层 123456789101112131415161718192021&lt;!-- 使用注解开发，不用配置controller，需要配置一个组件扫描器 --&gt;&lt;context:component-scan base-package="com.*" /&gt;&lt;!-- 视图解析器 --&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置从项目根目录到指定目录一端路径 ,建议指定浅一点的目录 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"&gt;&lt;/property&gt; &lt;!-- 文件的后缀名 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--将index2.jsp放在/WEB-INF/jsp/目录下，请求index2时不经过controller处理;配置了mvc:view-controller后需要配置mvc:annotation-driven,不然走controller的请求会失效 --&gt;&lt;mvc:view-controller path="/index2" view-name="index2" /&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;!--处理静态资源 --&gt;&lt;mvc:default-servlet-handler/&gt; index.jsp 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page language="java" contentType="text/html; charset=ISO-8859-1" pageEncoding="ISO-8859-1"%&gt;&lt;%@ taglib uri="http://java.sun.com/jstl/core_rt" prefix="c"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="ISO-8859-1"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;% request.setAttribute("path", request.getContextPath());%&gt;&lt;/head&gt;&lt;body&gt; //走controller跳转 &lt;a href="hello"&gt;go controller&lt;/a&gt; &lt;br&gt; //不走controller跳转，在springmvc配置文件中配置了mvc-view;index2.jsp页面需放在/WEB-INF/jsp/目录下 &lt;a href="index2"&gt;not go controller&lt;/a&gt; &lt;br/&gt; //加载静态资源 &lt;a href="$&#123;path&#125;/static/index3.jsp"&gt;load static resource index3.jsp&lt;/a&gt; //加载静态资源，需在springmvc配置文件中配置mvc:default-servlet-handler &lt;script type="text/javascript" src="$&#123;path&#125;/ui/jquery/jquery-1.8.3.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function() &#123; console.log("$&#123;path&#125;") &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、springmvc获取请求参数，封装数据到请求域 前台 123456&lt;form action='testParam' method='get'&gt; 用户名：&lt;input type='text' name='username'&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; 控制层 处理方式一：方法参数为Map或者ModelMap类型，数据封装到Map或者Modelmap类型中，其实就是将数据放入到请求域当中 123456789101112@RequestMapping("/testParam")public String testParam(ModelMap modelMap,HttpServletRequest request) &#123; String username = request.getParameter("username"); System.out.println("接收前台发送过来的请求参数=========&gt;用户名："+username); //modelmap会将数据放到请求域当中 modelMap.put("address", "haikou"); //返回视图 return "hello";&#125; 处理方式二：用ModelAndView作为返回值，可以将数据放到请求域中且指定返回的视图 1234567891011@RequestMapping("/testParam")public ModelAndView testParam(HttpServletRequest request) &#123; String username = request.getParameter("username"); System.out.println("接收前台发送过来的请求参数=========&gt;用户名："+username); //参数为返回的视图 ModelAndView hello =new ModelAndView("hello"); hello.addObject("address", "haikou"); return hello;&#125; 前台获取 1234&lt;!-- 获取后台封装在请求域中的数据 --&gt;地址：$&#123;requestScope.address&#125;&lt;br/&gt;&lt;%=request.getAttribute(&quot;address&quot;)%&gt; 3、springmvc处理文件上传 springmvc.xml增加如下配置 1234567&lt;!--文件上传 --&gt;&lt;bean name="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="defaultEncoding" value="UTF-8"&gt;&lt;/property&gt; &lt;property name="maxUploadSize" value="10240000"&gt;&lt;/property&gt;&lt;/bean&gt; 前台表单提交 123456//必须是post请求，且enctype='multipart/form-data'&lt;form action='testFileUpload' method='post' enctype='multipart/form-data'&gt; 文件：&lt;input type='file' name='file' &gt;&lt;br/&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; 控制层 12345678910@RequestMapping("/testFileUpload")public String testFileUpload(@RequestParam("file")MultipartFile file) throws IOException &#123; //获取文件名 String fileName=file.getOriginalFilename(); //获取流，即可取得内容 InputStream in=file.getInputStream(); System.out.println("文件名===========&gt;"+fileName); return "hello";&#125; 4、springmvc返回json数据 pom.xml加入依赖 12345678910111213141516171819&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; 控制层 12345678910//需要加@ResponseBody注解@RequestMapping("/testJson")@ResponseBodypublic Map testFileUpload() &#123; Map&lt;String, Object&gt; map=new HashMap&lt;&gt;(); map.put("username", "沈利兵"); map.put("sex", "男"); return map;&#125;]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my_en]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F06%2Fmy_en%2F</url>
    <content type="text"><![CDATA[###2018/12/14 12345678910111213141516171819202122232425262728293031323334353637383940414243eviction --赶出thorough --彻底fixed --固定notifications --通知traverse graphs --遍历图covers --覆盖block --阻塞Redis Releases --Redis 发布Benchmarks --基准Latency monitoring --延迟监控tune --调整High Availability --高可用性Signals Handling --信号处理Administration --管理troubleshoot --解决Troubleshooting --故障排除command line interface --命令行界面durability --持久力Credits --积分Sponsors --赞助商Trademark --商标Lexicographical order --字典顺序populated --填充reply --答复、回复indicating --指示、说明penultimate --倒数第二treat --对待、视其为abstractions --抽象separately --单独、分别地retrieve --检索、取出bitmaps --位图probabilistic --概率estimate --估计cardinality --基数scared --害怕trivial --不重要的、微不足道的crash course --速成班specification --规范Prerequisites --先决条件clause --条款、子句omit --忽略semantics --语义 ###20181215 参考https://tylermcginnis.com/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/ 123456789101112131415161718192021222324252627opinion --观点properly --正确地strategy --策略interpret --解释authoring --创作form --形式consist of --包括responsibilities --责任spot --点、发现key --关键phases --阶段deserve --值得cement --巩固Hoisting --提升exactly identical --完全相同fairly comfortable --相当熟悉adapt --调整、适应Set up memory space --设置内存空间Execution Stack --执行堆栈Call Stack --调用堆栈intuition --直觉scenario --脚本misunderstood --误解Implicit Binding --隐式绑定Explicit Binding --显示绑定Lexical Binding --词法绑定 ###20181217 参考 https://dev.to/siwalik/async-programming-basics-every-js-developer-should-know-in-2018-a9c 123hence --于是imensely --非常 ###20190117 参考： https://docs.python.org/3/library/stdtypes.html#comparisons 123456Comparisons --比较Comparisons can be chained arbitrarily --比较可以任意连接negated --否定notion --概念、主张raise --养、引发 https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range 12345678ascending --升序restrictions --限制imposed --加强lexicographically --字典顺序multidimensional list --多维列表Immutable Sequence Types --不可变序列类型slice --切片]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>english</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven配置]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F05%2Fmaven%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1、下载： https://maven.apache.org/download.cgi 2、配置path环境变量 3、验证安装是否成功 4、配置本地仓库、阿里镜像、jdk编译版本 配置本地仓库位置 12&lt;localRepository&gt;C:\greensoft\apache-maven-3.5.2\repository&lt;/localRepository&gt; 配置jar包下载阿里远程镜像 1234567&lt;mirror&gt; &lt;id&gt;aliyun-maven&lt;/id&gt; &lt;name&gt;aliyun-maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 配置jdk编译版本 12345678910111213&lt;profile&gt; &lt;id&gt;jdk-1.7&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.7&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 5、eclipse整合maven 使用自己的maven安装包 6、IDEA整合maven]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js面向对象_箭头函数this_数组常用方法]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F04%2Fjs%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this_%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、js面向对象 1)传统的面向对象 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function Person(name, age)&#123; this.name=name; this.age=age; &#125; Person.prototype.showName=function ()&#123; alert('我叫'+this.name); &#125;; Person.prototype.showAge=function ()&#123; alert('我'+this.age+'岁'); &#125;; let p=new Person('blue', 18); p.showName(); p.showAge(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function Person(name, age)&#123; this.name=name; this.age=age; &#125; Person.prototype.showName=function ()&#123; alert('我叫'+this.name); &#125;; Person.prototype.showAge=function ()&#123; alert('我'+this.age+'岁'); &#125;; //------------------------------------------------ function Worker(name, age, job)&#123; //通过call调用父类构造函数 Person.call(this, name, age); this.job=job; &#125; //使得子类实例对象共享父类原型对象上的方法 Worker.prototype=new Person(); //重写子类原型对象的构造，特别恶心 Worker.prototype.constructor=Worker; Worker.prototype.showJob=function ()&#123; alert('我是做：'+this.job); &#125;; let w=new Worker('blue', 18, '打杂的'); w.showName(); w.showAge(); w.showJob(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2）js标准的面向对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /*function Person(name, age)&#123; this.name=name; this.age=age; &#125; Person.prototype.showName=function ()&#123; alert('我叫'+this.name); &#125;; Person.prototype.showAge=function ()&#123; alert('我'+this.age+'岁'); &#125;;*/ //标准面向对象书写方式 class Person&#123; constructor(name, age)&#123; this.name=name; this.age=age; &#125; showName()&#123; alert('我叫'+this.name); &#125; showAge()&#123; alert('我'+this.age+'岁'); &#125; &#125; let p=new Person('blue', 18); p.showName(); p.showAge(); //------------------------------------------------ function Worker(name, age, job)&#123; Person.call(this, name, age); this.job=job; &#125; Worker.prototype=new Person(); Worker.prototype.constructor=Worker; Worker.prototype.showJob=function ()&#123; alert('我是做：'+this.job); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 标准的继承方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; /*function Person(name, age)&#123; this.name=name; this.age=age; &#125; Person.prototype.showName=function ()&#123; alert('我叫'+this.name); &#125;; Person.prototype.showAge=function ()&#123; alert('我'+this.age+'岁'); &#125;;*/ //标准面向对象书写方式 class Person&#123; constructor(name, age)&#123; this.name=name; this.age=age; &#125; showName()&#123; alert('我叫'+this.name); &#125; showAge()&#123; alert('我'+this.age+'岁'); &#125; &#125; /*let p=new Person('blue', 18); p.showName(); p.showAge();*/ //------------------------------------------------ /*function Worker(name, age, job)&#123; Person.call(this, name, age); this.job=job; &#125; Worker.prototype=new Person(); Worker.prototype.constructor=Worker; Worker.prototype.showJob=function ()&#123; alert('我是做：'+this.job); &#125;;*/ //标准继承方式，子类通过extends实例化的子类可以访问到父类原型对象的方法 class Worker extends Person&#123; constructor(name, age, job)&#123; //super-超类(父类)，可以访问到构造方法，不需要通过call的方式调用 super(name, age); this.job=job; &#125; showJob()&#123; alert('我是做：'+this.job); &#125; &#125; let w=new Worker('blue', 18, '打杂的'); w.showName(); w.showAge(); w.showJob(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2、箭头函数this 普通函数：根据调用我的人 this老变 箭头函数：根据所在的环境 this恒定 bind——给函数定死一个this 例1： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr = [1, 2, 3]; //箭头函数所处的环境是window arr.a = () =&gt; &#123; console.log(this); &#125;; arr.a(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 输出 例2： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; document.onclick=function ()&#123; let arr=[1,2,3]; //箭头函数所处的环境是document arr.a=()=&gt;&#123; console.log(this); &#125;; arr.a(); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 输出 例3： 箭头函数所处的环境是document，尽管通过bind绑定死了12，但还是输出document，说明箭头函数的this优先级高于bind方式绑定的this 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; document.onclick=function ()&#123; let a=()=&gt;&#123; console.log(this); &#125;; let oBtn=document.getElementById('btn1'); oBtn.onclick=a.bind(12); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="button" value="aaa" id="btn1"&gt; &lt;/body&gt;&lt;/html&gt; 输出 3、数组常用方法 1）map 映射 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[62, 55, 82, 37, 26]; let arr2=arr.map(function (item)&#123; if(item&gt;=60)&#123; return true; &#125;else&#123; return false; &#125; &#125;); //true,false,true,false,false alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 改进1 map参数：回调函数使用箭头函数书写方式 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[62, 55, 82, 37, 26]; let arr2=arr.map((item)=&gt;&#123; if(item&gt;=60)&#123; return true; &#125;else&#123; return false; &#125; &#125;); alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 改进2 如果有且仅有1个参数，()可以省 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[62, 55, 82, 37, 26]; let arr2=arr.map(item=&gt;&#123; if(item&gt;=60)&#123; return true; &#125;else&#123; return false; &#125; &#125;); alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 改进3 如果函数体只有一句话，而且是return，{}可以省 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[62, 55, 82, 37, 26]; let arr2=arr.map(item=&gt;item&gt;=60); alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2）filter过滤 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[12,5,88,37,21,91,17,24]; let arr2=arr.filter(item=&gt;item%2); //5,37,21,91,17 alert(arr2); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 3）forEach 遍历 求和 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[12,5,88,37,21,91,17,24]; let sum=0; arr.forEach(item=&gt;&#123; sum+=item; &#125;); //结果295 alert(sum); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 4）reduce 汇总 参数 tmp:中间结果 item：元素项 index：元素索引 求和 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[12,5,88,37,21,91,17,24]; let sum=arr.reduce((tmp,item,index)=&gt;&#123; console.log(tmp, item, index); return tmp+item; &#125;); console.log(sum); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 输出 求平均 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; let arr=[12,5,88,37,21,91,17,24]; let sum=arr.reduce((tmp,item,index)=&gt;&#123; return tmp+item; &#125;); //结果36.875 console.log(sum/arr.length); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 5）from 将类数组转换成数组 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style media="screen"&gt; div &#123;width:200px; height:200px; background:#CCC; float:left; margin:10px;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; //DOM对象 let aDiv=document.getElementsByTagName('div'); console.log(aDiv); //数组 let aDiv2=Array.from(aDiv); console.log(aDiv2); Array.from(aDiv).forEach(div=&gt;&#123; div.style.background='yellow'; &#125;); Array.prototype.slice.call(aDiv).forEach(div=&gt;&#123; div.style.background='blue'; &#125;); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;div class=""&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 输出]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js开发者经常忽略的基础知识点]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F03%2Fjs%E5%BC%80%E5%8F%91%E8%80%85%E7%BB%8F%E5%B8%B8%E5%BF%BD%E7%95%A5%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1、字符串匹配 匹配所有 1234567891011// Mistake// 踩到坑了var str = "David is an Arsenal fan, which means David is great";str.replace("David", "Darren");// "Darren is an Arsenal fan, which means David is great"// Desired// 符合预期str.replace(/David/g, "Darren");// "Darren is an Arsenal fan, which means Darren is great" 忽略大小写 123str.replace(/david/gi, "Darren");// "Darren will always be an Arsenal fan, which means Darren will always be great" 2、将“类数组”元素（比如 arguments 参数列表、节点列表和属性列表）转换成真正的数组 12345678var nodesArr = Array.prototype.slice.call(document.querySelectorAll("div"));// "true" array of DIVs// 得到一个由 div 元素组成的“真正的”数组var argsArr = Array.prototype.slice.call(arguments);// changes arguments to "true" array// 把 arguments 转换成一个“真正的”数组 克隆数组 1234var clone = myArray.slice(0);// naive clone// 浅克隆 3、数组的sort方法 简单排序 1234[1, 3, 9, 2].sort();// Returns: [1, 2, 3, 9]// 返回 [1, 2, 3, 9] 复杂排序 12345678910111213141516[ &#123; name: "Robin Van PurseStrings", age: 30 &#125;, &#123; name: "Theo Walcott", age: 24 &#125;, &#123; name: "Bacary Sagna", age: 28 &#125;].sort(function(obj1, obj2) &#123; // Ascending: first age less than the previous // 实现增序排列：前者的 age 小于后者 return obj1.age - obj2.age;&#125;); // Returns: // [ // &#123; name: "Theo Walcott", age: 24 &#125;, // &#123; name: "Bacary Sagna", age: 28 &#125;, // &#123; name: "Robin Van PurseStrings", age: 30 &#125; // ] 4、push合并数组 1234567var mergeTo = [4,5,6];var mergeFrom = [7,8,9];Array.prototype.push.apply(mergeTo, mergeFrom);mergeTo; // is: [4, 5, 6, 7, 8, 9] 5、join拼接字符串 1234567var str = [ '&lt;div&gt;', '&lt;button id="lucky-draw"&gt;Lucky Draw&lt;/button&gt;', '&lt;/div&gt;'].join('')log(str) 参考 https://github.com/cssmagic/blog/issues/21]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Inheritance and the Prototype Chain]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F02%2FJavaScript%20Inheritance%20and%20the%20Prototype%20Chain%2F</url>
    <content type="text"><![CDATA[参考： https://tylermcginnis.com/javascript-inheritance-and-the-prototype-chain/ ##JavaScript Inheritance and the Prototype Chain Post This post is designed to be read after you read JavaScript Private and Public Class Fields. Previously we learned how to create an Animal class both in ES5 as well as in ES6. We also learned how to share methods across those classes using JavaScript’s prototype. To review, here’s the code we saw in an earlier post. 12345678910111213141516171819202122function Animal (name, energy) &#123; this.name = name this.energy = energy&#125;Animal.prototype.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Animal.prototype.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Animal.prototype.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125;const leo = new Animal(&apos;Leo&apos;, 7) 123456789101112131415161718192021class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep() &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play() &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;const leo = new Animal(&apos;Leo&apos;, 7) Now let’s say we wanted to start making individual classes for specific animals. For example, what if we wanted to start making a bunch of dog instances. What properties and methods will these dogs have? Well, similar to our Animal class, we could give each dog a name, an energy level, and the ability to eat, sleep, and play. Unique to our Dog class, we could also give them a breed property as well as the ability to bark. In ES5, our Dog class could look something like this 12345678910111213141516171819202122232425262728function Dog (name, energy, breed) &#123; this.name = name this.energy = energy this.breed = breed&#125;Dog.prototype.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Dog.prototype.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Dog.prototype.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125;Dog.prototype.bark = function () &#123; console.log(&apos;Woof-Woof!&apos;) this.energy -= .1&#125;const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;) Alright, well… we just recreated the Animal class and added a few new properties to it. If we wanted to create another animal, say a Cat, at this point we’d again have to create a Cat class, duplicate all the common logic located in the Animal class to it, then add on Cat specific properties just like we did with the Dog class. In fact, we’d have to do this for each different type of animal we created. 12345678function Dog (name, energy, breed) &#123;&#125;function Cat (name, energy, declawed) &#123;&#125;function Giraffe (name, energy, height) &#123;&#125;function Monkey (name, energy, domesticated) &#123;&#125; This work, but it seems wasteful. The Animal class is the perfect base class. What that means is that it has all the properties that each one of our animals has in common. Whether we’re creating a dog, cat, giraffe, or monkey, all of them will have a name, energy level, and the ability to eat, sleep, and play. With that said, is there a way we can utilize the Animal class whenever we create the individual classes for each different animal? Let’s try it out. I’ll paste the Animal class again below for easy reference. 123456789101112131415161718192021222324function Animal (name, energy) &#123; this.name = name this.energy = energy&#125;Animal.prototype.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Animal.prototype.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Animal.prototype.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125;function Dog (name, energy, breed) &#123;&#125; What are some things we know about the Dog constructor function above? First, we know it takes 3 arguments, name, energy, and breed. Second, we know it’s going to be called with the new keyword so we’ll have a this object. And third, we know we need to utilize the Animal function so that any instance of dog will have a name, energy level, and be able to eat, sleep, and play. It’s the third one that’s the tricky one. The way you “utilize” a function is by calling it. So we know that inside of Dog, we want to call Animal. What we need to figure out though is how we can invoke Animal in the context of Dog. What that means it that we want to call Animal with the this keyword from Dog. If we do that correctly, then this inside of the Dog function will have all the properties of Animal (name, energy). If you remember from a previous section, every function in JavaScript has a .call method on it. .call() is a method on every function that allows you to invoke the function specifying in what context the function will be invoked. This sounds like exactly what we need. We want to invoke Animal in the context of Dog. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;) charlie.name // Charlie charlie.energy // 10 charlie.breed // Goldendoodle Solid, we’re half-way there. You’ll notice in the code above that because of this line Animal.call(this, name, energy), every instance of Dog will now have a name and energy property. Again, the reason for that is because it’s as if we ran the Animal function with the this keyword generated from Dog. Then after we added a name and energy property to this, we also added a breed property just as we normally would. Remember the goal here is to have each instance of Dog have not only all the properties of Animal, but also all the methods as well. If you run the code above, you’ll notice that if you try to run charlie.eat(10) you’ll get an error. Currently every instance of Dog will have the properties of Animal (name and energy), but we haven’t done anything to make sure that they also have the methods (play, eat, sleep). Let’s think about how we can solve this. We know that all the Animal’s methods are located on Animal.prototype. What that means is we somehow want to make sure that all instances of Dog will have access to the methods on Animal.prototype. What if we used our good friend Object.create here? If you’ll remember, Object.create allows you to create an object which will delegate to another object on failed lookups. So in our case, the object we want to create is going to be Dog’s prototype and the object we want to delegate to on failed lookups is Animal.prototype. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Now, whenever there’s a failed lookup on an instance of Dog, JavaScript will delegate that lookup to Animal.prototype. If this is still a little fuzzy, re-read A Beginner’s Guide to JavaScript’s Prototype where we talk all about Object.create and JavaScript’s prototype. Let’s look at the full code together then we’ll walk through what happens. function Animal (name, energy) { this.name = name this.energy = energy } Animal.prototype.eat = function (amount) { console.log(`${this.name} is eating.`) this.energy += amount } Animal.prototype.sleep = function (length) { console.log(`${this.name} is sleeping.`) this.energy += length } Animal.prototype.play = function (length) { console.log(`${this.name} is playing.`) this.energy -= length } function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Now we’ve created our base class (Animal) as well as our subclass (Dog), let’s see what it looks like under the hood when we create an instance of Dog. const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;) charlie.name // Charlie charlie.energy // 10 charlie.breed // Goldendoodle Nothing fancy so far, but let’s look at what happens when we invoke a method located on Animal. 1234567891011 charlie.eat(10)/*1) JavaScript checks if charlie has an eat property - it doesn&apos;t.2) JavaScript then checks if Dog.prototype has an eat property - it doesn&apos;t.3) JavaScript then checks if Animal.prototype has an eat property - it does so it calls it.*/ The reason Dog.prototype gets checked is because when we created a new instance of Dog, we used the new keyword. Under the hood, the this object that was created for us delegates to Dog.prototype (seen in comments below). function Dog (name, energy, breed) { // this = Object.create(Dog.prototype) Animal.call(this, name, energy) this.breed = breed // return this } The reason Animal.prototype gets checked is because we overwrote Dog.prototype to delegate to Animal.prototype on failed lookups with this line Dog.prototype = Object.create(Animal.prototype) Now one thing we haven’t talked about is what if Dog has its own methods? Well, that’s a simple solution. Just like with Animal, if we want to share a method across all instances of that class, we add it to the function’s prototype. 123456789101112131415...function Dog (name, energy, breed) &#123; Animal.call(this, name, energy) this.breed = breed&#125;Dog.prototype = Object.create(Animal.prototype)Dog.prototype.bark = function () &#123; console.log(&apos;Woof Woof!&apos;) this.energy -= .1&#125; very nice. There’s just one small addition we need to make. If you remember back to the Beginner’s Guide to JavaScript’s Prototype post, we were able to get access to the instances’ constructor function by using instance.constructor. function Animal (name, energy) { this.name = name this.energy = energy } const leo = new Animal(&apos;Leo&apos;, 7) console.log(leo.constructor) // Logs the constructor function As explained in the previous post, “the reason this works is because any instances of Animal are going to delegate to Animal.prototype on failed lookups. So when you try to access leo.prototype, leo doesn’t have a prototype property so it will delegate that lookup to Animal.prototype which indeed does have a constructor property.” The reason I bring this up is because in our implementation, we overwrote Dog.prototype with an object that delegates to Animal.prototype. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&apos;Woof Woof!&apos;) this.energy -= .1 } What that means is that now, any instances of Dog which log instance.constructor are going to get the Animal constructor rather than the Dog constructor. You can see for yourself by running this code - function Animal (name, energy) { this.name = name this.energy = energy } Animal.prototype.eat = function (amount) { console.log(`${this.name} is eating.`) this.energy += amount } Animal.prototype.sleep = function (length) { console.log(`${this.name} is sleeping.`) this.energy += length } Animal.prototype.play = function (length) { console.log(`${this.name} is playing.`) this.energy -= length } function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&apos;Woof Woof!&apos;) this.energy -= .1 } const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;) console.log(charlie.constructor) Notice it gives you the Animal constructor even though charlie is a direct instance of Dog. Again, we can walk through what’s happening here just like we did above. 1234567891011const charlie = new Dog(&apos;Charlie&apos;, 10, &apos;Goldendoodle&apos;)console.log(charlie.constructor)/*1) JavaScript checks if charlie has a constructor property - it doesn&apos;t.2) JavaScript then checks if Dog.prototype has a constructor property - it doesn&apos;t because it was deleted when we overwrote Dog.prototype.3) JavaScript then checks if Animal.prototype has a constructor property - it does so it logs that.*/ How can we fix this? Well, it’s pretty simple. We can just add the correct constructor property to Dog.prototype once we overwrite it. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&apos;Woof Woof!&apos;) this.energy -= .1 } Dog.prototype.constructor = Dog At this point if we wanted to make another subclass, say Cat, we’d follow the same pattern. function Cat (name, energy, declawed) { Animal.call(this, name, energy) this.declawed = declawed } Cat.prototype = Object.create(Animal.prototype) Cat.prototype.constructor = Cat Cat.prototype.meow = function () { console.log(&apos;Meow!&apos;) this.energy -= .1 } This concept of having a base class with subclasses that delegate to it is called inheritance and it’s a staple of Object Oriented Programming (OOP). If you’re coming from a different programming language, odds are you’re already familiar with OOP and inheritance. Before ES6 classes, in JavaScript, inheritance was quite the task as you can see above. You need to understand now only when to use inheritance, but also a nice mix of .call, Object.create, this, and FN.prototype - all pretty advanced JS topics. Let’s see how we’d accomplish the same thing using ES6 classes though. First, let’s review what it looks like to go from an ES5 “class” to an ES6 class using our Animal class. function Animal (name, energy) { this.name = name this.energy = energy } Animal.prototype.eat = function (amount) { console.log(`${this.name} is eating.`) this.energy += amount } Animal.prototype.sleep = function (length) { console.log(`${this.name} is sleeping.`) this.energy += length } Animal.prototype.play = function (length) { console.log(`${this.name} is playing.`) this.energy -= length } const leo = new Animal(&apos;Leo&apos;, 7) 123456789101112131415161718192021class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep() &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play() &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;const leo = new Animal(&apos;Leo&apos;, 7) Now that we’ve refactored our Animal constructor function into an ES6 class, the next thing we need to do is figure out how to refactor our base class (Dog). The good news is it’s much more intuitive. For reference, in ES5, here’s what we had. function Dog (name, energy, breed) { Animal.call(this, name, energy) this.breed = breed } Dog.prototype = Object.create(Animal.prototype) Dog.prototype.bark = function () { console.log(&apos;Woof Woof!&apos;) this.energy -= .1 } Dog.prototype.constructor = Dog Before we get into inheritance, let’s refactor Dog to use an ES6 class as we learned in a previous post. 12345678910class Dog &#123; constructor(name, energy, breed) &#123; this.breed = breed &#125; bark() &#123; console.log(&apos;Woof Woof!&apos;) this.energy -= .1 &#125;&#125; Looks great. Now, let’s figure out how to make sure that Dog inherits from Animal. The first step we need to make is a pretty straight forward one. With ES6 classes, you can extend a base class with this syntax class Subclass extends Baseclass {} Translated into our example, that would make our Dog class look like this 1234567891011121314151617181920212223242526272829class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep() &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play() &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;class Dog extends Animal &#123; constructor(name, energy, breed) &#123; this.breed = breed &#125; bark() &#123; console.log(&apos;Woof Woof!&apos;) this.energy -= .1 &#125;&#125; In ES5 in order to make sure that every instance of Dog had a name and an energy property, we used .call in order to invoke the Animal constructor function in the context of the Dog instance. Luckily for us, in ES6 it’s much more straight forward. Whenever you are extending a baseclass and you need to invoke that baseclass’ constructor function, you invoke super passing it any arguments it needs. So in our example, our Dog constructor gets refactored to look like this 12345678910111213141516171819202122232425262728293031class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep() &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play() &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;class Dog extends Animal &#123; constructor(name, energy, breed) &#123; super(name, energy) // calls Animal&apos;s constructor this.breed = breed &#125; bark() &#123; console.log(&apos;Woof Woof!&apos;) this.energy -= .1 &#125;&#125; And that’s it. No using .call, no using Object.create, no worrying about resetting constructor on the prototype - just extends the baseclass and make sure to call super. What’s interesting about JavaScript is the same patterns you’ve learned these last few posts are directly caked into the language itself. Previously you learned that the reason all instances of Array have access to the array methods like pop, slice, filter, etc are because all of those methods live on Array.prototype. 123456789101112131415161718192021222324252627282930313233343536console.log(Array.prototype)/* concat: ƒn concat() constructor: ƒn Array() copyWithin: ƒn copyWithin() entries: ƒn entries() every: ƒn every() fill: ƒn fill() filter: ƒn filter() find: ƒn find() findIndex: ƒn findIndex() forEach: ƒn forEach() includes: ƒn includes() indexOf: ƒn indexOf() join: ƒn join() keys: ƒn keys() lastIndexOf: ƒn lastIndexOf() length: 0n map: ƒn map() pop: ƒn pop() push: ƒn push() reduce: ƒn reduce() reduceRight: ƒn reduceRight() reverse: ƒn reverse() shift: ƒn shift() slice: ƒn slice() some: ƒn some() sort: ƒn sort() splice: ƒn splice() toLocaleString: ƒn toLocaleString() toString: ƒn toString() unshift: ƒn unshift() values: ƒn values()*/ You also learned that the reason all instances of Object have access to methods like hasOwnProperty and toString is because those methods live on Object.prototype. 123456789101112console.log(Object.prototype)/* constructor: ƒn Object() hasOwnProperty: ƒn hasOwnProperty() isPrototypeOf: ƒn isPrototypeOf() propertyIsEnumerable: ƒn propertyIsEnumerable() toLocaleString: ƒn toLocaleString() toString: ƒn toString() valueOf: ƒn valueOf()*/ Here’s a challenge for you. With the list of Array methods and Object methods above, why does this code below work? 1234const friends = [&apos;Mikenzi&apos;, &apos;Jake&apos;, &apos;Ean&apos;]friends.hasOwnProperty(&apos;push&apos;) // false If you look at Array.prototype, there isn’t a hasOwnProperty method. Well if there isn’t a hasOwnProperty method located on Array.prototype, how does the friends array in the example above have access to hasOwnProperty? The reason for that is because the Array class extends the Object class. So in our example above, when JavaScript sees that friends doesn’t have a hasOwnProperty property, it checks if Array.prototype does. When Array.prototype doesn’t, it checks if Object.prototype does, then it invokes it. It’s the same process we’ve seen throughout this blog post. JavaScript has two types - Primitive types and Reference types. Primitive types are boolean, number, string, null, and undefined and are immutable. Everything else is a reference type and they all extend Object.prototype. That’s why you can add properties to functions and arrays and that’s why both functions and arrays have access to the methods located on Object.prototype. 12345678function speak()&#123;&#125;speak.woahFunctionsAreLikeObjects = trueconsole.log(speak.woahFunctionsAreLikeObjects) // trueconst friends = [&apos;Mikenzi&apos;, &apos;Jake&apos;, &apos;Ean&apos;]friends.woahArraysAreLikeObjectsToo = trueconsole.log(friends.woahArraysAreLikeObjectsToo) // true –未完待续]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel入门]]></title>
    <url>%2Fmyhexo%2F2019%2F01%2F01%2Fbabel%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1、babel Babel is a toolchain that is mainly used to convert ECMAScript 2015+ code into a backwards compatible version of JavaScript in current and older browsers or environments. 参考 https://babeljs.io/setup#installation 1)生成package.json文件(描述项目所需要的各种模块，以及项目的配置信息—比如名称、版本、许可证等元数据) npm init D:\mytest\babel&gt;npm init 2)安装项目依赖 install Babel CLI locally D:\mytest\babel&gt;npm install --save-dev @babel/core @babel/cli 3）添加编译运行脚本命令 &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;babel src -d src_build&quot; }, 结果 4）运行脚本命令 D:\mytest\babel&gt;npm run build 此时并没有成功的将es6的语法转成es5 5）添加.babelrc文件 Great! You’ve configured Babel but you haven’t made it actually do anything. Create a .babelrc config in your project root and enable some plugins. To start, you can use the env preset, which enables transforms for ES2015+ D:\mytest\babel&gt;npm install @babel/preset-env --save-dev 结果 6）重新运行脚本命令 D:\mytest\babel&gt;npm run build 7)使用编译后的js &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&apos;../src_build/1.js&apos;&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; babel官网参考手册 https://babeljs.io/docs/en/usage]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>babel</tag>
        <tag>npm</tag>
      </tags>
  </entry>
</search>
